id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:16267,Modifiability,config,configuration,16267,"n = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.70799; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.70053 0.692869 0.625222 0.0421632 4287.73 0; : 2 | 0.694153 0.694394 0.638111 0.0419725 4193.66 1; : 3 | 0.689625 0.697522 0.634816 0.0412563 4211.88 2; : 4 | 0.681203 0.694822 0.628686 0.0407413 4252.1 3; : 5 Minimum Test error found - save the configuration ; : 5 | 0.673678 0.681248 0.619972 0.0411822 4319.36 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.614022 0.0406714 4360.33 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.602694 0.0404119 4446.16 0; : 8 | 0.616397 0.638352 0.610274 0.0409979 4391.54 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.618875 0.0405848 4323.09 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:16377,Modifiability,config,configuration,16377,"ity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.70799; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.70053 0.692869 0.625222 0.0421632 4287.73 0; : 2 | 0.694153 0.694394 0.638111 0.0419725 4193.66 1; : 3 | 0.689625 0.697522 0.634816 0.0412563 4211.88 2; : 4 | 0.681203 0.694822 0.628686 0.0407413 4252.1 3; : 5 Minimum Test error found - save the configuration ; : 5 | 0.673678 0.681248 0.619972 0.0411822 4319.36 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.614022 0.0406714 4360.33 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.602694 0.0404119 4446.16 0; : 8 | 0.616397 0.638352 0.610274 0.0409979 4391.54 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.618875 0.0405848 4323.09 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep L",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:16541,Modifiability,config,configuration,16541,"0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.70799; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.70053 0.692869 0.625222 0.0421632 4287.73 0; : 2 | 0.694153 0.694394 0.638111 0.0419725 4193.66 1; : 3 | 0.689625 0.697522 0.634816 0.0412563 4211.88 2; : 4 | 0.681203 0.694822 0.628686 0.0407413 4252.1 3; : 5 Minimum Test error found - save the configuration ; : 5 | 0.673678 0.681248 0.619972 0.0411822 4319.36 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.614022 0.0406714 4360.33 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.602694 0.0404119 4446.16 0; : 8 | 0.616397 0.638352 0.610274 0.0409979 4391.54 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.618875 0.0405848 4323.09 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Ou",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:16652,Modifiability,config,configuration,16652,"----------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.70053 0.692869 0.625222 0.0421632 4287.73 0; : 2 | 0.694153 0.694394 0.638111 0.0419725 4193.66 1; : 3 | 0.689625 0.697522 0.634816 0.0412563 4211.88 2; : 4 | 0.681203 0.694822 0.628686 0.0407413 4252.1 3; : 5 Minimum Test error found - save the configuration ; : 5 | 0.673678 0.681248 0.619972 0.0411822 4319.36 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.614022 0.0406714 4360.33 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.602694 0.0404119 4446.16 0; : 8 | 0.616397 0.638352 0.610274 0.0409979 4391.54 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.618875 0.0405848 4323.09 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = (",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:18410,Modifiability,config,configuration,18410,"NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576 0.189646 0.0148842 14648.6 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.689168 0.677551 0.190642 0.015026 14577.3 0; : 5 | 0.686885 0.678678 0.189865 0.0148775 14629.7 1; : 6 | 0.68905 0.681357 0.189104 0.014885 14694.1 2; : 7 | 0.687138 0.683485 0.19023 0.0152893 14633.6 3; : 8 | 0.686429 0.685529 0.189996 0.0147979 14612 4; : 9 | 0.685179 0.683467 0.190317 0.0152552 14623.4 5; : 10 Minimum Test error found - save the configuration ; : 10 | 0.684262 0.673795 0.18992 0.0153518 14664.7 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.682907 0.671521 0.194162 0.0155002 14328.7 0; : 12 | 0.693473 0.677553 0.188937 0.0147664 14698.2 1; : 13 | 0.695581 0.671789 0.190501 0.0149406 14581.9 2; : 14 | 0.68024 0.680521 0.188432 0.0146998 14735.3 ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:18520,Modifiability,config,configuration,18520,"300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576 0.189646 0.0148842 14648.6 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.689168 0.677551 0.190642 0.015026 14577.3 0; : 5 | 0.686885 0.678678 0.189865 0.0148775 14629.7 1; : 6 | 0.68905 0.681357 0.189104 0.014885 14694.1 2; : 7 | 0.687138 0.683485 0.19023 0.0152893 14633.6 3; : 8 | 0.686429 0.685529 0.189996 0.0147979 14612 4; : 9 | 0.685179 0.683467 0.190317 0.0152552 14623.4 5; : 10 Minimum Test error found - save the configuration ; : 10 | 0.684262 0.673795 0.18992 0.0153518 14664.7 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.682907 0.671521 0.194162 0.0155002 14328.7 0; : 12 | 0.693473 0.677553 0.188937 0.0147664 14698.2 1; : 13 | 0.695581 0.671789 0.190501 0.0149406 14581.9 2; : 14 | 0.68024 0.680521 0.188432 0.0146998 14735.3 3; : 15 | 0.68435 0.688062 0.189615 0.0147881 14643.1 4; : 16 | 0.686476 0.675588 0.190015 0.0152195 14645.7 ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:18683,Modifiability,config,configuration,18683,"tion = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576 0.189646 0.0148842 14648.6 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.689168 0.677551 0.190642 0.015026 14577.3 0; : 5 | 0.686885 0.678678 0.189865 0.0148775 14629.7 1; : 6 | 0.68905 0.681357 0.189104 0.014885 14694.1 2; : 7 | 0.687138 0.683485 0.19023 0.0152893 14633.6 3; : 8 | 0.686429 0.685529 0.189996 0.0147979 14612 4; : 9 | 0.685179 0.683467 0.190317 0.0152552 14623.4 5; : 10 Minimum Test error found - save the configuration ; : 10 | 0.684262 0.673795 0.18992 0.0153518 14664.7 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.682907 0.671521 0.194162 0.0155002 14328.7 0; : 12 | 0.693473 0.677553 0.188937 0.0147664 14698.2 1; : 13 | 0.695581 0.671789 0.190501 0.0149406 14581.9 2; : 14 | 0.68024 0.680521 0.188432 0.0146998 14735.3 3; : 15 | 0.68435 0.688062 0.189615 0.0147881 14643.1 4; : 16 | 0.686476 0.675588 0.190015 0.0152195 14645.7 5; : 17 | 0.677004 0.674528 0.190369 0.0146787 14571.1 6; : 18 Minimum Test error found - save the configuration ; : 18 | 0.670403 0.662 0.188594 0.0151297 14758.1",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:19058,Modifiability,config,configuration,19058,"eta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576 0.189646 0.0148842 14648.6 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.689168 0.677551 0.190642 0.015026 14577.3 0; : 5 | 0.686885 0.678678 0.189865 0.0148775 14629.7 1; : 6 | 0.68905 0.681357 0.189104 0.014885 14694.1 2; : 7 | 0.687138 0.683485 0.19023 0.0152893 14633.6 3; : 8 | 0.686429 0.685529 0.189996 0.0147979 14612 4; : 9 | 0.685179 0.683467 0.190317 0.0152552 14623.4 5; : 10 Minimum Test error found - save the configuration ; : 10 | 0.684262 0.673795 0.18992 0.0153518 14664.7 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.682907 0.671521 0.194162 0.0155002 14328.7 0; : 12 | 0.693473 0.677553 0.188937 0.0147664 14698.2 1; : 13 | 0.695581 0.671789 0.190501 0.0149406 14581.9 2; : 14 | 0.68024 0.680521 0.188432 0.0146998 14735.3 3; : 15 | 0.68435 0.688062 0.189615 0.0147881 14643.1 4; : 16 | 0.686476 0.675588 0.190015 0.0152195 14645.7 5; : 17 | 0.677004 0.674528 0.190369 0.0146787 14571.1 6; : 18 Minimum Test error found - save the configuration ; : 18 | 0.670403 0.662 0.188594 0.0151297 14758.1 0; : 19 | 0.673327 0.684121 0.189356 0.0146185 14650.5 1; : 20 | 0.68729 0.678527 0.188558 0.0148948 14741.2 2; : ; : Elapsed time for training with 3200 events: 3.82 sec ; : Evaluate deep neural network on CPU using batches with size = 256; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:19169,Modifiability,config,configuration,19169,----------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576 0.189646 0.0148842 14648.6 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.689168 0.677551 0.190642 0.015026 14577.3 0; : 5 | 0.686885 0.678678 0.189865 0.0148775 14629.7 1; : 6 | 0.68905 0.681357 0.189104 0.014885 14694.1 2; : 7 | 0.687138 0.683485 0.19023 0.0152893 14633.6 3; : 8 | 0.686429 0.685529 0.189996 0.0147979 14612 4; : 9 | 0.685179 0.683467 0.190317 0.0152552 14623.4 5; : 10 Minimum Test error found - save the configuration ; : 10 | 0.684262 0.673795 0.18992 0.0153518 14664.7 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.682907 0.671521 0.194162 0.0155002 14328.7 0; : 12 | 0.693473 0.677553 0.188937 0.0147664 14698.2 1; : 13 | 0.695581 0.671789 0.190501 0.0149406 14581.9 2; : 14 | 0.68024 0.680521 0.188432 0.0146998 14735.3 3; : 15 | 0.68435 0.688062 0.189615 0.0147881 14643.1 4; : 16 | 0.686476 0.675588 0.190015 0.0152195 14645.7 5; : 17 | 0.677004 0.674528 0.190369 0.0146787 14571.1 6; : 18 Minimum Test error found - save the configuration ; : 18 | 0.670403 0.662 0.188594 0.0151297 14758.1 0; : 19 | 0.673327 0.684121 0.189356 0.0146185 14650.5 1; : 20 | 0.68729 0.678527 0.188558 0.0148948 14741.2 2; : ; : Elapsed time for training with 3200 events: 3.82 sec ; : Evaluate deep neural network on CPU using batches with size = 256; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0999 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Cr,MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:19609,Modifiability,config,configuration,19609,91864 0.689576 0.189646 0.0148842 14648.6 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.689168 0.677551 0.190642 0.015026 14577.3 0; : 5 | 0.686885 0.678678 0.189865 0.0148775 14629.7 1; : 6 | 0.68905 0.681357 0.189104 0.014885 14694.1 2; : 7 | 0.687138 0.683485 0.19023 0.0152893 14633.6 3; : 8 | 0.686429 0.685529 0.189996 0.0147979 14612 4; : 9 | 0.685179 0.683467 0.190317 0.0152552 14623.4 5; : 10 Minimum Test error found - save the configuration ; : 10 | 0.684262 0.673795 0.18992 0.0153518 14664.7 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.682907 0.671521 0.194162 0.0155002 14328.7 0; : 12 | 0.693473 0.677553 0.188937 0.0147664 14698.2 1; : 13 | 0.695581 0.671789 0.190501 0.0149406 14581.9 2; : 14 | 0.68024 0.680521 0.188432 0.0146998 14735.3 3; : 15 | 0.68435 0.688062 0.189615 0.0147881 14643.1 4; : 16 | 0.686476 0.675588 0.190015 0.0152195 14645.7 5; : 17 | 0.677004 0.674528 0.190369 0.0146787 14571.1 6; : 18 Minimum Test error found - save the configuration ; : 18 | 0.670403 0.662 0.188594 0.0151297 14758.1 0; : 19 | 0.673327 0.684121 0.189356 0.0146185 14650.5 1; : 20 | 0.68729 0.678527 0.188558 0.0148948 14741.2 2; : ; : Elapsed time for training with 3200 events: 3.82 sec ; : Evaluate deep neural network on CPU using batches with size = 256; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0999 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras_LSTM for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras_LSTM ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predi,MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31127,Modifiability,variab,variable,31127,"on of 3200 events: 0.248 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: BDTG for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ BDTG ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : Boosted Decision Trees are a collection of individual decision; : trees which form a multivariate classifier by (weighted) majority ; : vote of the individual trees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEven",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31473,Modifiability,variab,variables,31473,"[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : Boosted Decision Trees are a collection of individual decision; : trees which form a multivariate classifier by (weighted) majority ; : vote of the individual trees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31552,Modifiability,variab,variables,31552,"[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : Boosted Decision Trees are a collection of individual decision; : trees which form a multivariate classifier by (weighted) majority ; : vote of the individual trees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31676,Modifiability,variab,variables,31676,"[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : Boosted Decision Trees are a collection of individual decision; : trees which form a multivariate classifier by (weighted) majority ; : vote of the individual trees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31812,Modifiability,config,configuration,31812,"ng of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining after the training which splits ; : are considered statistically insignificant and are removed. The; : user is advised to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sam",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31887,Modifiability,config,configuration,31887,"ng of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining after the training which splits ; : are considered statistically insignificant and are removed. The; : user is advised to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sam",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:33883,Modifiability,variab,variables,33883,"to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sample. They should be equal within statistical; : errors, in order to minimize statistical fluctuations in different samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 1600 bkg: 1600; : #events: (unweighted) sig: 1600 bkg: 1600; : Training 100 Decision Trees ... patience please; : Elapsed time for training with 3200 events: 1.7 sec ; BDTG : [dataset] : Evaluation of BDTG on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0183 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_BDTG.class.C␛[0m; : data_RNN_CPU.root:/dataset/Method_BDT/BDTG; Factory : Training finished; : ; : Ranking input variables (method specific)...; : No variable ranking supplied by classifier: TMVA_LSTM; : No variable ranking supplied by classifier: TMVA_DNN; : No variable ranking supplied by classifier: PyKeras_LSTM; BDTG : Ranking result (top variable is best ranked); : --------------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------------; : 1 : vars_time9 : 2.245e-02; : 2 : vars_time8 : 2.023e-02; : 3 : vars_time7 : 1.907e-02; : 4 : vars_time7 : 1.907e-02; : 5 : vars_time8 : 1.847e-02; : 6 : vars_time7 : 1.771e-02; : 7 : vars_time9 : 1.708e-02; : 8 : vars_time6 : 1.653e-02; : 9 : vars_time0 : 1.650e-02; : 10 : vars_time7 : 1.626e-02; : 11 : vars_time8 : 1.623e-02; : 12 : vars_time6 : 1.532e-02; : 13 : vars_time8 : 1.530e-02; : 14 : vars_time9 : 1.520e-02; : 15 : vars_time8 : 1.487e-02; : 16 : vars_time6 : 1.421e-02; : 17 : vars_time6 : 1.421e-02; : 18 : vars_time8 : 1.381e-02; : 19 : vars_time8 : 1.379e-02;",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:33920,Modifiability,variab,variable,33920,"erent samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 1600 bkg: 1600; : #events: (unweighted) sig: 1600 bkg: 1600; : Training 100 Decision Trees ... patience please; : Elapsed time for training with 3200 events: 1.7 sec ; BDTG : [dataset] : Evaluation of BDTG on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0183 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_BDTG.class.C␛[0m; : data_RNN_CPU.root:/dataset/Method_BDT/BDTG; Factory : Training finished; : ; : Ranking input variables (method specific)...; : No variable ranking supplied by classifier: TMVA_LSTM; : No variable ranking supplied by classifier: TMVA_DNN; : No variable ranking supplied by classifier: PyKeras_LSTM; BDTG : Ranking result (top variable is best ranked); : --------------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------------; : 1 : vars_time9 : 2.245e-02; : 2 : vars_time8 : 2.023e-02; : 3 : vars_time7 : 1.907e-02; : 4 : vars_time7 : 1.907e-02; : 5 : vars_time8 : 1.847e-02; : 6 : vars_time7 : 1.771e-02; : 7 : vars_time9 : 1.708e-02; : 8 : vars_time6 : 1.653e-02; : 9 : vars_time0 : 1.650e-02; : 10 : vars_time7 : 1.626e-02; : 11 : vars_time8 : 1.623e-02; : 12 : vars_time6 : 1.532e-02; : 13 : vars_time8 : 1.530e-02; : 14 : vars_time9 : 1.520e-02; : 15 : vars_time8 : 1.487e-02; : 16 : vars_time6 : 1.421e-02; : 17 : vars_time6 : 1.421e-02; : 18 : vars_time8 : 1.381e-02; : 19 : vars_time8 : 1.379e-02; : 20 : vars_time9 : 1.331e-02; : 21 : vars_time0 : 1.313e-02; : 22 : vars_time8 : 1.307e-02; : 23 : vars_time5 : 1.291e-02; : 24 : vars_time9 : 1.261e-02; : 25 : vars_time7 : 1.243e-02; : 26 : vars_time9 : 1.230e-02; : 27 : vars_time6 : 1.229e-02; ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:33977,Modifiability,variab,variable,33977,"erent samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 1600 bkg: 1600; : #events: (unweighted) sig: 1600 bkg: 1600; : Training 100 Decision Trees ... patience please; : Elapsed time for training with 3200 events: 1.7 sec ; BDTG : [dataset] : Evaluation of BDTG on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0183 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_BDTG.class.C␛[0m; : data_RNN_CPU.root:/dataset/Method_BDT/BDTG; Factory : Training finished; : ; : Ranking input variables (method specific)...; : No variable ranking supplied by classifier: TMVA_LSTM; : No variable ranking supplied by classifier: TMVA_DNN; : No variable ranking supplied by classifier: PyKeras_LSTM; BDTG : Ranking result (top variable is best ranked); : --------------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------------; : 1 : vars_time9 : 2.245e-02; : 2 : vars_time8 : 2.023e-02; : 3 : vars_time7 : 1.907e-02; : 4 : vars_time7 : 1.907e-02; : 5 : vars_time8 : 1.847e-02; : 6 : vars_time7 : 1.771e-02; : 7 : vars_time9 : 1.708e-02; : 8 : vars_time6 : 1.653e-02; : 9 : vars_time0 : 1.650e-02; : 10 : vars_time7 : 1.626e-02; : 11 : vars_time8 : 1.623e-02; : 12 : vars_time6 : 1.532e-02; : 13 : vars_time8 : 1.530e-02; : 14 : vars_time9 : 1.520e-02; : 15 : vars_time8 : 1.487e-02; : 16 : vars_time6 : 1.421e-02; : 17 : vars_time6 : 1.421e-02; : 18 : vars_time8 : 1.381e-02; : 19 : vars_time8 : 1.379e-02; : 20 : vars_time9 : 1.331e-02; : 21 : vars_time0 : 1.313e-02; : 22 : vars_time8 : 1.307e-02; : 23 : vars_time5 : 1.291e-02; : 24 : vars_time9 : 1.261e-02; : 25 : vars_time7 : 1.243e-02; : 26 : vars_time9 : 1.230e-02; : 27 : vars_time6 : 1.229e-02; ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:34033,Modifiability,variab,variable,34033,"erent samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 1600 bkg: 1600; : #events: (unweighted) sig: 1600 bkg: 1600; : Training 100 Decision Trees ... patience please; : Elapsed time for training with 3200 events: 1.7 sec ; BDTG : [dataset] : Evaluation of BDTG on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0183 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_BDTG.class.C␛[0m; : data_RNN_CPU.root:/dataset/Method_BDT/BDTG; Factory : Training finished; : ; : Ranking input variables (method specific)...; : No variable ranking supplied by classifier: TMVA_LSTM; : No variable ranking supplied by classifier: TMVA_DNN; : No variable ranking supplied by classifier: PyKeras_LSTM; BDTG : Ranking result (top variable is best ranked); : --------------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------------; : 1 : vars_time9 : 2.245e-02; : 2 : vars_time8 : 2.023e-02; : 3 : vars_time7 : 1.907e-02; : 4 : vars_time7 : 1.907e-02; : 5 : vars_time8 : 1.847e-02; : 6 : vars_time7 : 1.771e-02; : 7 : vars_time9 : 1.708e-02; : 8 : vars_time6 : 1.653e-02; : 9 : vars_time0 : 1.650e-02; : 10 : vars_time7 : 1.626e-02; : 11 : vars_time8 : 1.623e-02; : 12 : vars_time6 : 1.532e-02; : 13 : vars_time8 : 1.530e-02; : 14 : vars_time9 : 1.520e-02; : 15 : vars_time8 : 1.487e-02; : 16 : vars_time6 : 1.421e-02; : 17 : vars_time6 : 1.421e-02; : 18 : vars_time8 : 1.381e-02; : 19 : vars_time8 : 1.379e-02; : 20 : vars_time9 : 1.331e-02; : 21 : vars_time0 : 1.313e-02; : 22 : vars_time8 : 1.307e-02; : 23 : vars_time5 : 1.291e-02; : 24 : vars_time9 : 1.261e-02; : 25 : vars_time7 : 1.243e-02; : 26 : vars_time9 : 1.230e-02; : 27 : vars_time6 : 1.229e-02; ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:34115,Modifiability,variab,variable,34115,"erent samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 1600 bkg: 1600; : #events: (unweighted) sig: 1600 bkg: 1600; : Training 100 Decision Trees ... patience please; : Elapsed time for training with 3200 events: 1.7 sec ; BDTG : [dataset] : Evaluation of BDTG on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0183 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_BDTG.class.C␛[0m; : data_RNN_CPU.root:/dataset/Method_BDT/BDTG; Factory : Training finished; : ; : Ranking input variables (method specific)...; : No variable ranking supplied by classifier: TMVA_LSTM; : No variable ranking supplied by classifier: TMVA_DNN; : No variable ranking supplied by classifier: PyKeras_LSTM; BDTG : Ranking result (top variable is best ranked); : --------------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------------; : 1 : vars_time9 : 2.245e-02; : 2 : vars_time8 : 2.023e-02; : 3 : vars_time7 : 1.907e-02; : 4 : vars_time7 : 1.907e-02; : 5 : vars_time8 : 1.847e-02; : 6 : vars_time7 : 1.771e-02; : 7 : vars_time9 : 1.708e-02; : 8 : vars_time6 : 1.653e-02; : 9 : vars_time0 : 1.650e-02; : 10 : vars_time7 : 1.626e-02; : 11 : vars_time8 : 1.623e-02; : 12 : vars_time6 : 1.532e-02; : 13 : vars_time8 : 1.530e-02; : 14 : vars_time9 : 1.520e-02; : 15 : vars_time8 : 1.487e-02; : 16 : vars_time6 : 1.421e-02; : 17 : vars_time6 : 1.421e-02; : 18 : vars_time8 : 1.381e-02; : 19 : vars_time8 : 1.379e-02; : 20 : vars_time9 : 1.331e-02; : 21 : vars_time0 : 1.313e-02; : 22 : vars_time8 : 1.307e-02; : 23 : vars_time5 : 1.291e-02; : 24 : vars_time9 : 1.261e-02; : 25 : vars_time7 : 1.243e-02; : 26 : vars_time9 : 1.230e-02; : 27 : vars_time6 : 1.229e-02; ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46538,Modifiability,variab,variable,46538,"STM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : ---------------------------------------------------------",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46586,Modifiability,variab,variables,46586,"STM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : ---------------------------------------------------------",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46866,Modifiability,variab,variable,46866,"TM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDTG : 0.843; : dataset PyKeras_LSTM : 0.815; : dataset TMVA_LSTM : 0.732; : dataset TMVA_DNN : 0.637; : ------------------------------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46914,Modifiability,variab,variables,46914,"TM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDTG : 0.843; : dataset PyKeras_LSTM : 0.815; : dataset TMVA_LSTM : 0.732; : dataset TMVA_DNN : 0.637; : ------------------------------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:47128,Modifiability,variab,variable,47128,"ation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDTG : 0.843; : dataset PyKeras_LSTM : 0.815; : dataset TMVA_LSTM : 0.732; : dataset TMVA_DNN : 0.637; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method:",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:47176,Modifiability,variab,variables,47176,"ation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDTG : 0.843; : dataset PyKeras_LSTM : 0.815; : dataset TMVA_LSTM : 0.732; : dataset TMVA_DNN : 0.637; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method:",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:47374,Modifiability,variab,variable,47374,"] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDTG : 0.843; : dataset PyKeras_LSTM : 0.815; : dataset TMVA_LSTM : 0.732; : dataset TMVA_DNN : 0.637; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method: @B=0.01 @B=0.10 @B=0.30 ; : -------------------------------------------------------------------------------------------------------------------; : dataset BDTG : 0.135 (0.272) 0.502 (0.648) 0.835 (0.886); : dataset PyKeras_LSTM : 0.155 (0.155) 0.485 (0.572) 0.768 (0.836); : dataset TMVA_LSTM : 0.035 (0.077) 0.",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:47422,Modifiability,variab,variables,47422,"] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDTG : 0.843; : dataset PyKeras_LSTM : 0.815; : dataset TMVA_LSTM : 0.732; : dataset TMVA_DNN : 0.637; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method: @B=0.01 @B=0.10 @B=0.30 ; : -------------------------------------------------------------------------------------------------------------------; : dataset BDTG : 0.135 (0.272) 0.502 (0.648) 0.835 (0.886); : dataset PyKeras_LSTM : 0.155 (0.155) 0.485 (0.572) 0.768 (0.836); : dataset TMVA_LSTM : 0.035 (0.077) 0.",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:54709,Modifiability,config,configuration,54709,"xist = ROOT.gSystem.AccessPathName(inputFileName); ; # if file does not exists create it; if fileDoesNotExist:; MakeTimeData(nTotEvts, ntime, ninput); ; ; inputFile = TFile.Open(inputFileName); if inputFile is None:; raise ROOT.Error(""Error opening input file %s - exit"", inputFileName.Data()); ; ; print(""--- RNNClassification : Using input file: {}"".format(inputFile.GetName())); ; # Create a ROOT output file where TMVA will store ntuples, histograms, etc.; outfileName = ""data_RNN_"" + archString + "".root""; outputFile = None; ; ; if writeOutputFile:; outputFile = TFile.Open(outfileName, ""RECREATE""); ; ; ## Declare Factory; ; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; ; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to; # pass; ; # - The first argument is the base of the name of all the output; # weightfiles in the directory weight/ that will be created with the; # method parameters; ; # - The second argument is the output file for the training results; #; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in; # the option string; ; ; # // Creating the factory object; factory = TMVA.Factory(; ""TMVAClassification"",; outputFile,; V=False,; Silent=False,; Color=True,; DrawProgressBar=True,; Transformations=None,; Correlations=False,; AnalysisType=""Classification"",; ModelPersistence=True,; ); dataloader = TMVA.DataLoader(""dataset""); ; signalTree = inputFile.Get(""sgn""); background = inputFile.Get(""bkg""); ; nvar = ninput * ntime; ; ## add variables - use new AddVariablesArray function; for i in range(ntime):; dataloader.AddVariablesArray(""vars_time"" + str(i), ninput); ; ; dataloader.AddSignalTree(signalTree, 1.0); dataloader.AddBackgroundTree(background, 1.0); ; # check given input; datainfo = dat",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:55289,Modifiability,variab,variables,55289," is the major TMVA object you have to interact with. Here is the list of parameters you need to; # pass; ; # - The first argument is the base of the name of all the output; # weightfiles in the directory weight/ that will be created with the; # method parameters; ; # - The second argument is the output file for the training results; #; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in; # the option string; ; ; # // Creating the factory object; factory = TMVA.Factory(; ""TMVAClassification"",; outputFile,; V=False,; Silent=False,; Color=True,; DrawProgressBar=True,; Transformations=None,; Correlations=False,; AnalysisType=""Classification"",; ModelPersistence=True,; ); dataloader = TMVA.DataLoader(""dataset""); ; signalTree = inputFile.Get(""sgn""); background = inputFile.Get(""bkg""); ; nvar = ninput * ntime; ; ## add variables - use new AddVariablesArray function; for i in range(ntime):; dataloader.AddVariablesArray(""vars_time"" + str(i), ninput); ; ; dataloader.AddSignalTree(signalTree, 1.0); dataloader.AddBackgroundTree(background, 1.0); ; # check given input; datainfo = dataloader.GetDataSetInfo(); vars = datainfo.GetListOfVariables(); print(""number of variables is {}"".format(vars.size())); ; ; for v in vars:; print(v); ; nTrainSig = 0.8 * nTotEvts; nTrainBkg = 0.8 * nTotEvts; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = """" # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = """"; ; # build the string options for DataLoader::PrepareTrainingAndTestTree; dataloader.PrepareTrainingAndTestTree(; mycuts,; mycutb,; nTrain_Signal=nTrainSig,; nTrain_Background=nTrainBkg,; SplitMode=""Random"",; SplitSeed=100,; NormMode=""NumEvents"",; V=False,; CalcCorrelations=False,; ); ; print(""prepared DATA LOADER ""); ; ; ## Book TMVA recurrent models; ; # Book the differe",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:55633,Modifiability,variab,variables,55633,"e training results; #; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in; # the option string; ; ; # // Creating the factory object; factory = TMVA.Factory(; ""TMVAClassification"",; outputFile,; V=False,; Silent=False,; Color=True,; DrawProgressBar=True,; Transformations=None,; Correlations=False,; AnalysisType=""Classification"",; ModelPersistence=True,; ); dataloader = TMVA.DataLoader(""dataset""); ; signalTree = inputFile.Get(""sgn""); background = inputFile.Get(""bkg""); ; nvar = ninput * ntime; ; ## add variables - use new AddVariablesArray function; for i in range(ntime):; dataloader.AddVariablesArray(""vars_time"" + str(i), ninput); ; ; dataloader.AddSignalTree(signalTree, 1.0); dataloader.AddBackgroundTree(background, 1.0); ; # check given input; datainfo = dataloader.GetDataSetInfo(); vars = datainfo.GetListOfVariables(); print(""number of variables is {}"".format(vars.size())); ; ; for v in vars:; print(v); ; nTrainSig = 0.8 * nTotEvts; nTrainBkg = 0.8 * nTotEvts; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = """" # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = """"; ; # build the string options for DataLoader::PrepareTrainingAndTestTree; dataloader.PrepareTrainingAndTestTree(; mycuts,; mycutb,; nTrain_Signal=nTrainSig,; nTrain_Background=nTrainBkg,; SplitMode=""Random"",; SplitSeed=100,; NormMode=""NumEvents"",; V=False,; CalcCorrelations=False,; ); ; print(""prepared DATA LOADER ""); ; ; ## Book TMVA recurrent models; ; # Book the different types of recurrent models in TMVA (SimpleRNN, LSTM or GRU); ; ; if useTMVA_RNN:; for i in range(3):; if not use_rnn_type[i]:; continue; ; rnn_type = rnn_types[i]; ; ## Define RNN layer layout; ## it should be LayerType (RNN or LSTM or GRU) | number of units | number of inputs | time steps | remember output (ty",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:59365,Modifiability,layers,layers,59365,"thod(; dataloader,; TMVA.Types.kDL,; dnnName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=None,; WeightInitialization=""XAVIER"",; RandomSeed=0,; InputLayout=""1|1|"" + str(ntime * ninput),; Layout=""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"",; TrainingStrategy=trainingString1; ); ; ; ## Book Keras recurrent models; ; # Book the different types of recurrent models in Keras (SimpleRNN, LSTM or GRU); ; ; if useKeras:; for i in range(3):; if use_rnn_type[i]:; modelName = ""model_"" + rnn_types[i] + "".h5""; trainedModelName = ""trained_"" + modelName; print(""Building recurrent keras model using a"", rnn_types[i], ""layer""); # create python script which can be executed; # create 2 conv2d layer + maxpool + dense; from tensorflow.keras.models import Sequential; from tensorflow.keras.optimizers import Adam; ; # from keras.initializers import TruncatedNormal; # from keras import initializations; from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, SimpleRNN, GRU, LSTM, Reshape, BatchNormalization; ; model = Sequential(); model.add(Reshape((10, 30), input_shape=(10 * 30,))); # add recurrent neural network depending on type / Use option to return the full output; if rnn_types[i] == ""LSTM"":; model.add(LSTM(units=10, return_sequences=True)); elif rnn_types[i] == ""GRU"":; model.add(GRU(units=10, return_sequences=True)); else:; model.add(SimpleRNN(units=10, return_sequences=True)); # m.AddLine(""model.add(BatchNormalization())"");; model.add(Flatten()) # needed if returning the full time output sequence; model.add(Dense(64, activation=""tanh"")); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(modelName); model.summary(); print(""saved recurrent model"", modelName); ; if not os.path.exists(modelName):; useKeras = False; print(""Error creating Keras recurrent model file - Skip using Keras""); else:; # book PyKeras method only if Keras model could ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:61382,Modifiability,config,configured,61382,"sing Keras""); else:; # book PyKeras method only if Keras model could be created; print(""Booking Keras model "", rnn_types[i]); factory.BookMethod(; dataloader,; TMVA.Types.kPyKeras,; ""PyKeras_"" + rnn_types[i],; H=True,; V=False,; VarTransform=None,; FilenameModel=modelName,; FilenameTrainedModel=""trained_"" + modelName,; NumEpochs=maxepochs,; BatchSize=batchSize,; GpuOptions=""allow_growth=True"",; ); ; ; # use BDT in case not using Keras or TMVA DL; if not useKeras or not useTMVA_BDT:; useTMVA_BDT = True; ; ; ## Book TMVA BDT; ; ; if useTMVA_BDT:; factory.BookMethod(; dataloader,; TMVA.Types.kBDT,; ""BDTG"",; H=True,; V=False,; NTrees=100,; MinNodeSize=""2.5%"",; BoostType=""Grad"",; Shrinkage=0.10,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; nCuts=20,; MaxDepth=2,; ); ; ; ## Train all methods; factory.TrainAllMethods(); ; print(""nthreads = {}"".format(ROOT.GetThreadPoolSize())); ; # ---- Evaluate all MVAs using the set of test events; factory.TestAllMethods(); ; # ----- Evaluate and compare performance of all configured MVAs; factory.EvaluateAllMethods(); ; # check method; ; # plot ROC curve; c1 = factory.GetROCCurve(dataloader); c1.Draw(); ; if outputFile:; outputFile.Close(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGW",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:1956,Performance,perform,performed,1956,"ed=1234:InputLayout=10|30:Layout=LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIERUNIFORM:ValidationSize=0.2:RandomSeed=1234:InputLayout=10|30:Layout=LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set.",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:2965,Performance,perform,perform,2965,"formations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_DNN␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:3512,Performance,perform,performance,3512,"n squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_DNN␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:4859,Performance,perform,performed,4859,"ROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:5652,Performance,perform,perform,5652,"WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthrea",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:6200,Performance,perform,performance,6200,"med)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthreads = 4; --- RNNClassification : Using input file: time_data_t10_d30.root; number of variables is 300; vars_time0[0]; vars_time0[1]; vars_time0[2]; vars_time0[3]; vars_time0[4]; vars_time0[5]; vars_time0[6]; vars_time0[7]; vars_time0[8]; vars_time0[9]; vars_time0[10]; vars_time0[11]; vars_time0[12]; vars_time0[13]; vars_time0[14]; vars_time0[15]; vars_time0[16]; vars_time0[17]; vars_time0[18]; vars_time0[19]; vars_time0[20]; vars_time0[21]; vars_time0[22]; vars_time0[23]; vars_time0[24]; vars_time0[25]; vars_time0[26]; vars_time0[27]; vars_time0[28]; vars_time0[29",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:20848,Performance,load,loaded,20848,": Evaluate deep neural network on CPU using batches with size = 256; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0999 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras_LSTM for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras_LSTM ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; saved recurrent model model_LSTM.h5; Booking Keras model LSTM; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31442,Performance,perform,performed,31442,"[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : Boosted Decision Trees are a collection of individual decision; : trees which form a multivariate classifier by (weighted) majority ; : vote of the individual trees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31761,Performance,perform,performance,31761,"rees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:32369,Performance,perform,performance,32369,"jority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining after the training which splits ; : are considered statistically insignificant and are removed. The; : user is advised to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sample. They should be equal within statistical; : errors, in order to minimize statistical fluctuations in different samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 16",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45063,Performance,perform,performance,45063,"valError, Entries= 0, Total sum= 13.5872; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'accuracy', Entries= 0, Total sum= 6.34883; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'loss', Entries= 0, Total sum= 6.27501; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_accuracy', Entries= 0, Total sum= 6.33125; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_loss', Entries= 0, Total sum= 6.20691; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45342,Performance,perform,performance,45342,"al sum= 6.33125; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_loss', Entries= 0, Total sum= 6.20691; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with clas",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45623,Performance,perform,performance,45623,": ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46112,Performance,perform,performance,46112," ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:52136,Performance,perform,performing,52136," i % 1000 == 0:; print(""Generating event ... %d"", i); ; for j in range(ntime):; h1 = v1[j]; h2 = v2[j]; h1.Reset(); h2.Reset(); ; f1.SetParameters(1, mean1[j], sigma1[j]); f2.SetParameters(1, mean2[j], sigma2[j]); ; h1.FillRandom(""f1"", 1000); h2.FillRandom(""f2"", 1000); ; for k in range(ntime):; # std::cout << j*10+k << "" "";; x1[j][k] = h1.GetBinContent(k + 1) + ROOT.gRandom.Gaus(0, 10); x2[j][k] = h2.GetBinContent(k + 1) + ROOT.gRandom.Gaus(0, 10); ; sgn.Fill(); bkg.Fill(); ; if n == 1:; c1 = ROOT.TCanvas(); c1.Divide(ntime, 2); for j in range(ntime):; c1.cd(j + 1); v1[j].Draw(); for j in range(ntime):; c1.cd(ntime + j + 1); v2[j].Draw(); ; ROOT.gPad.Update(); ; if n > 1:; sgn.Write(); bkg.Write(); sgn.Print(); bkg.Print(); f.Close(); ; ; ## macro for performing a classification using a Recurrent Neural Network; ## @param use_type; ## use_type = 0 use Simple RNN network; ## use_type = 1 use LSTM network; ## use_type = 2 use GRU; ## use_type = 3 build 3 different networks with RNN, LSTM and GRU; ; ; use_type = 1; ninput = 30; ntime = 10; batchSize = 100; maxepochs = 10; ; nTotEvts = 2000 # total events to be generated for signal or background; ; useKeras = True; ; useTMVA_RNN = True; useTMVA_DNN = True; useTMVA_BDT = False; ; tf_spec = importlib.util.find_spec(""tensorflow""); if tf_spec is None:; useKeras = False; ROOT.Warning(""TMVA_RNN_Classificaton"",""Skip using Keras since tensorflow is not installed""); ; ; rnn_types = [""RNN"", ""LSTM"", ""GRU""]; use_rnn_type = [1, 1, 1]; ; if 0 <= use_type < 3:; use_rnn_type = [0, 0, 0]; use_rnn_type[use_type] = 1; ; useGPU = True # use GPU for TMVA if available; ; useGPU = ""tmva-gpu"" in ROOT.gROOT.GetConfigFeatures(); useTMVA_RNN = (""tmva-cpu"" in ROOT.gROOT.GetConfigFeatures()) or useGPU; ; if useTMVA_RNN:; ROOT.Warning(; ""TMVA_RNN_Classification"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for RNN"",; ); ; archString = ""GPU"" if useGPU else ""CPU""; ; writeOutputFile = True; ; rnn_type = ""RNN"";",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:53221,Performance,multi-thread,multi-thread,53221,"k; ## @param use_type; ## use_type = 0 use Simple RNN network; ## use_type = 1 use LSTM network; ## use_type = 2 use GRU; ## use_type = 3 build 3 different networks with RNN, LSTM and GRU; ; ; use_type = 1; ninput = 30; ntime = 10; batchSize = 100; maxepochs = 10; ; nTotEvts = 2000 # total events to be generated for signal or background; ; useKeras = True; ; useTMVA_RNN = True; useTMVA_DNN = True; useTMVA_BDT = False; ; tf_spec = importlib.util.find_spec(""tensorflow""); if tf_spec is None:; useKeras = False; ROOT.Warning(""TMVA_RNN_Classificaton"",""Skip using Keras since tensorflow is not installed""); ; ; rnn_types = [""RNN"", ""LSTM"", ""GRU""]; use_rnn_type = [1, 1, 1]; ; if 0 <= use_type < 3:; use_rnn_type = [0, 0, 0]; use_rnn_type[use_type] = 1; ; useGPU = True # use GPU for TMVA if available; ; useGPU = ""tmva-gpu"" in ROOT.gROOT.GetConfigFeatures(); useTMVA_RNN = (""tmva-cpu"" in ROOT.gROOT.GetConfigFeatures()) or useGPU; ; if useTMVA_RNN:; ROOT.Warning(; ""TMVA_RNN_Classification"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for RNN"",; ); ; archString = ""GPU"" if useGPU else ""CPU""; ; writeOutputFile = True; ; rnn_type = ""RNN""; ; if ""tmva-pymva"" in ROOT.gROOT.GetConfigFeatures():; TMVA.PyMethodBase.PyInitialize(); else:; useKeras = False; ; ; ; inputFileName = ""time_data_t10_d30.root""; ; fileDoesNotExist = ROOT.gSystem.AccessPathName(inputFileName); ; # if file does not exists create it; if fileDoesNotExist:; MakeTimeData(nTotEvts, ntime, ninput); ; ; inputFile = TFile.Open(inputFileName); if inputFile is None:; raise ROOT.Error(""Error opening input file %s - exit"", inputFileName.Data()); ; ; print(""--- RNNClassification : Using input file: {}"".format(inputFile.GetName())); ; # Create a ROOT output file where TMVA will store ntuples, histograms, etc.; outfileName = ""data_RNN_"" + archString + "".root""; outputFile = None; ; ; if writeOutputFile:; outputFile = TFile.Open(outfileName, ""RECREATE""); ; ; ## Declare Factory; ; # Create the ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:54252,Performance,perform,performance,54252," use TMVA Deep Learning for RNN"",; ); ; archString = ""GPU"" if useGPU else ""CPU""; ; writeOutputFile = True; ; rnn_type = ""RNN""; ; if ""tmva-pymva"" in ROOT.gROOT.GetConfigFeatures():; TMVA.PyMethodBase.PyInitialize(); else:; useKeras = False; ; ; ; inputFileName = ""time_data_t10_d30.root""; ; fileDoesNotExist = ROOT.gSystem.AccessPathName(inputFileName); ; # if file does not exists create it; if fileDoesNotExist:; MakeTimeData(nTotEvts, ntime, ninput); ; ; inputFile = TFile.Open(inputFileName); if inputFile is None:; raise ROOT.Error(""Error opening input file %s - exit"", inputFileName.Data()); ; ; print(""--- RNNClassification : Using input file: {}"".format(inputFile.GetName())); ; # Create a ROOT output file where TMVA will store ntuples, histograms, etc.; outfileName = ""data_RNN_"" + archString + "".root""; outputFile = None; ; ; if writeOutputFile:; outputFile = TFile.Open(outfileName, ""RECREATE""); ; ; ## Declare Factory; ; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; ; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to; # pass; ; # - The first argument is the base of the name of all the output; # weightfiles in the directory weight/ that will be created with the; # method parameters; ; # - The second argument is the output file for the training results; #; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in; # the option string; ; ; # // Creating the factory object; factory = TMVA.Factory(; ""TMVAClassification"",; outputFile,; V=False,; Silent=False,; Color=True,; DrawProgressBar=True,; Transformations=None,; Correlations=False,; AnalysisType=""Classification"",; ModelPersistence=True,; ); dataloader = TMVA.DataLoader(""dataset""); ; signalTree = inputFile.Get(""sgn""); background = inputFile.Get(""bk",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:59230,Performance,optimiz,optimizers,59230,"MaxEpochs=20""; ""DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:""; ) # + ""|"" + trainingString2; # General Options.; trainingString1.Append(archString); dnnName = ""TMVA_DNN""; factory.BookMethod(; dataloader,; TMVA.Types.kDL,; dnnName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=None,; WeightInitialization=""XAVIER"",; RandomSeed=0,; InputLayout=""1|1|"" + str(ntime * ninput),; Layout=""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"",; TrainingStrategy=trainingString1; ); ; ; ## Book Keras recurrent models; ; # Book the different types of recurrent models in Keras (SimpleRNN, LSTM or GRU); ; ; if useKeras:; for i in range(3):; if use_rnn_type[i]:; modelName = ""model_"" + rnn_types[i] + "".h5""; trainedModelName = ""trained_"" + modelName; print(""Building recurrent keras model using a"", rnn_types[i], ""layer""); # create python script which can be executed; # create 2 conv2d layer + maxpool + dense; from tensorflow.keras.models import Sequential; from tensorflow.keras.optimizers import Adam; ; # from keras.initializers import TruncatedNormal; # from keras import initializations; from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, SimpleRNN, GRU, LSTM, Reshape, BatchNormalization; ; model = Sequential(); model.add(Reshape((10, 30), input_shape=(10 * 30,))); # add recurrent neural network depending on type / Use option to return the full output; if rnn_types[i] == ""LSTM"":; model.add(LSTM(units=10, return_sequences=True)); elif rnn_types[i] == ""GRU"":; model.add(GRU(units=10, return_sequences=True)); else:; model.add(SimpleRNN(units=10, return_sequences=True)); # m.AddLine(""model.add(BatchNormalization())"");; model.add(Flatten()) # needed if returning the full time output sequence; model.add(Dense(64, activation=""tanh"")); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(modelName); model.summary(); print(""saved recurrent model"", modelName); ; ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:60096,Performance,optimiz,optimizer,60096," which can be executed; # create 2 conv2d layer + maxpool + dense; from tensorflow.keras.models import Sequential; from tensorflow.keras.optimizers import Adam; ; # from keras.initializers import TruncatedNormal; # from keras import initializations; from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, SimpleRNN, GRU, LSTM, Reshape, BatchNormalization; ; model = Sequential(); model.add(Reshape((10, 30), input_shape=(10 * 30,))); # add recurrent neural network depending on type / Use option to return the full output; if rnn_types[i] == ""LSTM"":; model.add(LSTM(units=10, return_sequences=True)); elif rnn_types[i] == ""GRU"":; model.add(GRU(units=10, return_sequences=True)); else:; model.add(SimpleRNN(units=10, return_sequences=True)); # m.AddLine(""model.add(BatchNormalization())"");; model.add(Flatten()) # needed if returning the full time output sequence; model.add(Dense(64, activation=""tanh"")); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(modelName); model.summary(); print(""saved recurrent model"", modelName); ; if not os.path.exists(modelName):; useKeras = False; print(""Error creating Keras recurrent model file - Skip using Keras""); else:; # book PyKeras method only if Keras model could be created; print(""Booking Keras model "", rnn_types[i]); factory.BookMethod(; dataloader,; TMVA.Types.kPyKeras,; ""PyKeras_"" + rnn_types[i],; H=True,; V=False,; VarTransform=None,; FilenameModel=modelName,; FilenameTrainedModel=""trained_"" + modelName,; NumEpochs=maxepochs,; BatchSize=batchSize,; GpuOptions=""allow_growth=True"",; ); ; ; # use BDT in case not using Keras or TMVA DL; if not useKeras or not useTMVA_BDT:; useTMVA_BDT = True; ; ; ## Book TMVA BDT; ; ; if useTMVA_BDT:; factory.BookMethod(; dataloader,; TMVA.Types.kBDT,; ""BDTG"",; H=True,; V=False,; NTrees=100,; MinNodeSize=""2.5%"",; BoostType=""Grad"",; Shrinkage=0.10,; UseBaggedBoost=True,; BaggedSampl",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:61363,Performance,perform,performance,61363,"sing Keras""); else:; # book PyKeras method only if Keras model could be created; print(""Booking Keras model "", rnn_types[i]); factory.BookMethod(; dataloader,; TMVA.Types.kPyKeras,; ""PyKeras_"" + rnn_types[i],; H=True,; V=False,; VarTransform=None,; FilenameModel=modelName,; FilenameTrainedModel=""trained_"" + modelName,; NumEpochs=maxepochs,; BatchSize=batchSize,; GpuOptions=""allow_growth=True"",; ); ; ; # use BDT in case not using Keras or TMVA DL; if not useKeras or not useTMVA_BDT:; useTMVA_BDT = True; ; ; ## Book TMVA BDT; ; ; if useTMVA_BDT:; factory.BookMethod(; dataloader,; TMVA.Types.kBDT,; ""BDTG"",; H=True,; V=False,; NTrees=100,; MinNodeSize=""2.5%"",; BoostType=""Grad"",; Shrinkage=0.10,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; nCuts=20,; MaxDepth=2,; ); ; ; ## Train all methods; factory.TrainAllMethods(); ; print(""nthreads = {}"".format(ROOT.GetThreadPoolSize())); ; # ---- Evaluate all MVAs using the set of test events; factory.TestAllMethods(); ; # ----- Evaluate and compare performance of all configured MVAs; factory.EvaluateAllMethods(); ; # check method; ; # plot ROC curve; c1 = factory.GetROCCurve(dataloader); c1.Draw(); ; if outputFile:; outputFile.Close(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGW",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:63259,Performance,multi-thread,multi-threading,63259," void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::Config::Instancestatic Config & Instance()static function: returns TMVA instanceDefinition Config.cxx:98; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; Drawth1 Draw(); AuthorHarshal Shende ; Definition in file TMVA_RNN_Classification.py. tutorialstmvaTMVA_RNN_Classification.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:20594,Safety,predict,predictions,20594,".188594 0.0151297 14758.1 0; : 19 | 0.673327 0.684121 0.189356 0.0146185 14650.5 1; : 20 | 0.68729 0.678527 0.188558 0.0148948 14741.2 2; : ; : Elapsed time for training with 3200 events: 3.82 sec ; : Evaluate deep neural network on CPU using batches with size = 256; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0999 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras_LSTM for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras_LSTM ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; saved recurrent model model_LSTM.h5; Booking Keras model LSTM; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total param",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:32250,Safety,risk,risk,32250,"jority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining after the training which splits ; : are considered statistically insignificant and are removed. The; : user is advised to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sample. They should be equal within statistical; : errors, in order to minimize statistical fluctuations in different samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 16",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:49542,Safety,avoid,avoid,49542,"0.077) 0.368 (0.368) 0.659 (0.684); : dataset TMVA_DNN : 0.027 (0.021) 0.223 (0.194) 0.487 (0.491); : -------------------------------------------------------------------------------------------------------------------; : ; Dataset:dataset : Created tree 'TestTree' with 800 events; : ; Dataset:dataset : Created tree 'TrainTree' with 3200 events; : ; Factory : ␛[1mThank you for using TMVA!␛[0m; : ␛[1mFor citation information, please visit: http://tmva.sf.net/citeTMVA.html␛[0m; nthreads = 4; ; ; # TMVA Classification Example Using a Recurrent Neural Network; ; # This is an example of using a RNN in TMVA.; # We do the classification using a toy data set containing a time series of data sample ntimes; # and with dimension ndim that is generated when running the provided function `MakeTimeData (nevents, ntime, ndim)`; ; ; import ROOT; ; num_threads = 4 # use max 4 threads; # do enable MT running; if ""imt"" in ROOT.gROOT.GetConfigFeatures():; ROOT.EnableImplicitMT(num_threads); # switch off MT in OpenBLAS to avoid conflict with tbb; ROOT.gSystem.Setenv(""OMP_NUM_THREADS"", ""1""); print(""Running with nthreads = {}"".format(ROOT.GetThreadPoolSize())); else:; print(""Running in serial mode since ROOT does not support MT""); ; ; TMVA = ROOT.TMVA; TFile = ROOT.TFile; ; import os; import importlib; ; ; TMVA.Tools.Instance(); TMVA.Config.Instance(); ; ; ## Helper function to generate the time data set; ## make some time data but not of fixed length.; ## use a poisson with mu = 5 and truncated at 10; ; ; def MakeTimeData(n, ntime, ndim):; # ntime = 10;; # ndim = 30; // number of dim/time; ; fname = ""time_data_t"" + str(ntime) + ""_d"" + str(ndim) + "".root""; v1 = []; v2 = []; ; for i in range(ntime):; v1.append(ROOT.TH1D(""h1_"" + str(i), ""h1"", ndim, 0, 10)); v2.append(ROOT.TH1D(""h2_"" + str(i), ""h2"", ndim, 0, 10)); ; f1 = ROOT.TF1(""f1"", ""gaus""); f2 = ROOT.TF1(""f2"", ""gaus""); ; sgn = ROOT.TTree(""sgn"", ""sgn""); bkg = ROOT.TTree(""bkg"", ""bkg""); f = TFile(fname, ""RECREATE""); ; x1 = []; x2 = []; ; for",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:2777,Security,validat,validation,2777,"ollowing options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_DNN␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENT",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:2845,Security,validat,validation,2845,"(short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_DNN␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:Input",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:6338,Security,validat,validation,6338,"med)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthreads = 4; --- RNNClassification : Using input file: time_data_t10_d30.root; number of variables is 300; vars_time0[0]; vars_time0[1]; vars_time0[2]; vars_time0[3]; vars_time0[4]; vars_time0[5]; vars_time0[6]; vars_time0[7]; vars_time0[8]; vars_time0[9]; vars_time0[10]; vars_time0[11]; vars_time0[12]; vars_time0[13]; vars_time0[14]; vars_time0[15]; vars_time0[16]; vars_time0[17]; vars_time0[18]; vars_time0[19]; vars_time0[20]; vars_time0[21]; vars_time0[22]; vars_time0[23]; vars_time0[24]; vars_time0[25]; vars_time0[26]; vars_time0[27]; vars_time0[28]; vars_time0[29",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:6406,Security,validat,validation,6406," error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthreads = 4; --- RNNClassification : Using input file: time_data_t10_d30.root; number of variables is 300; vars_time0[0]; vars_time0[1]; vars_time0[2]; vars_time0[3]; vars_time0[4]; vars_time0[5]; vars_time0[6]; vars_time0[7]; vars_time0[8]; vars_time0[9]; vars_time0[10]; vars_time0[11]; vars_time0[12]; vars_time0[13]; vars_time0[14]; vars_time0[15]; vars_time0[16]; vars_time0[17]; vars_time0[18]; vars_time0[19]; vars_time0[20]; vars_time0[21]; vars_time0[22]; vars_time0[23]; vars_time0[24]; vars_time0[25]; vars_time0[26]; vars_time0[27]; vars_time0[28]; vars_time0[29]; vars_time1[0]; vars_time1[1]; vars_time1[2]; vars_time1[3]; vars_time1[4]; vars_time1[5]; vars_time1[6]; vars_time1[7]; vars_time1[8]; vars_time1[9]; vars_time1[10]; vars_time1[11]; vars_time1[12]; vars_time1[13]; vars_time1[14]; vars_time1[15]; vars_time",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:15455,Security,validat,validation,15455,"ars_time0[0] from array expression vars_time0 of size 30; : Using variable vars_time1[0] from array expression vars_time1 of size 30; : Using variable vars_time2[0] from array expression vars_time2 of size 30; : Using variable vars_time3[0] from array expression vars_time3 of size 30; : Using variable vars_time4[0] from array expression vars_time4 of size 30; : Using variable vars_time5[0] from array expression vars_time5 of size 30; : Using variable vars_time6[0] from array expression vars_time6 of size 30; : Using variable vars_time7[0] from array expression vars_time7 of size 30; : Using variable vars_time8[0] from array expression vars_time8 of size 30; : Using variable vars_time9[0] from array expression vars_time9 of size 30; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1600; : Signal -- testing events : 400; : Signal -- training and testing events: 2000; : Background -- training events : 1600; : Background -- testing events : 400; : Background -- training and testing events: 2000; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: TMVA_LSTM for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 10, 1, 30 ) Batch size = 100 Loss function = C; Layer 0 LSTM Layer: (NInput = 30, NState = 10, NTime = 10 ) Output = ( 100 , 10 , 10 ); Layer 1 RESHAPE Layer Input = ( 1 , 10 , 10 ) Output = ( 1 , 100 , 100 ) ; Layer 2 DENSE Layer: ( Input = 100 , Width = 64 ) Output = ( 1 , 100 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:17977,Security,validat,validation,17977," 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:21092,Security,validat,validation,21092,"luation of 3200 events: 0.0999 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras_LSTM for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras_LSTM ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; saved recurrent model model_LSTM.h5; Booking Keras model LSTM; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/10; ; 1/26 [>.............................] - ETA: 42s - loss: 0.7326 - accuracy: 0.4600␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:21863,Security,validat,validation,21863,"en,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; saved recurrent model model_LSTM.h5; Booking Keras model LSTM; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/10; ; 1/26 [>.............................] - ETA: 42s - loss: 0.7326 - accuracy: 0.4600␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 7/26 [=======>......................] - ETA: 0s - loss: 0.7180 - accuracy: 0.4971 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 14/26 [===============>..............] - ETA: 0s - loss: 0.7130 - accuracy: 0.4957␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 23/26 [=========================>....] - ETA: 0s - loss: 0.7095 - accuracy: 0.4961; Epoch 1: val_loss improved from inf to 0.69938, saving model to trained_model_LSTM.h5; ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 26/26 [==============================] - 3s 37ms/step - loss: 0.7096 - accuracy: 0.4922 - val_loss: 0.6994 - val_accuracy: 0.5047; Epoch 2/10; ; 1/26 [>.........",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:3500,Testability,test,testing,3500,"n squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_DNN␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:6188,Testability,test,testing,6188,"med)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthreads = 4; --- RNNClassification : Using input file: time_data_t10_d30.root; number of variables is 300; vars_time0[0]; vars_time0[1]; vars_time0[2]; vars_time0[3]; vars_time0[4]; vars_time0[5]; vars_time0[6]; vars_time0[7]; vars_time0[8]; vars_time0[9]; vars_time0[10]; vars_time0[11]; vars_time0[12]; vars_time0[13]; vars_time0[14]; vars_time0[15]; vars_time0[16]; vars_time0[17]; vars_time0[18]; vars_time0[19]; vars_time0[20]; vars_time0[21]; vars_time0[22]; vars_time0[23]; vars_time0[24]; vars_time0[25]; vars_time0[26]; vars_time0[27]; vars_time0[28]; vars_time0[29",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:14358,Testability,test,testing,14358,"y expression vars_time9 of size 30; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree bkg; : Using variable vars_time0[0] from array expression vars_time0 of size 30; : Using variable vars_time1[0] from array expression vars_time1 of size 30; : Using variable vars_time2[0] from array expression vars_time2 of size 30; : Using variable vars_time3[0] from array expression vars_time3 of size 30; : Using variable vars_time4[0] from array expression vars_time4 of size 30; : Using variable vars_time5[0] from array expression vars_time5 of size 30; : Using variable vars_time6[0] from array expression vars_time6 of size 30; : Using variable vars_time7[0] from array expression vars_time7 of size 30; : Using variable vars_time8[0] from array expression vars_time8 of size 30; : Using variable vars_time9[0] from array expression vars_time9 of size 30; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1600; : Signal -- testing events : 400; : Signal -- training and testing events: 2000; : Background -- training events : 1600; : Background -- testing events : 400; : Background -- training and testing events: 2000; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: TMVA_LSTM for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 10, 1, 30 ) Batch size = 100 Loss function = C; Layer 0 LSTM Layer: (NInput = 30, NState = 10, NTime = 10 ) Output = ( 100 , 10 , 10 ); Layer 1 RESHAPE Layer Input = ( 1 , 10 , 10 ) Output = ( 1 , 100 , 100 ) ; Layer 2 DENSE Layer: ( Input = 100 , Width = 64 ) Output = ( 1 , 100 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = I",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:14501,Testability,test,testing,14501,"Using variable vars_time0[0] from array expression vars_time0 of size 30; : Using variable vars_time1[0] from array expression vars_time1 of size 30; : Using variable vars_time2[0] from array expression vars_time2 of size 30; : Using variable vars_time3[0] from array expression vars_time3 of size 30; : Using variable vars_time4[0] from array expression vars_time4 of size 30; : Using variable vars_time5[0] from array expression vars_time5 of size 30; : Using variable vars_time6[0] from array expression vars_time6 of size 30; : Using variable vars_time7[0] from array expression vars_time7 of size 30; : Using variable vars_time8[0] from array expression vars_time8 of size 30; : Using variable vars_time9[0] from array expression vars_time9 of size 30; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1600; : Signal -- testing events : 400; : Signal -- training and testing events: 2000; : Background -- training events : 1600; : Background -- testing events : 400; : Background -- training and testing events: 2000; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: TMVA_LSTM for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 10, 1, 30 ) Batch size = 100 Loss function = C; Layer 0 LSTM Layer: (NInput = 30, NState = 10, NTime = 10 ) Output = ( 100 , 10 , 10 ); Layer 1 RESHAPE Layer Input = ( 1 , 10 , 10 ) Output = ( 1 , 100 , 100 ) ; Layer 2 DENSE Layer: ( Input = 100 , Width = 64 ) Output = ( 1 , 100 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimiz",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:14548,Testability,test,testing,14548,"ars_time0[0] from array expression vars_time0 of size 30; : Using variable vars_time1[0] from array expression vars_time1 of size 30; : Using variable vars_time2[0] from array expression vars_time2 of size 30; : Using variable vars_time3[0] from array expression vars_time3 of size 30; : Using variable vars_time4[0] from array expression vars_time4 of size 30; : Using variable vars_time5[0] from array expression vars_time5 of size 30; : Using variable vars_time6[0] from array expression vars_time6 of size 30; : Using variable vars_time7[0] from array expression vars_time7 of size 30; : Using variable vars_time8[0] from array expression vars_time8 of size 30; : Using variable vars_time9[0] from array expression vars_time9 of size 30; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1600; : Signal -- testing events : 400; : Signal -- training and testing events: 2000; : Background -- training events : 1600; : Background -- testing events : 400; : Background -- training and testing events: 2000; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: TMVA_LSTM for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 10, 1, 30 ) Batch size = 100 Loss function = C; Layer 0 LSTM Layer: (NInput = 30, NState = 10, NTime = 10 ) Output = ( 100 , 10 , 10 ); Layer 1 RESHAPE Layer Input = ( 1 , 10 , 10 ) Output = ( 1 , 100 , 100 ) ; Layer 2 DENSE Layer: ( Input = 100 , Width = 64 ) Output = ( 1 , 100 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:14626,Testability,test,testing,14626,"ars_time0[0] from array expression vars_time0 of size 30; : Using variable vars_time1[0] from array expression vars_time1 of size 30; : Using variable vars_time2[0] from array expression vars_time2 of size 30; : Using variable vars_time3[0] from array expression vars_time3 of size 30; : Using variable vars_time4[0] from array expression vars_time4 of size 30; : Using variable vars_time5[0] from array expression vars_time5 of size 30; : Using variable vars_time6[0] from array expression vars_time6 of size 30; : Using variable vars_time7[0] from array expression vars_time7 of size 30; : Using variable vars_time8[0] from array expression vars_time8 of size 30; : Using variable vars_time9[0] from array expression vars_time9 of size 30; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1600; : Signal -- testing events : 400; : Signal -- training and testing events: 2000; : Background -- training events : 1600; : Background -- testing events : 400; : Background -- training and testing events: 2000; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: TMVA_LSTM for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 10, 1, 30 ) Batch size = 100 Loss function = C; Layer 0 LSTM Layer: (NInput = 30, NState = 10, NTime = 10 ) Output = ( 100 , 10 , 10 ); Layer 1 RESHAPE Layer Input = ( 1 , 10 , 10 ) Output = ( 1 , 100 , 100 ) ; Layer 2 DENSE Layer: ( Input = 100 , Width = 64 ) Output = ( 1 , 100 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:14677,Testability,test,testing,14677,"ars_time0[0] from array expression vars_time0 of size 30; : Using variable vars_time1[0] from array expression vars_time1 of size 30; : Using variable vars_time2[0] from array expression vars_time2 of size 30; : Using variable vars_time3[0] from array expression vars_time3 of size 30; : Using variable vars_time4[0] from array expression vars_time4 of size 30; : Using variable vars_time5[0] from array expression vars_time5 of size 30; : Using variable vars_time6[0] from array expression vars_time6 of size 30; : Using variable vars_time7[0] from array expression vars_time7 of size 30; : Using variable vars_time8[0] from array expression vars_time8 of size 30; : Using variable vars_time9[0] from array expression vars_time9 of size 30; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1600; : Signal -- testing events : 400; : Signal -- training and testing events: 2000; : Background -- training events : 1600; : Background -- testing events : 400; : Background -- training and testing events: 2000; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: TMVA_LSTM for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 10, 1, 30 ) Batch size = 100 Loss function = C; Layer 0 LSTM Layer: (NInput = 30, NState = 10, NTime = 10 ) Output = ( 100 , 10 , 10 ); Layer 1 RESHAPE Layer Input = ( 1 , 10 , 10 ) Output = ( 1 , 100 , 100 ) ; Layer 2 DENSE Layer: ( Input = 100 , Width = 64 ) Output = ( 1 , 100 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:15416,Testability,test,testing,15416,"ars_time0[0] from array expression vars_time0 of size 30; : Using variable vars_time1[0] from array expression vars_time1 of size 30; : Using variable vars_time2[0] from array expression vars_time2 of size 30; : Using variable vars_time3[0] from array expression vars_time3 of size 30; : Using variable vars_time4[0] from array expression vars_time4 of size 30; : Using variable vars_time5[0] from array expression vars_time5 of size 30; : Using variable vars_time6[0] from array expression vars_time6 of size 30; : Using variable vars_time7[0] from array expression vars_time7 of size 30; : Using variable vars_time8[0] from array expression vars_time8 of size 30; : Using variable vars_time9[0] from array expression vars_time9 of size 30; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1600; : Signal -- testing events : 400; : Signal -- training and testing events: 2000; : Background -- training events : 1600; : Background -- testing events : 400; : Background -- training and testing events: 2000; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: TMVA_LSTM for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 10, 1, 30 ) Batch size = 100 Loss function = C; Layer 0 LSTM Layer: (NInput = 30, NState = 10, NTime = 10 ) Output = ( 100 , 10 , 10 ); Layer 1 RESHAPE Layer Input = ( 1 , 10 , 10 ) Output = ( 1 , 100 , 100 ) ; Layer 2 DENSE Layer: ( Input = 100 , Width = 64 ) Output = ( 1 , 100 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:17938,Testability,test,testing,17938," 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31149,Testability,test,test,31149,"mdataset/weights/TMVAClassification_PyKeras_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: BDTG for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ BDTG ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : Boosted Decision Trees are a collection of individual decision; : trees which form a multivariate classifier by (weighted) majority ; : vote of the individual trees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:32989,Testability,test,test,32989,"mal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining after the training which splits ; : are considered statistically insignificant and are removed. The; : user is advised to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sample. They should be equal within statistical; : errors, in order to minimize statistical fluctuations in different samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 1600 bkg: 1600; : #events: (unweighted) sig: 1600 bkg: 1600; : Training 100 Decision Trees ... patience please; : Elapsed time for training with 3200 events: 1.7 sec ; BDTG : [dataset] : Evaluation of BDTG on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0183 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_BDTG.class.C␛[0m; : data_RNN_CPU.root:/dataset/Method_BDT/BDTG; Factory : Training finished; : ; : Ranking input variables (method specific)...; : ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:44593,Testability,test,testing,44593,"000e+00; : 296 : vars_time9 : 0.000e+00; : 297 : vars_time9 : 0.000e+00; : 298 : vars_time9 : 0.000e+00; : 299 : vars_time9 : 0.000e+00; : 300 : vars_time9 : 0.000e+00; : --------------------------------------------; TH1.Print Name = TrainingHistory_TMVA_LSTM_trainingError, Entries= 0, Total sum= 6.54098; TH1.Print Name = TrainingHistory_TMVA_LSTM_valError, Entries= 0, Total sum= 6.61254; TH1.Print Name = TrainingHistory_TMVA_DNN_trainingError, Entries= 0, Total sum= 13.752; TH1.Print Name = TrainingHistory_TMVA_DNN_valError, Entries= 0, Total sum= 13.5872; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'accuracy', Entries= 0, Total sum= 6.34883; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'loss', Entries= 0, Total sum= 6.27501; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_accuracy', Entries= 0, Total sum= 6.33125; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_loss', Entries= 0, Total sum= 6.20691; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LST",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45204,Testability,test,testing,45204,"valError, Entries= 0, Total sum= 13.5872; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'accuracy', Entries= 0, Total sum= 6.34883; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'loss', Entries= 0, Total sum= 6.27501; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_accuracy', Entries= 0, Total sum= 6.33125; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_loss', Entries= 0, Total sum= 6.20691; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45481,Testability,test,testing,45481,"al sum= 6.33125; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_loss', Entries= 0, Total sum= 6.20691; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with clas",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45979,Testability,test,testing,45979,"[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46170,Testability,test,testing,46170," ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46378,Testability,test,test,46378,"n performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier respo",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46706,Testability,test,test,46706,"STM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : ---------------------------------------------------------",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:47042,Testability,test,test,47042,"TM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDTG : 0.843; : dataset PyKeras_LSTM : 0.815; : dataset TMVA_LSTM : 0.732; : dataset TMVA_DNN : 0.637; : ------------------------------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:47288,Testability,test,test,47288,"ation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDTG : 0.843; : dataset PyKeras_LSTM : 0.815; : dataset TMVA_LSTM : 0.732; : dataset TMVA_DNN : 0.637; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method:",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:48171,Testability,test,test,48171,"[dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDTG : 0.843; : dataset PyKeras_LSTM : 0.815; : dataset TMVA_LSTM : 0.732; : dataset TMVA_DNN : 0.637; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method: @B=0.01 @B=0.10 @B=0.30 ; : -------------------------------------------------------------------------------------------------------------------; : dataset BDTG : 0.135 (0.272) 0.502 (0.648) 0.835 (0.886); : dataset PyKeras_LSTM : 0.155 (0.155) 0.485 (0.572) 0.768 (0.836); : dataset TMVA_LSTM : 0.035 (0.077) 0.368 (0.368) 0.659 (0.684); : dataset TMVA_DNN : 0.027 (0.021) 0.223 (0.194) 0.487 (0.491); : -------------------------------------------------------------------------------------------------------------------; : ; Dataset:dataset : Created tree 'TestTree' with 800 events; : ; Dataset:dataset : Created tree 'TrainTree' with 3200 events; : ; Factory : ␛[1mThank you for using TMVA!␛[0m; : ␛[1mFor citation information, please visit: http://tmva.sf.net/citeTMVA.html␛[0m; nthreads = 4; ",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:61293,Testability,test,test,61293,"s(modelName):; useKeras = False; print(""Error creating Keras recurrent model file - Skip using Keras""); else:; # book PyKeras method only if Keras model could be created; print(""Booking Keras model "", rnn_types[i]); factory.BookMethod(; dataloader,; TMVA.Types.kPyKeras,; ""PyKeras_"" + rnn_types[i],; H=True,; V=False,; VarTransform=None,; FilenameModel=modelName,; FilenameTrainedModel=""trained_"" + modelName,; NumEpochs=maxepochs,; BatchSize=batchSize,; GpuOptions=""allow_growth=True"",; ); ; ; # use BDT in case not using Keras or TMVA DL; if not useKeras or not useTMVA_BDT:; useTMVA_BDT = True; ; ; ## Book TMVA BDT; ; ; if useTMVA_BDT:; factory.BookMethod(; dataloader,; TMVA.Types.kBDT,; ""BDTG"",; H=True,; V=False,; NTrees=100,; MinNodeSize=""2.5%"",; BoostType=""Grad"",; Shrinkage=0.10,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; nCuts=20,; MaxDepth=2,; ); ; ; ## Train all methods; factory.TrainAllMethods(); ; print(""nthreads = {}"".format(ROOT.GetThreadPoolSize())); ; # ---- Evaluate all MVAs using the set of test events; factory.TestAllMethods(); ; # ----- Evaluate and compare performance of all configured MVAs; factory.EvaluateAllMethods(); ; # check method; ; # plot ROC curve; c1 = factory.GetROCCurve(dataloader); c1.Draw(); ; if outputFile:; outputFile.Close(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int",MatchSource.WIKI,doc/master/TMVA__RNN__Classification_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html
https://root.cern/doc/master/TMVA__SOFIE__GNN__Application_8C.html:531,Integrability,depend,dependency,531,". ROOT: tutorials/tmva/TMVA_SOFIE_GNN_Application.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Functions |; Variables ; TMVA_SOFIE_GNN_Application.C File Reference. #include ""encoder.hxx""; #include ""core.hxx""; #include ""decoder.hxx""; #include ""output_transform.hxx""; #include ""TMVA/SOFIE_common.hxx""; #include ""TRandom3.h""; #include ""TH1.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TSystem.h""; #include ""ROOT/RDataFrame.hxx"". Include dependency graph for TMVA_SOFIE_GNN_Application.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  SOFIE_GNN;  . Functions; double check_mem (std::string s="""");  ; std::vector< GNN_Data > GenerateData (int nevts, int seed);  ; int main ();  ; void Print (GNN_Data &d, std::string txt="""");  ; template<class T > ; void PrintTensor (RTensor< T > &t);  ; std::vector< GNN_Data > ReadData (std::string treename, std::string filename);  ; void TMVA_SOFIE_GNN_Application (bool verbose=false);  . Variables; const int EDGE_FEATURE_SIZE = 4;  ; const int GLOBAL_FEATURE_SIZE = 1;  ; const int NODE_FEATURE_SIZE = 4;  ; const int num_max_edges = 30;  ; const int num_max_nodes = 10;  . Function Documentation. ◆ check_mem(). double check_mem ; (; std::string ; s = """"). Definition at line 27 of file TMVA_SOFIE_GNN_Application.C. ◆ GenerateData(). std::vector< GNN_Data > GenerateData ; (; int ; nevts, . int ; seed . ). Definition at line 109 of file TMVA_SOFIE_GNN_Application.C. ◆ main(). int main ; (; ). Definition at line 234 of file TMVA_SOFIE_GNN_Application.C. ◆ Print(). void Print ; (; GNN_Data & ; d, . std::string ; txt = """" . ). Definition at line 59 of file TMVA_SOFIE_GNN_Application.C. ◆ PrintTensor(). template<class T > . void PrintTensor ; (; RTensor< T > & ; t). Definition at line 40 of file TMVA_SOFIE_GNN_Application.C. ◆ ReadData(). std::vector< GNN_Data > ReadData ; (; std::string ; treename, . s",MatchSource.WIKI,doc/master/TMVA__SOFIE__GNN__Application_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__GNN__Application_8C.html
https://root.cern/doc/master/TMVA__SOFIE__GNN__Application_8C_source.html:11924,Integrability,interface,interface,11924,".C:40; num_max_nodesconst int num_max_nodesDefinition TMVA_SOFIE_GNN_Application.C:103; TMVA_SOFIE_GNN_Applicationvoid TMVA_SOFIE_GNN_Application(bool verbose=false)Definition TMVA_SOFIE_GNN_Application.C:171; NODE_FEATURE_SIZEconst int NODE_FEATURE_SIZEDefinition TMVA_SOFIE_GNN_Application.C:105; check_memdouble check_mem(std::string s="""")Definition TMVA_SOFIE_GNN_Application.C:27; mainint main()Definition TMVA_SOFIE_GNN_Application.C:234; GenerateDatastd::vector< GNN_Data > GenerateData(int nevts, int seed)Definition TMVA_SOFIE_GNN_Application.C:109; TRandom3.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::RDF::RInterface::TakeRResultPtr< COLL > Take(std::string_view column="""")Return a collection of values of a column (lazy action, returns a std::vector by default).Definition RInterface.hxx:1761; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVecA ""std::vector""-like collection of values implementing handy operation to analyse them.Definition RVec.hxx:1529; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TMVA::Experimental::RTensor::endIterator end() noexceptDefinition RTensor.hxx:308",MatchSource.WIKI,doc/master/TMVA__SOFIE__GNN__Application_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__GNN__Application_8C_source.html
https://root.cern/doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html:5736,Safety,predict,prediction,5736,"####################################################################################; 116 ; 117# Instantiating EncodeProcessDecode Model; 118 ; 119printMemory(""before instantiating""); 120ep_model = EncodeProcessDecode(); 121printMemory(""after instantiating""); 122 ; 123# Initializing randomized input data with maximum number of nodes/edges; 124GraphData = get_fix_graph_data_dict(num_max_nodes, num_max_edges, node_size, edge_size, global_size); 125 ; 126#input_graphs is a tuple representing the initial data; 127input_graph_data = utils_tf.data_dicts_to_graphs_tuple([GraphData]); 128 ; 129# Initializing randomized input data for core; 130# note that the core network has as input a double number of features; 131CoreGraphData = get_fix_graph_data_dict(num_max_nodes, num_max_edges, 2*LATENT_SIZE, 2*LATENT_SIZE, 2*LATENT_SIZE); 132input_core_graph_data = utils_tf.data_dicts_to_graphs_tuple([CoreGraphData]); 133 ; 134#initialize graph data for decoder (input is LATENT_SIZE); 135DecodeGraphData = get_fix_graph_data_dict(num_max_nodes, num_max_edges, LATENT_SIZE, LATENT_SIZE, LATENT_SIZE); 136 ; 137# Make prediction of GNN. This will initialize the GNN with weights; 138printMemory(""before first eval""); 139output_gn = ep_model(input_graph_data, processing_steps); 140printMemory(""after first eval""); 141#print(""---> Input:\n"",input_graph_data); 142#print(""\n\n------> Input core data:\n"",input_core_graph_data); 143#print(""\n\n---> Output:\n"",output_gn); 144 ; 145# Make SOFIE Model, the model will be made using a maximum number of nodes/edges which are inside GraphData; 146 ; 147encoder = ROOT.TMVA.Experimental.SOFIE.RModel_GraphIndependent.ParseFromMemory(ep_model._encoder._network, GraphData, filename = ""encoder""); 148encoder.Generate(); 149encoder.OutputGenerated(); 150 ; 151core = ROOT.TMVA.Experimental.SOFIE.RModel_GNN.ParseFromMemory(ep_model._core._network, CoreGraphData, filename = ""core""); 152core.Generate(); 153core.OutputGenerated(); 154 ; 155decoder = ROOT.TMVA.Experim",MatchSource.WIKI,doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html
https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html:5623,Energy Efficiency,allocate,allocate,5623,rnel0.data();; std::vector<float> fTensor_dense_2kernel0 = std::vector<float>(4096);; float * tensor_dense_2kernel0 = fTensor_dense_2kernel0.data();; std::vector<float> fTensor_dense_1bias0 = std::vector<float>(64);; float * tensor_dense_1bias0 = fTensor_dense_1bias0.data();; std::vector<float> fTensor_dense_4bias0 = std::vector<float>(2);; float * tensor_dense_4bias0 = fTensor_dense_4bias0.data();; std::vector<float> fTensor_dense_1kernel0 = std::vector<float>(4096);; float * tensor_dense_1kernel0 = fTensor_dense_1kernel0.data();; std::vector<float> fTensor_densebias0 = std::vector<float>(64);; float * tensor_densebias0 = fTensor_densebias0.data();; std::vector<float> fTensor_dense_2bias0 = std::vector<float>(64);; float * tensor_dense_2bias0 = fTensor_dense_2bias0.data();; std::vector<float> fTensor_densekernel0 = std::vector<float>(448);; float * tensor_densekernel0 = fTensor_densekernel0.data();; ; //--- declare and allocate the intermediate tensors; std::vector<float> fTensor_dense_4Sigmoid0 = std::vector<float>(2);; float * tensor_dense_4Sigmoid0 = fTensor_dense_4Sigmoid0.data();; std::vector<float> fTensor_dense_4Dense = std::vector<float>(2);; float * tensor_dense_4Dense = fTensor_dense_4Dense.data();; std::vector<float> fTensor_densebias0bcast = std::vector<float>(64);; float * tensor_densebias0bcast = fTensor_densebias0bcast.data();; std::vector<float> fTensor_dense_1bias0bcast = std::vector<float>(64);; float * tensor_dense_1bias0bcast = fTensor_dense_1bias0bcast.data();; std::vector<float> fTensor_dense_3bias0bcast = std::vector<float>(64);; float * tensor_dense_3bias0bcast = fTensor_dense_3bias0bcast.data();; std::vector<float> fTensor_dense_1Dense = std::vector<float>(64);; float * tensor_dense_1Dense = fTensor_dense_1Dense.data();; std::vector<float> fTensor_dense_1Relu0 = std::vector<float>(64);; float * tensor_dense_1Relu0 = fTensor_dense_1Relu0.data();; std::vector<float> fTensor_dense_2Dense = std::vector<float>(64);; float * tensor_dense_2Dense =,MatchSource.WIKI,doc/master/TMVA__SOFIE__Inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html
https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html:14243,Energy Efficiency,allocate,allocate,14243,,MatchSource.WIKI,doc/master/TMVA__SOFIE__Inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html
https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html:3215,Integrability,interface,interface,3215," print(""size of data"", dataset_size); ; #instantiate SOFIE session class ; session = ROOT.TMVA_SOFIE_Higgs_trained_model.Session(); ; hs = ROOT.TH1D(""hs"",""Signal result"",100,0,1); for i in range(0,dataset_size):; result = session.infer(xsig[i,:]); hs.Fill(result[0]); ; ; # make SOFIE inference on background data; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); bkgData = df2.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); ; xbkg = np.column_stack(list(bkgData.values())); dataset_size = xbkg.shape[0]; ; hb = ROOT.TH1D(""hb"",""Background result"",100,0,1); for i in range(0,dataset_size):; result = session.infer(xbkg[i,:]); hb.Fill(result[0]); ; ; c1 = ROOT.TCanvas(); ROOT.gStyle.SetOptStat(0); hs.SetLineColor(ROOT.kRed); hs.Draw(); hb.SetLineColor(ROOT.kBlue); hb.Draw(""SAME""); c1.BuildLegend(); c1.Draw(); ; ; print(""Number of signal entries"",hs.GetEntries()); print(""Number of background entries"",hb.GetEntries()); ; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; //Code generated automatically by TMVA for Inference of Model file [Higgs_trained_model.h5] at [Tue Nov 5 09:32:51 2024] ; ; #ifndef ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; #define ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; ; #include <algorithm>; #include <vector>; #include <cmath>; #include ""TMVA/SOFIE_common.hxx""; #include <fstream>; ; namespace TMVA_SOFIE_Higgs_trained_model{; namespace BLAS{; extern ""C"" void sgemv_(const char * trans, const int * m, const int * n, const float * alpha, const float * A,; const int * lda, const float * X, const int * incx, const float * beta, const float * Y, const int * incy);; extern ""C"" void sgemm_(const char * transa, const char * transb, const int * m, const int * n, const int * k,; const float * alpha, const float * A, const int * lda, const float * B, const int *",MatchSource.WIKI,doc/master/TMVA__SOFIE__Inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html
https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html:3715,Deployability,install,installed,3715,"E::RModel::OutputGeneratedvoid OutputGenerated(std::string filename="""", bool append=false)Definition RModel.cxx:1081; TMVA::Experimental::SOFIE::RModel::PrintInitializedTensorsvoid PrintInitializedTensors()Definition RModel.cxx:985; TMVA::Experimental::SOFIE::RModel::Generatevoid Generate(std::underlying_type_t< Options > options, int batchSize=-1, long pos=0, bool verbose=false)Definition RModel.cxx:703; TMVA::Experimental::SOFIE::RModel::PrintRequiredInputTensorsvoid PrintRequiredInputTensors()Definition RModel.cxx:955; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMacroClass supporting a collection of lines with C++ code.Definition TMacro.h:31; TStringBasic string class.Definition TString.h:139; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA::Python_ExecutableTString Python_Executable()Function to find current Python executable used by ROOT If ""Python3"" is installed,...Definition PyMethodBase.cxx:43; mTMarker mDefinition textangle.C:8; ; Epoch 1/5; ; 1/1 [==============================] - ETA: 0s - loss: 0.3252␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 1/1 [==============================] - 0s 480ms/step - loss: 0.3252; Epoch 2/5; ; 1/1 [==============================] - ETA: 0s - loss: 0.3210␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 1/1 [==============================] - 0s 4ms/step - loss: 0.3210; Epoch 3/5; ; 1/1 [==============================] - ETA: 0s - loss: 0.3183␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 1/1 [==============================] - 0s 4ms/step - loss: 0.3183; Epoch 4/5; ; 1/1 [==============================] - ETA: 0s - loss: 0.3135␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 1/1 [==============================] - 0s 4ms/step - loss: 0.3135; Epoch 5/5; ; 1/1 [=======================",MatchSource.WIKI,doc/master/TMVA__SOFIE__Keras_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html
https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html:8056,Energy Efficiency,allocate,allocate,8056,.data();; std::vector<float> fTensor_dense_3kernel0 = std::vector<float>(32);; float * tensor_dense_3kernel0 = fTensor_dense_3kernel0.data();; std::vector<float> fTensor_dense_2kernel0 = std::vector<float>(128);; float * tensor_dense_2kernel0 = fTensor_dense_2kernel0.data();; std::vector<float> fTensor_dense_1bias0 = std::vector<float>(16);; float * tensor_dense_1bias0 = fTensor_dense_1bias0.data();; std::vector<float> fTensor_dense_1kernel0 = std::vector<float>(512);; float * tensor_dense_1kernel0 = fTensor_dense_1kernel0.data();; std::vector<float> fTensor_densebias0 = std::vector<float>(32);; float * tensor_densebias0 = fTensor_densebias0.data();; std::vector<float> fTensor_dense_2bias0 = std::vector<float>(8);; float * tensor_dense_2bias0 = fTensor_dense_2bias0.data();; std::vector<float> fTensor_densekernel0 = std::vector<float>(2048);; float * tensor_densekernel0 = fTensor_densekernel0.data();; ; //--- declare and allocate the intermediate tensors; std::vector<float> fTensor_dense_3BiasAdd0 = std::vector<float>(16);; float * tensor_dense_3BiasAdd0 = fTensor_dense_3BiasAdd0.data();; std::vector<float> fTensor_re_luRelu0 = std::vector<float>(16);; float * tensor_re_luRelu0 = fTensor_re_luRelu0.data();; std::vector<float> fTensor_dense_3bias0bcast = std::vector<float>(16);; float * tensor_dense_3bias0bcast = fTensor_dense_3bias0bcast.data();; std::vector<float> fTensor_dense_1Dense = std::vector<float>(64);; float * tensor_dense_1Dense = fTensor_dense_1Dense.data();; std::vector<float> fTensor_dense_1Relu0 = std::vector<float>(64);; float * tensor_dense_1Relu0 = fTensor_dense_1Relu0.data();; std::vector<float> fTensor_activationRelu0 = std::vector<float>(128);; float * tensor_activationRelu0 = fTensor_activationRelu0.data();; std::vector<float> fTensor_dense_2Relu0 = std::vector<float>(32);; float * tensor_dense_2Relu0 = fTensor_dense_2Relu0.data();; std::vector<float> fTensor_dense_2Dense = std::vector<float>(32);; float * tensor_dense_2Dense = fTensor_dense_2Den,MatchSource.WIKI,doc/master/TMVA__SOFIE__Keras_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html
https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html:15025,Energy Efficiency,allocate,allocate,15025,,MatchSource.WIKI,doc/master/TMVA__SOFIE__Keras_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html
https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html:594,Modifiability,layers,layers,594,". ROOT: tutorials/tmva/TMVA_SOFIE_Keras.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_Keras.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import os\n\; os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\; \n\; import numpy as np\n\; from tensorflow.keras.models import Model\n\; from tensorflow.keras.layers import Input,Dense,Activation,ReLU\n\; from tensorflow.keras.optimizers import SGD\n\; \n\; input=Input(shape=(64,),batch_size=4)\n\; x=Dense(32)(input)\n\; x=Activation('relu')(x)\n\; x=Dense(16,activation='relu')(x)\n\; x=Dense(8,activation='relu')(x)\n\; x=Dense(4)(x)\n\; output=ReLU()(x)\n\; model=Model(inputs=input,outputs=output)\n\; \n\; randomGenerator=np.random.RandomState(0)\n\; x_train=randomGenerator.rand(4,64)\n\; y_train=randomGenerator.rand(4,4)\n\; \n\; model.compile(loss='mean_squared_error', optimizer=SGD(learning_rate=0.01))\n\; model.fit(x_train, y_train, epochs=5, batch_size=4)\n\; model.save('KerasModel.h5')\n"";; ; ; void TMVA_SOFIE_Keras(const char * modelFile = nullptr, bool printModelInfo = true){; ; //Running the Python script to generate Keras .h5 file; TMVA::PyMethodBase::PyInitialize();; ; if (modelFile == nullptr) {; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_keras_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_keras_model.py"");; modelFile = ""KerasModel.h5"";; }; ; //Parsing the saved Keras .h5 file into RModel object; SOFIE::RModel model = SOFIE::PyKeras::Parse(modelFile);; ; ; //Generating inference code; model.Generate();; // generate output header. By default it will be modelName.hxx; model.OutputGenerated();; ; if (!printModelInfo) return;; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInpu",MatchSource.WIKI,doc/master/TMVA__SOFIE__Keras_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html
https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html:662,Performance,optimiz,optimizers,662,". ROOT: tutorials/tmva/TMVA_SOFIE_Keras.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_Keras.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import os\n\; os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\; \n\; import numpy as np\n\; from tensorflow.keras.models import Model\n\; from tensorflow.keras.layers import Input,Dense,Activation,ReLU\n\; from tensorflow.keras.optimizers import SGD\n\; \n\; input=Input(shape=(64,),batch_size=4)\n\; x=Dense(32)(input)\n\; x=Activation('relu')(x)\n\; x=Dense(16,activation='relu')(x)\n\; x=Dense(8,activation='relu')(x)\n\; x=Dense(4)(x)\n\; output=ReLU()(x)\n\; model=Model(inputs=input,outputs=output)\n\; \n\; randomGenerator=np.random.RandomState(0)\n\; x_train=randomGenerator.rand(4,64)\n\; y_train=randomGenerator.rand(4,4)\n\; \n\; model.compile(loss='mean_squared_error', optimizer=SGD(learning_rate=0.01))\n\; model.fit(x_train, y_train, epochs=5, batch_size=4)\n\; model.save('KerasModel.h5')\n"";; ; ; void TMVA_SOFIE_Keras(const char * modelFile = nullptr, bool printModelInfo = true){; ; //Running the Python script to generate Keras .h5 file; TMVA::PyMethodBase::PyInitialize();; ; if (modelFile == nullptr) {; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_keras_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_keras_model.py"");; modelFile = ""KerasModel.h5"";; }; ; //Parsing the saved Keras .h5 file into RModel object; SOFIE::RModel model = SOFIE::PyKeras::Parse(modelFile);; ; ; //Generating inference code; model.Generate();; // generate output header. By default it will be modelName.hxx; model.OutputGenerated();; ; if (!printModelInfo) return;; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInpu",MatchSource.WIKI,doc/master/TMVA__SOFIE__Keras_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html
https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html:1116,Performance,optimiz,optimizer,1116,"Searching...; No Matches. TMVA_SOFIE_Keras.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import os\n\; os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\; \n\; import numpy as np\n\; from tensorflow.keras.models import Model\n\; from tensorflow.keras.layers import Input,Dense,Activation,ReLU\n\; from tensorflow.keras.optimizers import SGD\n\; \n\; input=Input(shape=(64,),batch_size=4)\n\; x=Dense(32)(input)\n\; x=Activation('relu')(x)\n\; x=Dense(16,activation='relu')(x)\n\; x=Dense(8,activation='relu')(x)\n\; x=Dense(4)(x)\n\; output=ReLU()(x)\n\; model=Model(inputs=input,outputs=output)\n\; \n\; randomGenerator=np.random.RandomState(0)\n\; x_train=randomGenerator.rand(4,64)\n\; y_train=randomGenerator.rand(4,4)\n\; \n\; model.compile(loss='mean_squared_error', optimizer=SGD(learning_rate=0.01))\n\; model.fit(x_train, y_train, epochs=5, batch_size=4)\n\; model.save('KerasModel.h5')\n"";; ; ; void TMVA_SOFIE_Keras(const char * modelFile = nullptr, bool printModelInfo = true){; ; //Running the Python script to generate Keras .h5 file; TMVA::PyMethodBase::PyInitialize();; ; if (modelFile == nullptr) {; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_keras_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_keras_model.py"");; modelFile = ""KerasModel.h5"";; }; ; //Parsing the saved Keras .h5 file into RModel object; SOFIE::RModel model = SOFIE::PyKeras::Parse(modelFile);; ; ; //Generating inference code; model.Generate();; // generate output header. By default it will be modelName.hxx; model.OutputGenerated();; ; if (!printModelInfo) return;; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInputTensors();; ; //Printing initialized tensors (weights); std::cout<<""\n\n"";; model.PrintInitializedTensors();; ; ",MatchSource.WIKI,doc/master/TMVA__SOFIE__Keras_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html
https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html:244,Usability,simpl,simple,244,". ROOT: tutorials/tmva/TMVA_SOFIE_Keras.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_Keras.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import os\n\; os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\; \n\; import numpy as np\n\; from tensorflow.keras.models import Model\n\; from tensorflow.keras.layers import Input,Dense,Activation,ReLU\n\; from tensorflow.keras.optimizers import SGD\n\; \n\; input=Input(shape=(64,),batch_size=4)\n\; x=Dense(32)(input)\n\; x=Activation('relu')(x)\n\; x=Dense(16,activation='relu')(x)\n\; x=Dense(8,activation='relu')(x)\n\; x=Dense(4)(x)\n\; output=ReLU()(x)\n\; model=Model(inputs=input,outputs=output)\n\; \n\; randomGenerator=np.random.RandomState(0)\n\; x_train=randomGenerator.rand(4,64)\n\; y_train=randomGenerator.rand(4,4)\n\; \n\; model.compile(loss='mean_squared_error', optimizer=SGD(learning_rate=0.01))\n\; model.fit(x_train, y_train, epochs=5, batch_size=4)\n\; model.save('KerasModel.h5')\n"";; ; ; void TMVA_SOFIE_Keras(const char * modelFile = nullptr, bool printModelInfo = true){; ; //Running the Python script to generate Keras .h5 file; TMVA::PyMethodBase::PyInitialize();; ; if (modelFile == nullptr) {; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_keras_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_keras_model.py"");; modelFile = ""KerasModel.h5"";; }; ; //Parsing the saved Keras .h5 file into RModel object; SOFIE::RModel model = SOFIE::PyKeras::Parse(modelFile);; ; ; //Generating inference code; model.Generate();; // generate output header. By default it will be modelName.hxx; model.OutputGenerated();; ; if (!printModelInfo) return;; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInpu",MatchSource.WIKI,doc/master/TMVA__SOFIE__Keras_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html
https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html:6290,Integrability,interface,interface,6290,"Draw(); hb.Draw(""same""); ; c1 = ROOT.TCanvas(); c1.Divide(1,3); c1.cd(1); PlotHistos(hs1,hb1); c1.cd(2); PlotHistos(hs2,hb2); c1.cd(3); PlotHistos(hs3,hb3); c1.Draw(); ; ## draw also ROC curves; ; def GetContent(h) :; n = h.GetNbinsX(); x = ROOT.std.vector['float'](n); w = ROOT.std.vector['float'](n); for i in range(0,n):; x[i] = h.GetBinCenter(i+1); w[i] = h.GetBinContent(i+1); return x,w; ; def MakeROCCurve(hs, hb) :; xs,ws = GetContent(hs); xb,wb = GetContent(hb); roc = ROOT.TMVA.ROCCurve(xs,xb,ws,wb); print(""ROC integral for "",hs.GetName(), roc.GetROCIntegral()); curve = roc.GetROCCurve(); curve.SetName(hs.GetName()); return roc,curve; ; c2 = ROOT.TCanvas(); ; r1,curve1 = MakeROCCurve(hs1,hb1); curve1.SetLineColor(ROOT.kRed); curve1.Draw(""AC""); ; r2,curve2 = MakeROCCurve(hs2,hb2); curve2.SetLineColor(ROOT.kBlue); curve2.Draw(""C""); ; r3,curve3 = MakeROCCurve(hs3,hb3); curve3.SetLineColor(ROOT.kGreen); curve3.Draw(""C""); ; c2.Draw(); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; size of data 10000; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; dense (Dense) (None, 64) 512 ; ; dense_1 (Dense) (None, 64) 4160 ; ; dense_2 (Dense) (None, 64) 4160 ; ; dense_3 (Dense) (None, 64) 4160 ; ; dense_4 (Dense) (None, 1) 65 ; ; =================================================================; Total params: 13057 (51.00 KB); Trainable params: 13057 (51.00 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; Epoch 1/10; ; 1/200 [..............................] - ETA: 3:35 - loss: 0.7076 - accuracy: 0.3800␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 19/200 [=>............................] - ETA: 0s - loss: 0.6900 - accuracy: 0.5526 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈",MatchSource.WIKI,doc/master/TMVA__SOFIE__Models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html
https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html:888,Modifiability,layers,layers,888,". ROOT: tutorials/tmva/TMVA_SOFIE_Models.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; TMVA_SOFIE_Models.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of inference with SOFIE using a set of models trained with Keras. ; This tutorial shows how to store several models in a single header file and the weights in a ROOT binary file. The models are then evaluated using the RDataFrame First, generate the input model by running TMVA_Higgs_Classification.C.; This tutorial parses the input model and runs the inference using ROOT's JITing capability.; ; import ROOT; from os.path import exists; ; ROOT.TMVA.PyMethodBase.PyInitialize(); ; ; ## generate and train Keras models with different architectures; ; import numpy as np; from tensorflow.keras.models import Sequential; from tensorflow.keras.layers import Dense; from tensorflow.keras.optimizers import Adam; ; from sklearn.model_selection import train_test_split; ; def CreateModel(nlayers = 4, nunits = 64):; model = Sequential(); model.add(Dense(nunits, activation='relu',input_dim=7)); for i in range(1,nlayers) :; model.add(Dense(nunits, activation='relu')); ; model.add(Dense(1, activation='sigmoid')); model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy']); model.summary(); return model; ; def PrepareData() :; #get the input data; inputFileName = ""Higgs_data.root""; inputFile = ""http://root.cern.ch/files/"" + inputFileName; ; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); sigData = df1.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); #print(sigData); ; # stack all the 7 numpy array in a single array (nevents x nvars); xsig = np.column_stack(list(sigData.values())); data_sig_size = xsig.shape[0]; print(""size of data"", data_sig_size); ; # make SOFIE inference on background data; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); bkgData = df2.AsNumpy(c",MatchSource.WIKI,doc/master/TMVA__SOFIE__Models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html
https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html:931,Performance,optimiz,optimizers,931,". ROOT: tutorials/tmva/TMVA_SOFIE_Models.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; TMVA_SOFIE_Models.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of inference with SOFIE using a set of models trained with Keras. ; This tutorial shows how to store several models in a single header file and the weights in a ROOT binary file. The models are then evaluated using the RDataFrame First, generate the input model by running TMVA_Higgs_Classification.C.; This tutorial parses the input model and runs the inference using ROOT's JITing capability.; ; import ROOT; from os.path import exists; ; ROOT.TMVA.PyMethodBase.PyInitialize(); ; ; ## generate and train Keras models with different architectures; ; import numpy as np; from tensorflow.keras.models import Sequential; from tensorflow.keras.layers import Dense; from tensorflow.keras.optimizers import Adam; ; from sklearn.model_selection import train_test_split; ; def CreateModel(nlayers = 4, nunits = 64):; model = Sequential(); model.add(Dense(nunits, activation='relu',input_dim=7)); for i in range(1,nlayers) :; model.add(Dense(nunits, activation='relu')); ; model.add(Dense(1, activation='sigmoid')); model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy']); model.summary(); return model; ; def PrepareData() :; #get the input data; inputFileName = ""Higgs_data.root""; inputFile = ""http://root.cern.ch/files/"" + inputFileName; ; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); sigData = df1.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); #print(sigData); ; # stack all the 7 numpy array in a single array (nevents x nvars); xsig = np.column_stack(list(sigData.values())); data_sig_size = xsig.shape[0]; print(""size of data"", data_sig_size); ; # make SOFIE inference on background data; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); bkgData = df2.AsNumpy(c",MatchSource.WIKI,doc/master/TMVA__SOFIE__Models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html
https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html:1299,Performance,optimiz,optimizer,1299,"ned with Keras. ; This tutorial shows how to store several models in a single header file and the weights in a ROOT binary file. The models are then evaluated using the RDataFrame First, generate the input model by running TMVA_Higgs_Classification.C.; This tutorial parses the input model and runs the inference using ROOT's JITing capability.; ; import ROOT; from os.path import exists; ; ROOT.TMVA.PyMethodBase.PyInitialize(); ; ; ## generate and train Keras models with different architectures; ; import numpy as np; from tensorflow.keras.models import Sequential; from tensorflow.keras.layers import Dense; from tensorflow.keras.optimizers import Adam; ; from sklearn.model_selection import train_test_split; ; def CreateModel(nlayers = 4, nunits = 64):; model = Sequential(); model.add(Dense(nunits, activation='relu',input_dim=7)); for i in range(1,nlayers) :; model.add(Dense(nunits, activation='relu')); ; model.add(Dense(1, activation='sigmoid')); model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy']); model.summary(); return model; ; def PrepareData() :; #get the input data; inputFileName = ""Higgs_data.root""; inputFile = ""http://root.cern.ch/files/"" + inputFileName; ; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); sigData = df1.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); #print(sigData); ; # stack all the 7 numpy array in a single array (nevents x nvars); xsig = np.column_stack(list(sigData.values())); data_sig_size = xsig.shape[0]; print(""size of data"", data_sig_size); ; # make SOFIE inference on background data; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); bkgData = df2.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); xbkg = np.column_stack(list(bkgData.values())); data_bkg_size = xbkg.shape[0]; ; ysig = np.ones(data_sig_size); ybkg = np.zeros(data_bkg_size); inputs_data = np.concatenate((xsig,xbkg),axis=0); inputs_targets = np.concatenate(",MatchSource.WIKI,doc/master/TMVA__SOFIE__Models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html
https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html:2349,Testability,test,test,2349,"); model.summary(); return model; ; def PrepareData() :; #get the input data; inputFileName = ""Higgs_data.root""; inputFile = ""http://root.cern.ch/files/"" + inputFileName; ; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); sigData = df1.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); #print(sigData); ; # stack all the 7 numpy array in a single array (nevents x nvars); xsig = np.column_stack(list(sigData.values())); data_sig_size = xsig.shape[0]; print(""size of data"", data_sig_size); ; # make SOFIE inference on background data; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); bkgData = df2.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); xbkg = np.column_stack(list(bkgData.values())); data_bkg_size = xbkg.shape[0]; ; ysig = np.ones(data_sig_size); ybkg = np.zeros(data_bkg_size); inputs_data = np.concatenate((xsig,xbkg),axis=0); inputs_targets = np.concatenate((ysig,ybkg),axis=0); ; #split data in training and test data; ; x_train, x_test, y_train, y_test = train_test_split(; inputs_data, inputs_targets, test_size=0.50, random_state=1234); ; return x_train, y_train, x_test, y_test; ; def TrainModel(model, x, y, name) :; model.fit(x,y,epochs=10,batch_size=50); modelFile = name + '.h5'; model.save(modelFile); return modelFile; ; ### run the models; ; x_train, y_train, x_test, y_test = PrepareData(); ; ## create models and train them; ; model1 = TrainModel(CreateModel(4,64),x_train, y_train, 'Higgs_Model_4L_50'); model2 = TrainModel(CreateModel(4,64),x_train, y_train, 'Higgs_Model_4L_200'); model3 = TrainModel(CreateModel(4,64),x_train, y_train, 'Higgs_Model_2L_500'); ; #evaluate with SOFIE the 3 trained models; ; ; def GenerateModelCode(modelFile, generatedHeaderFile):; model = ROOT.TMVA.Experimental.SOFIE.PyKeras.Parse(modelFile); ; print(""Generating inference code for the Keras model from "",modelFile,""in the header "", generatedHeaderFile); #Generating inference code using a ROOT binary file; model.Generate(ROOT.TM",MatchSource.WIKI,doc/master/TMVA__SOFIE__Models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html
https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html:4224,Testability,test,test,4224,"erating inference code for the Keras model from "",modelFile,""in the header "", generatedHeaderFile); #Generating inference code using a ROOT binary file; model.Generate(ROOT.TMVA.Experimental.SOFIE.Options.kRootBinaryWeightFile); # add option to append to the same file the generated headers (pass True for append flag); model.OutputGenerated(generatedHeaderFile, True); #model.PrintGenerated(); return generatedHeaderFile; ; ; generatedHeaderFile = ""Higgs_Model.hxx""; #need to remove existing header file since we are appending on same one; import os; if (os.path.exists(generatedHeaderFile)):; weightFile = ""Higgs_Model.root""; print(""removing existing files"", generatedHeaderFile,weightFile); os.remove(generatedHeaderFile); os.remove(weightFile); ; GenerateModelCode(model1, generatedHeaderFile); GenerateModelCode(model2, generatedHeaderFile); GenerateModelCode(model3, generatedHeaderFile); ; #compile the generated code; ; ROOT.gInterpreter.Declare('#include ""' + generatedHeaderFile + '""'); ; ; #run the inference on the test data; session1 = ROOT.TMVA_SOFIE_Higgs_Model_4L_50.Session(""Higgs_Model.root""); session2 = ROOT.TMVA_SOFIE_Higgs_Model_4L_200.Session(""Higgs_Model.root""); session3 = ROOT.TMVA_SOFIE_Higgs_Model_2L_500.Session(""Higgs_Model.root""); ; hs1 = ROOT.TH1D(""hs1"",""Signal result 4L 50"",100,0,1); hs2 = ROOT.TH1D(""hs2"",""Signal result 4L 200"",100,0,1); hs3 = ROOT.TH1D(""hs3"",""Signal result 2L 500"",100,0,1); ; hb1 = ROOT.TH1D(""hb1"",""Background result 4L 50"",100,0,1); hb2 = ROOT.TH1D(""hb2"",""Background result 4L 200"",100,0,1); hb3 = ROOT.TH1D(""hb3"",""Background result 2L 500"",100,0,1); ; def EvalModel(session, x) :; result = session.infer(x); return result[0]; ; for i in range(0,x_test.shape[0]):; result1 = EvalModel(session1, x_test[i,:]); result2 = EvalModel(session2, x_test[i,:]); result3 = EvalModel(session3, x_test[i,:]); if (y_test[i] == 1) :; hs1.Fill(result1); hs2.Fill(result2); hs3.Fill(result3); else:; hb1.Fill(result1); hb2.Fill(result2); hb3.Fill(result3); ; de",MatchSource.WIKI,doc/master/TMVA__SOFIE__Models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html
https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html:16937,Energy Efficiency,allocate,allocate,16937,t = fTensor_18weight.data();; std::vector<float> fTensor_0weight = std::vector<float>(5000);; float * tensor_0weight = fTensor_0weight.data();; std::vector<float> fTensor_10bias = std::vector<float>(50);; float * tensor_10bias = fTensor_10bias.data();; std::vector<float> fTensor_2bias = std::vector<float>(50);; float * tensor_2bias = fTensor_2bias.data();; std::vector<float> fTensor_6weight = std::vector<float>(2500);; float * tensor_6weight = fTensor_6weight.data();; std::vector<float> fTensor_14weight = std::vector<float>(2500);; float * tensor_14weight = fTensor_14weight.data();; std::vector<float> fTensor_16weight = std::vector<float>(2500);; float * tensor_16weight = fTensor_16weight.data();; std::vector<float> fTensor_12weight = std::vector<float>(2500);; float * tensor_12weight = fTensor_12weight.data();; std::vector<float> fTensor_16bias = std::vector<float>(50);; float * tensor_16bias = fTensor_16bias.data();; ; //--- declare and allocate the intermediate tensors; std::vector<float> fTensor_39 = std::vector<float>(160);; float * tensor_39 = fTensor_39.data();; std::vector<float> fTensor_18biasbcast = std::vector<float>(160);; float * tensor_18biasbcast = fTensor_18biasbcast.data();; std::vector<float> fTensor_38 = std::vector<float>(800);; float * tensor_38 = fTensor_38.data();; std::vector<float> fTensor_35 = std::vector<float>(800);; float * tensor_35 = fTensor_35.data();; std::vector<float> fTensor_14biasbcast = std::vector<float>(800);; float * tensor_14biasbcast = fTensor_14biasbcast.data();; std::vector<float> fTensor_34 = std::vector<float>(800);; float * tensor_34 = fTensor_34.data();; std::vector<float> fTensor_33 = std::vector<float>(800);; float * tensor_33 = fTensor_33.data();; std::vector<float> fTensor_36 = std::vector<float>(800);; float * tensor_36 = fTensor_36.data();; std::vector<float> fTensor_12biasbcast = std::vector<float>(800);; float * tensor_12biasbcast = fTensor_12biasbcast.data();; std::vector<float> fTensor_10biasbcast = std::vect,MatchSource.WIKI,doc/master/TMVA__SOFIE__ONNX_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html
https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html:32496,Energy Efficiency,allocate,allocate,32496,,MatchSource.WIKI,doc/master/TMVA__SOFIE__ONNX_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html
https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html:242,Usability,simpl,simple,242,". ROOT: tutorials/tmva/TMVA_SOFIE_ONNX.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_ONNX.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; void TMVA_SOFIE_ONNX(std::string inputFile = """"){; if (inputFile.empty() ); inputFile = std::string(gROOT->GetTutorialsDir()) + ""/tmva/Linear_16.onnx"";; ; //Creating parser object to parse ONNX files; SOFIE::RModelParser_ONNX parser;; SOFIE::RModel model = parser.Parse(inputFile, true);; ; //Generating inference code; model.Generate();; // write the code in a file (by default Linear_16.hxx and Linear_16.dat; model.OutputGenerated();; ; //Printing required input tensors; model.PrintRequiredInputTensors();; ; //Printing initialized tensors (weights); std::cout<<""\n\n"";; model.PrintInitializedTensors();; ; //Printing intermediate tensors; std::cout<<""\n\n"";; model.PrintIntermediateTensors();; ; //Checking if tensor already exist in model; std::cout<<""\n\nTensor \""16weight\"" already exist: ""<<std::boolalpha<<model.CheckIfTensorAlreadyExist(""16weight"")<<""\n\n"";; std::vector<size_t> tensorShape = model.GetTensorShape(""16weight"");; std::cout<<""Shape of tensor \""16weight\"": "";; for(auto& it:tensorShape){; std::cout<<it<<"","";; }; std::cout<<""\n\nData type of tensor \""16weight\"": "";; SOFIE::ETensorType tensorType = model.GetTensorType(""16weight"");; std::cout<<SOFIE::ConvertTypeToString(tensorType);; ; //Printing generated inference code; std::cout<<""\n\n"";; model.PrintGenerated();; }; gROOT#define gROOTDefinition TROOT.h:406; TMVA::Experimental::SOFIE::RModelParser_ONNXDefinition RModelParser_ONNX.hxx:27; TMVA::Experimental::SOFIE::RModelParser_ONNX::ParseRModel Parse(std::string filename, bool verbose=false)Definition RModelParser_ONNX.cxx:312; TMVA::Experimental::SOFIE::RMo",MatchSource.WIKI,doc/master/TMVA__SOFIE__ONNX_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html
https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html:4569,Deployability,install,installed,4569,"Model.cxx:985; TMVA::Experimental::SOFIE::RModel::GetTensorShapeconst std::vector< size_t > & GetTensorShape(std::string name)Definition RModel.cxx:56; TMVA::Experimental::SOFIE::RModel::Generatevoid Generate(std::underlying_type_t< Options > options, int batchSize=-1, long pos=0, bool verbose=false)Definition RModel.cxx:703; TMVA::Experimental::SOFIE::RModel::PrintRequiredInputTensorsvoid PrintRequiredInputTensors()Definition RModel.cxx:955; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMacroClass supporting a collection of lines with C++ code.Definition TMacro.h:31; TStringBasic string class.Definition TString.h:139; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TMVA::Experimental::SOFIE::ETensorTypeETensorTypeDefinition SOFIE_common.hxx:25; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA::Python_ExecutableTString Python_Executable()Function to find current Python executable used by ROOT If ""Python3"" is installed,...Definition PyMethodBase.cxx:43; mTMarker mDefinition textangle.C:8; ; ; ; Model requires following inputs:; Fully Specified Tensor name: input1 type: float shape: [2,32]; ; ; ; Model initialized the following tensors:; Tensor name: ""2bias"" type: float shape: [8]; Tensor name: ""0weight"" type: float shape: [16,32]; Tensor name: ""2weight"" type: float shape: [8,16]; Tensor name: ""0bias"" type: float shape: [16]; ; ; ; Model specify the following intermediate tensors:; Tensor name: ""result3"" type: float shape: [2,8]; Tensor name: ""2biasbcast"" type: float shape: [2,8]; Tensor name: ""input2"" type: float shape: [2,8]; Tensor name: ""input0"" type: float shape: [2,16]; Tensor name: ""result"" type: float shape: [2,16]; Tensor name: ""0biasbcast"" type: float shape: [2,16]; ; ; ; Tensor ""0weight"" already exist: true; ; Shape of tensor ""0weight"": 16,32,; ; Data type of tensor ""0weight"": float; ; //Code generated automatically by TMVA",MatchSource.WIKI,doc/master/TMVA__SOFIE__PyTorch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html
https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html:6799,Energy Efficiency,allocate,allocate,6799,"* trans, const int * m, const int * n, const float * alpha, const float * A,; const int * lda, const float * X, const int * incx, const float * beta, const float * Y, const int * incy);; extern ""C"" void sgemm_(const char * transa, const char * transb, const int * m, const int * n, const int * k,; const float * alpha, const float * A, const int * lda, const float * B, const int * ldb,; const float * beta, float * C, const int * ldc);; }//BLAS; struct Session {; // initialized tensors; std::vector<float> fTensor_2bias = std::vector<float>(8);; float * tensor_2bias = fTensor_2bias.data();; std::vector<float> fTensor_0weight = std::vector<float>(512);; float * tensor_0weight = fTensor_0weight.data();; std::vector<float> fTensor_2weight = std::vector<float>(128);; float * tensor_2weight = fTensor_2weight.data();; std::vector<float> fTensor_0bias = std::vector<float>(16);; float * tensor_0bias = fTensor_0bias.data();; ; //--- declare and allocate the intermediate tensors; std::vector<float> fTensor_result3 = std::vector<float>(16);; float * tensor_result3 = fTensor_result3.data();; std::vector<float> fTensor_2biasbcast = std::vector<float>(16);; float * tensor_2biasbcast = fTensor_2biasbcast.data();; std::vector<float> fTensor_input2 = std::vector<float>(16);; float * tensor_input2 = fTensor_input2.data();; std::vector<float> fTensor_input0 = std::vector<float>(32);; float * tensor_input0 = fTensor_input0.data();; std::vector<float> fTensor_result = std::vector<float>(32);; float * tensor_result = fTensor_result.data();; std::vector<float> fTensor_0biasbcast = std::vector<float>(32);; float * tensor_0biasbcast = fTensor_0biasbcast.data();; ; ; Session(std::string filename =""PyTorchModel.dat"") {; ; //--- reading weights from file; std::ifstream f;; f.open(filename);; if (!f.is_open()) {; throw std::runtime_error(""tmva-sofie failed to open file "" + filename + "" for input weights"");; }; std::string tensor_name;; size_t length;; f >> tensor_name >> length;; if (tensor_name != ",MatchSource.WIKI,doc/master/TMVA__SOFIE__PyTorch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html
https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html:10237,Energy Efficiency,allocate,allocate,10237,"values for tensor tensor_0bias"");; }; f.close();; ; //---- allocate the intermediate dynamic tensors; //--- broadcast bias tensor 0biasfor Gemm op; {; float * data = TMVA::Experimental::SOFIE::UTILITY::UnidirectionalBroadcast<float>(tensor_0bias,{ 16 }, { 2 , 16 });; std::copy(data, data + 32, tensor_0biasbcast);; delete [] data;; }; //--- broadcast bias tensor 2biasfor Gemm op; {; float * data = TMVA::Experimental::SOFIE::UTILITY::UnidirectionalBroadcast<float>(tensor_2bias,{ 8 }, { 2 , 8 });; std::copy(data, data + 16, tensor_2biasbcast);; delete [] data;; }; }; ; std::vector<float> infer(float* tensor_input1){; ; //--------- Gemm; char op_0_transA = 'n';; char op_0_transB = 't';; int op_0_m = 2;; int op_0_n = 16;; int op_0_k = 32;; float op_0_alpha = 1;; float op_0_beta = 1;; int op_0_lda = 32;; int op_0_ldb = 32;; std::copy(tensor_0biasbcast, tensor_0biasbcast + 32, tensor_input0);; BLAS::sgemm_(&op_0_transB, &op_0_transA, &op_0_n, &op_0_m, &op_0_k, &op_0_alpha, tensor_0weight, &op_0_ldb, tensor_input1, &op_0_lda, &op_0_beta, tensor_input0, &op_0_n);; ; //------ RELU; for (int id = 0; id < 32 ; id++){; tensor_result[id] = ((tensor_input0[id] > 0 )? tensor_input0[id] : 0);; }; ; //--------- Gemm; char op_2_transA = 'n';; char op_2_transB = 't';; int op_2_m = 2;; int op_2_n = 8;; int op_2_k = 16;; float op_2_alpha = 1;; float op_2_beta = 1;; int op_2_lda = 16;; int op_2_ldb = 16;; std::copy(tensor_2biasbcast, tensor_2biasbcast + 16, tensor_input2);; BLAS::sgemm_(&op_2_transB, &op_2_transA, &op_2_n, &op_2_m, &op_2_k, &op_2_alpha, tensor_2weight, &op_2_ldb, tensor_result, &op_2_lda, &op_2_beta, tensor_input2, &op_2_n);; ; //------ RELU; for (int id = 0; id < 16 ; id++){; tensor_result3[id] = ((tensor_input2[id] > 0 )? tensor_input2[id] : 0);; }; return fTensor_result3;; }; }; // end of Session; } //TMVA_SOFIE_PyTorchModel; ; #endif // ROOT_TMVA_SOFIE_PYTORCHMODEL; AuthorSanjiban Sengupta ; Definition in file TMVA_SOFIE_PyTorch.C. tutorialstmvaTMVA_SOFIE_PyTorch.C. RO",MatchSource.WIKI,doc/master/TMVA__SOFIE__PyTorch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html
https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html:632,Performance,optimiz,optimizer,632,". ROOT: tutorials/tmva/TMVA_SOFIE_PyTorch.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_PyTorch.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import torch\n\; import torch.nn as nn\n\; \n\; model = nn.Sequential(\n\; nn.Linear(32,16),\n\; nn.ReLU(),\n\; nn.Linear(16,8),\n\; nn.ReLU()\n\; )\n\; \n\; criterion = nn.MSELoss()\n\; optimizer = torch.optim.SGD(model.parameters(),lr=0.01)\n\; \n\; x=torch.randn(2,32)\n\; y=torch.randn(2,8)\n\; \n\; for i in range(500):\n\; y_pred = model(x)\n\; loss = criterion(y_pred,y)\n\; optimizer.zero_grad()\n\; loss.backward()\n\; optimizer.step()\n\; \n\; model.eval()\n\; m = torch.jit.script(model)\n\; torch.jit.save(m,'PyTorchModel.pt')\n"";; ; ; void TMVA_SOFIE_PyTorch(){; ; //Running the Python script to generate PyTorch .pt file; TMVA::PyMethodBase::PyInitialize();; ; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_pytorch_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_pytorch_model.py"");; ; //Parsing a PyTorch model requires the shape and data-type of input tensor; //Data-type of input tensor defaults to Float if not specified; std::vector<size_t> inputTensorShapeSequential{2,32};; std::vector<std::vector<size_t>> inputShapesSequential{inputTensorShapeSequential};; ; //Parsing the saved PyTorch .pt file into RModel object; SOFIE::RModel model = SOFIE::PyTorch::Parse(""PyTorchModel.pt"",inputShapesSequential);; ; //Generating inference code; model.Generate();; model.OutputGenerated(""PyTorchModel.hxx"");; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInputTensors();; ; //Printing initialized tensors (weights); std::cout<<""\n\n"";; model.PrintInitializedTensors();; ; //Printing intermediat",MatchSource.WIKI,doc/master/TMVA__SOFIE__PyTorch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html
https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html:827,Performance,optimiz,optimizer,827,". ROOT: tutorials/tmva/TMVA_SOFIE_PyTorch.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_PyTorch.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import torch\n\; import torch.nn as nn\n\; \n\; model = nn.Sequential(\n\; nn.Linear(32,16),\n\; nn.ReLU(),\n\; nn.Linear(16,8),\n\; nn.ReLU()\n\; )\n\; \n\; criterion = nn.MSELoss()\n\; optimizer = torch.optim.SGD(model.parameters(),lr=0.01)\n\; \n\; x=torch.randn(2,32)\n\; y=torch.randn(2,8)\n\; \n\; for i in range(500):\n\; y_pred = model(x)\n\; loss = criterion(y_pred,y)\n\; optimizer.zero_grad()\n\; loss.backward()\n\; optimizer.step()\n\; \n\; model.eval()\n\; m = torch.jit.script(model)\n\; torch.jit.save(m,'PyTorchModel.pt')\n"";; ; ; void TMVA_SOFIE_PyTorch(){; ; //Running the Python script to generate PyTorch .pt file; TMVA::PyMethodBase::PyInitialize();; ; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_pytorch_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_pytorch_model.py"");; ; //Parsing a PyTorch model requires the shape and data-type of input tensor; //Data-type of input tensor defaults to Float if not specified; std::vector<size_t> inputTensorShapeSequential{2,32};; std::vector<std::vector<size_t>> inputShapesSequential{inputTensorShapeSequential};; ; //Parsing the saved PyTorch .pt file into RModel object; SOFIE::RModel model = SOFIE::PyTorch::Parse(""PyTorchModel.pt"",inputShapesSequential);; ; //Generating inference code; model.Generate();; model.OutputGenerated(""PyTorchModel.hxx"");; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInputTensors();; ; //Printing initialized tensors (weights); std::cout<<""\n\n"";; model.PrintInitializedTensors();; ; //Printing intermediat",MatchSource.WIKI,doc/master/TMVA__SOFIE__PyTorch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html
https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html:873,Performance,optimiz,optimizer,873,". ROOT: tutorials/tmva/TMVA_SOFIE_PyTorch.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_PyTorch.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import torch\n\; import torch.nn as nn\n\; \n\; model = nn.Sequential(\n\; nn.Linear(32,16),\n\; nn.ReLU(),\n\; nn.Linear(16,8),\n\; nn.ReLU()\n\; )\n\; \n\; criterion = nn.MSELoss()\n\; optimizer = torch.optim.SGD(model.parameters(),lr=0.01)\n\; \n\; x=torch.randn(2,32)\n\; y=torch.randn(2,8)\n\; \n\; for i in range(500):\n\; y_pred = model(x)\n\; loss = criterion(y_pred,y)\n\; optimizer.zero_grad()\n\; loss.backward()\n\; optimizer.step()\n\; \n\; model.eval()\n\; m = torch.jit.script(model)\n\; torch.jit.save(m,'PyTorchModel.pt')\n"";; ; ; void TMVA_SOFIE_PyTorch(){; ; //Running the Python script to generate PyTorch .pt file; TMVA::PyMethodBase::PyInitialize();; ; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_pytorch_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_pytorch_model.py"");; ; //Parsing a PyTorch model requires the shape and data-type of input tensor; //Data-type of input tensor defaults to Float if not specified; std::vector<size_t> inputTensorShapeSequential{2,32};; std::vector<std::vector<size_t>> inputShapesSequential{inputTensorShapeSequential};; ; //Parsing the saved PyTorch .pt file into RModel object; SOFIE::RModel model = SOFIE::PyTorch::Parse(""PyTorchModel.pt"",inputShapesSequential);; ; //Generating inference code; model.Generate();; model.OutputGenerated(""PyTorchModel.hxx"");; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInputTensors();; ; //Printing initialized tensors (weights); std::cout<<""\n\n"";; model.PrintInitializedTensors();; ; //Printing intermediat",MatchSource.WIKI,doc/master/TMVA__SOFIE__PyTorch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html
https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html:248,Usability,simpl,simple,248,". ROOT: tutorials/tmva/TMVA_SOFIE_PyTorch.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_PyTorch.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import torch\n\; import torch.nn as nn\n\; \n\; model = nn.Sequential(\n\; nn.Linear(32,16),\n\; nn.ReLU(),\n\; nn.Linear(16,8),\n\; nn.ReLU()\n\; )\n\; \n\; criterion = nn.MSELoss()\n\; optimizer = torch.optim.SGD(model.parameters(),lr=0.01)\n\; \n\; x=torch.randn(2,32)\n\; y=torch.randn(2,8)\n\; \n\; for i in range(500):\n\; y_pred = model(x)\n\; loss = criterion(y_pred,y)\n\; optimizer.zero_grad()\n\; loss.backward()\n\; optimizer.step()\n\; \n\; model.eval()\n\; m = torch.jit.script(model)\n\; torch.jit.save(m,'PyTorchModel.pt')\n"";; ; ; void TMVA_SOFIE_PyTorch(){; ; //Running the Python script to generate PyTorch .pt file; TMVA::PyMethodBase::PyInitialize();; ; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_pytorch_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_pytorch_model.py"");; ; //Parsing a PyTorch model requires the shape and data-type of input tensor; //Data-type of input tensor defaults to Float if not specified; std::vector<size_t> inputTensorShapeSequential{2,32};; std::vector<std::vector<size_t>> inputShapesSequential{inputTensorShapeSequential};; ; //Parsing the saved PyTorch .pt file into RModel object; SOFIE::RModel model = SOFIE::PyTorch::Parse(""PyTorchModel.pt"",inputShapesSequential);; ; //Generating inference code; model.Generate();; model.OutputGenerated(""PyTorchModel.hxx"");; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInputTensors();; ; //Printing initialized tensors (weights); std::cout<<""\n\n"";; model.PrintInitializedTensors();; ; //Printing intermediat",MatchSource.WIKI,doc/master/TMVA__SOFIE__PyTorch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html:2536,Integrability,interface,interface,2536," << nslots << "" threads"" << std::endl;; auto h1 = df1.DefineSlot(""DNN_Value"", SofieFunctor<7, TMVA_SOFIE_Higgs_trained_model::Session>(nslots),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Histo1D({""h_sig"", """", 100, 0, 1}, ""DNN_Value"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; nslots = df2.GetNSlots();; auto h2 = df2.DefineSlot(""DNN_Value"", SofieFunctor<7, TMVA_SOFIE_Higgs_trained_model::Session>(nslots),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""DNN_Value"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; R__ADD_INCLUDE_PATH#define R__ADD_INCLUDE_PATH(PATH)Definition Rtypes.h:497; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; SOFIEHelpers.hxx; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188;",MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html:3299,Performance,multi-thread,multi-threading,3299,"0, 1}, ""DNN_Value"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; nslots = df2.GetNSlots();; auto h2 = df2.DefineSlot(""DNN_Value"", SofieFunctor<7, TMVA_SOFIE_Higgs_trained_model::Session>(nslots),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""DNN_Value"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; R__ADD_INCLUDE_PATH#define R__ADD_INCLUDE_PATH(PATH)Definition Rtypes.h:497; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; SOFIEHelpers.hxx; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; ; Running using 2 threads; AuthorLorenzo Moneta ; Definition in file TMVA_SOFIE_RDataFrame.C. tutorialstmvaTMVA_SOFIE_RDataFrame.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html:4880,Energy Efficiency,allocate,allocate,4880,rnel0.data();; std::vector<float> fTensor_dense_2kernel0 = std::vector<float>(4096);; float * tensor_dense_2kernel0 = fTensor_dense_2kernel0.data();; std::vector<float> fTensor_dense_1bias0 = std::vector<float>(64);; float * tensor_dense_1bias0 = fTensor_dense_1bias0.data();; std::vector<float> fTensor_dense_4bias0 = std::vector<float>(2);; float * tensor_dense_4bias0 = fTensor_dense_4bias0.data();; std::vector<float> fTensor_dense_1kernel0 = std::vector<float>(4096);; float * tensor_dense_1kernel0 = fTensor_dense_1kernel0.data();; std::vector<float> fTensor_densebias0 = std::vector<float>(64);; float * tensor_densebias0 = fTensor_densebias0.data();; std::vector<float> fTensor_dense_2bias0 = std::vector<float>(64);; float * tensor_dense_2bias0 = fTensor_dense_2bias0.data();; std::vector<float> fTensor_densekernel0 = std::vector<float>(448);; float * tensor_densekernel0 = fTensor_densekernel0.data();; ; //--- declare and allocate the intermediate tensors; std::vector<float> fTensor_dense_4Sigmoid0 = std::vector<float>(2);; float * tensor_dense_4Sigmoid0 = fTensor_dense_4Sigmoid0.data();; std::vector<float> fTensor_dense_4Dense = std::vector<float>(2);; float * tensor_dense_4Dense = fTensor_dense_4Dense.data();; std::vector<float> fTensor_densebias0bcast = std::vector<float>(64);; float * tensor_densebias0bcast = fTensor_densebias0bcast.data();; std::vector<float> fTensor_dense_1bias0bcast = std::vector<float>(64);; float * tensor_dense_1bias0bcast = fTensor_dense_1bias0bcast.data();; std::vector<float> fTensor_dense_3bias0bcast = std::vector<float>(64);; float * tensor_dense_3bias0bcast = fTensor_dense_3bias0bcast.data();; std::vector<float> fTensor_dense_1Dense = std::vector<float>(64);; float * tensor_dense_1Dense = fTensor_dense_1Dense.data();; std::vector<float> fTensor_dense_1Relu0 = std::vector<float>(64);; float * tensor_dense_1Relu0 = fTensor_dense_1Relu0.data();; std::vector<float> fTensor_dense_2Dense = std::vector<float>(64);; float * tensor_dense_2Dense =,MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html:13500,Energy Efficiency,allocate,allocate,13500,,MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html:2302,Integrability,interface,interface,2302," = TMVA::Experimental::SofieFunctor<7,TMVA_SOFIE_'+modelName+'::Session>(0,""Higgs_trained_model_generated.dat"");'); ; # run inference over input data; inputFile = ""http://root.cern/files/Higgs_data.root""; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); h1 = df1.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_sig"", """", 100, 0, 1),""DNN_Value""); ; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); h2 = df2.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_bkg"", """", 100, 0, 1),""DNN_Value""); ; # run over the input data once, combining both RDataFrame graphs.; ROOT.RDF.RunGraphs([h1, h2]);; ; print(""Number of signal entries"",h1.GetEntries()); print(""Number of background entries"",h2.GetEntries()); ; h1.SetLineColor(ROOT.kRed); h2.SetLineColor(ROOT.kBlue); ; c1 = ROOT.TCanvas(); ROOT.gStyle.SetOptStat(0); ; h2.DrawClone(); h1.DrawClone(""SAME""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; //Code generated automatically by TMVA for Inference of Model file [Higgs_trained_model.h5] at [Tue Nov 5 09:33:48 2024] ; ; #ifndef ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; #define ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; ; #include <algorithm>; #include <vector>; #include <cmath>; #include ""TMVA/SOFIE_common.hxx""; #include <fstream>; ; namespace TMVA_SOFIE_Higgs_trained_model{; namespace BLAS{; extern ""C"" void sgemv_(const char * trans, const int * m, const int * n, const float * alpha, const float * A,; const int * lda, const float * X, const int * incx, const float * beta, const float * Y, const int * incy);; extern ""C"" void sgemm_(",MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html:2510,Performance,concurren,concurrently,2510,"""http://root.cern/files/Higgs_data.root""; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); h1 = df1.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_sig"", """", 100, 0, 1),""DNN_Value""); ; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); h2 = df2.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_bkg"", """", 100, 0, 1),""DNN_Value""); ; # run over the input data once, combining both RDataFrame graphs.; ROOT.RDF.RunGraphs([h1, h2]);; ; print(""Number of signal entries"",h1.GetEntries()); print(""Number of background entries"",h2.GetEntries()); ; h1.SetLineColor(ROOT.kRed); h2.SetLineColor(ROOT.kBlue); ; c1 = ROOT.TCanvas(); ROOT.gStyle.SetOptStat(0); ; h2.DrawClone(); h1.DrawClone(""SAME""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; //Code generated automatically by TMVA for Inference of Model file [Higgs_trained_model.h5] at [Tue Nov 5 09:33:48 2024] ; ; #ifndef ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; #define ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; ; #include <algorithm>; #include <vector>; #include <cmath>; #include ""TMVA/SOFIE_common.hxx""; #include <fstream>; ; namespace TMVA_SOFIE_Higgs_trained_model{; namespace BLAS{; extern ""C"" void sgemv_(const char * trans, const int * m, const int * n, const float * alpha, const float * A,; const int * lda, const float * X, const int * incx, const float * beta, const float * Y, const int * incy);; extern ""C"" void sgemm_(const char * transa, const char * transb, const int * m, const int * n, const int * k,; const float * alpha, const float * A, const int * lda, const float * B, con",MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html:3705,Availability,error,error,3705,"File,7);; ; std::string inputFileName = ""Higgs_data.root"";; std::string inputFile = ""http://root.cern.ch/files/"" + inputFileName;; ; ROOT::RDataFrame df1(""sig_tree"", inputFile);; auto h1 = df1.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)""); .Histo1D({""h_sig"", """", 100, 0, 1},""DNN_Value"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)""); .Histo1D({""h_bkg"", """", 100, 0, 1},""DNN_Value"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TMVA::Experimental::SOFIE::RModel_Base::PrintGeneratedvoid PrintGenerated()Definition RModel_Base.hxx:86; TMVA::Experimental::SOFIE::RModelDefinition RModel.hxx:12; TMVA::Experimental::SOFIE::RModel::OutputGeneratedvoid OutputGenerated(std::string filename="""", bool append=false)Definition RModel.cxx:1081; TMVA::Experimental::SOFIE::RModel::Generatevoid Generate(std::underlying_type_t< Options > options, int batchSize=-1, long pos=0, bool verbose=false)Definition RMode",MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html:7918,Energy Efficiency,allocate,allocate,7918,rnel0.data();; std::vector<float> fTensor_dense_2kernel0 = std::vector<float>(4096);; float * tensor_dense_2kernel0 = fTensor_dense_2kernel0.data();; std::vector<float> fTensor_dense_1bias0 = std::vector<float>(64);; float * tensor_dense_1bias0 = fTensor_dense_1bias0.data();; std::vector<float> fTensor_dense_4bias0 = std::vector<float>(2);; float * tensor_dense_4bias0 = fTensor_dense_4bias0.data();; std::vector<float> fTensor_dense_1kernel0 = std::vector<float>(4096);; float * tensor_dense_1kernel0 = fTensor_dense_1kernel0.data();; std::vector<float> fTensor_densebias0 = std::vector<float>(64);; float * tensor_densebias0 = fTensor_densebias0.data();; std::vector<float> fTensor_dense_2bias0 = std::vector<float>(64);; float * tensor_dense_2bias0 = fTensor_dense_2bias0.data();; std::vector<float> fTensor_densekernel0 = std::vector<float>(448);; float * tensor_densekernel0 = fTensor_densekernel0.data();; ; //--- declare and allocate the intermediate tensors; std::vector<float> fTensor_dense_4Sigmoid0 = std::vector<float>(2);; float * tensor_dense_4Sigmoid0 = fTensor_dense_4Sigmoid0.data();; std::vector<float> fTensor_dense_4Dense = std::vector<float>(2);; float * tensor_dense_4Dense = fTensor_dense_4Dense.data();; std::vector<float> fTensor_densebias0bcast = std::vector<float>(64);; float * tensor_densebias0bcast = fTensor_densebias0bcast.data();; std::vector<float> fTensor_dense_1bias0bcast = std::vector<float>(64);; float * tensor_dense_1bias0bcast = fTensor_dense_1bias0bcast.data();; std::vector<float> fTensor_dense_3bias0bcast = std::vector<float>(64);; float * tensor_dense_3bias0bcast = fTensor_dense_3bias0bcast.data();; std::vector<float> fTensor_dense_1Dense = std::vector<float>(64);; float * tensor_dense_1Dense = fTensor_dense_1Dense.data();; std::vector<float> fTensor_dense_1Relu0 = std::vector<float>(64);; float * tensor_dense_1Relu0 = fTensor_dense_1Relu0.data();; std::vector<float> fTensor_dense_2Dense = std::vector<float>(64);; float * tensor_dense_2Dense =,MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html:16538,Energy Efficiency,allocate,allocate,16538,,MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html:3579,Integrability,message,messages,3579,"t file is missing"");; return;; }; ; // now compile using ROOT JIT trained model (see function above); CompileModelForRDF(modelHeaderFile,7);; ; std::string inputFileName = ""Higgs_data.root"";; std::string inputFile = ""http://root.cern.ch/files/"" + inputFileName;; ; ROOT::RDataFrame df1(""sig_tree"", inputFile);; auto h1 = df1.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)""); .Histo1D({""h_sig"", """", 100, 0, 1},""DNN_Value"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)""); .Histo1D({""h_bkg"", """", 100, 0, 1},""DNN_Value"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TMVA::Experimental::SOFIE::RModel_Base::PrintGeneratedvoid PrintGenerated()Definition RModel_Base.hxx:86; TMVA::Experimental::SOFIE::RModelDefinition RModel.hxx:12; TMVA::Experimental::SOFIE::RModel::OutputGeneratedvoid OutputGenerated(std::string filename="""", bool append=false)Definition RModel.cxx:1081; TMVA::Experimental::SOFIE::RMode",MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html:3988,Integrability,interface,interface,3988,"b)""); .Histo1D({""h_sig"", """", 100, 0, 1},""DNN_Value"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)""); .Histo1D({""h_bkg"", """", 100, 0, 1},""DNN_Value"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TMVA::Experimental::SOFIE::RModel_Base::PrintGeneratedvoid PrintGenerated()Definition RModel_Base.hxx:86; TMVA::Experimental::SOFIE::RModelDefinition RModel.hxx:12; TMVA::Experimental::SOFIE::RModel::OutputGeneratedvoid OutputGenerated(std::string filename="""", bool append=false)Definition RModel.cxx:1081; TMVA::Experimental::SOFIE::RModel::Generatevoid Generate(std::underlying_type_t< Options > options, int batchSize=-1, long pos=0, bool verbose=false)Definition RModel.cxx:703; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSele",MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html:5322,Security,access,access,5322,"tedvoid PrintGenerated()Definition RModel_Base.hxx:86; TMVA::Experimental::SOFIE::RModelDefinition RModel.hxx:12; TMVA::Experimental::SOFIE::RModel::OutputGeneratedvoid OutputGenerated(std::string filename="""", bool append=false)Definition RModel.cxx:1081; TMVA::Experimental::SOFIE::RModel::Generatevoid Generate(std::underlying_type_t< Options > options, int batchSize=-1, long pos=0, bool verbose=false)Definition RModel.cxx:703; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; ; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; //Code generated automatically by TMVA for Inference of Model file [Higgs_trained_model.h5] at [Tue Nov 5 09:34:00 2024] ; ; #ifndef ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; #define ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; ; #include <algorithm>; #include <vector>; #include <cmath>; #include ""TMVA/SOFIE_common.hxx""; #include <fstream>; ; namespace TMVA_SOFIE_Higgs_trained_model{; namespace BLAS{; extern ""C"" void sgemv_(const char * trans, const int * m, const int * n, const float * alpha, const float * A,; const int * lda, const float * X, const int * incx, const float * beta, const float * ",MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html:5356,Security,access,access,5356,"tedvoid PrintGenerated()Definition RModel_Base.hxx:86; TMVA::Experimental::SOFIE::RModelDefinition RModel.hxx:12; TMVA::Experimental::SOFIE::RModel::OutputGeneratedvoid OutputGenerated(std::string filename="""", bool append=false)Definition RModel.cxx:1081; TMVA::Experimental::SOFIE::RModel::Generatevoid Generate(std::underlying_type_t< Options > options, int batchSize=-1, long pos=0, bool verbose=false)Definition RModel.cxx:703; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; ; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; //Code generated automatically by TMVA for Inference of Model file [Higgs_trained_model.h5] at [Tue Nov 5 09:34:00 2024] ; ; #ifndef ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; #define ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; ; #include <algorithm>; #include <vector>; #include <cmath>; #include ""TMVA/SOFIE_common.hxx""; #include <fstream>; ; namespace TMVA_SOFIE_Higgs_trained_model{; namespace BLAS{; extern ""C"" void sgemv_(const char * trans, const int * m, const int * n, const float * alpha, const float * A,; const int * lda, const float * X, const int * incx, const float * beta, const float * ",MatchSource.WIKI,doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:2428,Integrability,interface,interface,2428," h1 = df1.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_sig"", """", 100, 0, 1}, ""y"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TMVA::Experimental::RSofieReaderTMVA::RSofieReader class for reading external Machine Learning models in ONNX files,...Definition RSofieReader.hxx:45; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; outputstatic void output(); ; Model has no",MatchSource.WIKI,doc/master/TMVA__SOFIE__RSofieReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:1018,Safety,predict,predict,1018,"eference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_RSofieReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; Execute in this order: root TMVA_Higgs_Classification.C; root TMVA_SOFIE_RSofieReader.C; TMVA_Higgs_ClassificationDefinition TMVA_Higgs_Classification.py:1; ; using namespace TMVA::Experimental;; ; void TMVA_SOFIE_RSofieReader(){; ; RSofieReader model(""Higgs_trained_model.h5"");; // for debugging; //RSofieReader model(""Higgs_trained_model.h5"", {}, true);; ; // the input shape for this model is a tensor with shape (1,7); ; std::vector<float> input = {0.1,0.2,0.3,0.4,0.5,0.6,0.7};; ; // predict model on a single event (takes a std::vector<float>); ; auto output = model.Compute(input);; ; std::cout << ""Event prediction = "" << output[0] << std::endl;; ; // predict model now on a input file using RDataFrame; ; std::string inputFileName = ""Higgs_data.root"";; std::string inputFile = ""http://root.cern.ch/files/"" + inputFileName;; ; ; ROOT::RDataFrame df1(""sig_tree"", inputFile);; ; auto h1 = df1.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_sig"", """", 100, 0, 1}, ""y"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; kRed@ kRedDefinition Rt",MatchSource.WIKI,doc/master/TMVA__SOFIE__RSofieReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:1141,Safety,predict,prediction,1141,"als » TMVA tutorials. Detailed Description; This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; Execute in this order: root TMVA_Higgs_Classification.C; root TMVA_SOFIE_RSofieReader.C; TMVA_Higgs_ClassificationDefinition TMVA_Higgs_Classification.py:1; ; using namespace TMVA::Experimental;; ; void TMVA_SOFIE_RSofieReader(){; ; RSofieReader model(""Higgs_trained_model.h5"");; // for debugging; //RSofieReader model(""Higgs_trained_model.h5"", {}, true);; ; // the input shape for this model is a tensor with shape (1,7); ; std::vector<float> input = {0.1,0.2,0.3,0.4,0.5,0.6,0.7};; ; // predict model on a single event (takes a std::vector<float>); ; auto output = model.Compute(input);; ; std::cout << ""Event prediction = "" << output[0] << std::endl;; ; // predict model now on a input file using RDataFrame; ; std::string inputFileName = ""Higgs_data.root"";; std::string inputFile = ""http://root.cern.ch/files/"" + inputFileName;; ; ; ROOT::RDataFrame df1(""sig_tree"", inputFile);; ; auto h1 = df1.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_sig"", """", 100, 0, 1}, ""y"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor ",MatchSource.WIKI,doc/master/TMVA__SOFIE__RSofieReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:1189,Safety,predict,predict,1189,"als » TMVA tutorials. Detailed Description; This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; Execute in this order: root TMVA_Higgs_Classification.C; root TMVA_SOFIE_RSofieReader.C; TMVA_Higgs_ClassificationDefinition TMVA_Higgs_Classification.py:1; ; using namespace TMVA::Experimental;; ; void TMVA_SOFIE_RSofieReader(){; ; RSofieReader model(""Higgs_trained_model.h5"");; // for debugging; //RSofieReader model(""Higgs_trained_model.h5"", {}, true);; ; // the input shape for this model is a tensor with shape (1,7); ; std::vector<float> input = {0.1,0.2,0.3,0.4,0.5,0.6,0.7};; ; // predict model on a single event (takes a std::vector<float>); ; auto output = model.Compute(input);; ; std::cout << ""Event prediction = "" << output[0] << std::endl;; ; // predict model now on a input file using RDataFrame; ; std::string inputFileName = ""Higgs_data.root"";; std::string inputFile = ""http://root.cern.ch/files/"" + inputFileName;; ; ; ROOT::RDataFrame df1(""sig_tree"", inputFile);; ; auto h1 = df1.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_sig"", """", 100, 0, 1}, ""y"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor ",MatchSource.WIKI,doc/master/TMVA__SOFIE__RSofieReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html
https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:3509,Safety,predict,prediction,3509,""", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TMVA::Experimental::RSofieReaderTMVA::RSofieReader class for reading external Machine Learning models in ONNX files,...Definition RSofieReader.hxx:45; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; outputstatic void output(); ; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; Event prediction = 0.212106; AuthorLorenzo Moneta ; Definition in file TMVA_SOFIE_RSofieReader.C. tutorialstmvaTMVA_SOFIE_RSofieReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVA__SOFIE__RSofieReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html
https://root.cern/doc/master/TNamed_8h_source.html:4376,Security,hash,hash,4376,"TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::~TNamedvirtual ~TNamed()TNamed destructor.Definition TNamed.cxx:42; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::TNamedTNamed(const TString &name, const TString &title)Definition TNamed.h:38; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::TNamedTNamed()Definition TNamed.h:36; TNamed::Printvoid Print(Option_t *option="""") const overridePrint TNamed name and title.Definition TNamed.cxx:128; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::Clearvoid Clear(Option_t *option="""") overrideSet name and title to empty strings ("""").Definition TNamed.cxx:64; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TNamed::CompareInt_t Compare(const TObject *obj) const overrideCompare two TNamed objects.Definition TNamed.cxx:85; TNamed::Sizeofvirtual Int_t Sizeof() constReturn size of the TNamed part of the TObject.Definition TNamed.cxx:173; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TNamed::lsvoid ls(Option_t *option="""") const overrideList TNamed name and title.Definition TNamed.cxx:113; TNamed::SetNameTitlevirtual void SetNameTitle(const char *name, const char *title)Set all the TNamed parameters (name and title).Definition TNamed.cxx:154; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; bool. corebaseincTNamed.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.",MatchSource.WIKI,doc/master/TNamed_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNamed_8h_source.html
https://root.cern/doc/master/TNamed_8h_source.html:5201,Security,hash,hash,5201,"tTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::~TNamedvirtual ~TNamed()TNamed destructor.Definition TNamed.cxx:42; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::TNamedTNamed(const TString &name, const TString &title)Definition TNamed.h:38; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::TNamedTNamed()Definition TNamed.h:36; TNamed::Printvoid Print(Option_t *option="""") const overridePrint TNamed name and title.Definition TNamed.cxx:128; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::Clearvoid Clear(Option_t *option="""") overrideSet name and title to empty strings ("""").Definition TNamed.cxx:64; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TNamed::CompareInt_t Compare(const TObject *obj) const overrideCompare two TNamed objects.Definition TNamed.cxx:85; TNamed::Sizeofvirtual Int_t Sizeof() constReturn size of the TNamed part of the TObject.Definition TNamed.cxx:173; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TNamed::lsvoid ls(Option_t *option="""") const overrideList TNamed name and title.Definition TNamed.cxx:113; TNamed::SetNameTitlevirtual void SetNameTitle(const char *name, const char *title)Set all the TNamed parameters (name and title).Definition TNamed.cxx:154; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; bool. corebaseincTNamed.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TNamed_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNamed_8h_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:1682,Energy Efficiency,energy,energy,1682,"Buffer.h""; 14#include ""TTree.h""; 15#include ""TBranch.h""; 16#include ""TLeaf.h""; 17#include ""TBrowser.h""; 18#include ""TreeUtils.h""; 19#include ""strlcpy.h""; 20 ; 21#include <string>; 22 ; 23ClassImp(TNtuple);; 24 ; 25/** \class TNtuple; 26\ingroup tree; 27 ; 28A simple TTree restricted to a list of float variables only.; 29 ; 30Each variable goes to a separate branch.; 31 ; 32A Ntuple is created via; 33~~~ {.cpp}; 34 TNtuple(name,title,varlist,bufsize); 35~~~; 36It is filled via:; 37~~~ {.cpp}; 38 TNtuple::Fill(*x) or; 39 TNtuple::Fill(v1,v2,v3.....); 40~~~; 41*/; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor for Ntuple.; 45 ; 46TNtuple::TNtuple(): TTree(); 47{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *varlist, Int_t bufsize); 67 :TTree(name,title); 68{; 69 Int_t i;; 70 fNvar = 0;; 71 fArgs = nullptr;; 72 ; 73// Count number of variables (separated by :); 74 Int_t nch = strlen(varlist);; 75 if (nch == 0) return;; 76 char *vars = new char[nch+1];; 77 strlcpy(vars,varlist,nch+1);; 78 Int_t *pvars = new Int_t[nch+1];; 79 fNvar = 1;; 80 pvars[0] = 0;; 81 for (i=1;i<nch;i++) {; 82 if (vars[i] == ':') {; 83 pvars[fNvar] = i+1;; 84 vars[i] = 0;; 85 fNvar++;; 86 }; 87 }; 88 fArgs = new Float_t[fNvar];; 89 ; 90// Create one branch for each variable; 91 for (i=0;i<fNvar;i++) {; 92 Int_t pv = pvars[i];; 93 TTree::Branch(&vars[pv],&fArgs[i],&vars[pv],buf",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:956,Modifiability,variab,variables,956,". ROOT: tree/tree/src/TNtuple.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TNtuple.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 06/04/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TNtuple.h""; 13#include ""TBuffer.h""; 14#include ""TTree.h""; 15#include ""TBranch.h""; 16#include ""TLeaf.h""; 17#include ""TBrowser.h""; 18#include ""TreeUtils.h""; 19#include ""strlcpy.h""; 20 ; 21#include <string>; 22 ; 23ClassImp(TNtuple);; 24 ; 25/** \class TNtuple; 26\ingroup tree; 27 ; 28A simple TTree restricted to a list of float variables only.; 29 ; 30Each variable goes to a separate branch.; 31 ; 32A Ntuple is created via; 33~~~ {.cpp}; 34 TNtuple(name,title,varlist,bufsize); 35~~~; 36It is filled via:; 37~~~ {.cpp}; 38 TNtuple::Fill(*x) or; 39 TNtuple::Fill(v1,v2,v3.....); 40~~~; 41*/; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor for Ntuple.; 45 ; 46TNtuple::TNtuple(): TTree(); 47{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:985,Modifiability,variab,variable,985,". ROOT: tree/tree/src/TNtuple.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TNtuple.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 06/04/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TNtuple.h""; 13#include ""TBuffer.h""; 14#include ""TTree.h""; 15#include ""TBranch.h""; 16#include ""TLeaf.h""; 17#include ""TBrowser.h""; 18#include ""TreeUtils.h""; 19#include ""strlcpy.h""; 20 ; 21#include <string>; 22 ; 23ClassImp(TNtuple);; 24 ; 25/** \class TNtuple; 26\ingroup tree; 27 ; 28A simple TTree restricted to a list of float variables only.; 29 ; 30Each variable goes to a separate branch.; 31 ; 32A Ntuple is created via; 33~~~ {.cpp}; 34 TNtuple(name,title,varlist,bufsize); 35~~~; 36It is filled via:; 37~~~ {.cpp}; 38 TNtuple::Fill(*x) or; 39 TNtuple::Fill(v1,v2,v3.....); 40~~~; 41*/; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor for Ntuple.; 45 ; 46TNtuple::TNtuple(): TTree(); 47{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:1613,Modifiability,variab,variables,1613,"Buffer.h""; 14#include ""TTree.h""; 15#include ""TBranch.h""; 16#include ""TLeaf.h""; 17#include ""TBrowser.h""; 18#include ""TreeUtils.h""; 19#include ""strlcpy.h""; 20 ; 21#include <string>; 22 ; 23ClassImp(TNtuple);; 24 ; 25/** \class TNtuple; 26\ingroup tree; 27 ; 28A simple TTree restricted to a list of float variables only.; 29 ; 30Each variable goes to a separate branch.; 31 ; 32A Ntuple is created via; 33~~~ {.cpp}; 34 TNtuple(name,title,varlist,bufsize); 35~~~; 36It is filled via:; 37~~~ {.cpp}; 38 TNtuple::Fill(*x) or; 39 TNtuple::Fill(v1,v2,v3.....); 40~~~; 41*/; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor for Ntuple.; 45 ; 46TNtuple::TNtuple(): TTree(); 47{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *varlist, Int_t bufsize); 67 :TTree(name,title); 68{; 69 Int_t i;; 70 fNvar = 0;; 71 fArgs = nullptr;; 72 ; 73// Count number of variables (separated by :); 74 Int_t nch = strlen(varlist);; 75 if (nch == 0) return;; 76 char *vars = new char[nch+1];; 77 strlcpy(vars,varlist,nch+1);; 78 Int_t *pvars = new Int_t[nch+1];; 79 fNvar = 1;; 80 pvars[0] = 0;; 81 for (i=1;i<nch;i++) {; 82 if (vars[i] == ':') {; 83 pvars[fNvar] = i+1;; 84 vars[i] = 0;; 85 fNvar++;; 86 }; 87 }; 88 fArgs = new Float_t[fNvar];; 89 ; 90// Create one branch for each variable; 91 for (i=0;i<fNvar;i++) {; 92 Int_t pv = pvars[i];; 93 TTree::Branch(&vars[pv],&fArgs[i],&vars[pv],buf",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:1713,Modifiability,variab,variable,1713,"Buffer.h""; 14#include ""TTree.h""; 15#include ""TBranch.h""; 16#include ""TLeaf.h""; 17#include ""TBrowser.h""; 18#include ""TreeUtils.h""; 19#include ""strlcpy.h""; 20 ; 21#include <string>; 22 ; 23ClassImp(TNtuple);; 24 ; 25/** \class TNtuple; 26\ingroup tree; 27 ; 28A simple TTree restricted to a list of float variables only.; 29 ; 30Each variable goes to a separate branch.; 31 ; 32A Ntuple is created via; 33~~~ {.cpp}; 34 TNtuple(name,title,varlist,bufsize); 35~~~; 36It is filled via:; 37~~~ {.cpp}; 38 TNtuple::Fill(*x) or; 39 TNtuple::Fill(v1,v2,v3.....); 40~~~; 41*/; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor for Ntuple.; 45 ; 46TNtuple::TNtuple(): TTree(); 47{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *varlist, Int_t bufsize); 67 :TTree(name,title); 68{; 69 Int_t i;; 70 fNvar = 0;; 71 fArgs = nullptr;; 72 ; 73// Count number of variables (separated by :); 74 Int_t nch = strlen(varlist);; 75 if (nch == 0) return;; 76 char *vars = new char[nch+1];; 77 strlcpy(vars,varlist,nch+1);; 78 Int_t *pvars = new Int_t[nch+1];; 79 fNvar = 1;; 80 pvars[0] = 0;; 81 for (i=1;i<nch;i++) {; 82 if (vars[i] == ':') {; 83 pvars[fNvar] = i+1;; 84 vars[i] = 0;; 85 fNvar++;; 86 }; 87 }; 88 fArgs = new Float_t[fNvar];; 89 ; 90// Create one branch for each variable; 91 for (i=0;i<fNvar;i++) {; 92 Int_t pv = pvars[i];; 93 TTree::Branch(&vars[pv],&fArgs[i],&vars[pv],buf",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:1827,Modifiability,variab,variables,1827,"21#include <string>; 22 ; 23ClassImp(TNtuple);; 24 ; 25/** \class TNtuple; 26\ingroup tree; 27 ; 28A simple TTree restricted to a list of float variables only.; 29 ; 30Each variable goes to a separate branch.; 31 ; 32A Ntuple is created via; 33~~~ {.cpp}; 34 TNtuple(name,title,varlist,bufsize); 35~~~; 36It is filled via:; 37~~~ {.cpp}; 38 TNtuple::Fill(*x) or; 39 TNtuple::Fill(v1,v2,v3.....); 40~~~; 41*/; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor for Ntuple.; 45 ; 46TNtuple::TNtuple(): TTree(); 47{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *varlist, Int_t bufsize); 67 :TTree(name,title); 68{; 69 Int_t i;; 70 fNvar = 0;; 71 fArgs = nullptr;; 72 ; 73// Count number of variables (separated by :); 74 Int_t nch = strlen(varlist);; 75 if (nch == 0) return;; 76 char *vars = new char[nch+1];; 77 strlcpy(vars,varlist,nch+1);; 78 Int_t *pvars = new Int_t[nch+1];; 79 fNvar = 1;; 80 pvars[0] = 0;; 81 for (i=1;i<nch;i++) {; 82 if (vars[i] == ':') {; 83 pvars[fNvar] = i+1;; 84 vars[i] = 0;; 85 fNvar++;; 86 }; 87 }; 88 fArgs = new Float_t[fNvar];; 89 ; 90// Create one branch for each variable; 91 for (i=0;i<fNvar;i++) {; 92 Int_t pv = pvars[i];; 93 TTree::Branch(&vars[pv],&fArgs[i],&vars[pv],bufsize);; 94 }; 95 ; 96 delete [] vars;; 97 delete [] pvars;; 98}; 99 ; 100////////////////////////////////////////////////////////////////////////////////; 101/",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:2129,Modifiability,variab,variables,2129,"{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *varlist, Int_t bufsize); 67 :TTree(name,title); 68{; 69 Int_t i;; 70 fNvar = 0;; 71 fArgs = nullptr;; 72 ; 73// Count number of variables (separated by :); 74 Int_t nch = strlen(varlist);; 75 if (nch == 0) return;; 76 char *vars = new char[nch+1];; 77 strlcpy(vars,varlist,nch+1);; 78 Int_t *pvars = new Int_t[nch+1];; 79 fNvar = 1;; 80 pvars[0] = 0;; 81 for (i=1;i<nch;i++) {; 82 if (vars[i] == ':') {; 83 pvars[fNvar] = i+1;; 84 vars[i] = 0;; 85 fNvar++;; 86 }; 87 }; 88 fArgs = new Float_t[fNvar];; 89 ; 90// Create one branch for each variable; 91 for (i=0;i<fNvar;i++) {; 92 Int_t pv = pvars[i];; 93 TTree::Branch(&vars[pv],&fArgs[i],&vars[pv],bufsize);; 94 }; 95 ; 96 delete [] vars;; 97 delete [] pvars;; 98}; 99 ; 100////////////////////////////////////////////////////////////////////////////////; 101/// Default destructor for an Ntuple.; 102 ; 103TNtuple::~TNtuple(); 104{; 105 delete [] fArgs;; 106 fArgs = nullptr;; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Create a clone of this tree and copy nentries.; 111///; 112/// By default copy all entries.; 113/// Note that only active branches are copied.; 114/// The compression level of the cloned tree is set to the destination file's; 115/// compression level.; 116///; 117/// See TTree::CloneTree for more details.; 118 ; 119TTree* TNtuple::CloneTree(Long64_t n",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:2540,Modifiability,variab,variable,2540,"{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *varlist, Int_t bufsize); 67 :TTree(name,title); 68{; 69 Int_t i;; 70 fNvar = 0;; 71 fArgs = nullptr;; 72 ; 73// Count number of variables (separated by :); 74 Int_t nch = strlen(varlist);; 75 if (nch == 0) return;; 76 char *vars = new char[nch+1];; 77 strlcpy(vars,varlist,nch+1);; 78 Int_t *pvars = new Int_t[nch+1];; 79 fNvar = 1;; 80 pvars[0] = 0;; 81 for (i=1;i<nch;i++) {; 82 if (vars[i] == ':') {; 83 pvars[fNvar] = i+1;; 84 vars[i] = 0;; 85 fNvar++;; 86 }; 87 }; 88 fArgs = new Float_t[fNvar];; 89 ; 90// Create one branch for each variable; 91 for (i=0;i<fNvar;i++) {; 92 Int_t pv = pvars[i];; 93 TTree::Branch(&vars[pv],&fArgs[i],&vars[pv],bufsize);; 94 }; 95 ; 96 delete [] vars;; 97 delete [] pvars;; 98}; 99 ; 100////////////////////////////////////////////////////////////////////////////////; 101/// Default destructor for an Ntuple.; 102 ; 103TNtuple::~TNtuple(); 104{; 105 delete [] fArgs;; 106 fArgs = nullptr;; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Create a clone of this tree and copy nentries.; 111///; 112/// By default copy all entries.; 113/// Note that only active branches are copied.; 114/// The compression level of the cloned tree is set to the destination file's; 115/// compression level.; 116///; 117/// See TTree::CloneTree for more details.; 118 ; 119TTree* TNtuple::CloneTree(Long64_t n",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:6565,Modifiability,variab,variables,6565,"////////////////////////////////////////////////; 164/// Fill a Ntuple with current values in fArgs.; 165///; 166/// Note that this function is protected.; 167/// Currently called only by TChain::Merge; 168 ; 169Int_t TNtuple::Fill(); 170{; 171 return TTree::Fill();; 172}; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Fill a Ntuple with an array of floats; 176 ; 177Int_t TNtuple::Fill(const Float_t *x); 178{; 179 ; 180 // Store array x into buffer; 181 for (Int_t i=0;i<fNvar;i++) {; 182 fArgs[i] = x[i];; 183 }; 184 ; 185 return TTree::Fill();; 186}; 187 ; 188////////////////////////////////////////////////////////////////////////////////; 189/// Fill a Ntuple: Each Ntuple item is an argument; 190 ; 191Int_t TNtuple::Fill(Float_t x0,Float_t x1,Float_t x2,Float_t x3,Float_t x4; 192 ,Float_t x5,Float_t x6,Float_t x7,Float_t x8,Float_t x9; 193 ,Float_t x10,Float_t x11,Float_t x12,Float_t x13,Float_t x14); 194{; 195 if (fNvar > 0) fArgs[0] = x0;; 196 if (fNvar > 1) fArgs[1] = x1;; 197 if (fNvar > 2) fArgs[2] = x2;; 198 if (fNvar > 3) fArgs[3] = x3;; 199 if (fNvar > 4) fArgs[4] = x4;; 200 if (fNvar > 5) fArgs[5] = x5;; 201 if (fNvar > 6) fArgs[6] = x6;; 202 if (fNvar > 7) fArgs[7] = x7;; 203 if (fNvar > 8) fArgs[8] = x8;; 204 if (fNvar > 9) fArgs[9] = x9;; 205 if (fNvar > 10) fArgs[10] = x10;; 206 if (fNvar > 11) fArgs[11] = x11;; 207 if (fNvar > 12) fArgs[12] = x12;; 208 if (fNvar > 13) fArgs[13] = x13;; 209 if (fNvar > 14) fArgs[14] = x14;; 210 ; 211 return TTree::Fill();; 212}; 213 ; 214////////////////////////////////////////////////////////////////////////////////; 215/// Read from filename as many columns as variables in the ntuple; 216/// the function returns the number of rows found in the file; 217/// The second argument ""branchDescriptor"" is currently not used.; 218/// Lines in the input file starting with ""#"" are ignored.; 219 ; 220Long64_t TNtuple::ReadStream(std::istream &inputStream, const char * /*branchDes",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:9880,Modifiability,variab,variables,9880,"extMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TLeaf.h; TNtuple.h; TTree.h; TreeUtils.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::SetAddressvirtual void SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::IsATClass * IsA() const overrideDefinition TNtuple.h:61; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Classstatic TClass * Class(); TNtuple::Browsevoid Browse(TBrowser *b) overrideBrowse content of the ntuple.Definition TNtuple.cxx:158; TN",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:10085,Modifiability,variab,variables,10085,"n32VirtualXProxy.cxx:168; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TLeaf.h; TNtuple.h; TTree.h; TreeUtils.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::SetAddressvirtual void SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::IsATClass * IsA() const overrideDefinition TNtuple.h:61; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Classstatic TClass * Class(); TNtuple::Browsevoid Browse(TBrowser *b) overrideBrowse content of the ntuple.Definition TNtuple.cxx:158; TNtuple::TNtupleTNtuple()Default constructor for Ntuple.Definition TNtuple.cxx:46; TNtuple::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TNtuple.cxx",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:11191,Modifiability,variab,variablesDefinition,11191,"0; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::IsATClass * IsA() const overrideDefinition TNtuple.h:61; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Classstatic TClass * Class(); TNtuple::Browsevoid Browse(TBrowser *b) overrideBrowse content of the ntuple.Definition TNtuple.cxx:158; TNtuple::TNtupleTNtuple()Default constructor for Ntuple.Definition TNtuple.cxx:46; TNtuple::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TNtuple.cxx:249; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TNtuple::fArgsFloat_t * fArgs! [fNvar] Array of variablesDefinition TNtuple.h:32; TNtuple::CloneTreeTTree * CloneTree(Long64_t nentries=-1, Option_t *option="""") overrideCreate a clone of this tree and copy nentries.Definition TNtuple.cxx:119; TObjArray::IndexOfInt_t IndexOf(const TObject *obj) const overrideDefinition TObjArray.cxx:605; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::Fillvirtual Int_t Fill()Fill all branches.Definition TTree.cxx:4603; TTree::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TTree.cxx:9545; TTree::fBranchesTObjArray fBranchesList of Branches.Definition TTree.h:122; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::fLea",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:913,Usability,simpl,simple,913,". ROOT: tree/tree/src/TNtuple.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TNtuple.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 06/04/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TNtuple.h""; 13#include ""TBuffer.h""; 14#include ""TTree.h""; 15#include ""TBranch.h""; 16#include ""TLeaf.h""; 17#include ""TBrowser.h""; 18#include ""TreeUtils.h""; 19#include ""strlcpy.h""; 20 ; 21#include <string>; 22 ; 23ClassImp(TNtuple);; 24 ; 25/** \class TNtuple; 26\ingroup tree; 27 ; 28A simple TTree restricted to a list of float variables only.; 29 ; 30Each variable goes to a separate branch.; 31 ; 32A Ntuple is created via; 33~~~ {.cpp}; 34 TNtuple(name,title,varlist,bufsize); 35~~~; 36It is filled via:; 37~~~ {.cpp}; 38 TNtuple::Fill(*x) or; 39 TNtuple::Fill(v1,v2,v3.....); 40~~~; 41*/; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor for Ntuple.; 45 ; 46TNtuple::TNtuple(): TTree(); 47{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8cxx_source.html:9837,Usability,simpl,simple,9837,"extMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TLeaf.h; TNtuple.h; TTree.h; TreeUtils.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::SetAddressvirtual void SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::IsATClass * IsA() const overrideDefinition TNtuple.h:61; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Classstatic TClass * Class(); TNtuple::Browsevoid Browse(TBrowser *b) overrideBrowse content of the ntuple.Definition TNtuple.cxx:158; TN",MatchSource.WIKI,doc/master/TNtuple_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html
https://root.cern/doc/master/TNtuple_8h_source.html:1109,Modifiability,variab,variables,1109,"Ntuple; 13#define ROOT_TNtuple; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TNtuple //; 19// //; 20// A simple tree with branches of floats. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TTree.h""; 25 ; 26class TBrowser;; 27 ; 28class TNtuple : public TTree {; 29 ; 30protected:; 31 Int_t fNvar; ///< Number of columns; 32 Float_t *fArgs; ///<! [fNvar] Array of variables; 33 ; 34 Int_t Fill() override;; 35 ; 36private:; 37 TNtuple(const TNtuple&) = delete;; 38 TNtuple& operator=(const TNtuple&) = delete;; 39 ; 40public:; 41 TNtuple();; 42 TNtuple(const char *name,const char *title, const char *varlist, Int_t bufsize=32000);; 43 ~TNtuple() override;; 44 ; 45 void Browse(TBrowser *b) override;; 46 TTree *CloneTree(Long64_t nentries = -1, Option_t* option = """") override;; 47 virtual Int_t Fill(const Float_t *x);; 48 Int_t Fill(Int_t x0) { return Fill((Float_t)x0); }; 49 Int_t Fill(Double_t x0) { return Fill((Float_t)x0); }; 50 virtual Int_t Fill(Float_t x0, Float_t x1=0, Float_t x2=0, Float_t x3=0,; 51 Float_t x4=0, Float_t x5=0, Float_t x6=0, Float_t x7=0,; 52 Float_t x8=0, Float_t x9=0, Float_t x10=0,; 53 Float_t x11=0, Float_t x12=0, Float_t x13=0,; 54 Float_t x14=0);; 55 virtual Int_t GetNvar() const { return fNvar; }; 56 Float_t *GetArgs() const { return fArgs; }; 57 Long64_t ReadStream(std::istream& inputStream, const char *branchDescriptor="""", char delimiter = ' ') override;; 58 void ResetBranchAddress(TBranch *) override;; 59 void ResetBranchAddresses() override;; 60 ; 61 ClassDefOverride(TNtuple,2); //A simple tree with branches of floats.; 62};; 63 ; 64#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)",MatchSource.WIKI,doc/master/TNtuple_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8h_source.html
https://root.cern/doc/master/TNtuple_8h_source.html:3198,Modifiability,variab,variables,3198,"Branch *) override;; 59 void ResetBranchAddresses() override;; 60 ; 61 ClassDefOverride(TNtuple,2); //A simple tree with branches of floats.; 62};; 63 ; 64#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TTree.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::TNtupleTNtuple(const TNtuple &)=delete; TNtuple::GetNvarvirtual Int_t GetNvar() constDefinition TNtuple.h:55; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::GetArgsFloat_t * GetArgs() constDefinition TNtuple.h:56; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Browsevoid Browse(TB",MatchSource.WIKI,doc/master/TNtuple_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8h_source.html
https://root.cern/doc/master/TNtuple_8h_source.html:3403,Modifiability,variab,variables,3403,"(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TTree.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::TNtupleTNtuple(const TNtuple &)=delete; TNtuple::GetNvarvirtual Int_t GetNvar() constDefinition TNtuple.h:55; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::GetArgsFloat_t * GetArgs() constDefinition TNtuple.h:56; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Browsevoid Browse(TBrowser *b) overrideBrowse content of the ntuple.Definition TNtuple.cxx:158; TNtuple::operator=TNtuple & operator=(const TNtuple &)=delete; TNtuple::FillInt_t Fill(Double_t x",MatchSource.WIKI,doc/master/TNtuple_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8h_source.html
https://root.cern/doc/master/TNtuple_8h_source.html:4671,Modifiability,variab,variablesDefinition,4671,"T objects.Definition TBrowser.h:37; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::TNtupleTNtuple(const TNtuple &)=delete; TNtuple::GetNvarvirtual Int_t GetNvar() constDefinition TNtuple.h:55; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::GetArgsFloat_t * GetArgs() constDefinition TNtuple.h:56; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Browsevoid Browse(TBrowser *b) overrideBrowse content of the ntuple.Definition TNtuple.cxx:158; TNtuple::operator=TNtuple & operator=(const TNtuple &)=delete; TNtuple::FillInt_t Fill(Double_t x0)Definition TNtuple.h:49; TNtuple::TNtupleTNtuple()Default constructor for Ntuple.Definition TNtuple.cxx:46; TNtuple::FillInt_t Fill(Int_t x0)Definition TNtuple.h:48; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TNtuple::fArgsFloat_t * fArgs! [fNvar] Array of variablesDefinition TNtuple.h:32; TNtuple::CloneTreeTTree * CloneTree(Long64_t nentries=-1, Option_t *option="""") overrideCreate a clone of this tree and copy nentries.Definition TNtuple.cxx:119; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; double; int; xDouble_t x[n]Definition legend1.C:17. treetreeincTNtuple.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TNtuple_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8h_source.html
https://root.cern/doc/master/TNtuple_8h_source.html:790,Usability,simpl,simple,790,". ROOT: tree/tree/inc/TNtuple.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TNtuple.h. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 06/04/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TNtuple; 13#define ROOT_TNtuple; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TNtuple //; 19// //; 20// A simple tree with branches of floats. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TTree.h""; 25 ; 26class TBrowser;; 27 ; 28class TNtuple : public TTree {; 29 ; 30protected:; 31 Int_t fNvar; ///< Number of columns; 32 Float_t *fArgs; ///<! [fNvar] Array of variables; 33 ; 34 Int_t Fill() override;; 35 ; 36private:; 37 TNtuple(const TNtuple&) = delete;; 38 TNtuple& operator=(const TNtuple&) = delete;; 39 ; 40public:; 41 TNtuple();; 42 TNtuple(const char *name,const char *title, const char *varlist, Int_t bufsize=32000);; 43 ~TNtuple() override;; 44 ; 45 void Browse(TBrowser *b) override;; 46 TTree *CloneTree(Long64_t nentries = -1, Option_t* option = """") override;; 47 virtual Int_t Fill(const Float_t *x);; 48 Int_t Fill(Int_t x0) { return Fill((Float_t)x0); }; 49 Int_t Fill(Double_t x0) { return Fill((Float_t)x0); }; 50 virtual Int_t Fill(Float_t x0, Float_t x1=0, Float_t x2=0, Float_t x3=0,; 51 Float_t x4=0, Float_t x5=0, Float_t x6=0, Float_t x7=0,; 52 Float_t x8=0, Float_t x9=0, Float_t x10=0,; 53 Float_t x11=0, Float_t x12=0, Float_t x13=0,; 54 Float_t x14=0);; 55 virtual Int_t GetNvar() const { return fNvar; }; 56 Float_t *GetA",MatchSource.WIKI,doc/master/TNtuple_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8h_source.html
https://root.cern/doc/master/TNtuple_8h_source.html:2280,Usability,simpl,simple,2280,"Ntuple; 13#define ROOT_TNtuple; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TNtuple //; 19// //; 20// A simple tree with branches of floats. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TTree.h""; 25 ; 26class TBrowser;; 27 ; 28class TNtuple : public TTree {; 29 ; 30protected:; 31 Int_t fNvar; ///< Number of columns; 32 Float_t *fArgs; ///<! [fNvar] Array of variables; 33 ; 34 Int_t Fill() override;; 35 ; 36private:; 37 TNtuple(const TNtuple&) = delete;; 38 TNtuple& operator=(const TNtuple&) = delete;; 39 ; 40public:; 41 TNtuple();; 42 TNtuple(const char *name,const char *title, const char *varlist, Int_t bufsize=32000);; 43 ~TNtuple() override;; 44 ; 45 void Browse(TBrowser *b) override;; 46 TTree *CloneTree(Long64_t nentries = -1, Option_t* option = """") override;; 47 virtual Int_t Fill(const Float_t *x);; 48 Int_t Fill(Int_t x0) { return Fill((Float_t)x0); }; 49 Int_t Fill(Double_t x0) { return Fill((Float_t)x0); }; 50 virtual Int_t Fill(Float_t x0, Float_t x1=0, Float_t x2=0, Float_t x3=0,; 51 Float_t x4=0, Float_t x5=0, Float_t x6=0, Float_t x7=0,; 52 Float_t x8=0, Float_t x9=0, Float_t x10=0,; 53 Float_t x11=0, Float_t x12=0, Float_t x13=0,; 54 Float_t x14=0);; 55 virtual Int_t GetNvar() const { return fNvar; }; 56 Float_t *GetArgs() const { return fArgs; }; 57 Long64_t ReadStream(std::istream& inputStream, const char *branchDescriptor="""", char delimiter = ' ') override;; 58 void ResetBranchAddress(TBranch *) override;; 59 void ResetBranchAddresses() override;; 60 ; 61 ClassDefOverride(TNtuple,2); //A simple tree with branches of floats.; 62};; 63 ; 64#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)",MatchSource.WIKI,doc/master/TNtuple_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8h_source.html
https://root.cern/doc/master/TNtuple_8h_source.html:3155,Usability,simpl,simple,3155,"Branch *) override;; 59 void ResetBranchAddresses() override;; 60 ; 61 ClassDefOverride(TNtuple,2); //A simple tree with branches of floats.; 62};; 63 ; 64#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TTree.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::TNtupleTNtuple(const TNtuple &)=delete; TNtuple::GetNvarvirtual Int_t GetNvar() constDefinition TNtuple.h:55; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::GetArgsFloat_t * GetArgs() constDefinition TNtuple.h:56; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Browsevoid Browse(TB",MatchSource.WIKI,doc/master/TNtuple_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TNtuple_8h_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:8442,Availability,error,error,8442,"nd;; 223 if (idx == -1) {; 224 Error(""AddAfter"", ""after not found, object not added"");; 225 return;; 226 }; 227 AddAtAndExpand(obj, idx+fLowerBound+1);; 228 }; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Add object at position idx. If idx is larger than the current size; 233/// of the array, expand the array (double its size).; 234 ; 235void TObjArray::AddAtAndExpand(TObject *obj, Int_t idx); 236{; 237 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 238 ; 239 if (idx < fLowerBound) {; 240 Error(""AddAt"", ""out of bounds at %d in %zx"", idx, (size_t)this);; 241 return;; 242 }; 243 if (idx-fLowerBound >= fSize); 244 Expand(TMath::Max(idx-fLowerBound+1, GrowBy(fSize)));; 245 fCont[idx-fLowerBound] = obj;; 246 fLast = TMath::Max(idx-fLowerBound, GetAbsLast());; 247 Changed();; 248}; 249 ; 250////////////////////////////////////////////////////////////////////////////////; 251/// Add object at position ids. Give an error when idx is out of bounds; 252/// (i.e. the array is not expanded).; 253 ; 254void TObjArray::AddAt(TObject *obj, Int_t idx); 255{; 256 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 257 ; 258 if (!BoundsOk(""AddAt"", idx)) return;; 259 ; 260 fCont[idx-fLowerBound] = obj;; 261 fLast = TMath::Max(idx-fLowerBound, GetAbsLast());; 262 Changed();; 263}; 264 ; 265////////////////////////////////////////////////////////////////////////////////; 266/// Return the position of the new object.; 267/// Find the first empty cell or AddLast if there is no empty cell; 268 ; 269Int_t TObjArray::AddAtFree(TObject *obj); 270{; 271 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 272 ; 273 if (Last()) { // <---------- This is to take in account ""empty"" TObjArray's; 274 Int_t i;; 275 for (i = 0; i < fSize; i++); 276 if (!fCont[i]) { // Add object at position i; 277 fCont[i] = obj;; 278 fLast = TMath::Max(i, GetAbsLast());; 279 Changed();; 280 return i+fLowerBound;; 281 }; 282 }; 283 AddLast(obj);; 284 return GetL",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:21233,Availability,error,error,21233,"y slot; 616 for (i = 0; i < fSize; i++); 617 if (!fCont[i]); 618 return i+fLowerBound;; 619 }; 620 ; 621 return fLowerBound-1;; 622}; 623 ; 624////////////////////////////////////////////////////////////////////////////////; 625/// Initialize a TObjArray.; 626 ; 627void TObjArray::Init(Int_t s, Int_t lowerBound); 628{; 629 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 630 ; 631 if (fCont && fSize != s) {; 632 TStorage::Dealloc(fCont);; 633 fCont = nullptr;; 634 }; 635 ; 636 fSize = s;; 637 ; 638 if (!fCont); 639 fCont = (TObject**) TStorage::Alloc(fSize*sizeof(TObject*)); //new TObject* [fSize];; 640 memset(fCont, 0, fSize*sizeof(TObject*));; 641 fLowerBound = lowerBound;; 642 fLast = -1;; 643 Changed();; 644}; 645 ; 646////////////////////////////////////////////////////////////////////////////////; 647/// Returns an array iterator.; 648 ; 649TIterator *TObjArray::MakeIterator(Bool_t dir) const; 650{; 651 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 652 return new TObjArrayIter(this, dir);; 653}; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// Generate an out-of-bounds error. Always returns false.; 657 ; 658Bool_t TObjArray::OutOfBoundsError(const char *where, Int_t i) const; 659{; 660 Error(where, ""index %d out of bounds (size: %d, this: 0x%zx)"", i, fSize, (size_t)this);; 661 return kFALSE;; 662}; 663 ; 664////////////////////////////////////////////////////////////////////////////////; 665/// Remove object from this collection and recursively remove the object; 666/// from all other objects (and collections).; 667 ; 668void TObjArray::RecursiveRemove(TObject *obj); 669{; 670 if (!obj) return;; 671 ; 672 // We need to have the write lock even-though we are 'just'; 673 // reading as any insert or remove during the iteration will; 674 // invalidate fatally the cursor (e.g. might skip some items); 675 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 676 ; 677 for (int i = 0; i < fSize; i++) {; 678 if (fCont[i",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:38044,Availability,error,error,38044,"dx.Definition TObjArray.cxx:235; TObjArray::AddAftervoid AddAfter(const TObject *after, TObject *obj) overrideAdd object in the slot after object after.Definition TObjArray.cxx:215; TObjArray::Streamervoid Streamer(TBuffer &) overrideStream all objects in the array to or from the I/O buffer.Definition TObjArray.cxx:449; TObjArray::MakeIteratorTIterator * MakeIterator(Bool_t dir=kIterForward) const overrideReturns an array iterator.Definition TObjArray.cxx:649; TObjArray::Compressvirtual void Compress()Remove empty slots from array.Definition TObjArray.cxx:334; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::BoundsOkBool_t BoundsOk(const char *where, Int_t at) constDefinition TObjArray.h:157; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::OutOfBoundsErrorBool_t OutOfBoundsError(const char *where, Int_t i) constGenerate an out-of-bounds error. Always returns false.Definition TObjArray.cxx:658; TObjArray::BinarySearchvirtual Int_t BinarySearch(TObject *obj, Int_t upto=kMaxInt)Find object using a binary search.Definition TObjArray.cxx:841; TObjArray::AddLastvoid AddLast(TObject *obj) overrideAdd object in the next empty slot in the array.Definition TObjArray.cxx:178; TObjArray::FirstTObject * First() const overrideReturn the object in the first slot.Definition TObjArray.cxx:496; TObjArray::fLowerBoundInt_t fLowerBoundArray contents.Definition TObjArray.h:38; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObjArray::GetAbsLastInt_t GetAbsLast() constReturn absolute index to last object in array.Definition TObjArray.cxx:539; TObjArray::SetLastvoid SetLast(Int_t last)Set index of last object in array, effectively truncating the array.Definition TObjArray.cxx:775; TObjArray::RemoveAtTObject * RemoveAt(Int_",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:41677,Availability,error,error,41677,"ray.cxx:189; TObjArray::fLastInt_t fLastDefinition TObjArray.h:39; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::Changedvirtual void Changed()Definition TSeqCollection.h:34; TSeqCollection::QSortstatic void QSort(TObject **a, Int_t first, Int_t last)Sort array of TObject pointers using a quicksort algorithm.Definition TSeqCollection.cxx:70; TSeqCollection::fSortedBool_t fSortedDefinition TSeqCollection.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TString::Stream",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:17688,Deployability,update,update,17688,"urn fCont[GetAbsLast()];; 514}; 515 ; 516////////////////////////////////////////////////////////////////////////////////; 517/// Return the number of objects in array (i.e. number of non-empty slots).; 518/// Attention: use this method ONLY if you want to know the number of; 519/// non-empty slots. This function loops over the complete array and; 520/// is therefore very slow when applied in a loop. Most of the time you; 521/// better use GetEntriesFast() (only in case when there are no empty slots).; 522 ; 523Int_t TObjArray::GetEntries() const; 524{; 525 Int_t cnt = 0;; 526 ; 527 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 528 ; 529 for (Int_t i = 0; i < fSize; i++); 530 if (fCont[i]) cnt++;; 531 ; 532 return cnt;; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// Return absolute index to last object in array. Returns -1 in case; 537/// array is empty.; 538 ; 539Int_t TObjArray::GetAbsLast() const; 540{; 541 // For efficiency we need sometimes to update fLast so we have; 542 // to cast const away. Ugly, but making GetAbsLast() not const breaks; 543 // many other const functions.; 544 ; 545 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 546 ; 547 if (fLast == -2) {; 548 for (Int_t i = fSize-1; i >= 0; i--); 549 if (fCont[i]) {; 550 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 551 ((TObjArray*)this)->fLast = i;; 552 return fLast;; 553 }; 554 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 555 ((TObjArray*)this)->fLast = -1;; 556 }; 557 return fLast;; 558}; 559 ; 560////////////////////////////////////////////////////////////////////////////////; 561/// Return the number of objects in array (i.e. number of non-empty slots).; 562/// This is a thread-unsafe version of GetEntriesFast. Use it only if sure; 563/// it will not be invoked concurrently.; 564 ; 565Int_t TObjArray::GetEntriesUnsafe() const; 566{; 567 if (R__unlikely(fLast == -2)); 568 return GetEntriesFast();; 569 else; 570 return fLast + 1;;",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:14451,Energy Efficiency,efficient,efficient,14451,"bject*));; 407 fSize = newSize;; 408}; 409 ; 410////////////////////////////////////////////////////////////////////////////////; 411/// Find an object in this collection using its name. Requires a sequential; 412/// scan till the object has been found. Returns 0 if object with specified; 413/// name is not found.; 414 ; 415TObject *TObjArray::FindObject(const char *name) const; 416{; 417 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 418 ; 419 Int_t nobjects = GetAbsLast()+1;; 420 for (Int_t i = 0; i < nobjects; ++i) {; 421 TObject *obj = fCont[i];; 422 if (obj && 0 == strcmp(name, obj->GetName())) return obj;; 423 }; 424 return nullptr;; 425}; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Find an object in this collection using the object's IsEqual(); 429/// member function. Requires a sequential scan till the object has; 430/// been found. Returns 0 if object is not found.; 431/// Typically this function is overridden by a more efficient version; 432/// in concrete collection classes (e.g. THashTable).; 433 ; 434TObject *TObjArray::FindObject(const TObject *iobj) const; 435{; 436 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 437 ; 438 Int_t nobjects = GetAbsLast()+1;; 439 for (Int_t i = 0; i < nobjects; ++i) {; 440 TObject *obj = fCont[i];; 441 if (obj && obj->IsEqual(iobj)) return obj;; 442 }; 443 return nullptr;; 444}; 445 ; 446////////////////////////////////////////////////////////////////////////////////; 447/// Stream all objects in the array to or from the I/O buffer.; 448 ; 449void TObjArray::Streamer(TBuffer &b); 450{; 451 UInt_t R__s, R__c;; 452 Int_t nobjects;; 453 if (b.IsReading()) {; 454 Version_t v = b.ReadVersion(&R__s, &R__c);; 455 if (v > 2); 456 TObject::Streamer(b);; 457 if (v > 1); 458 fName.Streamer(b);; 459 ; 460 if (GetEntriesFast() > 0) Clear();; 461 ; 462 b >> nobjects;; 463 b >> fLowerBound;; 464 if (nobjects >= fSize) Expand(nobjects);; 465 fLast = -1;; 466 TObject *obj;; 467 for ",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:42445,Energy Efficiency,allocate,allocate,42445,":152; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::Changedvirtual void Changed()Definition TSeqCollection.h:34; TSeqCollection::QSortstatic void QSort(TObject **a, Int_t first, Int_t last)Sort array of TObject pointers using a quicksort algorithm.Definition TSeqCollection.cxx:70; TSeqCollection::fSortedBool_t fSortedDefinition TSeqCollection.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; bool; int; unsigned int; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; v@ vDefinition rootcling_impl.cxx:3699. corecontsrcTObjArray.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:42480,Energy Efficiency,allocate,allocated,42480,":152; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::Changedvirtual void Changed()Definition TSeqCollection.h:34; TSeqCollection::QSortstatic void QSort(TObject **a, Int_t first, Int_t last)Sort array of TObject pointers using a quicksort algorithm.Definition TSeqCollection.cxx:70; TSeqCollection::fSortedBool_t fSortedDefinition TSeqCollection.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; bool; int; unsigned int; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; v@ vDefinition rootcling_impl.cxx:3699. corecontsrcTObjArray.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:41514,Integrability,message,message,41514,"erDefinition TObjArray.h:33; TObjArray::AddBeforevoid AddBefore(const TObject *before, TObject *obj) overrideAdd object in the slot before object before.Definition TObjArray.cxx:189; TObjArray::fLastInt_t fLastDefinition TObjArray.h:39; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::Changedvirtual void Changed()Definition TSeqCollection.h:34; TSeqCollection::QSortstatic void QSort(TObject **a, Int_t first, Int_t last)Sort array of TObject pointers using a quicksort algorithm.Definition TSeqCollection.cxx:70; TSeqCollection::fSortedBool_t fSortedDefinition TSeqCollection.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Allo",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:41683,Integrability,message,message,41683,"ray.cxx:189; TObjArray::fLastInt_t fLastDefinition TObjArray.h:39; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::Changedvirtual void Changed()Definition TSeqCollection.h:34; TSeqCollection::QSortstatic void QSort(TObject **a, Int_t first, Int_t last)Sort array of TObject pointers using a quicksort algorithm.Definition TSeqCollection.cxx:70; TSeqCollection::fSortedBool_t fSortedDefinition TSeqCollection.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TString::Stream",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:18495,Performance,concurren,concurrently,18495,"//////////////////; 536/// Return absolute index to last object in array. Returns -1 in case; 537/// array is empty.; 538 ; 539Int_t TObjArray::GetAbsLast() const; 540{; 541 // For efficiency we need sometimes to update fLast so we have; 542 // to cast const away. Ugly, but making GetAbsLast() not const breaks; 543 // many other const functions.; 544 ; 545 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 546 ; 547 if (fLast == -2) {; 548 for (Int_t i = fSize-1; i >= 0; i--); 549 if (fCont[i]) {; 550 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 551 ((TObjArray*)this)->fLast = i;; 552 return fLast;; 553 }; 554 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 555 ((TObjArray*)this)->fLast = -1;; 556 }; 557 return fLast;; 558}; 559 ; 560////////////////////////////////////////////////////////////////////////////////; 561/// Return the number of objects in array (i.e. number of non-empty slots).; 562/// This is a thread-unsafe version of GetEntriesFast. Use it only if sure; 563/// it will not be invoked concurrently.; 564 ; 565Int_t TObjArray::GetEntriesUnsafe() const; 566{; 567 if (R__unlikely(fLast == -2)); 568 return GetEntriesFast();; 569 else; 570 return fLast + 1;; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return index of last object in array. Returns lowerBound-1 in case; 575/// array is empty.; 576 ; 577Int_t TObjArray::GetLast() const; 578{; 579 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 580 ; 581 return fLowerBound+GetAbsLast();; 582}; 583 ; 584////////////////////////////////////////////////////////////////////////////////; 585/// Return address of pointer obj. If obj is 0 returns address of container.; 586 ; 587TObject **TObjArray::GetObjectRef(const TObject *obj) const; 588{; 589 if (!obj); 590 return fCont;; 591 ; 592 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 593 ; 594 Int_t index = IndexOf(obj);; 595 return &fCont[index];; 596}; 597 ; 598////////////////////////////////////////",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8cxx_source.html:18410,Safety,unsafe,unsafe,18410,"////////////////////////////////////////////////////////////////////////////////; 536/// Return absolute index to last object in array. Returns -1 in case; 537/// array is empty.; 538 ; 539Int_t TObjArray::GetAbsLast() const; 540{; 541 // For efficiency we need sometimes to update fLast so we have; 542 // to cast const away. Ugly, but making GetAbsLast() not const breaks; 543 // many other const functions.; 544 ; 545 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 546 ; 547 if (fLast == -2) {; 548 for (Int_t i = fSize-1; i >= 0; i--); 549 if (fCont[i]) {; 550 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 551 ((TObjArray*)this)->fLast = i;; 552 return fLast;; 553 }; 554 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 555 ((TObjArray*)this)->fLast = -1;; 556 }; 557 return fLast;; 558}; 559 ; 560////////////////////////////////////////////////////////////////////////////////; 561/// Return the number of objects in array (i.e. number of non-empty slots).; 562/// This is a thread-unsafe version of GetEntriesFast. Use it only if sure; 563/// it will not be invoked concurrently.; 564 ; 565Int_t TObjArray::GetEntriesUnsafe() const; 566{; 567 if (R__unlikely(fLast == -2)); 568 return GetEntriesFast();; 569 else; 570 return fLast + 1;; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return index of last object in array. Returns lowerBound-1 in case; 575/// array is empty.; 576 ; 577Int_t TObjArray::GetLast() const; 578{; 579 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 580 ; 581 return fLowerBound+GetAbsLast();; 582}; 583 ; 584////////////////////////////////////////////////////////////////////////////////; 585/// Return address of pointer obj. If obj is 0 returns address of container.; 586 ; 587TObject **TObjArray::GetObjectRef(const TObject *obj) const; 588{; 589 if (!obj); 590 return fCont;; 591 ; 592 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 593 ; 594 Int_t index = IndexOf(obj);; 595 return &fCont[in",MatchSource.WIKI,doc/master/TObjArray_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html
https://root.cern/doc/master/TObjArray_8h_source.html:11694,Availability,error,error,11694,"he array.Definition TObjArray.cxx:321; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::AddAftervoid AddAfter(const TObject *after, TObject *obj) overrideAdd object in the slot after object after.Definition TObjArray.cxx:215; TObjArray::MakeIteratorTIterator * MakeIterator(Bool_t dir=kIterForward) const overrideReturns an array iterator.Definition TObjArray.cxx:649; TObjArray::Compressvirtual void Compress()Remove empty slots from array.Definition TObjArray.cxx:334; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::BoundsOkBool_t BoundsOk(const char *where, Int_t at) constDefinition TObjArray.h:157; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::OutOfBoundsErrorBool_t OutOfBoundsError(const char *where, Int_t i) constGenerate an out-of-bounds error. Always returns false.Definition TObjArray.cxx:658; TObjArray::BinarySearchvirtual Int_t BinarySearch(TObject *obj, Int_t upto=kMaxInt)Find object using a binary search.Definition TObjArray.cxx:841; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::AddLastvoid AddLast(TObject *obj) overrideAdd object in the next empty slot in the array.Definition TObjArray.cxx:178; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::FirstTObject * First() const overrideReturn the object in the first slot.Definition TObjArray.cxx:496; TObjArray::IsEmptyBool_t IsEmpty() const overrideDefinition TObjArray.h:65; TObjArray::fLowerBoundInt_t fLowerBoundArray contents.Definition TObjArray.h:38; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObjArray::GetAbsLastInt_t GetAbsLast() constReturn absolute in",MatchSource.WIKI,doc/master/TObjArray_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjArray_8h_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:3638,Availability,error,error,3638,"d but not operator; 73// delete, we can still use it to detect the cases where the destructor was called.; 74 ; 75ATTRIBUTE_NO_SANITIZE_ADDRESS; 76bool DeleteChangesMemoryImpl(); 77{; 78 static constexpr UInt_t kGoldenUUID = 0x00000021;; 79 static constexpr UInt_t kGoldenbits = 0x03000000;; 80 ; 81 TObject *o = new TObject;; 82 o->SetUniqueID(kGoldenUUID);; 83 UInt_t *o_fuid = &(o->fUniqueID);; 84 UInt_t *o_fbits = &(o->fBits);; 85 ; 86 if (*o_fuid != kGoldenUUID) {; 87 Error(""CheckingDeleteSideEffects"",; 88 ""fUniqueID is not as expected, we got 0x%.8x instead of 0x%.8x"",; 89 *o_fuid, kGoldenUUID);; 90 }; 91 if (*o_fbits != kGoldenbits) {; 92 Error(""CheckingDeleteSideEffects"",; 93 ""fBits is not as expected, we got 0x%.8x instead of 0x%.8x"",; 94 *o_fbits, kGoldenbits);; 95 }; 96 if (gDebug >= 9) {; 97 unsigned char *oc = reinterpret_cast<unsigned char *>(o); // for address calculations; 98 unsigned char references[sizeof(TObject)];; 99 memcpy(references, oc, sizeof(TObject));; 100 ; 101 // The effective part of this code (the else statement is just that without; 102 // any of the debug statement); 103 delete o;; 104 ; 105 // Not using the error logger, as there routine is meant to be called; 106 // during library initialization/loading.; 107 fprintf(stderr,; 108 ""DEBUG: Checking before and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a seg",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:4409,Availability,error,error,4409,"fore and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a segmentation fault); 120#if defined(_MSC_VER) && defined(__SANITIZE_ADDRESS__); 121 // on Windows, even __declspec(no_sanitize_address) does not prevent catching; 122 // heap-use-after-free errorswhen using the /fsanitize=address compiler flag; 123 // so don't even try; 124 return true;; 125#endif; 126 if ( *o_fbits != 0x01000000 ) {; 127 // operator delete tainted the memory, we can not rely on TestBit(kNotDeleted); 128 return true;; 129 }; 130 return false;; 131}; 132 ; 133bool DeleteChangesMemory(); 134{; 135 static const bool value = DeleteChangesMemoryImpl();; 136 if (gDebug >= 9); 137 DeleteChangesMemoryImpl(); // To allow for printing the debug info; 138 return value;; 139}; 140 ; 141}} // ROOT::Detail; 142 ; 143////////////////////////////////////////////////////////////////////////////////; 144/// Copy this to obj.; 145 ; 146void TObject::Copy(TObject &obj) const; 147{; 148 obj.fUniqueID = fUniqueID; // when really unique don't copy; 149 if (obj.IsOnHeap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:4493,Availability,fault,fault,4493,"fore and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a segmentation fault); 120#if defined(_MSC_VER) && defined(__SANITIZE_ADDRESS__); 121 // on Windows, even __declspec(no_sanitize_address) does not prevent catching; 122 // heap-use-after-free errorswhen using the /fsanitize=address compiler flag; 123 // so don't even try; 124 return true;; 125#endif; 126 if ( *o_fbits != 0x01000000 ) {; 127 // operator delete tainted the memory, we can not rely on TestBit(kNotDeleted); 128 return true;; 129 }; 130 return false;; 131}; 132 ; 133bool DeleteChangesMemory(); 134{; 135 static const bool value = DeleteChangesMemoryImpl();; 136 if (gDebug >= 9); 137 DeleteChangesMemoryImpl(); // To allow for printing the debug info; 138 return value;; 139}; 140 ; 141}} // ROOT::Detail; 142 ; 143////////////////////////////////////////////////////////////////////////////////; 144/// Copy this to obj.; 145 ; 146void TObject::Copy(TObject &obj) const; 147{; 148 obj.fUniqueID = fUniqueID; // when really unique don't copy; 149 if (obj.IsOnHeap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:4670,Availability,error,errorswhen,4670,"fore and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a segmentation fault); 120#if defined(_MSC_VER) && defined(__SANITIZE_ADDRESS__); 121 // on Windows, even __declspec(no_sanitize_address) does not prevent catching; 122 // heap-use-after-free errorswhen using the /fsanitize=address compiler flag; 123 // so don't even try; 124 return true;; 125#endif; 126 if ( *o_fbits != 0x01000000 ) {; 127 // operator delete tainted the memory, we can not rely on TestBit(kNotDeleted); 128 return true;; 129 }; 130 return false;; 131}; 132 ; 133bool DeleteChangesMemory(); 134{; 135 static const bool value = DeleteChangesMemoryImpl();; 136 if (gDebug >= 9); 137 DeleteChangesMemoryImpl(); // To allow for printing the debug info; 138 return value;; 139}; 140 ; 141}} // ROOT::Detail; 142 ; 143////////////////////////////////////////////////////////////////////////////////; 144/// Copy this to obj.; 145 ; 146void TObject::Copy(TObject &obj) const; 147{; 148 obj.fUniqueID = fUniqueID; // when really unique don't copy; 149 if (obj.IsOnHeap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:12738,Availability,error,error,12738,"; 341/// fY1 0.15 Y of 1st point; 342/// fX2 0.67 X of 2nd point; 343/// fY2 0.83 Y of 2nd point; 344/// fUniqueID 0 object unique identifier; 345/// fBits 50331648 bit field status word; 346/// fLineColor 1 line color; 347/// fLineStyle 1 line style; 348/// fLineWidth 1 line width; 349/// fFillColor 19 fill area color; 350/// fFillStyle 1001 fill area style; 351/// ~~~; 352 ; 353void TObject::Dump() const; 354{; 355 // Get the actual address of the object.; 356 const void *actual = IsA()->DynamicCast(TObject::Class(),this,kFALSE);; 357 IsA()->Dump(actual);; 358}; 359 ; 360////////////////////////////////////////////////////////////////////////////////; 361/// Execute method on this object with the given parameter string, e.g.; 362/// ""3.14,1,\""text\"""".; 363 ; 364void TObject::Execute(const char *method, const char *params, Int_t *error); 365{; 366 if (!IsA()) return;; 367 ; 368 Bool_t must_cleanup = TestBit(kMustCleanup);; 369 ; 370 gInterpreter->Execute(this, IsA(), method, params, error);; 371 ; 372 if (gPad && must_cleanup) gPad->Modified();; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Execute method on this object with parameters stored in the TObjArray.; 377/// The TObjArray should contain an argv vector like:; 378/// ~~~ {.cpp}; 379/// argv[0] ... argv[n] = the list of TObjString parameters; 380/// ~~~; 381 ; 382void TObject::Execute(TMethod *method, TObjArray *params, Int_t *error); 383{; 384 if (!IsA()) return;; 385 ; 386 Bool_t must_cleanup = TestBit(kMustCleanup);; 387 ; 388 gInterpreter->Execute(this, IsA(), method, params, error);; 389 ; 390 if (gPad && must_cleanup) gPad->Modified();; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Execute action corresponding to an event at (px,py). This method; 396/// must be overridden if an object can react to graphics events.; 397 ; 398void TObject::ExecuteEvent(Int_t, Int_t, Int_t); 399{; 400 ",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:12894,Availability,error,error,12894,"; 341/// fY1 0.15 Y of 1st point; 342/// fX2 0.67 X of 2nd point; 343/// fY2 0.83 Y of 2nd point; 344/// fUniqueID 0 object unique identifier; 345/// fBits 50331648 bit field status word; 346/// fLineColor 1 line color; 347/// fLineStyle 1 line style; 348/// fLineWidth 1 line width; 349/// fFillColor 19 fill area color; 350/// fFillStyle 1001 fill area style; 351/// ~~~; 352 ; 353void TObject::Dump() const; 354{; 355 // Get the actual address of the object.; 356 const void *actual = IsA()->DynamicCast(TObject::Class(),this,kFALSE);; 357 IsA()->Dump(actual);; 358}; 359 ; 360////////////////////////////////////////////////////////////////////////////////; 361/// Execute method on this object with the given parameter string, e.g.; 362/// ""3.14,1,\""text\"""".; 363 ; 364void TObject::Execute(const char *method, const char *params, Int_t *error); 365{; 366 if (!IsA()) return;; 367 ; 368 Bool_t must_cleanup = TestBit(kMustCleanup);; 369 ; 370 gInterpreter->Execute(this, IsA(), method, params, error);; 371 ; 372 if (gPad && must_cleanup) gPad->Modified();; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Execute method on this object with parameters stored in the TObjArray.; 377/// The TObjArray should contain an argv vector like:; 378/// ~~~ {.cpp}; 379/// argv[0] ... argv[n] = the list of TObjString parameters; 380/// ~~~; 381 ; 382void TObject::Execute(TMethod *method, TObjArray *params, Int_t *error); 383{; 384 if (!IsA()) return;; 385 ; 386 Bool_t must_cleanup = TestBit(kMustCleanup);; 387 ; 388 gInterpreter->Execute(this, IsA(), method, params, error);; 389 ; 390 if (gPad && must_cleanup) gPad->Modified();; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Execute action corresponding to an event at (px,py). This method; 396/// must be overridden if an object can react to graphics events.; 397 ; 398void TObject::ExecuteEvent(Int_t, Int_t, Int_t); 399{; 400 ",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:13361,Availability,error,error,13361,"/////////////////////////////////////////////////////////////////////; 361/// Execute method on this object with the given parameter string, e.g.; 362/// ""3.14,1,\""text\"""".; 363 ; 364void TObject::Execute(const char *method, const char *params, Int_t *error); 365{; 366 if (!IsA()) return;; 367 ; 368 Bool_t must_cleanup = TestBit(kMustCleanup);; 369 ; 370 gInterpreter->Execute(this, IsA(), method, params, error);; 371 ; 372 if (gPad && must_cleanup) gPad->Modified();; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Execute method on this object with parameters stored in the TObjArray.; 377/// The TObjArray should contain an argv vector like:; 378/// ~~~ {.cpp}; 379/// argv[0] ... argv[n] = the list of TObjString parameters; 380/// ~~~; 381 ; 382void TObject::Execute(TMethod *method, TObjArray *params, Int_t *error); 383{; 384 if (!IsA()) return;; 385 ; 386 Bool_t must_cleanup = TestBit(kMustCleanup);; 387 ; 388 gInterpreter->Execute(this, IsA(), method, params, error);; 389 ; 390 if (gPad && must_cleanup) gPad->Modified();; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Execute action corresponding to an event at (px,py). This method; 396/// must be overridden if an object can react to graphics events.; 397 ; 398void TObject::ExecuteEvent(Int_t, Int_t, Int_t); 399{; 400 // AbstractMethod(""ExecuteEvent"");; 401}; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Must be redefined in derived classes.; 405/// This function is typically used with TCollections, but can also be used; 406/// to find an object by name inside this object.; 407 ; 408TObject *TObject::FindObject(const char *) const; 409{; 410 return nullptr;; 411}; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Must be redefined in derived classes.; 415/// This function is typically used with TColl",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:13517,Availability,error,error,13517,"/////////////////////////////////////////////////////////////////////; 361/// Execute method on this object with the given parameter string, e.g.; 362/// ""3.14,1,\""text\"""".; 363 ; 364void TObject::Execute(const char *method, const char *params, Int_t *error); 365{; 366 if (!IsA()) return;; 367 ; 368 Bool_t must_cleanup = TestBit(kMustCleanup);; 369 ; 370 gInterpreter->Execute(this, IsA(), method, params, error);; 371 ; 372 if (gPad && must_cleanup) gPad->Modified();; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Execute method on this object with parameters stored in the TObjArray.; 377/// The TObjArray should contain an argv vector like:; 378/// ~~~ {.cpp}; 379/// argv[0] ... argv[n] = the list of TObjString parameters; 380/// ~~~; 381 ; 382void TObject::Execute(TMethod *method, TObjArray *params, Int_t *error); 383{; 384 if (!IsA()) return;; 385 ; 386 Bool_t must_cleanup = TestBit(kMustCleanup);; 387 ; 388 gInterpreter->Execute(this, IsA(), method, params, error);; 389 ; 390 if (gPad && must_cleanup) gPad->Modified();; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Execute action corresponding to an event at (px,py). This method; 396/// must be overridden if an object can react to graphics events.; 397 ; 398void TObject::ExecuteEvent(Int_t, Int_t, Int_t); 399{; 400 // AbstractMethod(""ExecuteEvent"");; 401}; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Must be redefined in derived classes.; 405/// This function is typically used with TCollections, but can also be used; 406/// to find an object by name inside this object.; 407 ; 408TObject *TObject::FindObject(const char *) const; 409{; 410 return nullptr;; 411}; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Must be redefined in derived classes.; 415/// This function is typically used with TColl",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:24947,Availability,avail,available,24947,"//////////////////////////////////////////////////; 671/// Save this object in the file specified by filename.; 672///; 673/// - if ""filename"" contains "".root"" the object is saved in filename as root; 674/// binary file.; 675///; 676/// - if ""filename"" contains "".xml"" the object is saved in filename as a xml; 677/// ascii file.; 678///; 679/// - if ""filename"" contains "".cc"" the object is saved in filename as C code; 680/// independant from ROOT. The code is generated via SavePrimitive().; 681/// Specific code should be implemented in each object to handle this; 682/// option. Like in TF1::SavePrimitive().; 683///; 684/// - otherwise the object is written to filename as a CINT/C++ script. The; 685/// C++ code to rebuild this object is generated via SavePrimitive(). The; 686/// ""option"" parameter is passed to SavePrimitive. By default it is an empty; 687/// string. It can be used to specify the Draw option in the code generated; 688/// by SavePrimitive.; 689///; 690/// The function is available via the object context menu.; 691 ; 692void TObject::SaveAs(const char *filename, Option_t *option) const; 693{; 694 //==============Save object as a root file===================================; 695 if (filename && strstr(filename,"".root"")) {; 696 if (gDirectory) gDirectory->SaveObjectAs(this,filename,"""");; 697 return;; 698 }; 699 ; 700 //==============Save object as a XML file====================================; 701 if (filename && strstr(filename,"".xml"")) {; 702 if (gDirectory) gDirectory->SaveObjectAs(this,filename,"""");; 703 return;; 704 }; 705 ; 706 //==============Save object as a JSON file================================; 707 if (filename && strstr(filename,"".json"")) {; 708 if (gDirectory) gDirectory->SaveObjectAs(this,filename,option);; 709 return;; 710 }; 711 ; 712 //==============Save object as a C, ROOT independant, file===================; 713 if (filename && strstr(filename,"".cc"")) {; 714 TString fname;; 715 if (filename && strlen(filename) > 0) {; 716 fname = file",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:36557,Availability,error,error,36557,"; 960 ::ErrorHandler(level, Form(""%s::%s"", classname, location), fmt, va);; 961}; 962 ; 963////////////////////////////////////////////////////////////////////////////////; 964/// Issue info message. Use ""location"" to specify the method where the; 965/// warning occurred. Accepts standard printf formatting arguments.; 966 ; 967void TObject::Info(const char *location, const char *va_(fmt), ...) const; 968{; 969 va_list ap;; 970 va_start(ap, va_(fmt));; 971 DoError(kInfo, location, va_(fmt), ap);; 972 va_end(ap);; 973}; 974 ; 975////////////////////////////////////////////////////////////////////////////////; 976/// Issue warning message. Use ""location"" to specify the method where the; 977/// warning occurred. Accepts standard printf formatting arguments.; 978 ; 979void TObject::Warning(const char *location, const char *va_(fmt), ...) const; 980{; 981 va_list ap;; 982 va_start(ap, va_(fmt));; 983 DoError(kWarning, location, va_(fmt), ap);; 984 va_end(ap);; 985 if (TROOT::Initialized()); 986 gROOT->Message(1001, this);; 987}; 988 ; 989////////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 10",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:36627,Availability,error,error,36627,"essage. Use ""location"" to specify the method where the; 965/// warning occurred. Accepts standard printf formatting arguments.; 966 ; 967void TObject::Info(const char *location, const char *va_(fmt), ...) const; 968{; 969 va_list ap;; 970 va_start(ap, va_(fmt));; 971 DoError(kInfo, location, va_(fmt), ap);; 972 va_end(ap);; 973}; 974 ; 975////////////////////////////////////////////////////////////////////////////////; 976/// Issue warning message. Use ""location"" to specify the method where the; 977/// warning occurred. Accepts standard printf formatting arguments.; 978 ; 979void TObject::Warning(const char *location, const char *va_(fmt), ...) const; 980{; 981 va_list ap;; 982 va_start(ap, va_(fmt));; 983 DoError(kWarning, location, va_(fmt), ap);; 984 va_end(ap);; 985 if (TROOT::Initialized()); 986 gROOT->Message(1001, this);; 987}; 988 ; 989////////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 1012 va_end(ap);; 1013 if (TROOT::Initialized()); 1014 gROOT->Message(1003, this);; 1015}; 1016 ; 1017////////////////////////////////////////////////////////////////////////////////; 1018/// Iss",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:37076,Availability,error,error,37076,");; 973}; 974 ; 975////////////////////////////////////////////////////////////////////////////////; 976/// Issue warning message. Use ""location"" to specify the method where the; 977/// warning occurred. Accepts standard printf formatting arguments.; 978 ; 979void TObject::Warning(const char *location, const char *va_(fmt), ...) const; 980{; 981 va_list ap;; 982 va_start(ap, va_(fmt));; 983 DoError(kWarning, location, va_(fmt), ap);; 984 va_end(ap);; 985 if (TROOT::Initialized()); 986 gROOT->Message(1001, this);; 987}; 988 ; 989////////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 1012 va_end(ap);; 1013 if (TROOT::Initialized()); 1014 gROOT->Message(1003, this);; 1015}; 1016 ; 1017////////////////////////////////////////////////////////////////////////////////; 1018/// Issue fatal error message. Use ""location"" to specify the method where the; 1019/// fatal error occurred. Accepts standard printf formatting arguments.; 1020 ; 1021void TObject::Fatal(const char *location, const char *va_(fmt), ...) const; 1022{; 1023 va_list ap;; 1024 va_start(ap, va_(fmt));; 1025 DoError(kFatal, location,",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:37154,Availability,error,error,37154,"d. Accepts standard printf formatting arguments.; 978 ; 979void TObject::Warning(const char *location, const char *va_(fmt), ...) const; 980{; 981 va_list ap;; 982 va_start(ap, va_(fmt));; 983 DoError(kWarning, location, va_(fmt), ap);; 984 va_end(ap);; 985 if (TROOT::Initialized()); 986 gROOT->Message(1001, this);; 987}; 988 ; 989////////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 1012 va_end(ap);; 1013 if (TROOT::Initialized()); 1014 gROOT->Message(1003, this);; 1015}; 1016 ; 1017////////////////////////////////////////////////////////////////////////////////; 1018/// Issue fatal error message. Use ""location"" to specify the method where the; 1019/// fatal error occurred. Accepts standard printf formatting arguments.; 1020 ; 1021void TObject::Fatal(const char *location, const char *va_(fmt), ...) const; 1022{; 1023 va_list ap;; 1024 va_start(ap, va_(fmt));; 1025 DoError(kFatal, location, va_(fmt), ap);; 1026 va_end(ap);; 1027 if (TROOT::Initialized()); 1028 gROOT->Message(1004, this);; 1029}; 1030 ; 1031////////////////////////////////////////////////////////////////////////////////; 1",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:37616,Availability,error,error,37616,"//////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 1012 va_end(ap);; 1013 if (TROOT::Initialized()); 1014 gROOT->Message(1003, this);; 1015}; 1016 ; 1017////////////////////////////////////////////////////////////////////////////////; 1018/// Issue fatal error message. Use ""location"" to specify the method where the; 1019/// fatal error occurred. Accepts standard printf formatting arguments.; 1020 ; 1021void TObject::Fatal(const char *location, const char *va_(fmt), ...) const; 1022{; 1023 va_list ap;; 1024 va_start(ap, va_(fmt));; 1025 DoError(kFatal, location, va_(fmt), ap);; 1026 va_end(ap);; 1027 if (TROOT::Initialized()); 1028 gROOT->Message(1004, this);; 1029}; 1030 ; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Use this method to implement an ""abstract"" method that you don't; 1033/// want to leave purely abstract.; 1034 ; 1035void TObject::AbstractMethod(const char *method) const; 1036{; 1037 Warning(method, ""this method must be overridden!"");; 1038}; 1039 ; 1040///////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:37693,Availability,error,error,37693,"rmatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 1012 va_end(ap);; 1013 if (TROOT::Initialized()); 1014 gROOT->Message(1003, this);; 1015}; 1016 ; 1017////////////////////////////////////////////////////////////////////////////////; 1018/// Issue fatal error message. Use ""location"" to specify the method where the; 1019/// fatal error occurred. Accepts standard printf formatting arguments.; 1020 ; 1021void TObject::Fatal(const char *location, const char *va_(fmt), ...) const; 1022{; 1023 va_list ap;; 1024 va_start(ap, va_(fmt));; 1025 DoError(kFatal, location, va_(fmt), ap);; 1026 va_end(ap);; 1027 if (TROOT::Initialized()); 1028 gROOT->Message(1004, this);; 1029}; 1030 ; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Use this method to implement an ""abstract"" method that you don't; 1033/// want to leave purely abstract.; 1034 ; 1035void TObject::AbstractMethod(const char *method) const; 1036{; 1037 Warning(method, ""this method must be overridden!"");; 1038}; 1039 ; 1040////////////////////////////////////////////////////////////////////////////////; 1041/// Use this method to signal that a method (defined in a base class); 1042/// may not be called in a derived class (in principle against good; 1043/// design since a child class should not ",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:43641,Availability,error,error,43641,"inition RConfig.hxx:586; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kInfoconstexpr Int_t kInfoDefinition TError.h:45; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name ",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:43687,Availability,error,error,43687,"tion RSha256.hxx:104; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kInfoconstexpr Int_t kInfoDefinition TError.h:45; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const cha",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:43926,Availability,error,error,43926,"e.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kInfoconstexpr Int_t kInfoDefinition TError.h:45; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMa",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:52028,Availability,error,error,52028,"ler (protected).Definition TObject.cxx:954; TObject::HandleTimervirtual Bool_t HandleTimer(TTimer *timer)Execute action in response of a timer timing out.Definition TObject.cxx:498; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::kIsOnHeap@ kIsOnHeapobject is on heapDefinition TObject.h:81; TObject::kNotDeleted@ kNotDeletedobject has not been deletedDefinition TObject.h:82; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; TObject::fgDtorOnlystatic Longptr_t fgDtorOnlyobject for which to call dtor only (i.e. no delete)Definition TObject.h:47; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDra",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:53556,Availability,error,error,53556,") constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TObject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::GetObjectInfovirtual char * GetObjectInfo(Int_t px, Int_t py) constReturns string containing info about the object at position (px,py).Definition TObject.cxx:473; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::SaveAsvirtual void SaveAs(const char *filename=""""",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:55432,Availability,error,error,55432,"objects to ...Definition TObject.h:106; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::~TObjectvirtual ~TObject()TObject de",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:55695,Availability,error,error,55695,"Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::~TObjectvirtual ~TObject()TObject destructor.Definition TObject.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to pain",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:9066,Energy Efficiency,allocate,allocated,9066,"e object will be appended to the current; 227/// ROOT directory.; 228 ; 229TObject *TObject::Clone(const char *) const; 230{; 231 if (gDirectory) {; 232 return gDirectory->CloneObject(this);; 233 } else {; 234 // Some of the streamer (eg. roofit's) expect(ed?) a valid gDirectory during streaming.; 235 return gROOT->CloneObject(this);; 236 }; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Compare abstract method. Must be overridden if a class wants to be able; 241/// to compare itself with other objects. Must return -1 if this is smaller; 242/// than obj, 0 if objects are equal and 1 if this is larger than obj.; 243 ; 244Int_t TObject::Compare(const TObject *) const; 245{; 246 AbstractMethod(""Compare"");; 247 return 0;; 248}; 249 ; 250////////////////////////////////////////////////////////////////////////////////; 251/// Delete this object. Typically called as a command via the interpreter.; 252/// Normally use ""delete"" operator when object has been allocated on the heap.; 253 ; 254void TObject::Delete(Option_t *); 255{; 256 if (IsOnHeap()) {; 257 // Delete object from CINT symbol table so it can not be used anymore.; 258 // CINT object are always on the heap.; 259 gInterpreter->DeleteGlobal(this);; 260 ; 261 delete this;; 262 }; 263}; 264 ; 265 ; 266////////////////////////////////////////////////////////////////////////////////; 267/// Computes distance from point (px,py) to the object.; 268/// This member function must be implemented for each graphics primitive.; 269/// This default function returns a big number (999999).; 270 ; 271Int_t TObject::DistancetoPrimitive(Int_t, Int_t); 272{; 273 // AbstractMethod(""DistancetoPrimitive"");; 274 return 999999;; 275}; 276 ; 277////////////////////////////////////////////////////////////////////////////////; 278/// Default Draw method for all objects; 279 ; 280void TObject::Draw(Option_t *option); 281{; 282 AppendPad(option);; 283}; 284 ; 285////////////////////////////",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:30834,Energy Efficiency,reduce,reduces,30834,"f the file.; 829///; 830/// - The buffer is written to the file.; 831///; 832/// Bufsize can be given to force a given buffer size to write this object.; 833/// By default, the buffersize will be taken from the average buffer size; 834/// of all objects written to the current file so far.; 835///; 836/// If a name is specified, it will be the name of the key.; 837/// If name is not given, the name of the key will be the name as returned; 838/// by GetName().; 839///; 840/// The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete; 841/// Using the kOverwrite option a previous key with the same name is; 842/// overwritten. The previous key is deleted before writing the new object.; 843/// Using the kWriteDelete option a previous key with the same name is; 844/// deleted only after the new object has been written. This option; 845/// is safer than kOverwrite but it is slower.; 846/// NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile--; 847/// the space is simply freed up to be overwritten; in the case of a TTree,; 848/// it is more complicated. If one opens a TTree, appends some entries,; 849/// then writes it out, the behaviour is effectively the same. If, however,; 850/// one creates a new TTree and writes it out in this way,; 851/// only the metadata is replaced, effectively making the old data invisible; 852/// without deleting it. TTree::Delete() can be used to mark all disk space; 853/// occupied by a TTree as free before overwriting its metadata this way.; 854/// The kSingleKey option is only used by TCollection::Write() to write; 855/// a container with a single key instead of each object in the container; 856/// with its own key.; 857///; 858/// An object is read from the file into memory via TKey::Read() or; 859/// via TObject::Read().; 860///; 861/// The function returns the total number of bytes written to the file.; 862/// It returns 0 if the object cannot be written.; 863 ; 864Int_t TObject::Write(const char *name, I",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:33285,Energy Efficiency,allocate,allocated,33285,"TObject(this,name,opt.Data(),bufsize);; 876 ; 877 const char *objname = name ? name : GetName();; 878 Error(""Write"",""The current directory (gDirectory) is null. The object (%s) has not been written."",objname);; 879 return 0;; 880}; 881 ; 882////////////////////////////////////////////////////////////////////////////////; 883/// Write this object to the current directory. For more see the; 884/// const version of this method.; 885 ; 886Int_t TObject::Write(const char *name, Int_t option, Int_t bufsize); 887{; 888 return ((const TObject*)this)->Write(name, option, bufsize);; 889}; 890 ; 891////////////////////////////////////////////////////////////////////////////////; 892/// Stream an object of class TObject.; 893 ; 894void TObject::Streamer(TBuffer &R__b); 895{; 896 if (IsA()->CanIgnoreTObjectStreamer()) return;; 897 UShort_t pidf;; 898 if (R__b.IsReading()) {; 899 R__b.SkipVersion(); // Version_t R__v = R__b.ReadVersion(); if (R__v) { }; 900 R__b >> fUniqueID;; 901 const UInt_t isonheap = fBits & kIsOnHeap; // Record how this instance was actually allocated.; 902 R__b >> fBits;; 903 fBits |= isonheap | kNotDeleted; // by definition de-serialized object are not yet deleted.; 904 if (TestBit(kIsReferenced)) {; 905 //if the object is referenced, we must read its old address; 906 //and store it in the ProcessID map in gROOT; 907 R__b >> pidf;; 908 pidf += R__b.GetPidOffset();; 909 TProcessID *pid = R__b.ReadProcessID(pidf);; 910 if (pid) {; 911 UInt_t gpid = pid->GetUniqueID();; 912 if (gpid>=0xff) {; 913 fUniqueID = fUniqueID | 0xff000000;; 914 } else {; 915 fUniqueID = ( fUniqueID & 0xffffff) + (gpid<<24);; 916 }; 917 pid->PutObjectWithID(this);; 918 }; 919 }; 920 } else {; 921 R__b.WriteVersion(TObject::IsA());; 922 // Can not read TFile.h here and avoid going through the interpreter by; 923 // simply hard-coding this value.; 924 // This **must** be equal to TFile::k630forwardCompatibility; 925 constexpr int TFile__k630forwardCompatibility = BIT(2);; 926 const auto",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:747,Integrability,protocol,protocol,747,". ROOT: core/base/src/TObject.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TObject.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 26/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TObject; 13\ingroup Base; 14 ; 15Mother of all ROOT objects.; 16 ; 17The TObject class provides default behaviour and protocol for all; 18objects in the ROOT system. It provides protocol for object I/O,; 19error handling, sorting, inspection, printing, drawing, etc.; 20Every object which inherits from TObject can be stored in the; 21ROOT collection classes.; 22 ; 23TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; 24reserved as global bits while bits 14 - 23 can be used in different; 25class hierarchies (watch out for overlaps).; 26*/; 27 ; 28#include <cstring>; 29#if !defined(WIN32) && !defined(__MWERKS__) && !defined(R__SOLARIS); 30#include <strings.h>; 31#endif; 32#include <cstdlib>; 33#include <cstdio>; 34#include <sstream>; 35#include <fstream>; 36#include <iostream>; 37 ; 38#include ""Varargs.h""; 39#include ""snprintf.h""; 40#include ""TObject.h""; 41#include ""TBuffer.h""; 42#include ""TClass.h""; 43#include ""TGuiFactory.h""; 44#include ""TMethod.h""; 45#include ""TROOT.h""; 46#include ""TError.h""; 47#include ""TObjectTable.h""; 48#include ""TVirtualPad.h""; 49#include ""TInterpreter.h""; 50#include ""TMemberInspector.h""; 51#include ""TRefTable.h""; 52#include ""TProcessID.h""; 53 ; 54Longptr_t TObject::fgDtorOnly = 0;; 55Bool_t TObject::fgObjectStat = kTRUE;; 56 ; 57ClassImp(TObject);; 58 ; 59#if defined(__clang__) || defined (__GNUC__); 60# define ATTRI",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:807,Integrability,protocol,protocol,807,". ROOT: core/base/src/TObject.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TObject.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 26/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TObject; 13\ingroup Base; 14 ; 15Mother of all ROOT objects.; 16 ; 17The TObject class provides default behaviour and protocol for all; 18objects in the ROOT system. It provides protocol for object I/O,; 19error handling, sorting, inspection, printing, drawing, etc.; 20Every object which inherits from TObject can be stored in the; 21ROOT collection classes.; 22 ; 23TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; 24reserved as global bits while bits 14 - 23 can be used in different; 25class hierarchies (watch out for overlaps).; 26*/; 27 ; 28#include <cstring>; 29#if !defined(WIN32) && !defined(__MWERKS__) && !defined(R__SOLARIS); 30#include <strings.h>; 31#endif; 32#include <cstdlib>; 33#include <cstdio>; 34#include <sstream>; 35#include <fstream>; 36#include <iostream>; 37 ; 38#include ""Varargs.h""; 39#include ""snprintf.h""; 40#include ""TObject.h""; 41#include ""TBuffer.h""; 42#include ""TClass.h""; 43#include ""TGuiFactory.h""; 44#include ""TMethod.h""; 45#include ""TROOT.h""; 46#include ""TError.h""; 47#include ""TObjectTable.h""; 48#include ""TVirtualPad.h""; 49#include ""TInterpreter.h""; 50#include ""TMemberInspector.h""; 51#include ""TRefTable.h""; 52#include ""TProcessID.h""; 53 ; 54Longptr_t TObject::fgDtorOnly = 0;; 55Bool_t TObject::fgObjectStat = kTRUE;; 56 ; 57ClassImp(TObject);; 58 ; 59#if defined(__clang__) || defined (__GNUC__); 60# define ATTRI",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:3661,Integrability,rout,routine,3661,"d but not operator; 73// delete, we can still use it to detect the cases where the destructor was called.; 74 ; 75ATTRIBUTE_NO_SANITIZE_ADDRESS; 76bool DeleteChangesMemoryImpl(); 77{; 78 static constexpr UInt_t kGoldenUUID = 0x00000021;; 79 static constexpr UInt_t kGoldenbits = 0x03000000;; 80 ; 81 TObject *o = new TObject;; 82 o->SetUniqueID(kGoldenUUID);; 83 UInt_t *o_fuid = &(o->fUniqueID);; 84 UInt_t *o_fbits = &(o->fBits);; 85 ; 86 if (*o_fuid != kGoldenUUID) {; 87 Error(""CheckingDeleteSideEffects"",; 88 ""fUniqueID is not as expected, we got 0x%.8x instead of 0x%.8x"",; 89 *o_fuid, kGoldenUUID);; 90 }; 91 if (*o_fbits != kGoldenbits) {; 92 Error(""CheckingDeleteSideEffects"",; 93 ""fBits is not as expected, we got 0x%.8x instead of 0x%.8x"",; 94 *o_fbits, kGoldenbits);; 95 }; 96 if (gDebug >= 9) {; 97 unsigned char *oc = reinterpret_cast<unsigned char *>(o); // for address calculations; 98 unsigned char references[sizeof(TObject)];; 99 memcpy(references, oc, sizeof(TObject));; 100 ; 101 // The effective part of this code (the else statement is just that without; 102 // any of the debug statement); 103 delete o;; 104 ; 105 // Not using the error logger, as there routine is meant to be called; 106 // during library initialization/loading.; 107 fprintf(stderr,; 108 ""DEBUG: Checking before and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a seg",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:4428,Integrability,message,message,4428,"fore and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a segmentation fault); 120#if defined(_MSC_VER) && defined(__SANITIZE_ADDRESS__); 121 // on Windows, even __declspec(no_sanitize_address) does not prevent catching; 122 // heap-use-after-free errorswhen using the /fsanitize=address compiler flag; 123 // so don't even try; 124 return true;; 125#endif; 126 if ( *o_fbits != 0x01000000 ) {; 127 // operator delete tainted the memory, we can not rely on TestBit(kNotDeleted); 128 return true;; 129 }; 130 return false;; 131}; 132 ; 133bool DeleteChangesMemory(); 134{; 135 static const bool value = DeleteChangesMemoryImpl();; 136 if (gDebug >= 9); 137 DeleteChangesMemoryImpl(); // To allow for printing the debug info; 138 return value;; 139}; 140 ; 141}} // ROOT::Detail; 142 ; 143////////////////////////////////////////////////////////////////////////////////; 144/// Copy this to obj.; 145 ; 146void TObject::Copy(TObject &obj) const; 147{; 148 obj.fUniqueID = fUniqueID; // when really unique don't copy; 149 if (obj.IsOnHeap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:6459,Integrability,depend,dependency,6459,"eap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////////////////; 161/// TObject destructor. Removes object from all canvases and object browsers; 162/// if observer bit is on and remove from the global object table.; 163 ; 164TObject::~TObject(); 165{; 166 // if (!TestBit(kNotDeleted)); 167 // Fatal(""~TObject"", ""object deleted twice"");; 168 ; 169 ROOT::CallRecursiveRemoveIfNeeded(*this);; 170 ; 171 fBits &= ~kNotDeleted;; 172 ; 173 if (fgObjectStat && gObjectTable) gObjectTable->RemoveQuietly(this);; 174}; 175 ; 176////////////////////////////////////////////////////////////////////////////////; 177/// Private helper function which will dispatch to; 178/// TObjectTable::AddObj.; 179/// Included here to avoid circular dependency between header files.; 180 ; 181void TObject::AddToTObjectTable(TObject *op); 182{; 183 TObjectTable::AddObj(op);; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Append graphics object to current pad. In case no current pad is set; 188/// yet, create a default canvas with the name ""c1"".; 189 ; 190void TObject::AppendPad(Option_t *option); 191{; 192 if (!gPad); 193 gROOT->MakeDefCanvas();; 194 ; 195 if (!gPad->IsEditable()); 196 return;; 197 ; 198 gPad->Add(this, option);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Browse object. May be overridden for another default action; 203 ; 204void TObject::Browse(TBrowser *b); 205{; 206 //Inspect();; 207 TClass::AutoBrowse(this,b);; 208}; 209 ; 210////////////////////////////////////////////////////////////////////////////////; 211/// Returns name of class to which the object belongs.; 212 ; 213const char *TObject:",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:17617,Integrability,rout,routine,17617," 478 Float_t y = gPad->AbsPixeltoY(py);; 479 snprintf(info,64,""x=%g, y=%g"",gPad->PadtoX(x),gPad->PadtoY(y));; 480 return info;; 481}; 482 ; 483////////////////////////////////////////////////////////////////////////////////; 484/// Returns title of object. This default method returns the class title; 485/// (i.e. description). Classes that give objects a title should override; 486/// this method.; 487 ; 488const char *TObject::GetTitle() const; 489{; 490 return IsA()->GetTitle();; 491}; 492 ; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Execute action in response of a timer timing out. This method; 496/// must be overridden if an object has to react to timers.; 497 ; 498Bool_t TObject::HandleTimer(TTimer *); 499{; 500 return kFALSE;; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Return hash value for this object.; 505///; 506/// Note: If this routine is overloaded in a derived class, this derived class; 507/// should also add; 508/// ~~~ {.cpp}; 509/// ROOT::CallRecursiveRemoveIfNeeded(*this); 510/// ~~~; 511/// Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; 512/// type of object, the transversal of THashList and THashTable containers will; 513/// will have to be done without call Hash (and hence be linear rather than; 514/// logarithmic complexity). You will also see warnings like; 515/// ~~~; 516/// Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; 517/// ~~~; 518///; 519 ; 520ULong_t TObject::Hash() const; 521{; 522 //return (ULong_t) this >> 2;; 523 const void *ptr = this;; 524 return TString::Hash(&ptr, sizeof(void*));; 525}; 526 ; 527////////////////////////////////////////////////////////////////////////////////; 528/// Returns kTRUE if object inherits from class ""classname"".; 529 ;",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:35605,Integrability,message,message,35605,"its;; 931 else; 932 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 933 } else {; 934 //if the object is referenced, we must save its address/file_pid; 935 UInt_t uid = fUniqueID & 0xffffff;; 936 R__b << uid;; 937 if (R__unlikely(parent && parent->TestBit(TFile__k630forwardCompatibility))); 938 R__b << fBits;; 939 else; 940 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 941 TProcessID *pid = TProcessID::GetProcessWithUID(fUniqueID,this);; 942 //add uid to the TRefTable if there is one; 943 TRefTable *table = TRefTable::GetRefTable();; 944 if(table) table->Add(uid, pid);; 945 pidf = R__b.WriteProcessID(pid);; 946 R__b << pidf;; 947 }; 948 }; 949}; 950 ; 951////////////////////////////////////////////////////////////////////////////////; 952/// Interface to ErrorHandler (protected).; 953 ; 954void TObject::DoError(int level, const char *location, const char *fmt, va_list va) const; 955{; 956 const char *classname = ""UnknownClass"";; 957 if (TROOT::Initialized()); 958 classname = ClassName();; 959 ; 960 ::ErrorHandler(level, Form(""%s::%s"", classname, location), fmt, va);; 961}; 962 ; 963////////////////////////////////////////////////////////////////////////////////; 964/// Issue info message. Use ""location"" to specify the method where the; 965/// warning occurred. Accepts standard printf formatting arguments.; 966 ; 967void TObject::Info(const char *location, const char *va_(fmt), ...) const; 968{; 969 va_list ap;; 970 va_start(ap, va_(fmt));; 971 DoError(kInfo, location, va_(fmt), ap);; 972 va_end(ap);; 973}; 974 ; 975////////////////////////////////////////////////////////////////////////////////; 976/// Issue warning message. Use ""location"" to specify the method where the; 977/// warning occurred. Accepts standard printf formatting arguments.; 978 ; 979void TObject::Warning(const char *location, const char *va_(fmt), ...) const; 980{; 981 va_list ap;; 982 va_start(ap, va_(fmt));; 983 DoError(kWarning, location, va_(fmt), ap);; 984 va_end(ap);; 985 if (TROOT::Initial",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:36050,Integrability,message,message,36050,"RefTable();; 944 if(table) table->Add(uid, pid);; 945 pidf = R__b.WriteProcessID(pid);; 946 R__b << pidf;; 947 }; 948 }; 949}; 950 ; 951////////////////////////////////////////////////////////////////////////////////; 952/// Interface to ErrorHandler (protected).; 953 ; 954void TObject::DoError(int level, const char *location, const char *fmt, va_list va) const; 955{; 956 const char *classname = ""UnknownClass"";; 957 if (TROOT::Initialized()); 958 classname = ClassName();; 959 ; 960 ::ErrorHandler(level, Form(""%s::%s"", classname, location), fmt, va);; 961}; 962 ; 963////////////////////////////////////////////////////////////////////////////////; 964/// Issue info message. Use ""location"" to specify the method where the; 965/// warning occurred. Accepts standard printf formatting arguments.; 966 ; 967void TObject::Info(const char *location, const char *va_(fmt), ...) const; 968{; 969 va_list ap;; 970 va_start(ap, va_(fmt));; 971 DoError(kInfo, location, va_(fmt), ap);; 972 va_end(ap);; 973}; 974 ; 975////////////////////////////////////////////////////////////////////////////////; 976/// Issue warning message. Use ""location"" to specify the method where the; 977/// warning occurred. Accepts standard printf formatting arguments.; 978 ; 979void TObject::Warning(const char *location, const char *va_(fmt), ...) const; 980{; 981 va_list ap;; 982 va_start(ap, va_(fmt));; 983 DoError(kWarning, location, va_(fmt), ap);; 984 va_end(ap);; 985 if (TROOT::Initialized()); 986 gROOT->Message(1001, this);; 987}; 988 ; 989////////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->M",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:36563,Integrability,message,message,36563,"; 960 ::ErrorHandler(level, Form(""%s::%s"", classname, location), fmt, va);; 961}; 962 ; 963////////////////////////////////////////////////////////////////////////////////; 964/// Issue info message. Use ""location"" to specify the method where the; 965/// warning occurred. Accepts standard printf formatting arguments.; 966 ; 967void TObject::Info(const char *location, const char *va_(fmt), ...) const; 968{; 969 va_list ap;; 970 va_start(ap, va_(fmt));; 971 DoError(kInfo, location, va_(fmt), ap);; 972 va_end(ap);; 973}; 974 ; 975////////////////////////////////////////////////////////////////////////////////; 976/// Issue warning message. Use ""location"" to specify the method where the; 977/// warning occurred. Accepts standard printf formatting arguments.; 978 ; 979void TObject::Warning(const char *location, const char *va_(fmt), ...) const; 980{; 981 va_list ap;; 982 va_start(ap, va_(fmt));; 983 DoError(kWarning, location, va_(fmt), ap);; 984 va_end(ap);; 985 if (TROOT::Initialized()); 986 gROOT->Message(1001, this);; 987}; 988 ; 989////////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 10",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:37082,Integrability,message,message,37082,");; 973}; 974 ; 975////////////////////////////////////////////////////////////////////////////////; 976/// Issue warning message. Use ""location"" to specify the method where the; 977/// warning occurred. Accepts standard printf formatting arguments.; 978 ; 979void TObject::Warning(const char *location, const char *va_(fmt), ...) const; 980{; 981 va_list ap;; 982 va_start(ap, va_(fmt));; 983 DoError(kWarning, location, va_(fmt), ap);; 984 va_end(ap);; 985 if (TROOT::Initialized()); 986 gROOT->Message(1001, this);; 987}; 988 ; 989////////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 1012 va_end(ap);; 1013 if (TROOT::Initialized()); 1014 gROOT->Message(1003, this);; 1015}; 1016 ; 1017////////////////////////////////////////////////////////////////////////////////; 1018/// Issue fatal error message. Use ""location"" to specify the method where the; 1019/// fatal error occurred. Accepts standard printf formatting arguments.; 1020 ; 1021void TObject::Fatal(const char *location, const char *va_(fmt), ...) const; 1022{; 1023 va_list ap;; 1024 va_start(ap, va_(fmt));; 1025 DoError(kFatal, location,",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:37622,Integrability,message,message,37622,"//////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 1012 va_end(ap);; 1013 if (TROOT::Initialized()); 1014 gROOT->Message(1003, this);; 1015}; 1016 ; 1017////////////////////////////////////////////////////////////////////////////////; 1018/// Issue fatal error message. Use ""location"" to specify the method where the; 1019/// fatal error occurred. Accepts standard printf formatting arguments.; 1020 ; 1021void TObject::Fatal(const char *location, const char *va_(fmt), ...) const; 1022{; 1023 va_list ap;; 1024 va_start(ap, va_(fmt));; 1025 DoError(kFatal, location, va_(fmt), ap);; 1026 va_end(ap);; 1027 if (TROOT::Initialized()); 1028 gROOT->Message(1004, this);; 1029}; 1030 ; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Use this method to implement an ""abstract"" method that you don't; 1033/// want to leave purely abstract.; 1034 ; 1035void TObject::AbstractMethod(const char *method) const; 1036{; 1037 Warning(method, ""this method must be overridden!"");; 1038}; 1039 ; 1040///////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:52034,Integrability,message,message,52034,"ler (protected).Definition TObject.cxx:954; TObject::HandleTimervirtual Bool_t HandleTimer(TTimer *timer)Execute action in response of a timer timing out.Definition TObject.cxx:498; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::kIsOnHeap@ kIsOnHeapobject is on heapDefinition TObject.h:81; TObject::kNotDeleted@ kNotDeletedobject has not been deletedDefinition TObject.h:82; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; TObject::fgDtorOnlystatic Longptr_t fgDtorOnlyobject for which to call dtor only (i.e. no delete)Definition TObject.h:47; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDra",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:52723,Integrability,message,message,52723,"tic Longptr_t fgDtorOnlyobject for which to call dtor only (i.e. no delete)Definition TObject.h:47; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TObject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::AppendPadvirtual void AppendPad(Option_t *o",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:55438,Integrability,message,message,55438,"objects to ...Definition TObject.h:106; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::~TObjectvirtual ~TObject()TObject de",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:55701,Integrability,message,message,55701,"Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::~TObjectvirtual ~TObject()TObject destructor.Definition TObject.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to pain",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:58131,Integrability,message,message,58131,"d ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::fgObjectStatstatic Bool_t fgObjectStatif true keep track of objects in TObjectTableDefinition TObject.h:48; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; TObject::AddToTObjectTablestatic void AddToTObjectTable(TObject *)Private helper function which will dispatch to TObjectTable::AddObj.Definition TObject.cxx:181; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::PutObjectWithIDvoid PutObjectWithID(TObject *obj, UInt_t uid=0)stores the object at the uid th slot in the table of objects The object uniqued is set as well as its...Definition TProcessID.cxx:383; TProcessID::GetProcessWithUIDstatic TProcessID * GetProcessWithUID(const TObject *obj)static function returning a pointer to TProcessID with its pid encoded in the highest byte of obj->Ge...Definition TProcessID.cxx:297; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.c",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:918,Modifiability,inherit,inherits,918,". ROOT: core/base/src/TObject.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TObject.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 26/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TObject; 13\ingroup Base; 14 ; 15Mother of all ROOT objects.; 16 ; 17The TObject class provides default behaviour and protocol for all; 18objects in the ROOT system. It provides protocol for object I/O,; 19error handling, sorting, inspection, printing, drawing, etc.; 20Every object which inherits from TObject can be stored in the; 21ROOT collection classes.; 22 ; 23TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; 24reserved as global bits while bits 14 - 23 can be used in different; 25class hierarchies (watch out for overlaps).; 26*/; 27 ; 28#include <cstring>; 29#if !defined(WIN32) && !defined(__MWERKS__) && !defined(R__SOLARIS); 30#include <strings.h>; 31#endif; 32#include <cstdlib>; 33#include <cstdio>; 34#include <sstream>; 35#include <fstream>; 36#include <iostream>; 37 ; 38#include ""Varargs.h""; 39#include ""snprintf.h""; 40#include ""TObject.h""; 41#include ""TBuffer.h""; 42#include ""TClass.h""; 43#include ""TGuiFactory.h""; 44#include ""TMethod.h""; 45#include ""TROOT.h""; 46#include ""TError.h""; 47#include ""TObjectTable.h""; 48#include ""TVirtualPad.h""; 49#include ""TInterpreter.h""; 50#include ""TMemberInspector.h""; 51#include ""TRefTable.h""; 52#include ""TProcessID.h""; 53 ; 54Longptr_t TObject::fgDtorOnly = 0;; 55Bool_t TObject::fgObjectStat = kTRUE;; 56 ; 57ClassImp(TObject);; 58 ; 59#if defined(__clang__) || defined (__GNUC__); 60# define ATTRI",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:10119,Modifiability,inherit,inheritance,10119,"///////////; 251/// Delete this object. Typically called as a command via the interpreter.; 252/// Normally use ""delete"" operator when object has been allocated on the heap.; 253 ; 254void TObject::Delete(Option_t *); 255{; 256 if (IsOnHeap()) {; 257 // Delete object from CINT symbol table so it can not be used anymore.; 258 // CINT object are always on the heap.; 259 gInterpreter->DeleteGlobal(this);; 260 ; 261 delete this;; 262 }; 263}; 264 ; 265 ; 266////////////////////////////////////////////////////////////////////////////////; 267/// Computes distance from point (px,py) to the object.; 268/// This member function must be implemented for each graphics primitive.; 269/// This default function returns a big number (999999).; 270 ; 271Int_t TObject::DistancetoPrimitive(Int_t, Int_t); 272{; 273 // AbstractMethod(""DistancetoPrimitive"");; 274 return 999999;; 275}; 276 ; 277////////////////////////////////////////////////////////////////////////////////; 278/// Default Draw method for all objects; 279 ; 280void TObject::Draw(Option_t *option); 281{; 282 AppendPad(option);; 283}; 284 ; 285////////////////////////////////////////////////////////////////////////////////; 286/// Draw class inheritance tree of the class to which this object belongs.; 287/// If a class B inherits from a class A, description of B is drawn; 288/// on the right side of description of A.; 289/// Member functions overridden by B are shown in class A with a blue line; 290/// crossing-out the corresponding member function.; 291/// The following picture is the class inheritance tree of class TPaveLabel:; 292///; 293/// \image html base_object.png; 294 ; 295void TObject::DrawClass() const; 296{; 297 IsA()->Draw();; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// Draw a clone of this object in the current selected pad with:; 302/// `gROOT->SetSelectedPad(c1)`.; 303/// If pad was not selected - `gPad` will be used.; 304 ; 305TObject *TObject::Dr",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:10200,Modifiability,inherit,inherits,10200," 258 // CINT object are always on the heap.; 259 gInterpreter->DeleteGlobal(this);; 260 ; 261 delete this;; 262 }; 263}; 264 ; 265 ; 266////////////////////////////////////////////////////////////////////////////////; 267/// Computes distance from point (px,py) to the object.; 268/// This member function must be implemented for each graphics primitive.; 269/// This default function returns a big number (999999).; 270 ; 271Int_t TObject::DistancetoPrimitive(Int_t, Int_t); 272{; 273 // AbstractMethod(""DistancetoPrimitive"");; 274 return 999999;; 275}; 276 ; 277////////////////////////////////////////////////////////////////////////////////; 278/// Default Draw method for all objects; 279 ; 280void TObject::Draw(Option_t *option); 281{; 282 AppendPad(option);; 283}; 284 ; 285////////////////////////////////////////////////////////////////////////////////; 286/// Draw class inheritance tree of the class to which this object belongs.; 287/// If a class B inherits from a class A, description of B is drawn; 288/// on the right side of description of A.; 289/// Member functions overridden by B are shown in class A with a blue line; 290/// crossing-out the corresponding member function.; 291/// The following picture is the class inheritance tree of class TPaveLabel:; 292///; 293/// \image html base_object.png; 294 ; 295void TObject::DrawClass() const; 296{; 297 IsA()->Draw();; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// Draw a clone of this object in the current selected pad with:; 302/// `gROOT->SetSelectedPad(c1)`.; 303/// If pad was not selected - `gPad` will be used.; 304 ; 305TObject *TObject::DrawClone(Option_t *option) const; 306{; 307 TVirtualPad::TContext ctxt(true);; 308 auto pad = gROOT->GetSelectedPad();; 309 if (pad); 310 pad->cd();; 311 ; 312 TObject *newobj = Clone();; 313 if (!newobj); 314 return nullptr;; 315 ; 316 if (!option || !*option); 317 option = GetDrawOption();; 318 ; 319 if (pad) {; 320 pad-",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:10476,Modifiability,inherit,inheritance,10476,"x,py) to the object.; 268/// This member function must be implemented for each graphics primitive.; 269/// This default function returns a big number (999999).; 270 ; 271Int_t TObject::DistancetoPrimitive(Int_t, Int_t); 272{; 273 // AbstractMethod(""DistancetoPrimitive"");; 274 return 999999;; 275}; 276 ; 277////////////////////////////////////////////////////////////////////////////////; 278/// Default Draw method for all objects; 279 ; 280void TObject::Draw(Option_t *option); 281{; 282 AppendPad(option);; 283}; 284 ; 285////////////////////////////////////////////////////////////////////////////////; 286/// Draw class inheritance tree of the class to which this object belongs.; 287/// If a class B inherits from a class A, description of B is drawn; 288/// on the right side of description of A.; 289/// Member functions overridden by B are shown in class A with a blue line; 290/// crossing-out the corresponding member function.; 291/// The following picture is the class inheritance tree of class TPaveLabel:; 292///; 293/// \image html base_object.png; 294 ; 295void TObject::DrawClass() const; 296{; 297 IsA()->Draw();; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// Draw a clone of this object in the current selected pad with:; 302/// `gROOT->SetSelectedPad(c1)`.; 303/// If pad was not selected - `gPad` will be used.; 304 ; 305TObject *TObject::DrawClone(Option_t *option) const; 306{; 307 TVirtualPad::TContext ctxt(true);; 308 auto pad = gROOT->GetSelectedPad();; 309 if (pad); 310 pad->cd();; 311 ; 312 TObject *newobj = Clone();; 313 if (!newobj); 314 return nullptr;; 315 ; 316 if (!option || !*option); 317 option = GetDrawOption();; 318 ; 319 if (pad) {; 320 pad->Add(newobj, option);; 321 pad->Update();; 322 } else {; 323 newobj->Draw(option);; 324 }; 325 ; 326 return newobj;; 327}; 328 ; 329////////////////////////////////////////////////////////////////////////////////; 330/// Dump contents of object on stdout.",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:18612,Modifiability,inherit,inherits,18612,"/////////////////////////////////////////////////////////////////////; 504/// Return hash value for this object.; 505///; 506/// Note: If this routine is overloaded in a derived class, this derived class; 507/// should also add; 508/// ~~~ {.cpp}; 509/// ROOT::CallRecursiveRemoveIfNeeded(*this); 510/// ~~~; 511/// Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; 512/// type of object, the transversal of THashList and THashTable containers will; 513/// will have to be done without call Hash (and hence be linear rather than; 514/// logarithmic complexity). You will also see warnings like; 515/// ~~~; 516/// Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; 517/// ~~~; 518///; 519 ; 520ULong_t TObject::Hash() const; 521{; 522 //return (ULong_t) this >> 2;; 523 const void *ptr = this;; 524 return TString::Hash(&ptr, sizeof(void*));; 525}; 526 ; 527////////////////////////////////////////////////////////////////////////////////; 528/// Returns kTRUE if object inherits from class ""classname"".; 529 ; 530Bool_t TObject::InheritsFrom(const char *classname) const; 531{; 532 return IsA()->InheritsFrom(classname);; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// Returns kTRUE if object inherits from TClass cl.; 537 ; 538Bool_t TObject::InheritsFrom(const TClass *cl) const; 539{; 540 return IsA()->InheritsFrom(cl);; 541}; 542 ; 543////////////////////////////////////////////////////////////////////////////////; 544/// Dump contents of this object in a graphics canvas.; 545/// Same action as Dump but in a graphical form.; 546/// In addition pointers to other objects can be followed.; 547///; 548/// The following picture is the Inspect of a histogram object:; 549/// \image html base_inspect.png; 550 ; 551void TObject::Inspect() const; 552{; 553 gGuiFactory->Cr",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:18892,Modifiability,inherit,inherits,18892,"~; 511/// Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; 512/// type of object, the transversal of THashList and THashTable containers will; 513/// will have to be done without call Hash (and hence be linear rather than; 514/// logarithmic complexity). You will also see warnings like; 515/// ~~~; 516/// Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; 517/// ~~~; 518///; 519 ; 520ULong_t TObject::Hash() const; 521{; 522 //return (ULong_t) this >> 2;; 523 const void *ptr = this;; 524 return TString::Hash(&ptr, sizeof(void*));; 525}; 526 ; 527////////////////////////////////////////////////////////////////////////////////; 528/// Returns kTRUE if object inherits from class ""classname"".; 529 ; 530Bool_t TObject::InheritsFrom(const char *classname) const; 531{; 532 return IsA()->InheritsFrom(classname);; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// Returns kTRUE if object inherits from TClass cl.; 537 ; 538Bool_t TObject::InheritsFrom(const TClass *cl) const; 539{; 540 return IsA()->InheritsFrom(cl);; 541}; 542 ; 543////////////////////////////////////////////////////////////////////////////////; 544/// Dump contents of this object in a graphics canvas.; 545/// Same action as Dump but in a graphical form.; 546/// In addition pointers to other objects can be followed.; 547///; 548/// The following picture is the Inspect of a histogram object:; 549/// \image html base_inspect.png; 550 ; 551void TObject::Inspect() const; 552{; 553 gGuiFactory->CreateInspectorImp(this, 400, 200);; 554}; 555 ; 556////////////////////////////////////////////////////////////////////////////////; 557/// Returns kTRUE in case object contains browsable objects (like containers; 558/// or lists of other objects).; 559 ; 560Bool_t TObject::IsFolder() const; 561{; 562 retu",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:46888,Modifiability,inherit,inheritance,46888,"40; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)=0Return the current Process-ID.Definition TBuffer.cxx:344; TBuffer::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)=0Always return 0 (current processID).Definition TBuffer.cxx:353; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::GetPidOffsetvirtual UShort_t GetPidOffset() const =0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::SkipVersionvirtual void SkipVersion(const TClass *cl=nullptr)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Drawvoid Draw(Option_t *option="""") overrideDraw detailed class inheritance structure.Definition TClass.cxx:2554; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:2033; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TGuiFactory::CreateInspectorImpvirtual TInspectorImp * CreateInspectorImp(const TObject *obj, UInt_t width, UInt_t height)Create a batch version of TInspectorImp.Definition TGuiFactory.cxx:182; TListIterIterator of linked list.Definition TList.h:193; TListIter::GetOptionOption_t * GetOption() const overrideReturns the object option s",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:47209,Modifiability,inherit,inherited,47209,"riteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)=0Always return 0 (current processID).Definition TBuffer.cxx:353; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::GetPidOffsetvirtual UShort_t GetPidOffset() const =0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::SkipVersionvirtual void SkipVersion(const TClass *cl=nullptr)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Drawvoid Draw(Option_t *option="""") overrideDraw detailed class inheritance structure.Definition TClass.cxx:2554; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:2033; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TGuiFactory::CreateInspectorImpvirtual TInspectorImp * CreateInspectorImp(const TObject *obj, UInt_t width, UInt_t height)Create a batch version of TInspectorImp.Definition TGuiFactory.cxx:182; TListIterIterator of linked list.Definition TList.h:193; TListIter::GetOptionOption_t * GetOption() const overrideReturns the object option stored in the list.Definition TList.cxx:1140; TListIter::SetOptionvoid SetOption(Option_t *option)Sets the object option stored in the list.Definition TList.cxx:1149; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamed::GetNameconst char * GetName() const overri",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:47454,Modifiability,inherit,inherits,47454,"fsetvirtual UShort_t GetPidOffset() const =0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::SkipVersionvirtual void SkipVersion(const TClass *cl=nullptr)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Drawvoid Draw(Option_t *option="""") overrideDraw detailed class inheritance structure.Definition TClass.cxx:2554; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:2033; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TGuiFactory::CreateInspectorImpvirtual TInspectorImp * CreateInspectorImp(const TObject *obj, UInt_t width, UInt_t height)Create a batch version of TInspectorImp.Definition TGuiFactory.cxx:182; TListIterIterator of linked list.Definition TList.h:193; TListIter::GetOptionOption_t * GetOption() const overrideReturns the object option stored in the list.Definition TList.cxx:1140; TListIter::SetOptionvoid SetOption(Option_t *option)Sets the object option stored in the list.Definition TList.cxx:1149; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectTable::AddObjstatic void AddObj(TObject *o",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:55075,Modifiability,inherit,inherits,55075,"on_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Def",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:56120,Modifiability,inherit,inheritance,56120,"on TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::~TObjectvirtual ~TObject()TObject destructor.Definition TObject.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display list.Definition TObject.cxx:621; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:520; TObject::lsv",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:3729,Performance,load,loading,3729,"d but not operator; 73// delete, we can still use it to detect the cases where the destructor was called.; 74 ; 75ATTRIBUTE_NO_SANITIZE_ADDRESS; 76bool DeleteChangesMemoryImpl(); 77{; 78 static constexpr UInt_t kGoldenUUID = 0x00000021;; 79 static constexpr UInt_t kGoldenbits = 0x03000000;; 80 ; 81 TObject *o = new TObject;; 82 o->SetUniqueID(kGoldenUUID);; 83 UInt_t *o_fuid = &(o->fUniqueID);; 84 UInt_t *o_fbits = &(o->fBits);; 85 ; 86 if (*o_fuid != kGoldenUUID) {; 87 Error(""CheckingDeleteSideEffects"",; 88 ""fUniqueID is not as expected, we got 0x%.8x instead of 0x%.8x"",; 89 *o_fuid, kGoldenUUID);; 90 }; 91 if (*o_fbits != kGoldenbits) {; 92 Error(""CheckingDeleteSideEffects"",; 93 ""fBits is not as expected, we got 0x%.8x instead of 0x%.8x"",; 94 *o_fbits, kGoldenbits);; 95 }; 96 if (gDebug >= 9) {; 97 unsigned char *oc = reinterpret_cast<unsigned char *>(o); // for address calculations; 98 unsigned char references[sizeof(TObject)];; 99 memcpy(references, oc, sizeof(TObject));; 100 ; 101 // The effective part of this code (the else statement is just that without; 102 // any of the debug statement); 103 delete o;; 104 ; 105 // Not using the error logger, as there routine is meant to be called; 106 // during library initialization/loading.; 107 fprintf(stderr,; 108 ""DEBUG: Checking before and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a seg",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:21159,Performance,load,load,21159,"The ls function lists the contents of a class on stdout. Ls output; 577/// is typically much less verbose then Dump().; 578 ; 579void TObject::ls(Option_t *option) const; 580{; 581 TROOT::IndentLevel();; 582 std::cout <<""OBJ: "" << IsA()->GetName() << ""\t"" << GetName() << ""\t"" << GetTitle() << "" : "";; 583 std::cout << Int_t(TestBit(kCanDelete));; 584 if (option && strstr(option,""noaddr"")==nullptr) {; 585 std::cout <<"" at: ""<< this ;; 586 }; 587 std::cout << std::endl;; 588}; 589 ; 590////////////////////////////////////////////////////////////////////////////////; 591/// This method must be overridden to handle object notification (the base implementation is no-op).; 592///; 593/// Different objects in ROOT use the `Notify` method for different purposes, in coordination; 594/// with other objects that call this method at the appropriate time.; 595///; 596/// For example, `TLeaf` uses it to load class information; `TBranchRef` to load contents of; 597/// referenced branches `TBranchRef`; most notably, based on `Notify`, `TChain` implements a; 598/// callback mechanism to inform interested parties when it switches to a new sub-tree.; 599Bool_t TObject::Notify(); 600{; 601 return kFALSE;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// This method must be overridden if a class wants to paint itself.; 606/// The difference between Paint() and Draw() is that when a object; 607/// draws itself it is added to the display list of the pad in; 608/// which it is drawn (and automatically redrawn whenever the pad is; 609/// redrawn). While paint just draws the object without adding it to; 610/// the pad display list.; 611 ; 612void TObject::Paint(Option_t *); 613{; 614 // AbstractMethod(""Paint"");; 615}; 616 ; 617////////////////////////////////////////////////////////////////////////////////; 618/// Pop on object drawn in a pad to the top of the display list. I.e. it; 619/// will be drawn last and on top of all other primit",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:21199,Performance,load,load,21199,"The ls function lists the contents of a class on stdout. Ls output; 577/// is typically much less verbose then Dump().; 578 ; 579void TObject::ls(Option_t *option) const; 580{; 581 TROOT::IndentLevel();; 582 std::cout <<""OBJ: "" << IsA()->GetName() << ""\t"" << GetName() << ""\t"" << GetTitle() << "" : "";; 583 std::cout << Int_t(TestBit(kCanDelete));; 584 if (option && strstr(option,""noaddr"")==nullptr) {; 585 std::cout <<"" at: ""<< this ;; 586 }; 587 std::cout << std::endl;; 588}; 589 ; 590////////////////////////////////////////////////////////////////////////////////; 591/// This method must be overridden to handle object notification (the base implementation is no-op).; 592///; 593/// Different objects in ROOT use the `Notify` method for different purposes, in coordination; 594/// with other objects that call this method at the appropriate time.; 595///; 596/// For example, `TLeaf` uses it to load class information; `TBranchRef` to load contents of; 597/// referenced branches `TBranchRef`; most notably, based on `Notify`, `TChain` implements a; 598/// callback mechanism to inform interested parties when it switches to a new sub-tree.; 599Bool_t TObject::Notify(); 600{; 601 return kFALSE;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// This method must be overridden if a class wants to paint itself.; 606/// The difference between Paint() and Draw() is that when a object; 607/// draws itself it is added to the display list of the pad in; 608/// which it is drawn (and automatically redrawn whenever the pad is; 609/// redrawn). While paint just draws the object without adding it to; 610/// the pad display list.; 611 ; 612void TObject::Paint(Option_t *); 613{; 614 // AbstractMethod(""Paint"");; 615}; 616 ; 617////////////////////////////////////////////////////////////////////////////////; 618/// Pop on object drawn in a pad to the top of the display list. I.e. it; 619/// will be drawn last and on top of all other primit",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:2538,Safety,detect,detect,2538,"Varargs.h""; 39#include ""snprintf.h""; 40#include ""TObject.h""; 41#include ""TBuffer.h""; 42#include ""TClass.h""; 43#include ""TGuiFactory.h""; 44#include ""TMethod.h""; 45#include ""TROOT.h""; 46#include ""TError.h""; 47#include ""TObjectTable.h""; 48#include ""TVirtualPad.h""; 49#include ""TInterpreter.h""; 50#include ""TMemberInspector.h""; 51#include ""TRefTable.h""; 52#include ""TProcessID.h""; 53 ; 54Longptr_t TObject::fgDtorOnly = 0;; 55Bool_t TObject::fgObjectStat = kTRUE;; 56 ; 57ClassImp(TObject);; 58 ; 59#if defined(__clang__) || defined (__GNUC__); 60# define ATTRIBUTE_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address)); 61#else; 62# define ATTRIBUTE_NO_SANITIZE_ADDRESS; 63#endif; 64 ; 65namespace ROOT {; 66namespace Internal {; 67 ; 68// Return true if delete changes/poisons/taints the memory.; 69//; 70// Detect whether operator delete taints the memory. If it does, we can not rely; 71// on TestBit(kNotDeleted) to check if the memory has been deleted (but in case,; 72// like TClonesArray, where we know the destructor will be called but not operator; 73// delete, we can still use it to detect the cases where the destructor was called.; 74 ; 75ATTRIBUTE_NO_SANITIZE_ADDRESS; 76bool DeleteChangesMemoryImpl(); 77{; 78 static constexpr UInt_t kGoldenUUID = 0x00000021;; 79 static constexpr UInt_t kGoldenbits = 0x03000000;; 80 ; 81 TObject *o = new TObject;; 82 o->SetUniqueID(kGoldenUUID);; 83 UInt_t *o_fuid = &(o->fUniqueID);; 84 UInt_t *o_fbits = &(o->fBits);; 85 ; 86 if (*o_fuid != kGoldenUUID) {; 87 Error(""CheckingDeleteSideEffects"",; 88 ""fUniqueID is not as expected, we got 0x%.8x instead of 0x%.8x"",; 89 *o_fuid, kGoldenUUID);; 90 }; 91 if (*o_fbits != kGoldenbits) {; 92 Error(""CheckingDeleteSideEffects"",; 93 ""fBits is not as expected, we got 0x%.8x instead of 0x%.8x"",; 94 *o_fbits, kGoldenbits);; 95 }; 96 if (gDebug >= 9) {; 97 unsigned char *oc = reinterpret_cast<unsigned char *>(o); // for address calculations; 98 unsigned char references[sizeof(TObject)];; 99 memcpy(referen",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:4385,Safety,detect,detect,4385,"fore and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a segmentation fault); 120#if defined(_MSC_VER) && defined(__SANITIZE_ADDRESS__); 121 // on Windows, even __declspec(no_sanitize_address) does not prevent catching; 122 // heap-use-after-free errorswhen using the /fsanitize=address compiler flag; 123 // so don't even try; 124 return true;; 125#endif; 126 if ( *o_fbits != 0x01000000 ) {; 127 // operator delete tainted the memory, we can not rely on TestBit(kNotDeleted); 128 return true;; 129 }; 130 return false;; 131}; 132 ; 133bool DeleteChangesMemory(); 134{; 135 static const bool value = DeleteChangesMemoryImpl();; 136 if (gDebug >= 9); 137 DeleteChangesMemoryImpl(); // To allow for printing the debug info; 138 return value;; 139}; 140 ; 141}} // ROOT::Detail; 142 ; 143////////////////////////////////////////////////////////////////////////////////; 144/// Copy this to obj.; 145 ; 146void TObject::Copy(TObject &obj) const; 147{; 148 obj.fUniqueID = fUniqueID; // when really unique don't copy; 149 if (obj.IsOnHeap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:6444,Safety,avoid,avoid,6444,"eap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////////////////; 161/// TObject destructor. Removes object from all canvases and object browsers; 162/// if observer bit is on and remove from the global object table.; 163 ; 164TObject::~TObject(); 165{; 166 // if (!TestBit(kNotDeleted)); 167 // Fatal(""~TObject"", ""object deleted twice"");; 168 ; 169 ROOT::CallRecursiveRemoveIfNeeded(*this);; 170 ; 171 fBits &= ~kNotDeleted;; 172 ; 173 if (fgObjectStat && gObjectTable) gObjectTable->RemoveQuietly(this);; 174}; 175 ; 176////////////////////////////////////////////////////////////////////////////////; 177/// Private helper function which will dispatch to; 178/// TObjectTable::AddObj.; 179/// Included here to avoid circular dependency between header files.; 180 ; 181void TObject::AddToTObjectTable(TObject *op); 182{; 183 TObjectTable::AddObj(op);; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Append graphics object to current pad. In case no current pad is set; 188/// yet, create a default canvas with the name ""c1"".; 189 ; 190void TObject::AppendPad(Option_t *option); 191{; 192 if (!gPad); 193 gROOT->MakeDefCanvas();; 194 ; 195 if (!gPad->IsEditable()); 196 return;; 197 ; 198 gPad->Add(this, option);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Browse object. May be overridden for another default action; 203 ; 204void TObject::Browse(TBrowser *b); 205{; 206 //Inspect();; 207 TClass::AutoBrowse(this,b);; 208}; 209 ; 210////////////////////////////////////////////////////////////////////////////////; 211/// Returns name of class to which the object belongs.; 212 ; 213const char *TObject:",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:30744,Safety,safe,safer,30744,"ffer.; 826///; 827/// - Reservation of the corresponding space in the file by looking; 828/// in the TFree list of free blocks of the file.; 829///; 830/// - The buffer is written to the file.; 831///; 832/// Bufsize can be given to force a given buffer size to write this object.; 833/// By default, the buffersize will be taken from the average buffer size; 834/// of all objects written to the current file so far.; 835///; 836/// If a name is specified, it will be the name of the key.; 837/// If name is not given, the name of the key will be the name as returned; 838/// by GetName().; 839///; 840/// The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete; 841/// Using the kOverwrite option a previous key with the same name is; 842/// overwritten. The previous key is deleted before writing the new object.; 843/// Using the kWriteDelete option a previous key with the same name is; 844/// deleted only after the new object has been written. This option; 845/// is safer than kOverwrite but it is slower.; 846/// NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile--; 847/// the space is simply freed up to be overwritten; in the case of a TTree,; 848/// it is more complicated. If one opens a TTree, appends some entries,; 849/// then writes it out, the behaviour is effectively the same. If, however,; 850/// one creates a new TTree and writes it out in this way,; 851/// only the metadata is replaced, effectively making the old data invisible; 852/// without deleting it. TTree::Delete() can be used to mark all disk space; 853/// occupied by a TTree as free before overwriting its metadata this way.; 854/// The kSingleKey option is only used by TCollection::Write() to write; 855/// a container with a single key instead of each object in the container; 856/// with its own key.; 857///; 858/// An object is read from the file into memory via TKey::Read() or; 859/// via TObject::Read().; 860///; 861/// The function returns the total number of byte",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:33999,Safety,avoid,avoid,33999,"()) return;; 897 UShort_t pidf;; 898 if (R__b.IsReading()) {; 899 R__b.SkipVersion(); // Version_t R__v = R__b.ReadVersion(); if (R__v) { }; 900 R__b >> fUniqueID;; 901 const UInt_t isonheap = fBits & kIsOnHeap; // Record how this instance was actually allocated.; 902 R__b >> fBits;; 903 fBits |= isonheap | kNotDeleted; // by definition de-serialized object are not yet deleted.; 904 if (TestBit(kIsReferenced)) {; 905 //if the object is referenced, we must read its old address; 906 //and store it in the ProcessID map in gROOT; 907 R__b >> pidf;; 908 pidf += R__b.GetPidOffset();; 909 TProcessID *pid = R__b.ReadProcessID(pidf);; 910 if (pid) {; 911 UInt_t gpid = pid->GetUniqueID();; 912 if (gpid>=0xff) {; 913 fUniqueID = fUniqueID | 0xff000000;; 914 } else {; 915 fUniqueID = ( fUniqueID & 0xffffff) + (gpid<<24);; 916 }; 917 pid->PutObjectWithID(this);; 918 }; 919 }; 920 } else {; 921 R__b.WriteVersion(TObject::IsA());; 922 // Can not read TFile.h here and avoid going through the interpreter by; 923 // simply hard-coding this value.; 924 // This **must** be equal to TFile::k630forwardCompatibility; 925 constexpr int TFile__k630forwardCompatibility = BIT(2);; 926 const auto parent = R__b.GetParent();; 927 if (!TestBit(kIsReferenced)) {; 928 R__b << fUniqueID;; 929 if (R__unlikely(parent && parent->TestBit(TFile__k630forwardCompatibility))); 930 R__b << fBits;; 931 else; 932 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 933 } else {; 934 //if the object is referenced, we must save its address/file_pid; 935 UInt_t uid = fUniqueID & 0xffffff;; 936 R__b << uid;; 937 if (R__unlikely(parent && parent->TestBit(TFile__k630forwardCompatibility))); 938 R__b << fBits;; 939 else; 940 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 941 TProcessID *pid = TProcessID::GetProcessWithUID(fUniqueID,this);; 942 //add uid to the TRefTable if there is one; 943 TRefTable *table = TRefTable::GetRefTable();; 944 if(table) table->Add(uid, pid);; 945 pidf = R__b.WriteProcessID(pid);; 946 R__b <<",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:4117,Security,access,accessing,4117,"93 ""fBits is not as expected, we got 0x%.8x instead of 0x%.8x"",; 94 *o_fbits, kGoldenbits);; 95 }; 96 if (gDebug >= 9) {; 97 unsigned char *oc = reinterpret_cast<unsigned char *>(o); // for address calculations; 98 unsigned char references[sizeof(TObject)];; 99 memcpy(references, oc, sizeof(TObject));; 100 ; 101 // The effective part of this code (the else statement is just that without; 102 // any of the debug statement); 103 delete o;; 104 ; 105 // Not using the error logger, as there routine is meant to be called; 106 // during library initialization/loading.; 107 fprintf(stderr,; 108 ""DEBUG: Checking before and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a segmentation fault); 120#if defined(_MSC_VER) && defined(__SANITIZE_ADDRESS__); 121 // on Windows, even __declspec(no_sanitize_address) does not prevent catching; 122 // heap-use-after-free errorswhen using the /fsanitize=address compiler flag; 123 // so don't even try; 124 return true;; 125#endif; 126 if ( *o_fbits != 0x01000000 ) {; 127 // operator delete tainted the memory, we can not rely on TestBit(kNotDeleted); 128 return true;; 129 }; 130 return false;; 131}; 132 ; 133bool DeleteChangesMemory(); 134{; 135 static const bool value = DeleteChangesMemoryImpl();; 136 if (gDebug >= 9); 137 DeleteChangesMemoryImpl(); // To allow for printing the debug info; 138 return value;; 139};",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:17559,Security,hash,hash,17559," 472 ; 473char *TObject::GetObjectInfo(Int_t px, Int_t py) const; 474{; 475 if (!gPad) return (char*)"""";; 476 static char info[64];; 477 Float_t x = gPad->AbsPixeltoX(px);; 478 Float_t y = gPad->AbsPixeltoY(py);; 479 snprintf(info,64,""x=%g, y=%g"",gPad->PadtoX(x),gPad->PadtoY(y));; 480 return info;; 481}; 482 ; 483////////////////////////////////////////////////////////////////////////////////; 484/// Returns title of object. This default method returns the class title; 485/// (i.e. description). Classes that give objects a title should override; 486/// this method.; 487 ; 488const char *TObject::GetTitle() const; 489{; 490 return IsA()->GetTitle();; 491}; 492 ; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Execute action in response of a timer timing out. This method; 496/// must be overridden if an object has to react to timers.; 497 ; 498Bool_t TObject::HandleTimer(TTimer *); 499{; 500 return kFALSE;; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Return hash value for this object.; 505///; 506/// Note: If this routine is overloaded in a derived class, this derived class; 507/// should also add; 508/// ~~~ {.cpp}; 509/// ROOT::CallRecursiveRemoveIfNeeded(*this); 510/// ~~~; 511/// Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; 512/// type of object, the transversal of THashList and THashTable containers will; 513/// will have to be done without call Hash (and hence be linear rather than; 514/// logarithmic complexity). You will also see warnings like; 515/// ~~~; 516/// Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; 517/// ~~~; 518///; 519 ; 520ULong_t TObject::Hash() const; 521{; 522 //return (ULong_t) this >> 2;; 523 const void *ptr = this;; 524 return TString::Hash(&ptr, sizeof(void*",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:57049,Security,hash,hash,57049,"efinition TObject.cxx:488; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::~TObjectvirtual ~TObject()TObject destructor.Definition TObject.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display list.Definition TObject.cxx:621; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:520; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::fgObjectStatstatic Bool_t fgObjectStatif true keep track of objects in TObjectTableDefinition TObject.h:48; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; TObject::AddToTObjectTablestatic void AddToTObjectTable(TObject *)Private helper function which will dispatch to TObjectTable::AddObj.Definition TObject.cxx",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:59873,Security,hash,hash,59873," obj->Ge...Definition TProcessID.cxx:297; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TRefTableA TRefTable maintains the association between a referenced object and the parent object supporting th...Definition TRefTable.h:35; TRefTable::GetRefTablestatic TRefTable * GetRefTable()Static function returning the current TRefTable.Definition TRefTable.cxx:287; TRefTable::Addvirtual Int_t Add(Int_t uid, TProcessID *context=nullptr)Add a new uid to the table.Definition TRefTable.cxx:88; TStorage::ObjectDeallocstatic void ObjectDealloc(void *vp)Used to deallocate a TObject on the heap (via TObject::operator delete()).Definition TStorage.cxx:322; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOT::Internal::DeleteChangesMemorybool DeleteChangesMemory()Definition TObject.cxx:133; ROOT::Internal::DeleteChangesMemoryImplbool DeleteChangesMemoryImpl()Definition TObject.cxx:76; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TRO",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:3644,Testability,log,logger,3644,"d but not operator; 73// delete, we can still use it to detect the cases where the destructor was called.; 74 ; 75ATTRIBUTE_NO_SANITIZE_ADDRESS; 76bool DeleteChangesMemoryImpl(); 77{; 78 static constexpr UInt_t kGoldenUUID = 0x00000021;; 79 static constexpr UInt_t kGoldenbits = 0x03000000;; 80 ; 81 TObject *o = new TObject;; 82 o->SetUniqueID(kGoldenUUID);; 83 UInt_t *o_fuid = &(o->fUniqueID);; 84 UInt_t *o_fbits = &(o->fBits);; 85 ; 86 if (*o_fuid != kGoldenUUID) {; 87 Error(""CheckingDeleteSideEffects"",; 88 ""fUniqueID is not as expected, we got 0x%.8x instead of 0x%.8x"",; 89 *o_fuid, kGoldenUUID);; 90 }; 91 if (*o_fbits != kGoldenbits) {; 92 Error(""CheckingDeleteSideEffects"",; 93 ""fBits is not as expected, we got 0x%.8x instead of 0x%.8x"",; 94 *o_fbits, kGoldenbits);; 95 }; 96 if (gDebug >= 9) {; 97 unsigned char *oc = reinterpret_cast<unsigned char *>(o); // for address calculations; 98 unsigned char references[sizeof(TObject)];; 99 memcpy(references, oc, sizeof(TObject));; 100 ; 101 // The effective part of this code (the else statement is just that without; 102 // any of the debug statement); 103 delete o;; 104 ; 105 // Not using the error logger, as there routine is meant to be called; 106 // during library initialization/loading.; 107 fprintf(stderr,; 108 ""DEBUG: Checking before and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a seg",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:5466,Testability,test,test,5466,"gmentation fault); 120#if defined(_MSC_VER) && defined(__SANITIZE_ADDRESS__); 121 // on Windows, even __declspec(no_sanitize_address) does not prevent catching; 122 // heap-use-after-free errorswhen using the /fsanitize=address compiler flag; 123 // so don't even try; 124 return true;; 125#endif; 126 if ( *o_fbits != 0x01000000 ) {; 127 // operator delete tainted the memory, we can not rely on TestBit(kNotDeleted); 128 return true;; 129 }; 130 return false;; 131}; 132 ; 133bool DeleteChangesMemory(); 134{; 135 static const bool value = DeleteChangesMemoryImpl();; 136 if (gDebug >= 9); 137 DeleteChangesMemoryImpl(); // To allow for printing the debug info; 138 return value;; 139}; 140 ; 141}} // ROOT::Detail; 142 ; 143////////////////////////////////////////////////////////////////////////////////; 144/// Copy this to obj.; 145 ; 146void TObject::Copy(TObject &obj) const; 147{; 148 obj.fUniqueID = fUniqueID; // when really unique don't copy; 149 if (obj.IsOnHeap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////////////////; 161/// TObject destructor. Removes object from all canvases and object browsers; 162/// if observer bit is on and remove from the global object table.; 163 ; 164TObject::~TObject(); 165{; 166 // if (!TestBit(kNotDeleted)); 167 // Fatal(""~TObject"", ""object deleted twice"");; 168 ; 169 ROOT::CallRecursiveRemoveIfNeeded(*this);; 170 ; 171 fBits &= ~kNotDeleted;; 172 ; 173 if (fgObjectStat && gObjectTable) gObjectTable->RemoveQuietly(this);; 174}; 175 ; 176////////////////////////////////////////////////////////////////////////////////; 177/// Private helper function which will dispatch to; 178/// TObjectTable::AddObj.; 179/// Included here to avoid circular dependency between head",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:18038,Testability,log,logarithmic,18038,"s title of object. This default method returns the class title; 485/// (i.e. description). Classes that give objects a title should override; 486/// this method.; 487 ; 488const char *TObject::GetTitle() const; 489{; 490 return IsA()->GetTitle();; 491}; 492 ; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Execute action in response of a timer timing out. This method; 496/// must be overridden if an object has to react to timers.; 497 ; 498Bool_t TObject::HandleTimer(TTimer *); 499{; 500 return kFALSE;; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Return hash value for this object.; 505///; 506/// Note: If this routine is overloaded in a derived class, this derived class; 507/// should also add; 508/// ~~~ {.cpp}; 509/// ROOT::CallRecursiveRemoveIfNeeded(*this); 510/// ~~~; 511/// Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; 512/// type of object, the transversal of THashList and THashTable containers will; 513/// will have to be done without call Hash (and hence be linear rather than; 514/// logarithmic complexity). You will also see warnings like; 515/// ~~~; 516/// Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; 517/// ~~~; 518///; 519 ; 520ULong_t TObject::Hash() const; 521{; 522 //return (ULong_t) this >> 2;; 523 const void *ptr = this;; 524 return TString::Hash(&ptr, sizeof(void*));; 525}; 526 ; 527////////////////////////////////////////////////////////////////////////////////; 528/// Returns kTRUE if object inherits from class ""classname"".; 529 ; 530Bool_t TObject::InheritsFrom(const char *classname) const; 531{; 532 return IsA()->InheritsFrom(classname);; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// Returns kTRUE if obje",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:30885,Usability,simpl,simply,30885,"f the file.; 829///; 830/// - The buffer is written to the file.; 831///; 832/// Bufsize can be given to force a given buffer size to write this object.; 833/// By default, the buffersize will be taken from the average buffer size; 834/// of all objects written to the current file so far.; 835///; 836/// If a name is specified, it will be the name of the key.; 837/// If name is not given, the name of the key will be the name as returned; 838/// by GetName().; 839///; 840/// The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete; 841/// Using the kOverwrite option a previous key with the same name is; 842/// overwritten. The previous key is deleted before writing the new object.; 843/// Using the kWriteDelete option a previous key with the same name is; 844/// deleted only after the new object has been written. This option; 845/// is safer than kOverwrite but it is slower.; 846/// NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile--; 847/// the space is simply freed up to be overwritten; in the case of a TTree,; 848/// it is more complicated. If one opens a TTree, appends some entries,; 849/// then writes it out, the behaviour is effectively the same. If, however,; 850/// one creates a new TTree and writes it out in this way,; 851/// only the metadata is replaced, effectively making the old data invisible; 852/// without deleting it. TTree::Delete() can be used to mark all disk space; 853/// occupied by a TTree as free before overwriting its metadata this way.; 854/// The kSingleKey option is only used by TCollection::Write() to write; 855/// a container with a single key instead of each object in the container; 856/// with its own key.; 857///; 858/// An object is read from the file into memory via TKey::Read() or; 859/// via TObject::Read().; 860///; 861/// The function returns the total number of bytes written to the file.; 862/// It returns 0 if the object cannot be written.; 863 ; 864Int_t TObject::Write(const char *name, I",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8cxx_source.html:34046,Usability,simpl,simply,34046,"()) return;; 897 UShort_t pidf;; 898 if (R__b.IsReading()) {; 899 R__b.SkipVersion(); // Version_t R__v = R__b.ReadVersion(); if (R__v) { }; 900 R__b >> fUniqueID;; 901 const UInt_t isonheap = fBits & kIsOnHeap; // Record how this instance was actually allocated.; 902 R__b >> fBits;; 903 fBits |= isonheap | kNotDeleted; // by definition de-serialized object are not yet deleted.; 904 if (TestBit(kIsReferenced)) {; 905 //if the object is referenced, we must read its old address; 906 //and store it in the ProcessID map in gROOT; 907 R__b >> pidf;; 908 pidf += R__b.GetPidOffset();; 909 TProcessID *pid = R__b.ReadProcessID(pidf);; 910 if (pid) {; 911 UInt_t gpid = pid->GetUniqueID();; 912 if (gpid>=0xff) {; 913 fUniqueID = fUniqueID | 0xff000000;; 914 } else {; 915 fUniqueID = ( fUniqueID & 0xffffff) + (gpid<<24);; 916 }; 917 pid->PutObjectWithID(this);; 918 }; 919 }; 920 } else {; 921 R__b.WriteVersion(TObject::IsA());; 922 // Can not read TFile.h here and avoid going through the interpreter by; 923 // simply hard-coding this value.; 924 // This **must** be equal to TFile::k630forwardCompatibility; 925 constexpr int TFile__k630forwardCompatibility = BIT(2);; 926 const auto parent = R__b.GetParent();; 927 if (!TestBit(kIsReferenced)) {; 928 R__b << fUniqueID;; 929 if (R__unlikely(parent && parent->TestBit(TFile__k630forwardCompatibility))); 930 R__b << fBits;; 931 else; 932 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 933 } else {; 934 //if the object is referenced, we must save its address/file_pid; 935 UInt_t uid = fUniqueID & 0xffffff;; 936 R__b << uid;; 937 if (R__unlikely(parent && parent->TestBit(TFile__k630forwardCompatibility))); 938 R__b << fBits;; 939 else; 940 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 941 TProcessID *pid = TProcessID::GetProcessWithUID(fUniqueID,this);; 942 //add uid to the TRefTable if there is one; 943 TRefTable *table = TRefTable::GetRefTable();; 944 if(table) table->Add(uid, pid);; 945 pidf = R__b.WriteProcessID(pid);; 946 R__b <<",MatchSource.WIKI,doc/master/TObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html
https://root.cern/doc/master/TObject_8h_source.html:5294,Availability,error,error,5294,"lass and TTree::Merge); 106 kOnlyPrepStep = BIT(3); 107 };; 108 ; 109public:; 110 ; 111 TObject();; 112 TObject(const TObject &object);; 113 TObject &operator=(const TObject &rhs);; 114 virtual ~TObject();; 115 ; 116 virtual void AppendPad(Option_t *option="""");; 117 virtual void Browse(TBrowser *b);; 118 virtual const char *ClassName() const;; 119 virtual void Clear(Option_t * /*option*/ ="""") { }; 120 ULong_t CheckedHash(); // Not virtual; 121 virtual TObject *Clone(const char *newname="""") const;; 122 virtual Int_t Compare(const TObject *obj) const;; 123 virtual void Copy(TObject &object) const;; 124 virtual void Delete(Option_t *option=""""); // *MENU*; 125 virtual Int_t DistancetoPrimitive(Int_t px, Int_t py);; 126 virtual void Draw(Option_t *option="""");; 127 virtual void DrawClass() const; // *MENU*; 128 virtual TObject *DrawClone(Option_t *option="""") const; // *MENU*; 129 virtual void Dump() const; // *MENU*; 130 virtual void Execute(const char *method, const char *params, Int_t *error = nullptr);; 131 virtual void Execute(TMethod *method, TObjArray *params, Int_t *error = nullptr);; 132 virtual void ExecuteEvent(Int_t event, Int_t px, Int_t py);; 133 virtual TObject *FindObject(const char *name) const;; 134 virtual TObject *FindObject(const TObject *obj) const;; 135 virtual Option_t *GetDrawOption() const;; 136 virtual UInt_t GetUniqueID() const;; 137 virtual const char *GetName() const;; 138 virtual const char *GetIconName() const;; 139 virtual Option_t *GetOption() const { return """"; }; 140 virtual char *GetObjectInfo(Int_t px, Int_t py) const;; 141 virtual const char *GetTitle() const;; 142 virtual Bool_t HandleTimer(TTimer *timer);; 143 Bool_t HasInconsistentHash() const;; 144 virtual ULong_t Hash() const;; 145 virtual Bool_t InheritsFrom(const char *classname) const;; 146 virtual Bool_t InheritsFrom(const TClass *cl) const;; 147 virtual void Inspect() const; // *MENU*; 148 virtual Bool_t IsFolder() const;; 149 virtual Bool_t IsEqual(const TObject *obj) const",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:5381,Availability,error,error,5381," TObject();; 112 TObject(const TObject &object);; 113 TObject &operator=(const TObject &rhs);; 114 virtual ~TObject();; 115 ; 116 virtual void AppendPad(Option_t *option="""");; 117 virtual void Browse(TBrowser *b);; 118 virtual const char *ClassName() const;; 119 virtual void Clear(Option_t * /*option*/ ="""") { }; 120 ULong_t CheckedHash(); // Not virtual; 121 virtual TObject *Clone(const char *newname="""") const;; 122 virtual Int_t Compare(const TObject *obj) const;; 123 virtual void Copy(TObject &object) const;; 124 virtual void Delete(Option_t *option=""""); // *MENU*; 125 virtual Int_t DistancetoPrimitive(Int_t px, Int_t py);; 126 virtual void Draw(Option_t *option="""");; 127 virtual void DrawClass() const; // *MENU*; 128 virtual TObject *DrawClone(Option_t *option="""") const; // *MENU*; 129 virtual void Dump() const; // *MENU*; 130 virtual void Execute(const char *method, const char *params, Int_t *error = nullptr);; 131 virtual void Execute(TMethod *method, TObjArray *params, Int_t *error = nullptr);; 132 virtual void ExecuteEvent(Int_t event, Int_t px, Int_t py);; 133 virtual TObject *FindObject(const char *name) const;; 134 virtual TObject *FindObject(const TObject *obj) const;; 135 virtual Option_t *GetDrawOption() const;; 136 virtual UInt_t GetUniqueID() const;; 137 virtual const char *GetName() const;; 138 virtual const char *GetIconName() const;; 139 virtual Option_t *GetOption() const { return """"; }; 140 virtual char *GetObjectInfo(Int_t px, Int_t py) const;; 141 virtual const char *GetTitle() const;; 142 virtual Bool_t HandleTimer(TTimer *timer);; 143 Bool_t HasInconsistentHash() const;; 144 virtual ULong_t Hash() const;; 145 virtual Bool_t InheritsFrom(const char *classname) const;; 146 virtual Bool_t InheritsFrom(const TClass *cl) const;; 147 virtual void Inspect() const; // *MENU*; 148 virtual Bool_t IsFolder() const;; 149 virtual Bool_t IsEqual(const TObject *obj) const;; 150 virtual Bool_t IsSortable() const { return kFALSE; }; 151 ; 152 R__ALWAYS_INLINE",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:8904,Availability,error,error,8904,"new with placement).; 176 ///; 177 /// \return true if this object's destructor has been run.; 178 Bool_t IsDestructed() const { return !TestBit(kNotDeleted); }; 179 ; 180 //----- operators; 181 void *operator new(size_t sz) { return TStorage::ObjectAlloc(sz); }; 182 void *operator new[](size_t sz) { return TStorage::ObjectAllocArray(sz); }; 183 void *operator new(size_t sz, void *vp) { return TStorage::ObjectAlloc(sz, vp); }; 184 void *operator new[](size_t sz, void *vp) { return TStorage::ObjectAlloc(sz, vp); }; 185 void operator delete(void *ptr);; 186 void operator delete[](void *ptr);; 187#ifdef R__SIZEDDELETE; 188 // Sized deallocation.; 189 void operator delete(void*, size_t);; 190 void operator delete[](void*, size_t);; 191#endif; 192 void operator delete(void *ptr, void *vp);; 193 void operator delete[](void *ptr, void *vp);; 194 ; 195 //----- bit manipulation; 196 void SetBit(UInt_t f, Bool_t set);; 197 void SetBit(UInt_t f) { fBits |= f & kBitMask; }; 198 void ResetBit(UInt_t f) { fBits &= ~(f & kBitMask); }; 199 R__ALWAYS_INLINE Bool_t TestBit(UInt_t f) const { return (Bool_t) ((fBits & f) != 0); }; 200 Int_t TestBits(UInt_t f) const { return (Int_t) (fBits & f); }; 201 void InvertBit(UInt_t f) { fBits ^= f & kBitMask; }; 202 ; 203 //---- error handling; 204 virtual void Info(const char *method, const char *msgfmt, ...) const; 205#if defined(__GNUC__); 206 __attribute__((format(printf, 3, 4))) /* 1 is the this pointer */; 207#endif; 208 ;; 209 virtual void Warning(const char *method, const char *msgfmt, ...) const; 210#if defined(__GNUC__); 211 __attribute__((format(printf, 3, 4))) /* 1 is the this pointer */; 212#endif; 213 ;; 214 virtual void Error(const char *method, const char *msgfmt, ...) const; 215#if defined(__GNUC__); 216 __attribute__((format(printf, 3, 4))) /* 1 is the this pointer */; 217#endif; 218 ;; 219 virtual void SysError(const char *method, const char *msgfmt, ...) const; 220#if defined(__GNUC__); 221 __attribute__((format(printf, 3, 4",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:16398,Availability,error,error,16398,"e Bool_t TObject::HasInconsistentHash() const; 359{; 360 return fBits & kInconsistent;; 361}; 362 ; 363// Global bits (can be set for any object and should not be reused).; 364// Only here for backward compatibility reasons.; 365// For detailed description see TObject::EStatusBits above.; 366enum EObjBits {; 367 kCanDelete = TObject::kCanDelete,; 368 kMustCleanup = TObject::kMustCleanup,; 369 kObjInCanvas = TObject::kObjInCanvas,; 370 kIsReferenced = TObject::kIsReferenced,; 371 kHasUUID = TObject::kHasUUID,; 372 kCannotPick = TObject::kCannotPick,; 373 kNoContextMenu = TObject::kNoContextMenu,; 374 kInvalidObject = TObject::kInvalidObject; 375};; 376 ; 377namespace cling {; 378 std::string printValue(TObject *val);; 379}; 380 ; 381namespace ROOT {; 382 ; 383namespace Internal {; 384 bool DeleteChangesMemory();; 385} // Internal; 386 ; 387namespace Detail {; 388 ; 389 ; 390/// @brief Check if the TObject's memory has been deleted.; 391/// @warning This should be only used for error mitigation as the answer is only; 392/// sometimes correct. It actually just checks whether the object has been; 393/// deleted, so this will falsely return true for an object that has; 394/// been destructed but its memory has not been deleted. This will return an; 395/// undefined value if the memory is re-used between the deletion and the check.; 396/// i.e. This is useful to prevent a segmentation fault in case where the problem; 397/// can be detected when the deletion and the usage are 'close-by'; 398/// @warning In enviroment where delete taints (changes) the memory, this function; 399/// always returns false as the marker left by ~TObject will be overwritten.; 400/// @param obj The memory to check; 401/// @return true if the object has been destructed and it can be inferred that it has been deleted; 402R__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj) {; 403 return !ROOT::Internal::DeleteChangesMemory() && obj->IsDestructed();; 404}; 405 ; 406}} // ROOT::Details; 407 ; 408#",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:16809,Availability,fault,fault,16809,"72 kCannotPick = TObject::kCannotPick,; 373 kNoContextMenu = TObject::kNoContextMenu,; 374 kInvalidObject = TObject::kInvalidObject; 375};; 376 ; 377namespace cling {; 378 std::string printValue(TObject *val);; 379}; 380 ; 381namespace ROOT {; 382 ; 383namespace Internal {; 384 bool DeleteChangesMemory();; 385} // Internal; 386 ; 387namespace Detail {; 388 ; 389 ; 390/// @brief Check if the TObject's memory has been deleted.; 391/// @warning This should be only used for error mitigation as the answer is only; 392/// sometimes correct. It actually just checks whether the object has been; 393/// deleted, so this will falsely return true for an object that has; 394/// been destructed but its memory has not been deleted. This will return an; 395/// undefined value if the memory is re-used between the deletion and the check.; 396/// i.e. This is useful to prevent a segmentation fault in case where the problem; 397/// can be detected when the deletion and the usage are 'close-by'; 398/// @warning In enviroment where delete taints (changes) the memory, this function; 399/// always returns false as the marker left by ~TObject will be overwritten.; 400/// @param obj The memory to check; 401/// @return true if the object has been destructed and it can be inferred that it has been deleted; 402R__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj) {; 403 return !ROOT::Internal::DeleteChangesMemory() && obj->IsDestructed();; 404}; 405 ; 406}} // ROOT::Details; 407 ; 408#endif; R__ALWAYS_INLINE#define R__ALWAYS_INLINEDefinition RConfig.hxx:552; R__likely#define R__likely(expr)Definition RConfig.hxx:587; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; UInt_tunsigned int UInt_tDefinition Rtype",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:25241,Availability,error,error,25241,"Int_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::kIsOnHeap@ kIsOnHeapobject is on heapDefinition TObject.h:81; TObject::kNotDeleted@ kNotDeletedobject has not been deletedDefinition TObject.h:82; TObject::kBitMask@ kBitMaskDefinition TObject.h:86; TObject::kZombie@ kZombieobject ctor failedDefinition TObject.h:83; TObject::kInconsistent@ kInconsistentclass overload Hash but does call RecursiveRemove in destructorDefinition TObject.h:84; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; TObject::IsSortablevirtual Bool_t IsSortable() constDefinition TObject.h:150; TObject::GetOptionvirtual Option_t * GetOption() constDefinition TObject.h:139; TObject::fgDtorOnlystatic Longptr_t fgDtorOnlyobject for which to call dtor only (i.e. no delete)Definition TObject.h:47; TObject::InvertBitvoid InvertBit(UInt_t f)Definition TObject.h:201; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDra",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:26730,Availability,error,error,26730,"_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TObject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::GetObjectInfovirtual char * GetObjectInfo(Int_t px, Int_t py) constReturns string containing info about the object at position (px,py).Definition TObject.cxx:473; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:28689,Availability,error,error,28689,"objects to ...Definition TObject.h:106; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::EDeprecatedStatusBitsEDeprecatedStatusBitsDefinition TObject.h:75; TObject::kObjInCanvas@ kObjInCanvasfor backward compatibility only, use kMustCleanupDefinition TObject.h:76; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::TestBitsInt_t TestBits(UInt_t f)",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:28952,Availability,error,error,28952,"Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::EDeprecatedStatusBitsEDeprecatedStatusBitsDefinition TObject.h:75; TObject::kObjInCanvas@ kObjInCanvasfor backward compatibility only, use kMustCleanupDefinition TObject.h:76; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::TestBitsInt_t TestBits(UInt_t f) constDefinition TObject.h:200; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::~TObjectvirtual ~TObject()TObject destructo",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:10767,Energy Efficiency,allocate,allocated,10767,", const char *msgfmt, ...) const; 225#if defined(__GNUC__); 226 __attribute__((format(printf, 3, 4))) /* 1 is the this pointer */; 227#endif; 228 ;; 229 ; 230 void AbstractMethod(const char *method) const;; 231 void MayNotUse(const char *method) const;; 232 void Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) const;; 233 ; 234 //---- static functions; 235 static Longptr_t GetDtorOnly();; 236 static void SetDtorOnly(void *obj);; 237 static Bool_t GetObjectStat();; 238 static void SetObjectStat(Bool_t stat);; 239 ; 240 friend class TClonesArray; // needs to reset kNotDeleted in fBits; 241 friend bool ROOT::Internal::DeleteChangesMemoryImpl();; 242 ; 243 ClassDef(TObject,1) //Basic ROOT object; 244};; 245 ; 246////////////////////////////////////////////////////////////////////////////////; 247/// TObject constructor. It sets the two data words of TObject to their; 248/// initial values. The unique ID is set to 0 and the status word is; 249/// set depending if the object is created on the stack or allocated; 250/// on the heap. Depending on the ROOT environment variable ""Root.ObjStat""; 251/// (see TEnv) the object is added to the global TObjectTable for; 252/// bookkeeping.; 253 ; 254inline TObject::TObject() : fBits(kNotDeleted) // Need to leave fUniqueID unset; 255{; 256 // This will be reported by valgrind as uninitialized memory reads for; 257 // object created on the stack, use $ROOTSYS/etc/valgrind-root.supp; 258 TStorage::UpdateIsOnHeap(fUniqueID, fBits);; 259 ; 260 fUniqueID = 0;; 261 ; 262#ifdef R__WIN32; 263 if (R__unlikely(GetObjectStat())) TObject::AddToTObjectTable(this);; 264#else; 265 if (R__unlikely(fgObjectStat)) TObject::AddToTObjectTable(this);; 266#endif; 267}; 268 ; 269////////////////////////////////////////////////////////////////////////////////; 270/// TObject copy ctor.; 271 ; 272inline TObject::TObject(const TObject &obj); 273{; 274 fBits = obj.fBits;; 275 ; 276 // This will be reported by valgrind as uninitiali",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:32491,Energy Efficiency,allocate,allocate,32491,"if object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; TObject::AddToTObjectTablestatic void AddToTObjectTable(TObject *)Private helper function which will dispatch to TObjectTable::AddObj.Definition TObject.cxx:181; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TStorage::UpdateIsOnHeapstatic void UpdateIsOnHeap(volatile const UInt_t &uniqueID, volatile UInt_t &bits)Definition TStorage.h:123; TStorage::ObjectAllocArraystatic void * ObjectAllocArray(size_t size)Used to allocate array of TObject on the heap (via TObject::operator new[]()).Definition TStorage.cxx:303; TStorage::ObjectAllocstatic void * ObjectAlloc(size_t size)Used to allocate a TObject on the heap (via TObject::operator new()).Definition TStorage.cxx:291; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; bool; int; unsigned int; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::Internal::DeleteChangesMemorybool DeleteChangesMemory()Definition TObject.cxx:133; ROOT::Internal::DeleteChangesMemoryImplbool DeleteChangesMemoryImpl()Definition TObject.cxx:76; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Drawth1 Draw(). corebaseincTObject.h. ROOT master - Reference Guide Generated on Tue No",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:32657,Energy Efficiency,allocate,allocate,32657,"n TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; TObject::AddToTObjectTablestatic void AddToTObjectTable(TObject *)Private helper function which will dispatch to TObjectTable::AddObj.Definition TObject.cxx:181; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TStorage::UpdateIsOnHeapstatic void UpdateIsOnHeap(volatile const UInt_t &uniqueID, volatile UInt_t &bits)Definition TStorage.h:123; TStorage::ObjectAllocArraystatic void * ObjectAllocArray(size_t size)Used to allocate array of TObject on the heap (via TObject::operator new[]()).Definition TStorage.cxx:303; TStorage::ObjectAllocstatic void * ObjectAlloc(size_t size)Used to allocate a TObject on the heap (via TObject::operator new()).Definition TStorage.cxx:291; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; bool; int; unsigned int; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::Internal::DeleteChangesMemorybool DeleteChangesMemory()Definition TObject.cxx:133; ROOT::Internal::DeleteChangesMemoryImplbool DeleteChangesMemoryImpl()Definition TObject.cxx:76; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Drawth1 Draw(). corebaseincTObject.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:10716,Integrability,depend,depending,10716,", const char *msgfmt, ...) const; 225#if defined(__GNUC__); 226 __attribute__((format(printf, 3, 4))) /* 1 is the this pointer */; 227#endif; 228 ;; 229 ; 230 void AbstractMethod(const char *method) const;; 231 void MayNotUse(const char *method) const;; 232 void Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) const;; 233 ; 234 //---- static functions; 235 static Longptr_t GetDtorOnly();; 236 static void SetDtorOnly(void *obj);; 237 static Bool_t GetObjectStat();; 238 static void SetObjectStat(Bool_t stat);; 239 ; 240 friend class TClonesArray; // needs to reset kNotDeleted in fBits; 241 friend bool ROOT::Internal::DeleteChangesMemoryImpl();; 242 ; 243 ClassDef(TObject,1) //Basic ROOT object; 244};; 245 ; 246////////////////////////////////////////////////////////////////////////////////; 247/// TObject constructor. It sets the two data words of TObject to their; 248/// initial values. The unique ID is set to 0 and the status word is; 249/// set depending if the object is created on the stack or allocated; 250/// on the heap. Depending on the ROOT environment variable ""Root.ObjStat""; 251/// (see TEnv) the object is added to the global TObjectTable for; 252/// bookkeeping.; 253 ; 254inline TObject::TObject() : fBits(kNotDeleted) // Need to leave fUniqueID unset; 255{; 256 // This will be reported by valgrind as uninitialized memory reads for; 257 // object created on the stack, use $ROOTSYS/etc/valgrind-root.supp; 258 TStorage::UpdateIsOnHeap(fUniqueID, fBits);; 259 ; 260 fUniqueID = 0;; 261 ; 262#ifdef R__WIN32; 263 if (R__unlikely(GetObjectStat())) TObject::AddToTObjectTable(this);; 264#else; 265 if (R__unlikely(fgObjectStat)) TObject::AddToTObjectTable(this);; 266#endif; 267}; 268 ; 269////////////////////////////////////////////////////////////////////////////////; 270/// TObject copy ctor.; 271 ; 272inline TObject::TObject(const TObject &obj); 273{; 274 fBits = obj.fBits;; 275 ; 276 // This will be reported by valgrind as uninitiali",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:13107,Integrability,rout,routine,13107,"88#else; 289 if (R__unlikely(fgObjectStat)) TObject::AddToTObjectTable(this);; 290#endif; 291}; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// TObject assignment operator.; 295 ; 296inline TObject &TObject::operator=(const TObject &rhs); 297{; 298 if (R__likely(this != &rhs)) {; 299 fUniqueID = rhs.fUniqueID; // when really unique don't copy; 300 if (IsOnHeap()) { // test uses fBits so don't move next line; 301 fBits = rhs.fBits;; 302 fBits |= kIsOnHeap;; 303 } else {; 304 fBits = rhs.fBits;; 305 fBits &= ~kIsOnHeap;; 306 }; 307 fBits &= ~kIsReferenced;; 308 fBits &= ~kCanDelete;; 309 }; 310 return *this;; 311}; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// @brief Check and record whether this class has a consistent; 316/// Hash/RecursiveRemove setup (*) and then return the regular Hash value for; 317/// this object. The intent is for this routine to be called instead of directly; 318/// calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; 319///; 320/// (*) The setup is consistent when all classes in the class hierarchy that overload; 321/// TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 322/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 323 ; 324inline ULong_t TObject::CheckedHash(); 325{; 326 // Testing and recording whether we already called HasInconstistentTObjectHash; 327 // for this object could save some cpu cycles in some circuntances (at the cost; 328 // of reserving yet another bit).; 329 // For each insert (CheckedHash is called only for insert in THashList/THashTable), it; 330 // cost one memory fetch, one arithmetic operation and one branching.; 331 // This save a virtual function call which itself contains a static variable memory; 332 // fetch, a branching (of whether the static was already set or not).; 333 // Given that a v",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:15049,Integrability,rout,routine,15049,"h, a branching (of whether the static was already set or not).; 333 // Given that a virtual function call is essentially 2 memory fetches (virtual table; 334 // location and then content), one arithmetic operation and one function call/jump),; 335 // we guess-estimate that the version recording-then-testing-prior-check would start; 336 // saving cpu cycle when each object is inserted in average 1.5 times in a THashList/THashTable.; 337 ; 338 // if ( !fBits & kCheckedHash) {; 339 if (!CheckTObjectHashConsistency()); 340 fBits |= kInconsistent;; 341 // fBits &= kChecked;; 342 //}; 343 return Hash();; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// @brief Return true is the type of this object is *known* to have an; 348/// inconsistent setup for Hash and RecursiveRemove (i.e. missing call to; 349/// RecursiveRemove in destructor).; 350///; 351/// Note: Since the consistency is only tested for during inserts, this; 352/// routine will return true for object that have never been inserted; 353/// whether or not they have a consistent setup. This has no negative; 354/// side-effect as searching for the object with the right or wrong; 355/// Hash will always yield a not-found answer (Since anyway no hash; 356/// can be guaranteed unique, there is always a check); 357 ; 358inline Bool_t TObject::HasInconsistentHash() const; 359{; 360 return fBits & kInconsistent;; 361}; 362 ; 363// Global bits (can be set for any object and should not be reused).; 364// Only here for backward compatibility reasons.; 365// For detailed description see TObject::EStatusBits above.; 366enum EObjBits {; 367 kCanDelete = TObject::kCanDelete,; 368 kMustCleanup = TObject::kMustCleanup,; 369 kObjInCanvas = TObject::kObjInCanvas,; 370 kIsReferenced = TObject::kIsReferenced,; 371 kHasUUID = TObject::kHasUUID,; 372 kCannotPick = TObject::kCannotPick,; 373 kNoContextMenu = TObject::kNoContextMenu,; 374 kInvalidObject = TObject::kInvalidObject; 375};;",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:25247,Integrability,message,message,25247,"Int_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::kIsOnHeap@ kIsOnHeapobject is on heapDefinition TObject.h:81; TObject::kNotDeleted@ kNotDeletedobject has not been deletedDefinition TObject.h:82; TObject::kBitMask@ kBitMaskDefinition TObject.h:86; TObject::kZombie@ kZombieobject ctor failedDefinition TObject.h:83; TObject::kInconsistent@ kInconsistentclass overload Hash but does call RecursiveRemove in destructorDefinition TObject.h:84; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; TObject::IsSortablevirtual Bool_t IsSortable() constDefinition TObject.h:150; TObject::GetOptionvirtual Option_t * GetOption() constDefinition TObject.h:139; TObject::fgDtorOnlystatic Longptr_t fgDtorOnlyobject for which to call dtor only (i.e. no delete)Definition TObject.h:47; TObject::InvertBitvoid InvertBit(UInt_t f)Definition TObject.h:201; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDra",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:25936,Integrability,message,message,25936,"ition TObject.h:139; TObject::fgDtorOnlystatic Longptr_t fgDtorOnlyobject for which to call dtor only (i.e. no delete)Definition TObject.h:47; TObject::InvertBitvoid InvertBit(UInt_t f)Definition TObject.h:201; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TObject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to curr",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:28695,Integrability,message,message,28695,"objects to ...Definition TObject.h:106; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::EDeprecatedStatusBitsEDeprecatedStatusBitsDefinition TObject.h:75; TObject::kObjInCanvas@ kObjInCanvasfor backward compatibility only, use kMustCleanupDefinition TObject.h:76; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::TestBitsInt_t TestBits(UInt_t f)",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:28958,Integrability,message,message,28958,"Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::EDeprecatedStatusBitsEDeprecatedStatusBitsDefinition TObject.h:75; TObject::kObjInCanvas@ kObjInCanvasfor backward compatibility only, use kMustCleanupDefinition TObject.h:76; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::TestBitsInt_t TestBits(UInt_t f) constDefinition TObject.h:200; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::~TObjectvirtual ~TObject()TObject destructo",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:32064,Integrability,message,message,32064,"enu@ kNoContextMenuif object does not want context menuDefinition TObject.h:69; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kHasUUID@ kHasUUIDif object has a TUUID (its fUniqueID=UUIDNumber)Definition TObject.h:66; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; TObject::AddToTObjectTablestatic void AddToTObjectTable(TObject *)Private helper function which will dispatch to TObjectTable::AddObj.Definition TObject.cxx:181; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TStorage::UpdateIsOnHeapstatic void UpdateIsOnHeap(volatile const UInt_t &uniqueID, volatile UInt_t &bits)Definition TStorage.h:123; TStorage::ObjectAllocArraystatic void * ObjectAllocArray(size_t size)Used to allocate array of TObject on the heap (via TObject::operator new[]()).Definition TStorage.cxx:303; TStorage::ObjectAllocstatic void * ObjectAlloc(size_t size)Used to allocate a TObject on the heap (via TObject::operator new()).Definition TStorage.cxx:291; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; bool; int; unsigned int; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::Internal::DeleteChangesMemorybool DeleteCha",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:10832,Modifiability,variab,variable,10832,"4))) /* 1 is the this pointer */; 227#endif; 228 ;; 229 ; 230 void AbstractMethod(const char *method) const;; 231 void MayNotUse(const char *method) const;; 232 void Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) const;; 233 ; 234 //---- static functions; 235 static Longptr_t GetDtorOnly();; 236 static void SetDtorOnly(void *obj);; 237 static Bool_t GetObjectStat();; 238 static void SetObjectStat(Bool_t stat);; 239 ; 240 friend class TClonesArray; // needs to reset kNotDeleted in fBits; 241 friend bool ROOT::Internal::DeleteChangesMemoryImpl();; 242 ; 243 ClassDef(TObject,1) //Basic ROOT object; 244};; 245 ; 246////////////////////////////////////////////////////////////////////////////////; 247/// TObject constructor. It sets the two data words of TObject to their; 248/// initial values. The unique ID is set to 0 and the status word is; 249/// set depending if the object is created on the stack or allocated; 250/// on the heap. Depending on the ROOT environment variable ""Root.ObjStat""; 251/// (see TEnv) the object is added to the global TObjectTable for; 252/// bookkeeping.; 253 ; 254inline TObject::TObject() : fBits(kNotDeleted) // Need to leave fUniqueID unset; 255{; 256 // This will be reported by valgrind as uninitialized memory reads for; 257 // object created on the stack, use $ROOTSYS/etc/valgrind-root.supp; 258 TStorage::UpdateIsOnHeap(fUniqueID, fBits);; 259 ; 260 fUniqueID = 0;; 261 ; 262#ifdef R__WIN32; 263 if (R__unlikely(GetObjectStat())) TObject::AddToTObjectTable(this);; 264#else; 265 if (R__unlikely(fgObjectStat)) TObject::AddToTObjectTable(this);; 266#endif; 267}; 268 ; 269////////////////////////////////////////////////////////////////////////////////; 270/// TObject copy ctor.; 271 ; 272inline TObject::TObject(const TObject &obj); 273{; 274 fBits = obj.fBits;; 275 ; 276 // This will be reported by valgrind as uninitialized memory reads for; 277 // object created on the stack, use $ROOTSYS/etc/valgrind-root.supp; 2",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:14033,Modifiability,variab,variable,14033,"egular Hash value for; 317/// this object. The intent is for this routine to be called instead of directly; 318/// calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; 319///; 320/// (*) The setup is consistent when all classes in the class hierarchy that overload; 321/// TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 322/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 323 ; 324inline ULong_t TObject::CheckedHash(); 325{; 326 // Testing and recording whether we already called HasInconstistentTObjectHash; 327 // for this object could save some cpu cycles in some circuntances (at the cost; 328 // of reserving yet another bit).; 329 // For each insert (CheckedHash is called only for insert in THashList/THashTable), it; 330 // cost one memory fetch, one arithmetic operation and one branching.; 331 // This save a virtual function call which itself contains a static variable memory; 332 // fetch, a branching (of whether the static was already set or not).; 333 // Given that a virtual function call is essentially 2 memory fetches (virtual table; 334 // location and then content), one arithmetic operation and one function call/jump),; 335 // we guess-estimate that the version recording-then-testing-prior-check would start; 336 // saving cpu cycle when each object is inserted in average 1.5 times in a THashList/THashTable.; 337 ; 338 // if ( !fBits & kCheckedHash) {; 339 if (!CheckTObjectHashConsistency()); 340 fBits |= kInconsistent;; 341 // fBits &= kChecked;; 342 //}; 343 return Hash();; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// @brief Return true is the type of this object is *known* to have an; 348/// inconsistent setup for Hash and RecursiveRemove (i.e. missing call to; 349/// RecursiveRemove in destructor).; 350///; 351/// Note: Since the consistency is only tested for during inserts, this;",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:28332,Modifiability,inherit,inherits,28332,"ition TObject.cxx:757; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::GetDtorOnlystatic Longptr_t GetDtorOnly()Return destructor only flag.Definition TObject.cxx:1082; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Def",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:29562,Modifiability,inherit,inheritance,29562,"y this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetDtorOnlystatic void SetDtorOnly(void *obj)Set destructor only flag.Definition TObject.cxx:1090; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::EDeprecatedStatusBitsEDeprecatedStatusBitsDefinition TObject.h:75; TObject::kObjInCanvas@ kObjInCanvasfor backward compatibility only, use kMustCleanupDefinition TObject.h:76; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::TestBitsInt_t TestBits(UInt_t f) constDefinition TObject.h:200; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::~TObjectvirtual ~TObject()TObject destructor.Definition TObject.cxx:164; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display list.Definition TObject.cxx:621; TObject::TObjectTObject()TObject constructor.Definition TObject.h:254; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObjec",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:13454,Safety,safe,safe,13454,"ID = rhs.fUniqueID; // when really unique don't copy; 300 if (IsOnHeap()) { // test uses fBits so don't move next line; 301 fBits = rhs.fBits;; 302 fBits |= kIsOnHeap;; 303 } else {; 304 fBits = rhs.fBits;; 305 fBits &= ~kIsOnHeap;; 306 }; 307 fBits &= ~kIsReferenced;; 308 fBits &= ~kCanDelete;; 309 }; 310 return *this;; 311}; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// @brief Check and record whether this class has a consistent; 316/// Hash/RecursiveRemove setup (*) and then return the regular Hash value for; 317/// this object. The intent is for this routine to be called instead of directly; 318/// calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; 319///; 320/// (*) The setup is consistent when all classes in the class hierarchy that overload; 321/// TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 322/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 323 ; 324inline ULong_t TObject::CheckedHash(); 325{; 326 // Testing and recording whether we already called HasInconstistentTObjectHash; 327 // for this object could save some cpu cycles in some circuntances (at the cost; 328 // of reserving yet another bit).; 329 // For each insert (CheckedHash is called only for insert in THashList/THashTable), it; 330 // cost one memory fetch, one arithmetic operation and one branching.; 331 // This save a virtual function call which itself contains a static variable memory; 332 // fetch, a branching (of whether the static was already set or not).; 333 // Given that a virtual function call is essentially 2 memory fetches (virtual table; 334 // location and then content), one arithmetic operation and one function call/jump),; 335 // we guess-estimate that the version recording-then-testing-prior-check would start; 336 // saving cpu cycle when each object is inserted in average 1.5 times in a THashList/THash",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:16856,Safety,detect,detected,16856,"72 kCannotPick = TObject::kCannotPick,; 373 kNoContextMenu = TObject::kNoContextMenu,; 374 kInvalidObject = TObject::kInvalidObject; 375};; 376 ; 377namespace cling {; 378 std::string printValue(TObject *val);; 379}; 380 ; 381namespace ROOT {; 382 ; 383namespace Internal {; 384 bool DeleteChangesMemory();; 385} // Internal; 386 ; 387namespace Detail {; 388 ; 389 ; 390/// @brief Check if the TObject's memory has been deleted.; 391/// @warning This should be only used for error mitigation as the answer is only; 392/// sometimes correct. It actually just checks whether the object has been; 393/// deleted, so this will falsely return true for an object that has; 394/// been destructed but its memory has not been deleted. This will return an; 395/// undefined value if the memory is re-used between the deletion and the check.; 396/// i.e. This is useful to prevent a segmentation fault in case where the problem; 397/// can be detected when the deletion and the usage are 'close-by'; 398/// @warning In enviroment where delete taints (changes) the memory, this function; 399/// always returns false as the marker left by ~TObject will be overwritten.; 400/// @param obj The memory to check; 401/// @return true if the object has been destructed and it can be inferred that it has been deleted; 402R__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj) {; 403 return !ROOT::Internal::DeleteChangesMemory() && obj->IsDestructed();; 404}; 405 ; 406}} // ROOT::Details; 407 ; 408#endif; R__ALWAYS_INLINE#define R__ALWAYS_INLINEDefinition RConfig.hxx:552; R__likely#define R__likely(expr)Definition RConfig.hxx:587; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; UInt_tunsigned int UInt_tDefinition Rtype",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:15328,Security,hash,hash,15328,"ior-check would start; 336 // saving cpu cycle when each object is inserted in average 1.5 times in a THashList/THashTable.; 337 ; 338 // if ( !fBits & kCheckedHash) {; 339 if (!CheckTObjectHashConsistency()); 340 fBits |= kInconsistent;; 341 // fBits &= kChecked;; 342 //}; 343 return Hash();; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// @brief Return true is the type of this object is *known* to have an; 348/// inconsistent setup for Hash and RecursiveRemove (i.e. missing call to; 349/// RecursiveRemove in destructor).; 350///; 351/// Note: Since the consistency is only tested for during inserts, this; 352/// routine will return true for object that have never been inserted; 353/// whether or not they have a consistent setup. This has no negative; 354/// side-effect as searching for the object with the right or wrong; 355/// Hash will always yield a not-found answer (Since anyway no hash; 356/// can be guaranteed unique, there is always a check); 357 ; 358inline Bool_t TObject::HasInconsistentHash() const; 359{; 360 return fBits & kInconsistent;; 361}; 362 ; 363// Global bits (can be set for any object and should not be reused).; 364// Only here for backward compatibility reasons.; 365// For detailed description see TObject::EStatusBits above.; 366enum EObjBits {; 367 kCanDelete = TObject::kCanDelete,; 368 kMustCleanup = TObject::kMustCleanup,; 369 kObjInCanvas = TObject::kObjInCanvas,; 370 kIsReferenced = TObject::kIsReferenced,; 371 kHasUUID = TObject::kHasUUID,; 372 kCannotPick = TObject::kCannotPick,; 373 kNoContextMenu = TObject::kNoContextMenu,; 374 kInvalidObject = TObject::kInvalidObject; 375};; 376 ; 377namespace cling {; 378 std::string printValue(TObject *val);; 379}; 380 ; 381namespace ROOT {; 382 ; 383namespace Internal {; 384 bool DeleteChangesMemory();; 385} // Internal; 386 ; 387namespace Detail {; 388 ; 389 ; 390/// @brief Check if the TObject's memory has been deleted.; 391/// @warning This",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:30515,Security,hash,hash,30515,"; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::TestBitsInt_t TestBits(UInt_t f) constDefinition TObject.h:200; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::~TObjectvirtual ~TObject()TObject destructor.Definition TObject.cxx:164; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display list.Definition TObject.cxx:621; TObject::TObjectTObject()TObject constructor.Definition TObject.h:254; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:520; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::fgObjectStatstatic Bool_t fgObjectStatif true keep track of objects in TObjectTableDefinition TObject.h:48; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::EStatusBitsEStatusBitsDefinition TObject.h:61; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kNoContextMenu@ kNoContextMenuif object does not want context menuDefinition TObject.h:69; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kHasUUID@ kHasUUIDif object has a TUUID (its fUniqueID=UUIDNumber)Definition TObject.h:66; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kIsReferenced@ kIsReferencedif object is refe",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:2833,Testability,test,test,2833,"destructor must call RecursiveRemove(); 65 kIsReferenced = BIT(4), ///< if object is referenced by a TRef or TRefArray; 66 kHasUUID = BIT(5), ///< if object has a TUUID (its fUniqueID=UUIDNumber); 67 kCannotPick = BIT(6), ///< if object in a pad cannot be picked; 68 // 7 is taken by TAxis and TClass.; 69 kNoContextMenu = BIT(8), ///< if object does not want context menu; 70 // 9, 10 are taken by TH1, TF1, TAxis and a few others; 71 // 12 is taken by TAxis; 72 kInvalidObject = BIT(13) ///< if object ctor succeeded but object should not be used; 73 };; 74 ; 75 enum EDeprecatedStatusBits {; 76 kObjInCanvas = BIT(3) ///< for backward compatibility only, use kMustCleanup; 77 };; 78 ; 79 //----- Private bits, clients can only test but not change them; 80 enum {; 81 kIsOnHeap = 0x01000000, ///< object is on heap; 82 kNotDeleted = 0x02000000, ///< object has not been deleted; 83 kZombie = 0x04000000, ///< object ctor failed; 84 kInconsistent = 0x08000000, ///< class overload Hash but does call RecursiveRemove in destructor; 85 // kCheckedHash = 0x10000000, ///< CheckedHash has check for the consistency of Hash/RecursiveRemove; 86 kBitMask = 0x00ffffff; 87 };; 88 ; 89 //----- Write() options; 90 enum {; 91 kSingleKey = BIT(0), ///< write collection with single key; 92 kOverwrite = BIT(1), ///< overwrite existing object with same name; 93 kWriteDelete = BIT(2), ///< write object, then delete previous key with same name; 94 };; 95 ; 96protected:; 97 enum { // DeprectatedWriteOptions; 98 ///< Used to request that the class specific implementation of `TObject::Write`; 99 ///< just prepare the objects to be ready to be written but do not actually write; 100 ///< them into the TBuffer. This is just for example by TBufferMerger to request; 101 ///< that the TTree inside the file calls `TTree::FlushBaskets` (outside of the merging lock); 102 ///< and TBufferMerger will later ask for the write (inside the merging lock).; 103 ///< To take advantage of this feature the class needs to o",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:12567,Testability,test,test,12567,"/ TObject copy ctor.; 271 ; 272inline TObject::TObject(const TObject &obj); 273{; 274 fBits = obj.fBits;; 275 ; 276 // This will be reported by valgrind as uninitialized memory reads for; 277 // object created on the stack, use $ROOTSYS/etc/valgrind-root.supp; 278 TStorage::UpdateIsOnHeap(fUniqueID, fBits);; 279 ; 280 fBits &= ~kIsReferenced;; 281 fBits &= ~kCanDelete;; 282 ; 283 // Set only after used in above call; 284 fUniqueID = obj.fUniqueID; // when really unique don't copy; 285 ; 286#ifdef R__WIN32; 287 if (R__unlikely(GetObjectStat())) TObject::AddToTObjectTable(this);; 288#else; 289 if (R__unlikely(fgObjectStat)) TObject::AddToTObjectTable(this);; 290#endif; 291}; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// TObject assignment operator.; 295 ; 296inline TObject &TObject::operator=(const TObject &rhs); 297{; 298 if (R__likely(this != &rhs)) {; 299 fUniqueID = rhs.fUniqueID; // when really unique don't copy; 300 if (IsOnHeap()) { // test uses fBits so don't move next line; 301 fBits = rhs.fBits;; 302 fBits |= kIsOnHeap;; 303 } else {; 304 fBits = rhs.fBits;; 305 fBits &= ~kIsOnHeap;; 306 }; 307 fBits &= ~kIsReferenced;; 308 fBits &= ~kCanDelete;; 309 }; 310 return *this;; 311}; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// @brief Check and record whether this class has a consistent; 316/// Hash/RecursiveRemove setup (*) and then return the regular Hash value for; 317/// this object. The intent is for this routine to be called instead of directly; 318/// calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; 319///; 320/// (*) The setup is consistent when all classes in the class hierarchy that overload; 321/// TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 322/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 323 ; 324inline ULong_t TObje",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:14362,Testability,test,testing-prior-check,14362,"ent when all classes in the class hierarchy that overload; 321/// TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 322/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 323 ; 324inline ULong_t TObject::CheckedHash(); 325{; 326 // Testing and recording whether we already called HasInconstistentTObjectHash; 327 // for this object could save some cpu cycles in some circuntances (at the cost; 328 // of reserving yet another bit).; 329 // For each insert (CheckedHash is called only for insert in THashList/THashTable), it; 330 // cost one memory fetch, one arithmetic operation and one branching.; 331 // This save a virtual function call which itself contains a static variable memory; 332 // fetch, a branching (of whether the static was already set or not).; 333 // Given that a virtual function call is essentially 2 memory fetches (virtual table; 334 // location and then content), one arithmetic operation and one function call/jump),; 335 // we guess-estimate that the version recording-then-testing-prior-check would start; 336 // saving cpu cycle when each object is inserted in average 1.5 times in a THashList/THashTable.; 337 ; 338 // if ( !fBits & kCheckedHash) {; 339 if (!CheckTObjectHashConsistency()); 340 fBits |= kInconsistent;; 341 // fBits &= kChecked;; 342 //}; 343 return Hash();; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// @brief Return true is the type of this object is *known* to have an; 348/// inconsistent setup for Hash and RecursiveRemove (i.e. missing call to; 349/// RecursiveRemove in destructor).; 350///; 351/// Note: Since the consistency is only tested for during inserts, this; 352/// routine will return true for object that have never been inserted; 353/// whether or not they have a consistent setup. This has no negative; 354/// side-effect as searching for the object with the right or wrong; 355/// Hash will always yield ",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObject_8h_source.html:15009,Testability,test,tested,15009,"h, a branching (of whether the static was already set or not).; 333 // Given that a virtual function call is essentially 2 memory fetches (virtual table; 334 // location and then content), one arithmetic operation and one function call/jump),; 335 // we guess-estimate that the version recording-then-testing-prior-check would start; 336 // saving cpu cycle when each object is inserted in average 1.5 times in a THashList/THashTable.; 337 ; 338 // if ( !fBits & kCheckedHash) {; 339 if (!CheckTObjectHashConsistency()); 340 fBits |= kInconsistent;; 341 // fBits &= kChecked;; 342 //}; 343 return Hash();; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// @brief Return true is the type of this object is *known* to have an; 348/// inconsistent setup for Hash and RecursiveRemove (i.e. missing call to; 349/// RecursiveRemove in destructor).; 350///; 351/// Note: Since the consistency is only tested for during inserts, this; 352/// routine will return true for object that have never been inserted; 353/// whether or not they have a consistent setup. This has no negative; 354/// side-effect as searching for the object with the right or wrong; 355/// Hash will always yield a not-found answer (Since anyway no hash; 356/// can be guaranteed unique, there is always a check); 357 ; 358inline Bool_t TObject::HasInconsistentHash() const; 359{; 360 return fBits & kInconsistent;; 361}; 362 ; 363// Global bits (can be set for any object and should not be reused).; 364// Only here for backward compatibility reasons.; 365// For detailed description see TObject::EStatusBits above.; 366enum EObjBits {; 367 kCanDelete = TObject::kCanDelete,; 368 kMustCleanup = TObject::kMustCleanup,; 369 kObjInCanvas = TObject::kObjInCanvas,; 370 kIsReferenced = TObject::kIsReferenced,; 371 kHasUUID = TObject::kHasUUID,; 372 kCannotPick = TObject::kCannotPick,; 373 kNoContextMenu = TObject::kNoContextMenu,; 374 kInvalidObject = TObject::kInvalidObject; 375};;",MatchSource.WIKI,doc/master/TObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html
https://root.cern/doc/master/TObjString_8h.html:223,Integrability,depend,dependency,223,". ROOT: core/base/inc/TObjString.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TObjString.h File Reference. #include ""TObject.h""; #include ""TString.h"". Include dependency graph for TObjString.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TObjString;  Collectable string class. More...;  . corebaseincTObjString.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TObjString_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjString_8h.html
https://root.cern/doc/master/TObjString_8h_source.html:1108,Integrability,wrap,wrapped,1108," Rademakers 12/11/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TObjString; 13#define ROOT_TObjString; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TObjString //; 19// //; 20// Collectable string class. This is a TObject containing a TString. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TObject.h""; 25#include ""TString.h""; 26 ; 27 ; 28class TObjString : public TObject {; 29 ; 30private:; 31 TString fString; // wrapped TString; 32 ; 33public:; 34 TObjString(const char *s = """") : fString(s) { }; 35 ~TObjString();; 36 Int_t Compare(const TObject *obj) const override;; 37 TString CopyString() const { return fString; }; 38 const char *GetName() const override { return fString; }; 39 ULong_t Hash() const override { return fString.Hash(); }; 40 void FillBuffer(char *&buffer) { fString.FillBuffer(buffer); }; 41 void Print(Option_t *) const override { Printf(""TObjString = %s"", (const char*)fString); }; 42 Bool_t IsSortable() const override { return kTRUE; }; 43 Bool_t IsEqual(const TObject *obj) const override;; 44 void ReadBuffer(char *&buffer) { fString.ReadBuffer(buffer); }; 45 void SetString(const char *s) { fString = s; }; 46 const TString &GetString() const { return fString; }; 47 Int_t Sizeof() const { return fString.Sizeof(); }; 48 TString &String() { return fString; }; 49 ; 50 ClassDefOverride(TObjString,1) //Collectable string class; 51};; 52 ; 53#endif; 54 ; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; kT",MatchSource.WIKI,doc/master/TObjString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjString_8h_source.html
https://root.cern/doc/master/TObjString_8h_source.html:3573,Security,hash,hash,3573,"x:2503; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::TObjStringTObjString(const char *s="""")Definition TObjString.h:34; TObjString::IsEqualBool_t IsEqual(const TObject *obj) const overrideReturn kTRUE if the argument has the same content as this object.Definition TObjString.cxx:45; TObjString::FillBuffervoid FillBuffer(char *&buffer)Definition TObjString.h:40; TObjString::ReadBuffervoid ReadBuffer(char *&buffer)Definition TObjString.h:44; TObjString::GetStringconst TString & GetString() constDefinition TObjString.h:46; TObjString::CompareInt_t Compare(const TObject *obj) const overrideString compare the argument with this object.Definition TObjString.cxx:35; TObjString::SizeofInt_t Sizeof() constDefinition TObjString.h:47; TObjString::StringTString & String()Definition TObjString.h:48; TObjString::CopyStringTString CopyString() constDefinition TObjString.h:37; TObjString::fStringTString fStringDefinition TObjString.h:31; TObjString::HashULong_t Hash() const overrideReturn hash value for this object.Definition TObjString.h:39; TObjString::Printvoid Print(Option_t *) const overrideThis method must be overridden when a class wants to print itself.Definition TObjString.h:41; TObjString::SetStringvoid SetString(const char *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObjString::IsSortableBool_t IsSortable() const overrideDefinition TObjString.h:42; TObjString::~TObjString~TObjString()TObjString destructor.Definition TObjString.cxx:26; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::FillBuffervirtual void FillBuffer(char *&buffer) constCopy string into I/O buffer.Definition TString.cxx:1310; TString::Sizeofvirtual Int_t Sizeof() constReturns size string will occupy on I/O buffer.Defi",MatchSource.WIKI,doc/master/TObjString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjString_8h_source.html
https://root.cern/doc/master/TObjString_8h_source.html:4306,Security,hash,hash,4306,t.Definition TObjString.cxx:45; TObjString::FillBuffervoid FillBuffer(char *&buffer)Definition TObjString.h:40; TObjString::ReadBuffervoid ReadBuffer(char *&buffer)Definition TObjString.h:44; TObjString::GetStringconst TString & GetString() constDefinition TObjString.h:46; TObjString::CompareInt_t Compare(const TObject *obj) const overrideString compare the argument with this object.Definition TObjString.cxx:35; TObjString::SizeofInt_t Sizeof() constDefinition TObjString.h:47; TObjString::StringTString & String()Definition TObjString.h:48; TObjString::CopyStringTString CopyString() constDefinition TObjString.h:37; TObjString::fStringTString fStringDefinition TObjString.h:31; TObjString::HashULong_t Hash() const overrideReturn hash value for this object.Definition TObjString.h:39; TObjString::Printvoid Print(Option_t *) const overrideThis method must be overridden when a class wants to print itself.Definition TObjString.h:41; TObjString::SetStringvoid SetString(const char *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObjString::IsSortableBool_t IsSortable() const overrideDefinition TObjString.h:42; TObjString::~TObjString~TObjString()TObjString destructor.Definition TObjString.cxx:26; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::FillBuffervirtual void FillBuffer(char *&buffer) constCopy string into I/O buffer.Definition TString.cxx:1310; TString::Sizeofvirtual Int_t Sizeof() constReturns size string will occupy on I/O buffer.Definition TString.cxx:1401; TString::ReadBuffervirtual void ReadBuffer(char *&buffer)Read string from I/O buffer.Definition TString.cxx:1331; bool; int. corebaseincTObjString.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/TObjString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TObjString_8h_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:10307,Availability,error,error,10307,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:12875,Availability,error,errors,12875,"jvar<<"")="" <<(*covMat)(jvar, jvar); 352 << Endl;; 353 ; 354 }; 355 }; 356 else (*corrMat)(ivar, ivar) = 1.0;; 357 }; 358 }; 359 Log() << Endl;; 360 return corrMat;; 361}; 362 ; 363////////////////////////////////////////////////////////////////////////////////; 364/// projects variable from tree into normalised histogram; 365 ; 366TH1* TMVA::Tools::projNormTH1F( TTree* theTree, const TString& theVarName,; 367 const TString& name, Int_t nbins,; 368 Double_t xmin, Double_t xmax, const TString& cut ); 369{; 370 // needed because of ROOT bug (feature) that excludes events that have value == xmax; 371 xmax += 0.00001;; 372 ; 373 TH1* hist = new TH1F( name, name, nbins, xmin, xmax );; 374 hist->Sumw2(); // enable quadratic errors; 375 theTree->Project( name, theVarName, cut );; 376 NormHist( hist );; 377 return hist;; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// normalises histogram; 382 ; 383Double_t TMVA::Tools::NormHist( TH1* theHist, Double_t norm ); 384{; 385 if (!theHist) return 0;; 386 ; 387 if (theHist->GetSumw2N() == 0) theHist->Sumw2();; 388 if (theHist->GetSumOfWeights() != 0) {; 389 Double_t w = ( theHist->GetSumOfWeights(); 390 *(theHist->GetXaxis()->GetXmax() - theHist->GetXaxis()->GetXmin())/theHist->GetNbinsX() );; 391 if (w > 0) theHist->Scale( norm/w );; 392 return w;; 393 }; 394 ; 395 return 1.0;; 396}; 397 ; 398////////////////////////////////////////////////////////////////////////////////; 399/// Parse the string and cut into labels separated by "":""; 400 ; 401TList* TMVA::Tools::ParseFormatLine( TString formatString, const char* sep ); 402{; 403 TList* labelList = new TList();; 404 labelList->SetOwner();; 405 while (formatString.First(sep)==0) formatString.Remove(0,1); // remove initial separators; 406 ; 407 while (formatString.Length()>0) {; 408 if (formatString.First(sep) == -1) { // no more separator; 409 labelList->Add(new TObjString(formatString.Data()));; 410 formatString="""";; 411 break;",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:30997,Availability,error,error,30997,"en_b;; 865 if (c == ""dyellow"") return gClr_darkyellow;; 866 ; 867 if (c == ""bold"") return gClr_bold;; 868 if (c == ""bblack"") return gClr_black_b;; 869 ; 870 if (c == ""blue_bgd"") return gClr_blue_bg;; 871 if (c == ""red_bgd"" ) return gClr_red_bg;; 872 ; 873 if (c == ""white_on_blue"" ) return gClr_whiteonblue;; 874 if (c == ""white_on_green"") return gClr_whiteongreen;; 875 ; 876 if (c == ""reset"") return gClr_reset;; 877 ; 878 std::cout << ""Unknown color "" << c << std::endl;; 879 exit(1);; 880 ; 881 return gClr_none;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// formatted output of simple table; 886 ; 887void TMVA::Tools::FormattedOutput( const std::vector<Double_t>& values, const std::vector<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger <",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:32626,Availability,error,error,32626,"er << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<n",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:36538,Availability,avail,available,36538,"//////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit, Bool_t normalised ); 1049{; 1050 TString retval = ( normalised ? ""(1/N) "" : """" );; 1051 retval += TString::Format( ""dN_{ }/^{ }%.3g %s"", h.GetXaxis()->GetBinWidth(1), unit.Data() );; 1052 return retval;; 1053}; 1054 ; 1055////////////////////////////////////////////////////////////////////////////////; 1056/// writes a float value with the available precision to a stream; 1057 ; 1058void TMVA::Tools::WriteFloatArbitraryPrecision( Float_t val, ostream& os ); 1059{; 1060 os << val << "" :: "";; 1061 void * c = &val;; 1062 for (int i=0; i<4; i++) {; 1063 Int_t ic = *((char*)c+i)-'\0';; 1064 if (ic<0) ic+=256;; 1065 os << ic << "" "";; 1066 }; 1067 os << "":: "";; 1068}; 1069 ; 1070////////////////////////////////////////////////////////////////////////////////; 1071/// reads a float value with the available precision from a stream; 1072 ; 1073void TMVA::Tools::ReadFloatArbitraryPrecision( Float_t& val, istream& is ); 1074{; 1075 Float_t a = 0;; 1076 is >> a;; 1077 TString dn;; 1078 is >> dn;; 1079 Int_t c[4];; 1080 void * ap = &a;; 1081 for (int i=0; i<4; i++) {; 1082 is >> c[i];; 1083 *((char*)ap+i) = '\0'+c[i];; 1084 }; 1085 is >> dn;; 1086 val = a;; 1087}; 1088 ; 1089// XML file reading/writing helper functions; 1090 ; 1091////////////////////////////////////////////////////////////////////////////////; 1092/// add attribute from xml; 1093 ; 1094Bool_t TMVA::Tools::HasAttr( void* node, const char* attrname ); 1095{; 1096 return xmlengine().HasAttr(node, attrname);; 1097}; 1098 ; 1099////////////////////////////////////////////////////////////////////////////////; 1100/// add attribute from xml; 1101 ; 1102void TMVA::Tools::ReadAttr( void* node, const char* attrname, TString& value ); 1103{; 1104 if (!HasAttr(node, attrname)) {; 1105 const char * nodename = xmlengine().GetNodeName(node);; 11",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:36996,Availability,avail,available,36996,"//////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit, Bool_t normalised ); 1049{; 1050 TString retval = ( normalised ? ""(1/N) "" : """" );; 1051 retval += TString::Format( ""dN_{ }/^{ }%.3g %s"", h.GetXaxis()->GetBinWidth(1), unit.Data() );; 1052 return retval;; 1053}; 1054 ; 1055////////////////////////////////////////////////////////////////////////////////; 1056/// writes a float value with the available precision to a stream; 1057 ; 1058void TMVA::Tools::WriteFloatArbitraryPrecision( Float_t val, ostream& os ); 1059{; 1060 os << val << "" :: "";; 1061 void * c = &val;; 1062 for (int i=0; i<4; i++) {; 1063 Int_t ic = *((char*)c+i)-'\0';; 1064 if (ic<0) ic+=256;; 1065 os << ic << "" "";; 1066 }; 1067 os << "":: "";; 1068}; 1069 ; 1070////////////////////////////////////////////////////////////////////////////////; 1071/// reads a float value with the available precision from a stream; 1072 ; 1073void TMVA::Tools::ReadFloatArbitraryPrecision( Float_t& val, istream& is ); 1074{; 1075 Float_t a = 0;; 1076 is >> a;; 1077 TString dn;; 1078 is >> dn;; 1079 Int_t c[4];; 1080 void * ap = &a;; 1081 for (int i=0; i<4; i++) {; 1082 is >> c[i];; 1083 *((char*)ap+i) = '\0'+c[i];; 1084 }; 1085 is >> dn;; 1086 val = a;; 1087}; 1088 ; 1089// XML file reading/writing helper functions; 1090 ; 1091////////////////////////////////////////////////////////////////////////////////; 1092/// add attribute from xml; 1093 ; 1094Bool_t TMVA::Tools::HasAttr( void* node, const char* attrname ); 1095{; 1096 return xmlengine().HasAttr(node, attrname);; 1097}; 1098 ; 1099////////////////////////////////////////////////////////////////////////////////; 1100/// add attribute from xml; 1101 ; 1102void TMVA::Tools::ReadAttr( void* node, const char* attrname, TString& value ); 1103{; 1104 if (!HasAttr(node, attrname)) {; 1105 const char * nodename = xmlengine().GetNodeName(node);; 11",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:56097,Availability,mask,mask,56097,"matrices for each class); 1533 ; 1534 std::vector<TVectorD*>* vec = new std::vector<TVectorD*>(matNum);; 1535 std::vector<TMatrixD*>* mat2 = new std::vector<TMatrixD*>(matNum);; 1536 std::vector<Double_t> count(matNum);; 1537 count.assign(matNum,0);; 1538 ; 1539 Int_t cls = 0;; 1540 TVectorD* v;; 1541 TMatrixD* m;; 1542 UInt_t ivar=0, jvar=0;; 1543 for (cls = 0; cls < matNum ; cls++) {; 1544 vec->at(cls) = new TVectorD(nvars);; 1545 mat2->at(cls) = new TMatrixD(nvars,nvars);; 1546 v = vec->at(cls);; 1547 m = mat2->at(cls);; 1548 ; 1549 for (ivar=0; ivar<nvars; ivar++) {; 1550 (*v)(ivar) = 0;; 1551 for (jvar=0; jvar<nvars; jvar++) {; 1552 (*m)(ivar, jvar) = 0;; 1553 }; 1554 }; 1555 }; 1556 ; 1557 // perform event loop; 1558 for (UInt_t i=0; i<events.size(); i++) {; 1559 ; 1560 // fill the event; 1561 const Event * ev = events[i];; 1562 cls = ev->GetClass();; 1563 Double_t weight = ev->GetWeight();; 1564 ; 1565 std::vector<Float_t> input;; 1566 std::vector<Char_t> mask; // entries with kTRUE must not be transformed; 1567 // Bool_t hasMaskedEntries = kFALSE;; 1568 if (transformBase) {; 1569 /* hasMaskedEntries = */ transformBase->GetInput (ev, input, mask);; 1570 } else {; 1571 for (ivar=0; ivar<nvars; ++ivar) {; 1572 input.push_back (ev->GetValue(ivar));; 1573 }; 1574 }; 1575 ; 1576 if (maxCls > 1) {; 1577 v = vec->at(matNum-1);; 1578 m = mat2->at(matNum-1);; 1579 ; 1580 count.at(matNum-1)+=weight; // count used events; 1581 for (ivar=0; ivar<nvars; ivar++) {; 1582 ; 1583 Double_t xi = input.at (ivar);; 1584 (*v)(ivar) += xi*weight;; 1585 (*m)(ivar, ivar) += (xi*xi*weight);; 1586 ; 1587 for (jvar=ivar+1; jvar<nvars; jvar++) {; 1588 Double_t xj = input.at (jvar);; 1589 (*m)(ivar, jvar) += (xi*xj*weight);; 1590 (*m)(jvar, ivar) = (*m)(ivar, jvar); // symmetric matrix; 1591 }; 1592 }; 1593 }; 1594 ; 1595 count.at(cls)+=weight; // count used events; 1596 v = vec->at(cls);; 1597 m = mat2->at(cls);; 1598 for (ivar=0; ivar<nvars; ivar++) {; 1599 Double_t xi = input.at (ivar)",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:56286,Availability,mask,mask,56286,"matrices for each class); 1533 ; 1534 std::vector<TVectorD*>* vec = new std::vector<TVectorD*>(matNum);; 1535 std::vector<TMatrixD*>* mat2 = new std::vector<TMatrixD*>(matNum);; 1536 std::vector<Double_t> count(matNum);; 1537 count.assign(matNum,0);; 1538 ; 1539 Int_t cls = 0;; 1540 TVectorD* v;; 1541 TMatrixD* m;; 1542 UInt_t ivar=0, jvar=0;; 1543 for (cls = 0; cls < matNum ; cls++) {; 1544 vec->at(cls) = new TVectorD(nvars);; 1545 mat2->at(cls) = new TMatrixD(nvars,nvars);; 1546 v = vec->at(cls);; 1547 m = mat2->at(cls);; 1548 ; 1549 for (ivar=0; ivar<nvars; ivar++) {; 1550 (*v)(ivar) = 0;; 1551 for (jvar=0; jvar<nvars; jvar++) {; 1552 (*m)(ivar, jvar) = 0;; 1553 }; 1554 }; 1555 }; 1556 ; 1557 // perform event loop; 1558 for (UInt_t i=0; i<events.size(); i++) {; 1559 ; 1560 // fill the event; 1561 const Event * ev = events[i];; 1562 cls = ev->GetClass();; 1563 Double_t weight = ev->GetWeight();; 1564 ; 1565 std::vector<Float_t> input;; 1566 std::vector<Char_t> mask; // entries with kTRUE must not be transformed; 1567 // Bool_t hasMaskedEntries = kFALSE;; 1568 if (transformBase) {; 1569 /* hasMaskedEntries = */ transformBase->GetInput (ev, input, mask);; 1570 } else {; 1571 for (ivar=0; ivar<nvars; ++ivar) {; 1572 input.push_back (ev->GetValue(ivar));; 1573 }; 1574 }; 1575 ; 1576 if (maxCls > 1) {; 1577 v = vec->at(matNum-1);; 1578 m = mat2->at(matNum-1);; 1579 ; 1580 count.at(matNum-1)+=weight; // count used events; 1581 for (ivar=0; ivar<nvars; ivar++) {; 1582 ; 1583 Double_t xi = input.at (ivar);; 1584 (*v)(ivar) += xi*weight;; 1585 (*m)(ivar, ivar) += (xi*xi*weight);; 1586 ; 1587 for (jvar=ivar+1; jvar<nvars; jvar++) {; 1588 Double_t xj = input.at (jvar);; 1589 (*m)(ivar, jvar) += (xi*xj*weight);; 1590 (*m)(jvar, ivar) = (*m)(ivar, jvar); // symmetric matrix; 1591 }; 1592 }; 1593 }; 1594 ; 1595 count.at(cls)+=weight; // count used events; 1596 v = vec->at(cls);; 1597 m = mat2->at(cls);; 1598 for (ivar=0; ivar<nvars; ivar++) {; 1599 Double_t xi = input.at (ivar)",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:64807,Availability,error,error,64807,"Attr(node, attrname);; 1807 if (val == nullptr) {; 1808 const char *nodename = xmlengine().GetNodeName(node);; 1809 Log() << kFATAL << ""Trying to read non-existing attribute '"" << attrname << ""' from xml node '"" << nodename << ""'""; 1810 << Endl;; 1811 } else; 1812 value = atoi(val);; 1813}; Event.h; MsgLogger.h; PDF.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAli",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:65373,Availability,mask,maskDefinition,65373,"(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; childOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:73405,Availability,avail,available,73405,"&, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::HistoHasEquidistantBinsBool_t HistoHasEquidistantBins(const TH1 &h)Definition Tools.cxx:1486; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::NormVariableDouble_t NormVariable(Double_t x, Double_t xmin, Double_t xmax)normalise to output range: [-1, 1]Definition Tools.cxx:110; TMVA::Tools::WriteFloatArbitraryPrecisionvoid WriteFloatArbitraryPrecision(Float_t val, std::ostream &os)writes a float value with the available precision to a streamDefinition Tools.cxx:1058; TMVA::Tools::GetYTitleWithUnitTString GetYTitleWithUnit(const TH1 &h, const TString &unit, Bool_t normalised)histogramming utilityDefinition Tools.cxx:1048; TMVA::Tools::GetSeparationDouble_t GetSeparation(TH1 *S, TH1 *B) constcompute ""separation"" defined asDefinition Tools.cxx:121; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::GetSQRootMatrixTMatrixD * GetSQRootMatrix(TMatrixDSym *symMat)square-root of symmetric matrix of course the resulting sqrtMat is also symmetric,...Definition Tools.cxx:271; TMVA::Tools::MVADiffstd::vector< Double_t > MVADiff(std::vector< Double_t > &, std::vector< Double_t > &)computes difference between two vectorsDefinition Tools.cxx:506; TMVA::Tools::GetIndexMinElementInt_t GetIndexMinElement(std::vector< Double_t > &)find index of minimum entry in vectorDefinition Tools.cxx:765; TMVA::Tools::projNormTH1FTH1 * projNor",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:75330,Availability,avail,available,75330," in vectorDefinition Tools.cxx:765; TMVA::Tools::projNormTH1FTH1 * projNormTH1F(TTree *theTree, const TString &theVarName, const TString &name, Int_t nbins, Double_t xmin, Double_t xmax, const TString &cut)projects variable from tree into normalised histogramDefinition Tools.cxx:366; TMVA::Tools::ROOTVersionMessagevoid ROOTVersionMessage(MsgLogger &logger)prints the ROOT release number and dateDefinition Tools.cxx:1325; TMVA::Tools::ReplaceRegularExpressionsTString ReplaceRegularExpressions(const TString &s, const TString &replace=""+"")replace regular expressions helper function to remove all occurrences ""$!%^&()'<>?...Definition Tools.cxx:798; TMVA::Tools::ReadTVectorDFromXMLvoid ReadTVectorDFromXML(void *node, const char *name, TVectorD *vec)Definition Tools.cxx:1267; TMVA::Tools::GetCumulativeDistTH1 * GetCumulativeDist(TH1 *h)get the cumulative distribution of a histogramDefinition Tools.cxx:1756; TMVA::Tools::ReadFloatArbitraryPrecisionvoid ReadFloatArbitraryPrecision(Float_t &val, std::istream &is)reads a float value with the available precision from a streamDefinition Tools.cxx:1073; TMVA::Tools::AddRawLineBool_t AddRawLine(void *node, const char *raw)XML helpers.Definition Tools.cxx:1190; TMVA::Tools::~Tools~Tools()destructorDefinition Tools.cxx:101; TMVA::Tools::ContainsRegularExpressionBool_t ContainsRegularExpression(const TString &s)check if regular expression helper function to search for ""$!%^&()'<>?= "" in a stringDefinition Tools.cxx:784; TMVA::Tools::UsefulSortDescendingvoid UsefulSortDescending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:564; TMVA::Tools::DestroyInstancestatic void DestroyInstance()Definition Tools.cxx:82; TMVA::Tools::MeanDouble_t Mean(Long64_t n, const T *a, const Double_t *w=0)Return the weighted mean of an array a with length n.Definition Tools.cxx:1687; TMVA::Tools::GetMutua",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:82099,Availability,mask,mask,82099,"ndexMaxElementInt_t GetIndexMaxElement(std::vector< Double_t > &)find index of maximum entry in vectorDefinition Tools.cxx:748; TMVA::Tools::TransposeHistTH2F * TransposeHist(const TH2F &)Transpose quadratic histogram.Definition Tools.cxx:657; TMVA::Tools::EWelcomeMessageEWelcomeMessageDefinition Tools.h:198; TMVA::Tools::HasAttrBool_t HasAttr(void *node, const char *attrname)add attribute from xmlDefinition Tools.cxx:1094; TMVA::Tools::GetNextChildvoid * GetNextChild(void *prevchild, const char *childname=nullptr)XML helpers.Definition Tools.cxx:1162; TMVA::Tools::fRegexpconst TString fRegexpDefinition Tools.h:226; TMVA::Tools::CheckForSilentOptionBool_t CheckForSilentOption(const TString &) constcheck for ""silence"" option in configuration option stringDefinition Tools.cxx:691; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::GetInputvirtual Bool_t GetInput(const Event *event, std::vector< Float_t > &input, std::vector< Char_t > &mask, Bool_t backTransform=kFALSE) constselect the values from the eventDefinition VariableTransformBase.cxx:315; TMVA::VariableTransformBase::CountVariableTypesvirtual void CountVariableTypes(UInt_t &nvars, UInt_t &ntgts, UInt_t &nspcts) constcount variables, targets and spectatorsDefinition VariableTransformBase.cxx:429; TMatrixDSymEigenTMatrixDSymEigen.Definition TMatrixDSymEigen.h:28; TMatrixDSymEigen::GetEigenVectorsconst TMatrixD & GetEigenVectors() constDefinition TMatrixDSymEigen.h:53; TMatrixTBase::GetNrowsInt_t GetNrows() constDefinition TMatrixTBase.h:123; TMatrixTBase::GetNcolsInt_t GetNcols() constDefinition TMatrixTBase.h:126; TMatrixTSym< Double_t >; TMatrixT< Double_t >; TMatrixT::TransposeTMatrixT< Element > & Transpose(const TMatrixT< Element > &source)Transpose matrix source.Definition TMatrixT.cxx:1455; TMatrixT::ResizeToTMatrixTBase< Element > & ResizeTo(Int_t nrows, Int_t ncols, Int_t=-1) overrideSet size of the matrix to nrows x ncols New dynami",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:404,Deployability,integrat,integrated,404,". ROOT: tmva/tmva/src/Tools.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Tools.cxx. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Jan Therhaag; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : Tools *; 8 * *; 9 * *; 10 * Description: *; 11 * Implementation (see header for description) *; 12 * *; 13 * Authors (alphabetical): *; 14 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 15 * Peter Speckmayer <Peter.Speckmayer@cern.ch> - CERN, Switzerland *; 16 * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; 17 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 18 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 19 * *; 20 * Copyright (c) 2005-2011: *; 21 * CERN, Switzerland *; 22 * U. of Victoria, Canada *; 23 * MPI-K Heidelberg, Germany *; 24 * U. of Bonn, Germany *; 25 * *; 26 * Redistribution and use in source and binary forms, with or without *; 27 * modification, are permitted according to the terms listed in LICENSE *; 28 * (see tmva/doc/LICENSE) *; 29 **********************************************************************************/; 30 ; 31/*! \class TMVA::Tools; 32\ingroup TMVA; 33Global auxiliary applications and data treatment routines.; 34*/; 35 ; 36#include ""TMVA/Tools.h""; 37 ; 38#include ""TMVA/Config.h""; 39#include ""TMVA/Event.h""; 40#include ""TMVA/Version.h""; 41#include ""TMVA/PDF.h""; 42#include ""TMVA/MsgLogger.h""; 43#include ""TMVA/Types.h""; 44 ; 45#include ""TObjString.h""; 46#include ""TMath.h""; 47#include ""TString.h""; 48#include ""TTree.h""; 49#include ""TLeaf.h""; 50#include ""TH1.h""; 51#include ""TH2.h""; 52#include ""TList.h""; 53#include ""TSpline.h""; 54#include ""TVector.h""; 55#include ""TMatrixD.h""; 56#include ""TMatrixDSymE",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:23895,Deployability,configurat,configuration,23895,"/// Transpose quadratic histogram; 656 ; 657TH2F* TMVA::Tools::TransposeHist( const TH2F& h ); 658{; 659 // sanity check; 660 if (h.GetNbinsX() != h.GetNbinsY()) {; 661 Log() << kFATAL << ""<TransposeHist> cannot transpose non-quadratic histogram"" << Endl;; 662 }; 663 ; 664 TH2F *transposedHisto = new TH2F( h );; 665 for (Int_t ix=1; ix <= h.GetNbinsX(); ix++){; 666 for (Int_t iy=1; iy <= h.GetNbinsY(); iy++){; 667 transposedHisto->SetBinContent(iy,ix,h.GetBinContent(ix,iy));; 668 }; 669 }; 670 ; 671 // copy stats (thanks to Swagato Banerjee for pointing out the missing stats information); 672 Double_t stats_old[7];; 673 Double_t stats_new[7];; 674 ; 675 h.GetStats(stats_old);; 676 stats_new[0] = stats_old[0];; 677 stats_new[1] = stats_old[1];; 678 stats_new[2] = stats_old[4];; 679 stats_new[3] = stats_old[5];; 680 stats_new[4] = stats_old[2];; 681 stats_new[5] = stats_old[3];; 682 stats_new[6] = stats_old[6];; 683 transposedHisto->PutStats(stats_new);; 684 ; 685 return transposedHisto; // ownership returned; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// check for ""silence"" option in configuration option string; 690 ; 691Bool_t TMVA::Tools::CheckForSilentOption( const TString& cs ) const; 692{; 693 Bool_t isSilent = kFALSE;; 694 ; 695 TString s( cs );; 696 s.ToLower();; 697 s.ReplaceAll("" "","""");; 698 if (s.Contains(""silent"") && !s.Contains(""silent=f"")) {; 699 if (!s.Contains(""!silent"") || s.Contains(""silent=t"")) isSilent = kTRUE;; 700 }; 701 ; 702 return isSilent;; 703}; 704 ; 705////////////////////////////////////////////////////////////////////////////////; 706/// check if verbosity ""V"" set in option; 707 ; 708Bool_t TMVA::Tools::CheckForVerboseOption( const TString& cs ) const; 709{; 710 Bool_t isVerbose = kFALSE;; 711 ; 712 TString s( cs );; 713 s.ToLower();; 714 s.ReplaceAll("" "","""");; 715 std::vector<TString> v = SplitString( s, ':' );; 716 for (std::vector<TString>::iterator it = v.begin(); it != v.end(",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:45892,Deployability,release,release,45892,"DATE << std::endl;; 1307 std::cout << "" "" << ""Copyright (C) 2005-2010 CERN, MPI-K Heidelberg, Us of Bonn and Victoria"" << std::endl;; 1308 std::cout << "" "" << ""Home page: http://tmva.sf.net"" << std::endl;; 1309 std::cout << "" "" << ""Citation info: http://tmva.sf.net/citeTMVA.html"" << std::endl;; 1310 std::cout << "" "" << ""License: http://tmva.sf.net/LICENSE"" << std::endl << std::endl;; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// prints the TMVA release number and date; 1315 ; 1316void TMVA::Tools::TMVAVersionMessage( MsgLogger& logger ); 1317{; 1318 logger << ""___________TMVA Version "" << TMVA_RELEASE << "", "" << TMVA_RELEASE_DATE; 1319 << """" << Endl;; 1320}; 1321 ; 1322////////////////////////////////////////////////////////////////////////////////; 1323/// prints the ROOT release number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LA",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:46227,Deployability,release,release,46227,"DATE << std::endl;; 1307 std::cout << "" "" << ""Copyright (C) 2005-2010 CERN, MPI-K Heidelberg, Us of Bonn and Victoria"" << std::endl;; 1308 std::cout << "" "" << ""Home page: http://tmva.sf.net"" << std::endl;; 1309 std::cout << "" "" << ""Citation info: http://tmva.sf.net/citeTMVA.html"" << std::endl;; 1310 std::cout << "" "" << ""License: http://tmva.sf.net/LICENSE"" << std::endl << std::endl;; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// prints the TMVA release number and date; 1315 ; 1316void TMVA::Tools::TMVAVersionMessage( MsgLogger& logger ); 1317{; 1318 logger << ""___________TMVA Version "" << TMVA_RELEASE << "", "" << TMVA_RELEASE_DATE; 1319 << """" << Endl;; 1320}; 1321 ; 1322////////////////////////////////////////////////////////////////////////////////; 1323/// prints the ROOT release number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LA",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:74657,Deployability,release,release,74657,"ols::GetSeparationDouble_t GetSeparation(TH1 *S, TH1 *B) constcompute ""separation"" defined asDefinition Tools.cxx:121; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::GetSQRootMatrixTMatrixD * GetSQRootMatrix(TMatrixDSym *symMat)square-root of symmetric matrix of course the resulting sqrtMat is also symmetric,...Definition Tools.cxx:271; TMVA::Tools::MVADiffstd::vector< Double_t > MVADiff(std::vector< Double_t > &, std::vector< Double_t > &)computes difference between two vectorsDefinition Tools.cxx:506; TMVA::Tools::GetIndexMinElementInt_t GetIndexMinElement(std::vector< Double_t > &)find index of minimum entry in vectorDefinition Tools.cxx:765; TMVA::Tools::projNormTH1FTH1 * projNormTH1F(TTree *theTree, const TString &theVarName, const TString &name, Int_t nbins, Double_t xmin, Double_t xmax, const TString &cut)projects variable from tree into normalised histogramDefinition Tools.cxx:366; TMVA::Tools::ROOTVersionMessagevoid ROOTVersionMessage(MsgLogger &logger)prints the ROOT release number and dateDefinition Tools.cxx:1325; TMVA::Tools::ReplaceRegularExpressionsTString ReplaceRegularExpressions(const TString &s, const TString &replace=""+"")replace regular expressions helper function to remove all occurrences ""$!%^&()'<>?...Definition Tools.cxx:798; TMVA::Tools::ReadTVectorDFromXMLvoid ReadTVectorDFromXML(void *node, const char *name, TVectorD *vec)Definition Tools.cxx:1267; TMVA::Tools::GetCumulativeDistTH1 * GetCumulativeDist(TH1 *h)get the cumulative distribution of a histogramDefinition Tools.cxx:1756; TMVA::Tools::ReadFloatArbitraryPrecisionvoid ReadFloatArbitraryPrecision(Float_t &val, std::istream &is)reads a float value with the available precision from a streamDefinition Tools.cxx:1073; TMVA::Tools::AddRawLineBool_t AddRawLine(void *node, const char *raw)XML helpers.Definition Tools.cxx:1190; TMVA::Tools::~Tools~Tools()destructorDefinition Tools.cxx:101; TMVA::Tools::ContainsRegularExpressionBool_t ContainsRegularExpress",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:80606,Deployability,release,release,80606," AddChild(void *parent, const char *childname, const char *content=nullptr, bool isRootNode=false)add child nodeDefinition Tools.cxx:1124; TMVA::Tools::UsefulSortAscendingvoid UsefulSortAscending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:538; TMVA::Tools::GetYMean_binXDouble_t GetYMean_binX(const TH2 &, Int_t bin_x)Compute the mean in Y for a given bin X of a 2D histogram.Definition Tools.cxx:642; TMVA::Tools::CalcCovarianceMatricesstd::vector< TMatrixDSym * > * CalcCovarianceMatrices(const std::vector< Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr)compute covariance matricesDefinition Tools.cxx:1513; TMVA::Tools::TMVACitationvoid TMVACitation(MsgLogger &logger, ECitation citType=kPlainText)kinds of TMVA citationDefinition Tools.cxx:1440; TMVA::Tools::TMVAVersionMessagevoid TMVAVersionMessage(MsgLogger &logger)prints the TMVA release number and dateDefinition Tools.cxx:1316; TMVA::Tools::TMVAWelcomeMessagevoid TMVAWelcomeMessage()direct output, eg, when starting ROOT session -> no use of Logger hereDefinition Tools.cxx:1302; TMVA::Tools::ParseANNOptionStringstd::vector< Int_t > * ParseANNOptionString(TString theOptions, Int_t nvar, std::vector< Int_t > *nodes)parse option string for ANN methods default settings (should be defined in theOption string)Definition Tools.cxx:443; TMVA::Tools::GetIndexMaxElementInt_t GetIndexMaxElement(std::vector< Double_t > &)find index of maximum entry in vectorDefinition Tools.cxx:748; TMVA::Tools::TransposeHistTH2F * TransposeHist(const TH2F &)Transpose quadratic histogram.Definition Tools.cxx:657; TMVA::Tools::EWelcomeMessageEWelcomeMessageDefinition Tools.h:198; TMVA::Tools::HasAttrBool_t HasAttr(void *node, const char *attrname)add attribute from xmlDefinition Tools.cxx:1094; TMVA::Tools::GetNextChildvoid * GetNextChild(void *prevchild, const ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:81818,Deployability,configurat,configuration,81818,"reDefinition Tools.cxx:1302; TMVA::Tools::ParseANNOptionStringstd::vector< Int_t > * ParseANNOptionString(TString theOptions, Int_t nvar, std::vector< Int_t > *nodes)parse option string for ANN methods default settings (should be defined in theOption string)Definition Tools.cxx:443; TMVA::Tools::GetIndexMaxElementInt_t GetIndexMaxElement(std::vector< Double_t > &)find index of maximum entry in vectorDefinition Tools.cxx:748; TMVA::Tools::TransposeHistTH2F * TransposeHist(const TH2F &)Transpose quadratic histogram.Definition Tools.cxx:657; TMVA::Tools::EWelcomeMessageEWelcomeMessageDefinition Tools.h:198; TMVA::Tools::HasAttrBool_t HasAttr(void *node, const char *attrname)add attribute from xmlDefinition Tools.cxx:1094; TMVA::Tools::GetNextChildvoid * GetNextChild(void *prevchild, const char *childname=nullptr)XML helpers.Definition Tools.cxx:1162; TMVA::Tools::fRegexpconst TString fRegexpDefinition Tools.h:226; TMVA::Tools::CheckForSilentOptionBool_t CheckForSilentOption(const TString &) constcheck for ""silence"" option in configuration option stringDefinition Tools.cxx:691; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::GetInputvirtual Bool_t GetInput(const Event *event, std::vector< Float_t > &input, std::vector< Char_t > &mask, Bool_t backTransform=kFALSE) constselect the values from the eventDefinition VariableTransformBase.cxx:315; TMVA::VariableTransformBase::CountVariableTypesvirtual void CountVariableTypes(UInt_t &nvars, UInt_t &ntgts, UInt_t &nspcts) constcount variables, targets and spectatorsDefinition VariableTransformBase.cxx:429; TMatrixDSymEigenTMatrixDSymEigen.Definition TMatrixDSymEigen.h:28; TMatrixDSymEigen::GetEigenVectorsconst TMatrixD & GetEigenVectors() constDefinition TMatrixDSymEigen.h:53; TMatrixTBase::GetNrowsInt_t GetNrows() constDefinition TMatrixTBase.h:123; TMatrixTBase::GetNcolsInt_t GetNcols() constDefinition TMatrixTBase.h:126; TMatrixTSym< Double_t >; TMatrix",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:28632,Energy Efficiency,green,green,28632,"aceAll( ""]"", ""_"" );; 816 snew.ReplaceAll( ""="", ""_E_"" );; 817 snew.ReplaceAll( "">"", ""_GT_"" );; 818 snew.ReplaceAll( ""<"", ""_LT_"" );; 819 snew.ReplaceAll( ""("", ""_"" );; 820 snew.ReplaceAll( "")"", ""_"" );; 821 ; 822 return snew;; 823}; 824 ; 825////////////////////////////////////////////////////////////////////////////////; 826/// human readable color strings; 827 ; 828const TString& TMVA::Tools::Color( const TString& c ); 829{; 830 static const TString gClr_none = """" ;; 831 static const TString gClr_white = ""\033[1;37m""; // white; 832 static const TString gClr_black = ""\033[30m""; // black; 833 static const TString gClr_blue = ""\033[34m""; // blue; 834 static const TString gClr_red = ""\033[1;31m"" ; // red; 835 static const TString gClr_yellow = ""\033[1;33m""; // yellow; 836 static const TString gClr_darkred = ""\033[31m""; // dark red; 837 static const TString gClr_darkgreen = ""\033[32m""; // dark green; 838 static const TString gClr_darkyellow = ""\033[33m""; // dark yellow; 839 ; 840 static const TString gClr_bold = ""\033[1m"" ; // bold; 841 static const TString gClr_black_b = ""\033[30m"" ; // bold black; 842 static const TString gClr_lblue_b = ""\033[1;34m"" ; // bold light blue; 843 static const TString gClr_cyan_b = ""\033[0;36m"" ; // bold cyan; 844 static const TString gClr_lgreen_b = ""\033[1;32m""; // bold light green; 845 ; 846 static const TString gClr_blue_bg = ""\033[44m""; // blue background; 847 static const TString gClr_red_bg = ""\033[1;41m""; // white on red background; 848 static const TString gClr_whiteonblue = ""\033[1;44m""; // white on blue background; 849 static const TString gClr_whiteongreen = ""\033[1;42m""; // white on green background; 850 static const TString gClr_grey_bg = ""\033[47m""; // grey background; 851 ; 852 static const TString gClr_reset = ""\033[0m""; // reset; 853 ; 854 if (!gConfig().UseColor()) return gClr_none;; 855 ; 856 if (c == ""white"" ) return gClr_white;; 857 if (c == ""blue"" ) return gClr_blue;; 858 if (c == ""black"" ) return gClr_black;; 859 if (c ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:29054,Energy Efficiency,green,green,29054,"aceAll( ""]"", ""_"" );; 816 snew.ReplaceAll( ""="", ""_E_"" );; 817 snew.ReplaceAll( "">"", ""_GT_"" );; 818 snew.ReplaceAll( ""<"", ""_LT_"" );; 819 snew.ReplaceAll( ""("", ""_"" );; 820 snew.ReplaceAll( "")"", ""_"" );; 821 ; 822 return snew;; 823}; 824 ; 825////////////////////////////////////////////////////////////////////////////////; 826/// human readable color strings; 827 ; 828const TString& TMVA::Tools::Color( const TString& c ); 829{; 830 static const TString gClr_none = """" ;; 831 static const TString gClr_white = ""\033[1;37m""; // white; 832 static const TString gClr_black = ""\033[30m""; // black; 833 static const TString gClr_blue = ""\033[34m""; // blue; 834 static const TString gClr_red = ""\033[1;31m"" ; // red; 835 static const TString gClr_yellow = ""\033[1;33m""; // yellow; 836 static const TString gClr_darkred = ""\033[31m""; // dark red; 837 static const TString gClr_darkgreen = ""\033[32m""; // dark green; 838 static const TString gClr_darkyellow = ""\033[33m""; // dark yellow; 839 ; 840 static const TString gClr_bold = ""\033[1m"" ; // bold; 841 static const TString gClr_black_b = ""\033[30m"" ; // bold black; 842 static const TString gClr_lblue_b = ""\033[1;34m"" ; // bold light blue; 843 static const TString gClr_cyan_b = ""\033[0;36m"" ; // bold cyan; 844 static const TString gClr_lgreen_b = ""\033[1;32m""; // bold light green; 845 ; 846 static const TString gClr_blue_bg = ""\033[44m""; // blue background; 847 static const TString gClr_red_bg = ""\033[1;41m""; // white on red background; 848 static const TString gClr_whiteonblue = ""\033[1;44m""; // white on blue background; 849 static const TString gClr_whiteongreen = ""\033[1;42m""; // white on green background; 850 static const TString gClr_grey_bg = ""\033[47m""; // grey background; 851 ; 852 static const TString gClr_reset = ""\033[0m""; // reset; 853 ; 854 if (!gConfig().UseColor()) return gClr_none;; 855 ; 856 if (c == ""white"" ) return gClr_white;; 857 if (c == ""blue"" ) return gClr_blue;; 858 if (c == ""black"" ) return gClr_black;; 859 if (c ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:29378,Energy Efficiency,green,green,29378,"aceAll( ""]"", ""_"" );; 816 snew.ReplaceAll( ""="", ""_E_"" );; 817 snew.ReplaceAll( "">"", ""_GT_"" );; 818 snew.ReplaceAll( ""<"", ""_LT_"" );; 819 snew.ReplaceAll( ""("", ""_"" );; 820 snew.ReplaceAll( "")"", ""_"" );; 821 ; 822 return snew;; 823}; 824 ; 825////////////////////////////////////////////////////////////////////////////////; 826/// human readable color strings; 827 ; 828const TString& TMVA::Tools::Color( const TString& c ); 829{; 830 static const TString gClr_none = """" ;; 831 static const TString gClr_white = ""\033[1;37m""; // white; 832 static const TString gClr_black = ""\033[30m""; // black; 833 static const TString gClr_blue = ""\033[34m""; // blue; 834 static const TString gClr_red = ""\033[1;31m"" ; // red; 835 static const TString gClr_yellow = ""\033[1;33m""; // yellow; 836 static const TString gClr_darkred = ""\033[31m""; // dark red; 837 static const TString gClr_darkgreen = ""\033[32m""; // dark green; 838 static const TString gClr_darkyellow = ""\033[33m""; // dark yellow; 839 ; 840 static const TString gClr_bold = ""\033[1m"" ; // bold; 841 static const TString gClr_black_b = ""\033[30m"" ; // bold black; 842 static const TString gClr_lblue_b = ""\033[1;34m"" ; // bold light blue; 843 static const TString gClr_cyan_b = ""\033[0;36m"" ; // bold cyan; 844 static const TString gClr_lgreen_b = ""\033[1;32m""; // bold light green; 845 ; 846 static const TString gClr_blue_bg = ""\033[44m""; // blue background; 847 static const TString gClr_red_bg = ""\033[1;41m""; // white on red background; 848 static const TString gClr_whiteonblue = ""\033[1;44m""; // white on blue background; 849 static const TString gClr_whiteongreen = ""\033[1;42m""; // white on green background; 850 static const TString gClr_grey_bg = ""\033[47m""; // grey background; 851 ; 852 static const TString gClr_reset = ""\033[0m""; // reset; 853 ; 854 if (!gConfig().UseColor()) return gClr_none;; 855 ; 856 if (c == ""white"" ) return gClr_white;; 857 if (c == ""blue"" ) return gClr_blue;; 858 if (c == ""black"" ) return gClr_black;; 859 if (c ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:404,Integrability,integrat,integrated,404,". ROOT: tmva/tmva/src/Tools.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Tools.cxx. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Jan Therhaag; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : Tools *; 8 * *; 9 * *; 10 * Description: *; 11 * Implementation (see header for description) *; 12 * *; 13 * Authors (alphabetical): *; 14 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 15 * Peter Speckmayer <Peter.Speckmayer@cern.ch> - CERN, Switzerland *; 16 * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; 17 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 18 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 19 * *; 20 * Copyright (c) 2005-2011: *; 21 * CERN, Switzerland *; 22 * U. of Victoria, Canada *; 23 * MPI-K Heidelberg, Germany *; 24 * U. of Bonn, Germany *; 25 * *; 26 * Redistribution and use in source and binary forms, with or without *; 27 * modification, are permitted according to the terms listed in LICENSE *; 28 * (see tmva/doc/LICENSE) *; 29 **********************************************************************************/; 30 ; 31/*! \class TMVA::Tools; 32\ingroup TMVA; 33Global auxiliary applications and data treatment routines.; 34*/; 35 ; 36#include ""TMVA/Tools.h""; 37 ; 38#include ""TMVA/Config.h""; 39#include ""TMVA/Event.h""; 40#include ""TMVA/Version.h""; 41#include ""TMVA/PDF.h""; 42#include ""TMVA/MsgLogger.h""; 43#include ""TMVA/Types.h""; 44 ; 45#include ""TObjString.h""; 46#include ""TMath.h""; 47#include ""TString.h""; 48#include ""TTree.h""; 49#include ""TLeaf.h""; 50#include ""TH1.h""; 51#include ""TH2.h""; 52#include ""TList.h""; 53#include ""TSpline.h""; 54#include ""TVector.h""; 55#include ""TMatrixD.h""; 56#include ""TMatrixDSymE",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:1499,Integrability,rout,routines,1499,"***********************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : Tools *; 8 * *; 9 * *; 10 * Description: *; 11 * Implementation (see header for description) *; 12 * *; 13 * Authors (alphabetical): *; 14 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 15 * Peter Speckmayer <Peter.Speckmayer@cern.ch> - CERN, Switzerland *; 16 * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; 17 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 18 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 19 * *; 20 * Copyright (c) 2005-2011: *; 21 * CERN, Switzerland *; 22 * U. of Victoria, Canada *; 23 * MPI-K Heidelberg, Germany *; 24 * U. of Bonn, Germany *; 25 * *; 26 * Redistribution and use in source and binary forms, with or without *; 27 * modification, are permitted according to the terms listed in LICENSE *; 28 * (see tmva/doc/LICENSE) *; 29 **********************************************************************************/; 30 ; 31/*! \class TMVA::Tools; 32\ingroup TMVA; 33Global auxiliary applications and data treatment routines.; 34*/; 35 ; 36#include ""TMVA/Tools.h""; 37 ; 38#include ""TMVA/Config.h""; 39#include ""TMVA/Event.h""; 40#include ""TMVA/Version.h""; 41#include ""TMVA/PDF.h""; 42#include ""TMVA/MsgLogger.h""; 43#include ""TMVA/Types.h""; 44 ; 45#include ""TObjString.h""; 46#include ""TMath.h""; 47#include ""TString.h""; 48#include ""TTree.h""; 49#include ""TLeaf.h""; 50#include ""TH1.h""; 51#include ""TH2.h""; 52#include ""TList.h""; 53#include ""TSpline.h""; 54#include ""TVector.h""; 55#include ""TMatrixD.h""; 56#include ""TMatrixDSymEigen.h""; 57#include ""TVectorD.h""; 58#include ""TTreeFormula.h""; 59#include ""TXMLEngine.h""; 60#include ""TROOT.h""; 61 ; 62#include <algorithm>; 63#include <cstdlib>; 64#include <iomanip>; 65 ; 66using std::vector, std::setw, std::istream, std::ostream;; 67 ; 68std::atomic<TMVA::Tools*> TMVA::Tools::fgTool",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:21410,Integrability,depend,dependency,21410,"86/// Mutual Information method for non-linear correlations estimates in 2D histogram; 587/// Author: Moritz Backes, Geneva (2009); 588 ; 589Double_t TMVA::Tools::GetMutualInformation( const TH2F& h_ ); 590{; 591 Double_t hi = h_.Integral();; 592 if (hi == 0) return -1;; 593 ; 594 // copy histogram and rebin to speed up procedure; 595 TH2F h( h_ );; 596 h.RebinX(2);; 597 h.RebinY(2);; 598 ; 599 Double_t mutualInfo = 0.;; 600 Int_t maxBinX = h.GetNbinsX();; 601 Int_t maxBinY = h.GetNbinsY();; 602 for (Int_t x = 1; x <= maxBinX; x++) {; 603 for (Int_t y = 1; y <= maxBinY; y++) {; 604 Double_t p_xy = h.GetBinContent(x,y)/hi;; 605 Double_t p_x = h.Integral(x,x,1,maxBinY)/hi;; 606 Double_t p_y = h.Integral(1,maxBinX,y,y)/hi;; 607 if (p_x > 0. && p_y > 0. && p_xy > 0.){; 608 mutualInfo += p_xy*TMath::Log(p_xy / (p_x * p_y));; 609 }; 610 }; 611 }; 612 ; 613 return mutualInfo;; 614}; 615 ; 616////////////////////////////////////////////////////////////////////////////////; 617/// Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables; 618/// Author: Moritz Backes, Geneva (2009); 619 ; 620Double_t TMVA::Tools::GetCorrelationRatio( const TH2F& h_ ); 621{; 622 Double_t hi = h_.Integral();; 623 if (hi == 0.) return -1;; 624 ; 625 // copy histogram and rebin to speed up procedure; 626 TH2F h( h_ );; 627 h.RebinX(2);; 628 h.RebinY(2);; 629 ; 630 Double_t corrRatio = 0.;; 631 Double_t y_mean = h.ProjectionY()->GetMean();; 632 for (Int_t ix=1; ix<=h.GetNbinsX(); ix++) {; 633 corrRatio += (h.Integral(ix,ix,1,h.GetNbinsY())/hi)*pow((GetYMean_binX(h,ix)-y_mean),2);; 634 }; 635 corrRatio /= pow(h.ProjectionY()->GetRMS(),2);; 636 return corrRatio;; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Compute the mean in Y for a given bin X of a 2D histogram; 641 ; 642Double_t TMVA::Tools::GetYMean_binX( const TH2& h, Int_t bin_x ); 643{; 644 if (h.Integral(bin_x,bin_x,1,h.GetNbinsY()) == 0.) {r",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:46972,Integrability,message,messages,46972,"DATE << std::endl;; 1307 std::cout << "" "" << ""Copyright (C) 2005-2010 CERN, MPI-K Heidelberg, Us of Bonn and Victoria"" << std::endl;; 1308 std::cout << "" "" << ""Home page: http://tmva.sf.net"" << std::endl;; 1309 std::cout << "" "" << ""Citation info: http://tmva.sf.net/citeTMVA.html"" << std::endl;; 1310 std::cout << "" "" << ""License: http://tmva.sf.net/LICENSE"" << std::endl << std::endl;; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// prints the TMVA release number and date; 1315 ; 1316void TMVA::Tools::TMVAVersionMessage( MsgLogger& logger ); 1317{; 1318 logger << ""___________TMVA Version "" << TMVA_RELEASE << "", "" << TMVA_RELEASE_DATE; 1319 << """" << Endl;; 1320}; 1321 ; 1322////////////////////////////////////////////////////////////////////////////////; 1323/// prints the ROOT release number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LA",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:50943,Integrability,message,message,50943,"; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A.",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:71564,Integrability,depend,depending,71564,"xx:9020; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH2.cxx:2616; TH2::IntegralDouble_t Integral(Option_t *option="""") const overrideReturn integral of bin contents.Definition TH2.cxx:1317; TH2::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH2.cxx:2485; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMVA::EventDefinition Event.h:51; TMVA::Event::GetValueFloat_t GetValue(UInt_t ivar) constreturn value of i'th variableDefinition Event.cxx:236; TMVA::Event::GetWeightDouble_t GetWeight() constreturn the event weight - depending on whether the flag IgnoreNegWeightsInTraining is or not.Definition Event.cxx:389; TMVA::Event::GetClassUInt_t GetClass() constDefinition Event.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefini",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:71833,Integrability,wrap,wrapper,71833,"ntegral(Option_t *option="""") const overrideReturn integral of bin contents.Definition TH2.cxx:1317; TH2::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH2.cxx:2485; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMVA::EventDefinition Event.h:51; TMVA::Event::GetValueFloat_t GetValue(UInt_t ivar) constreturn value of i'th variableDefinition Event.cxx:236; TMVA::Event::GetWeightDouble_t GetWeight() constreturn the event weight - depending on whether the flag IgnoreNegWeightsInTraining is or not.Definition Event.cxx:389; TMVA::Event::GetClassUInt_t GetClass() constDefinition Event.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:72199,Integrability,rout,routines,72199,"j) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMVA::EventDefinition Event.h:51; TMVA::Event::GetValueFloat_t GetValue(UInt_t ivar) constreturn value of i'th variableDefinition Event.cxx:236; TMVA::Event::GetWeightDouble_t GetWeight() constreturn the event weight - depending on whether the flag IgnoreNegWeightsInTraining is or not.Definition Event.cxx:389; TMVA::Event::GetClassUInt_t GetClass() constDefinition Event.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::HistoHasEquidistantBinsBool_t HistoHasEquidistantBins(const TH1 &h)Definition Tools.cxx:1486; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::NormVariableDouble_t NormVariable(",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:78323,Integrability,depend,dependency,78323,"id *node)XML helpers.Definition Tools.cxx:1174; TMVA::Tools::WriteTVectorDToXMLvoid WriteTVectorDToXML(void *node, const char *name, TVectorD *vec)Definition Tools.cxx:1259; TMVA::Tools::xmlengineTXMLEngine & xmlengine()Definition Tools.h:262; TMVA::Tools::Scalevoid Scale(std::vector< Double_t > &, Double_t)scales double vectorDefinition Tools.cxx:519; TMVA::Tools::CheckSplinesBool_t CheckSplines(const TH1 *, const TSpline *)check quality of splining by comparing splines and histograms in each binDefinition Tools.cxx:479; TMVA::Tools::GetNameconst char * GetName(void *node)XML helpers.Definition Tools.cxx:1182; TMVA::Tools::GetCorrelationMatrixconst TMatrixD * GetCorrelationMatrix(const TMatrixD *covMat)turns covariance into correlation matrixDefinition Tools.cxx:324; TMVA::Tools::WriteTMatrixDToXMLvoid WriteTMatrixDToXML(void *node, const char *name, TMatrixD *mat)XML helpers.Definition Tools.cxx:1243; TMVA::Tools::GetCorrelationRatioDouble_t GetCorrelationRatio(const TH2F &)Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables Aut...Definition Tools.cxx:620; TMVA::Tools::ReadAttrvoid ReadAttr(void *node, const char *, T &value)read attribute from xmlDefinition Tools.h:329; TMVA::Tools::fgToolsstatic std::atomic< Tools * > fgToolsDefinition Tools.h:229; TMVA::Tools::AddCommentBool_t AddComment(void *node, const char *comment)Definition Tools.cxx:1132; TMVA::Tools::ReadTMatrixDFromXMLvoid ReadTMatrixDFromXML(void *node, const char *name, TMatrixD *mat)Definition Tools.cxx:1276; TMVA::Tools::GetXTitleWithUnitTString GetXTitleWithUnit(const TString &title, const TString &unit)histogramming utilityDefinition Tools.cxx:1040; TMVA::Tools::GetChildvoid * GetChild(void *parent, const char *childname=nullptr)get child nodeDefinition Tools.cxx:1150; TMVA::Tools::AddAttrvoid AddAttr(void *node, const char *, const T &value, Int_t precision=16)add attribute to xmlDefinition Tools.h:347; TMVA::Tools::ECitationECitationDefinition Tools",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:11785,Modifiability,variab,variables,11785,"Print();; 295 Log() << kWARNING << ""<GetSQRootMatrix> error in matrix diagonalization; printed S and B"" << Endl;; 296 }; 297 }; 298 }; 299 ; 300 // make exactly diagonal; 301 for (i=0; i<n; i++) for (j=0; j<n; j++) if (j != i) (*d)(i,j) = 0;; 302 ; 303 // compute the square-root C' of covariance matrix: C = C'*C'; 304 for (i=0; i<n; i++) (*d)(i,i) = TMath::Sqrt((*d)(i,i));; 305 ; 306 TMatrixD* sqrtMat = new TMatrixD( n, n );; 307 sqrtMat->Mult( (*s), (*d) );; 308 (*sqrtMat) *= (*si);; 309 ; 310 // invert square-root matrices; 311 sqrtMat->Invert();; 312 ; 313 delete eigen;; 314 delete s;; 315 delete si;; 316 delete d;; 317 ; 318 return sqrtMat;; 319}; 320 ; 321////////////////////////////////////////////////////////////////////////////////; 322/// turns covariance into correlation matrix; 323 ; 324const TMatrixD* TMVA::Tools::GetCorrelationMatrix( const TMatrixD* covMat ); 325{; 326 ; 327 if (covMat == 0) return 0;; 328 // sanity check; 329 Int_t nvar = covMat->GetNrows();; 330 if (nvar != covMat->GetNcols()); 331 Log() << kFATAL << ""<GetCorrelationMatrix> input matrix not quadratic"" << Endl;; 332 ; 333 Log() << kWARNING;; 334 TMatrixD* corrMat = new TMatrixD( nvar, nvar );; 335 for (Int_t ivar=0; ivar<nvar; ivar++) {; 336 for (Int_t jvar=0; jvar<nvar; jvar++) {; 337 if (ivar != jvar) {; 338 Double_t d = (*covMat)(ivar, ivar)*(*covMat)(jvar, jvar);; 339 if (d > 1E-20) {; 340 (*corrMat)(ivar, jvar) = (*covMat)(ivar, jvar)/TMath::Sqrt(d);; 341 } else {; 342 Log() << ""<GetCorrelationMatrix> zero variances for variables ""; 343 << ""("" << ivar << "", "" << jvar << "")"" << Endl;; 344 (*corrMat)(ivar, jvar) = 0;; 345 }; 346 if (TMath::Abs( (*corrMat)(ivar,jvar)) > 1){; 347 Log() << kWARNING; 348 << "" Element corr(""<<ivar<<"",""<<ivar<<"")="" << (*corrMat)(ivar,jvar); 349 << "" sigma2=""<<d; 350 << "" cov(""<<ivar<<"",""<<ivar<<"")="" <<(*covMat)(ivar, ivar); 351 << "" cov(""<<jvar<<"",""<<jvar<<"")="" <<(*covMat)(jvar, jvar); 352 << Endl;; 353 ; 354 }; 355 }; 356 else (*corrMat)(ivar, ivar) = 1.",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:12426,Modifiability,variab,variable,12426,"var=0; jvar<nvar; jvar++) {; 337 if (ivar != jvar) {; 338 Double_t d = (*covMat)(ivar, ivar)*(*covMat)(jvar, jvar);; 339 if (d > 1E-20) {; 340 (*corrMat)(ivar, jvar) = (*covMat)(ivar, jvar)/TMath::Sqrt(d);; 341 } else {; 342 Log() << ""<GetCorrelationMatrix> zero variances for variables ""; 343 << ""("" << ivar << "", "" << jvar << "")"" << Endl;; 344 (*corrMat)(ivar, jvar) = 0;; 345 }; 346 if (TMath::Abs( (*corrMat)(ivar,jvar)) > 1){; 347 Log() << kWARNING; 348 << "" Element corr(""<<ivar<<"",""<<ivar<<"")="" << (*corrMat)(ivar,jvar); 349 << "" sigma2=""<<d; 350 << "" cov(""<<ivar<<"",""<<ivar<<"")="" <<(*covMat)(ivar, ivar); 351 << "" cov(""<<jvar<<"",""<<jvar<<"")="" <<(*covMat)(jvar, jvar); 352 << Endl;; 353 ; 354 }; 355 }; 356 else (*corrMat)(ivar, ivar) = 1.0;; 357 }; 358 }; 359 Log() << Endl;; 360 return corrMat;; 361}; 362 ; 363////////////////////////////////////////////////////////////////////////////////; 364/// projects variable from tree into normalised histogram; 365 ; 366TH1* TMVA::Tools::projNormTH1F( TTree* theTree, const TString& theVarName,; 367 const TString& name, Int_t nbins,; 368 Double_t xmin, Double_t xmax, const TString& cut ); 369{; 370 // needed because of ROOT bug (feature) that excludes events that have value == xmax; 371 xmax += 0.00001;; 372 ; 373 TH1* hist = new TH1F( name, name, nbins, xmin, xmax );; 374 hist->Sumw2(); // enable quadratic errors; 375 theTree->Project( name, theVarName, cut );; 376 NormHist( hist );; 377 return hist;; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// normalises histogram; 382 ; 383Double_t TMVA::Tools::NormHist( TH1* theHist, Double_t norm ); 384{; 385 if (!theHist) return 0;; 386 ; 387 if (theHist->GetSumw2N() == 0) theHist->Sumw2();; 388 if (theHist->GetSumOfWeights() != 0) {; 389 Double_t w = ( theHist->GetSumOfWeights(); 390 *(theHist->GetXaxis()->GetXmax() - theHist->GetXaxis()->GetXmin())/theHist->GetNbinsX() );; 391 if (w > 0) theHist->Scale( norm/w );; 392 return w;;",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:14917,Modifiability,variab,variables,14917," ; 401TList* TMVA::Tools::ParseFormatLine( TString formatString, const char* sep ); 402{; 403 TList* labelList = new TList();; 404 labelList->SetOwner();; 405 while (formatString.First(sep)==0) formatString.Remove(0,1); // remove initial separators; 406 ; 407 while (formatString.Length()>0) {; 408 if (formatString.First(sep) == -1) { // no more separator; 409 labelList->Add(new TObjString(formatString.Data()));; 410 formatString="""";; 411 break;; 412 }; 413 ; 414 Ssiz_t posSep = formatString.First(sep);; 415 labelList->Add(new TObjString(TString(formatString(0,posSep)).Data()));; 416 formatString.Remove(0,posSep+1);; 417 ; 418 while (formatString.First(sep)==0) formatString.Remove(0,1); // remove additional separators; 419 ; 420 }; 421 return labelList;; 422}; 423 ; 424////////////////////////////////////////////////////////////////////////////////; 425/// parse option string for ANN methods; 426/// default settings (should be defined in theOption string); 427///; 428/// format and syntax of option string: ""3000:N:N+2:N-3:6""; 429///; 430/// where:; 431/// - 3000 - number of training cycles (epochs); 432/// - N - number of nodes in first hidden layer, where N is the number; 433/// of discriminating variables used (note that the first ANN; 434/// layer necessarily has N nodes, and hence is not given).; 435/// - N+2 - number of nodes in 2nd hidden layer (2 nodes more than; 436/// number of variables); 437/// - N-3 - number of nodes in 3rd hidden layer (3 nodes less than; 438/// number of variables); 439/// - 6 - 6 nodes in last (4th) hidden layer (note that the last ANN; 440/// layer in MVA has 2 nodes, each one for signal and background; 441/// classes); 442 ; 443vector<Int_t>* TMVA::Tools::ParseANNOptionString( TString theOptions, Int_t nvar,; 444 vector<Int_t>* nodes ); 445{; 446 TList* list = TMVA::Tools::ParseFormatLine( theOptions, "":"" );; 447 ; 448 ; 449 // sanity check; 450 if (list->GetSize() < 1) {; 451 Log() << kFATAL << ""<ParseANNOptionString> unrecognized op",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:15110,Modifiability,variab,variables,15110,"////////////////////////////////////////; 425/// parse option string for ANN methods; 426/// default settings (should be defined in theOption string); 427///; 428/// format and syntax of option string: ""3000:N:N+2:N-3:6""; 429///; 430/// where:; 431/// - 3000 - number of training cycles (epochs); 432/// - N - number of nodes in first hidden layer, where N is the number; 433/// of discriminating variables used (note that the first ANN; 434/// layer necessarily has N nodes, and hence is not given).; 435/// - N+2 - number of nodes in 2nd hidden layer (2 nodes more than; 436/// number of variables); 437/// - N-3 - number of nodes in 3rd hidden layer (3 nodes less than; 438/// number of variables); 439/// - 6 - 6 nodes in last (4th) hidden layer (note that the last ANN; 440/// layer in MVA has 2 nodes, each one for signal and background; 441/// classes); 442 ; 443vector<Int_t>* TMVA::Tools::ParseANNOptionString( TString theOptions, Int_t nvar,; 444 vector<Int_t>* nodes ); 445{; 446 TList* list = TMVA::Tools::ParseFormatLine( theOptions, "":"" );; 447 ; 448 ; 449 // sanity check; 450 if (list->GetSize() < 1) {; 451 Log() << kFATAL << ""<ParseANNOptionString> unrecognized option string: "" << theOptions << Endl;; 452 }; 453 ; 454 // add number of cycles; 455 nodes->push_back( atoi( ((TObjString*)list->At(0))->GetString() ) );; 456 ; 457 Int_t a;; 458 if (list->GetSize() > 1) {; 459 for (Int_t i=1; i<list->GetSize(); i++) {; 460 TString s = ((TObjString*)list->At(i))->GetString();; 461 s.ToUpper();; 462 if (s(0) == 'N') {; 463 if (s.Length() > 1) nodes->push_back( nvar + atoi(&s[1]) );; 464 else nodes->push_back( nvar );; 465 }; 466 else if ((a = atoi( s )) > 0) nodes->push_back( atoi(s ) );; 467 else {; 468 Log() << kFATAL << ""<ParseANNOptionString> unrecognized option string: "" << theOptions << Endl;; 469 }; 470 }; 471 }; 472 ; 473 return nodes;; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// check quality of splining by",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:15210,Modifiability,variab,variables,15210,"////////////////////////////////////////; 425/// parse option string for ANN methods; 426/// default settings (should be defined in theOption string); 427///; 428/// format and syntax of option string: ""3000:N:N+2:N-3:6""; 429///; 430/// where:; 431/// - 3000 - number of training cycles (epochs); 432/// - N - number of nodes in first hidden layer, where N is the number; 433/// of discriminating variables used (note that the first ANN; 434/// layer necessarily has N nodes, and hence is not given).; 435/// - N+2 - number of nodes in 2nd hidden layer (2 nodes more than; 436/// number of variables); 437/// - N-3 - number of nodes in 3rd hidden layer (3 nodes less than; 438/// number of variables); 439/// - 6 - 6 nodes in last (4th) hidden layer (note that the last ANN; 440/// layer in MVA has 2 nodes, each one for signal and background; 441/// classes); 442 ; 443vector<Int_t>* TMVA::Tools::ParseANNOptionString( TString theOptions, Int_t nvar,; 444 vector<Int_t>* nodes ); 445{; 446 TList* list = TMVA::Tools::ParseFormatLine( theOptions, "":"" );; 447 ; 448 ; 449 // sanity check; 450 if (list->GetSize() < 1) {; 451 Log() << kFATAL << ""<ParseANNOptionString> unrecognized option string: "" << theOptions << Endl;; 452 }; 453 ; 454 // add number of cycles; 455 nodes->push_back( atoi( ((TObjString*)list->At(0))->GetString() ) );; 456 ; 457 Int_t a;; 458 if (list->GetSize() > 1) {; 459 for (Int_t i=1; i<list->GetSize(); i++) {; 460 TString s = ((TObjString*)list->At(i))->GetString();; 461 s.ToUpper();; 462 if (s(0) == 'N') {; 463 if (s.Length() > 1) nodes->push_back( nvar + atoi(&s[1]) );; 464 else nodes->push_back( nvar );; 465 }; 466 else if ((a = atoi( s )) > 0) nodes->push_back( atoi(s ) );; 467 else {; 468 Log() << kFATAL << ""<ParseANNOptionString> unrecognized option string: "" << theOptions << Endl;; 469 }; 470 }; 471 }; 472 ; 473 return nodes;; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// check quality of splining by",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:21433,Modifiability,variab,variables,21433,"86/// Mutual Information method for non-linear correlations estimates in 2D histogram; 587/// Author: Moritz Backes, Geneva (2009); 588 ; 589Double_t TMVA::Tools::GetMutualInformation( const TH2F& h_ ); 590{; 591 Double_t hi = h_.Integral();; 592 if (hi == 0) return -1;; 593 ; 594 // copy histogram and rebin to speed up procedure; 595 TH2F h( h_ );; 596 h.RebinX(2);; 597 h.RebinY(2);; 598 ; 599 Double_t mutualInfo = 0.;; 600 Int_t maxBinX = h.GetNbinsX();; 601 Int_t maxBinY = h.GetNbinsY();; 602 for (Int_t x = 1; x <= maxBinX; x++) {; 603 for (Int_t y = 1; y <= maxBinY; y++) {; 604 Double_t p_xy = h.GetBinContent(x,y)/hi;; 605 Double_t p_x = h.Integral(x,x,1,maxBinY)/hi;; 606 Double_t p_y = h.Integral(1,maxBinX,y,y)/hi;; 607 if (p_x > 0. && p_y > 0. && p_xy > 0.){; 608 mutualInfo += p_xy*TMath::Log(p_xy / (p_x * p_y));; 609 }; 610 }; 611 }; 612 ; 613 return mutualInfo;; 614}; 615 ; 616////////////////////////////////////////////////////////////////////////////////; 617/// Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables; 618/// Author: Moritz Backes, Geneva (2009); 619 ; 620Double_t TMVA::Tools::GetCorrelationRatio( const TH2F& h_ ); 621{; 622 Double_t hi = h_.Integral();; 623 if (hi == 0.) return -1;; 624 ; 625 // copy histogram and rebin to speed up procedure; 626 TH2F h( h_ );; 627 h.RebinX(2);; 628 h.RebinY(2);; 629 ; 630 Double_t corrRatio = 0.;; 631 Double_t y_mean = h.ProjectionY()->GetMean();; 632 for (Int_t ix=1; ix<=h.GetNbinsX(); ix++) {; 633 corrRatio += (h.Integral(ix,ix,1,h.GetNbinsY())/hi)*pow((GetYMean_binX(h,ix)-y_mean),2);; 634 }; 635 corrRatio /= pow(h.ProjectionY()->GetRMS(),2);; 636 return corrRatio;; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Compute the mean in Y for a given bin X of a 2D histogram; 641 ; 642Double_t TMVA::Tools::GetYMean_binX( const TH2& h, Int_t bin_x ); 643{; 644 if (h.Integral(bin_x,bin_x,1,h.GetNbinsY()) == 0.) {r",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:23895,Modifiability,config,configuration,23895,"/// Transpose quadratic histogram; 656 ; 657TH2F* TMVA::Tools::TransposeHist( const TH2F& h ); 658{; 659 // sanity check; 660 if (h.GetNbinsX() != h.GetNbinsY()) {; 661 Log() << kFATAL << ""<TransposeHist> cannot transpose non-quadratic histogram"" << Endl;; 662 }; 663 ; 664 TH2F *transposedHisto = new TH2F( h );; 665 for (Int_t ix=1; ix <= h.GetNbinsX(); ix++){; 666 for (Int_t iy=1; iy <= h.GetNbinsY(); iy++){; 667 transposedHisto->SetBinContent(iy,ix,h.GetBinContent(ix,iy));; 668 }; 669 }; 670 ; 671 // copy stats (thanks to Swagato Banerjee for pointing out the missing stats information); 672 Double_t stats_old[7];; 673 Double_t stats_new[7];; 674 ; 675 h.GetStats(stats_old);; 676 stats_new[0] = stats_old[0];; 677 stats_new[1] = stats_old[1];; 678 stats_new[2] = stats_old[4];; 679 stats_new[3] = stats_old[5];; 680 stats_new[4] = stats_old[2];; 681 stats_new[5] = stats_old[3];; 682 stats_new[6] = stats_old[6];; 683 transposedHisto->PutStats(stats_new);; 684 ; 685 return transposedHisto; // ownership returned; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// check for ""silence"" option in configuration option string; 690 ; 691Bool_t TMVA::Tools::CheckForSilentOption( const TString& cs ) const; 692{; 693 Bool_t isSilent = kFALSE;; 694 ; 695 TString s( cs );; 696 s.ToLower();; 697 s.ReplaceAll("" "","""");; 698 if (s.Contains(""silent"") && !s.Contains(""silent=f"")) {; 699 if (!s.Contains(""!silent"") || s.Contains(""silent=t"")) isSilent = kTRUE;; 700 }; 701 ; 702 return isSilent;; 703}; 704 ; 705////////////////////////////////////////////////////////////////////////////////; 706/// check if verbosity ""V"" set in option; 707 ; 708Bool_t TMVA::Tools::CheckForVerboseOption( const TString& cs ) const; 709{; 710 Bool_t isVerbose = kFALSE;; 711 ; 712 TString s( cs );; 713 s.ToLower();; 714 s.ReplaceAll("" "","""");; 715 std::vector<TString> v = SplitString( s, ':' );; 716 for (std::vector<TString>::iterator it = v.begin(); it != v.end(",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:32781,Modifiability,variab,variable,32781,"gger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:34298,Modifiability,variab,variable,34298,"t_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 l",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:71456,Modifiability,variab,variableDefinition,71456,"TH1.cxx:7917; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH2.cxx:2616; TH2::IntegralDouble_t Integral(Option_t *option="""") const overrideReturn integral of bin contents.Definition TH2.cxx:1317; TH2::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH2.cxx:2485; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMVA::EventDefinition Event.h:51; TMVA::Event::GetValueFloat_t GetValue(UInt_t ivar) constreturn value of i'th variableDefinition Event.cxx:236; TMVA::Event::GetWeightDouble_t GetWeight() constreturn the event weight - depending on whether the flag IgnoreNegWeightsInTraining is or not.Definition Event.cxx:389; TMVA::Event::GetClassUInt_t GetClass() constDefinition Event.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:74498,Modifiability,variab,variable,74498,"amDefinition Tools.cxx:1058; TMVA::Tools::GetYTitleWithUnitTString GetYTitleWithUnit(const TH1 &h, const TString &unit, Bool_t normalised)histogramming utilityDefinition Tools.cxx:1048; TMVA::Tools::GetSeparationDouble_t GetSeparation(TH1 *S, TH1 *B) constcompute ""separation"" defined asDefinition Tools.cxx:121; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::GetSQRootMatrixTMatrixD * GetSQRootMatrix(TMatrixDSym *symMat)square-root of symmetric matrix of course the resulting sqrtMat is also symmetric,...Definition Tools.cxx:271; TMVA::Tools::MVADiffstd::vector< Double_t > MVADiff(std::vector< Double_t > &, std::vector< Double_t > &)computes difference between two vectorsDefinition Tools.cxx:506; TMVA::Tools::GetIndexMinElementInt_t GetIndexMinElement(std::vector< Double_t > &)find index of minimum entry in vectorDefinition Tools.cxx:765; TMVA::Tools::projNormTH1FTH1 * projNormTH1F(TTree *theTree, const TString &theVarName, const TString &name, Int_t nbins, Double_t xmin, Double_t xmax, const TString &cut)projects variable from tree into normalised histogramDefinition Tools.cxx:366; TMVA::Tools::ROOTVersionMessagevoid ROOTVersionMessage(MsgLogger &logger)prints the ROOT release number and dateDefinition Tools.cxx:1325; TMVA::Tools::ReplaceRegularExpressionsTString ReplaceRegularExpressions(const TString &s, const TString &replace=""+"")replace regular expressions helper function to remove all occurrences ""$!%^&()'<>?...Definition Tools.cxx:798; TMVA::Tools::ReadTVectorDFromXMLvoid ReadTVectorDFromXML(void *node, const char *name, TVectorD *vec)Definition Tools.cxx:1267; TMVA::Tools::GetCumulativeDistTH1 * GetCumulativeDist(TH1 *h)get the cumulative distribution of a histogramDefinition Tools.cxx:1756; TMVA::Tools::ReadFloatArbitraryPrecisionvoid ReadFloatArbitraryPrecision(Float_t &val, std::istream &is)reads a float value with the available precision from a streamDefinition Tools.cxx:1073; TMVA::Tools::AddRawLineBool_t AddRawLine(void",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:78346,Modifiability,variab,variables,78346,"id *node)XML helpers.Definition Tools.cxx:1174; TMVA::Tools::WriteTVectorDToXMLvoid WriteTVectorDToXML(void *node, const char *name, TVectorD *vec)Definition Tools.cxx:1259; TMVA::Tools::xmlengineTXMLEngine & xmlengine()Definition Tools.h:262; TMVA::Tools::Scalevoid Scale(std::vector< Double_t > &, Double_t)scales double vectorDefinition Tools.cxx:519; TMVA::Tools::CheckSplinesBool_t CheckSplines(const TH1 *, const TSpline *)check quality of splining by comparing splines and histograms in each binDefinition Tools.cxx:479; TMVA::Tools::GetNameconst char * GetName(void *node)XML helpers.Definition Tools.cxx:1182; TMVA::Tools::GetCorrelationMatrixconst TMatrixD * GetCorrelationMatrix(const TMatrixD *covMat)turns covariance into correlation matrixDefinition Tools.cxx:324; TMVA::Tools::WriteTMatrixDToXMLvoid WriteTMatrixDToXML(void *node, const char *name, TMatrixD *mat)XML helpers.Definition Tools.cxx:1243; TMVA::Tools::GetCorrelationRatioDouble_t GetCorrelationRatio(const TH2F &)Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables Aut...Definition Tools.cxx:620; TMVA::Tools::ReadAttrvoid ReadAttr(void *node, const char *, T &value)read attribute from xmlDefinition Tools.h:329; TMVA::Tools::fgToolsstatic std::atomic< Tools * > fgToolsDefinition Tools.h:229; TMVA::Tools::AddCommentBool_t AddComment(void *node, const char *comment)Definition Tools.cxx:1132; TMVA::Tools::ReadTMatrixDFromXMLvoid ReadTMatrixDFromXML(void *node, const char *name, TMatrixD *mat)Definition Tools.cxx:1276; TMVA::Tools::GetXTitleWithUnitTString GetXTitleWithUnit(const TString &title, const TString &unit)histogramming utilityDefinition Tools.cxx:1040; TMVA::Tools::GetChildvoid * GetChild(void *parent, const char *childname=nullptr)get child nodeDefinition Tools.cxx:1150; TMVA::Tools::AddAttrvoid AddAttr(void *node, const char *, const T &value, Int_t precision=16)add attribute to xmlDefinition Tools.h:347; TMVA::Tools::ECitationECitationDefinition Tools",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:81818,Modifiability,config,configuration,81818,"reDefinition Tools.cxx:1302; TMVA::Tools::ParseANNOptionStringstd::vector< Int_t > * ParseANNOptionString(TString theOptions, Int_t nvar, std::vector< Int_t > *nodes)parse option string for ANN methods default settings (should be defined in theOption string)Definition Tools.cxx:443; TMVA::Tools::GetIndexMaxElementInt_t GetIndexMaxElement(std::vector< Double_t > &)find index of maximum entry in vectorDefinition Tools.cxx:748; TMVA::Tools::TransposeHistTH2F * TransposeHist(const TH2F &)Transpose quadratic histogram.Definition Tools.cxx:657; TMVA::Tools::EWelcomeMessageEWelcomeMessageDefinition Tools.h:198; TMVA::Tools::HasAttrBool_t HasAttr(void *node, const char *attrname)add attribute from xmlDefinition Tools.cxx:1094; TMVA::Tools::GetNextChildvoid * GetNextChild(void *prevchild, const char *childname=nullptr)XML helpers.Definition Tools.cxx:1162; TMVA::Tools::fRegexpconst TString fRegexpDefinition Tools.h:226; TMVA::Tools::CheckForSilentOptionBool_t CheckForSilentOption(const TString &) constcheck for ""silence"" option in configuration option stringDefinition Tools.cxx:691; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::GetInputvirtual Bool_t GetInput(const Event *event, std::vector< Float_t > &input, std::vector< Char_t > &mask, Bool_t backTransform=kFALSE) constselect the values from the eventDefinition VariableTransformBase.cxx:315; TMVA::VariableTransformBase::CountVariableTypesvirtual void CountVariableTypes(UInt_t &nvars, UInt_t &ntgts, UInt_t &nspcts) constcount variables, targets and spectatorsDefinition VariableTransformBase.cxx:429; TMatrixDSymEigenTMatrixDSymEigen.Definition TMatrixDSymEigen.h:28; TMatrixDSymEigen::GetEigenVectorsconst TMatrixD & GetEigenVectors() constDefinition TMatrixDSymEigen.h:53; TMatrixTBase::GetNrowsInt_t GetNrows() constDefinition TMatrixTBase.h:123; TMatrixTBase::GetNcolsInt_t GetNcols() constDefinition TMatrixTBase.h:126; TMatrixTSym< Double_t >; TMatrix",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:82349,Modifiability,variab,variables,82349," Tools.cxx:657; TMVA::Tools::EWelcomeMessageEWelcomeMessageDefinition Tools.h:198; TMVA::Tools::HasAttrBool_t HasAttr(void *node, const char *attrname)add attribute from xmlDefinition Tools.cxx:1094; TMVA::Tools::GetNextChildvoid * GetNextChild(void *prevchild, const char *childname=nullptr)XML helpers.Definition Tools.cxx:1162; TMVA::Tools::fRegexpconst TString fRegexpDefinition Tools.h:226; TMVA::Tools::CheckForSilentOptionBool_t CheckForSilentOption(const TString &) constcheck for ""silence"" option in configuration option stringDefinition Tools.cxx:691; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::GetInputvirtual Bool_t GetInput(const Event *event, std::vector< Float_t > &input, std::vector< Char_t > &mask, Bool_t backTransform=kFALSE) constselect the values from the eventDefinition VariableTransformBase.cxx:315; TMVA::VariableTransformBase::CountVariableTypesvirtual void CountVariableTypes(UInt_t &nvars, UInt_t &ntgts, UInt_t &nspcts) constcount variables, targets and spectatorsDefinition VariableTransformBase.cxx:429; TMatrixDSymEigenTMatrixDSymEigen.Definition TMatrixDSymEigen.h:28; TMatrixDSymEigen::GetEigenVectorsconst TMatrixD & GetEigenVectors() constDefinition TMatrixDSymEigen.h:53; TMatrixTBase::GetNrowsInt_t GetNrows() constDefinition TMatrixTBase.h:123; TMatrixTBase::GetNcolsInt_t GetNcols() constDefinition TMatrixTBase.h:126; TMatrixTSym< Double_t >; TMatrixT< Double_t >; TMatrixT::TransposeTMatrixT< Element > & Transpose(const TMatrixT< Element > &source)Transpose matrix source.Definition TMatrixT.cxx:1455; TMatrixT::ResizeToTMatrixTBase< Element > & ResizeTo(Int_t nrows, Int_t ncols, Int_t=-1) overrideSet size of the matrix to nrows x ncols New dynamic elements are created, the overlapping part of the...Definition TMatrixT.cxx:1203; TMatrixT::InvertTMatrixT< Element > & Invert(Double_t *det=nullptr)Invert the matrix and calculate its determinant.Definition TMatrixT.cxx:1390; ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:2833,Performance,load,load,2833,"ector, std::setw, std::istream, std::ostream;; 67 ; 68std::atomic<TMVA::Tools*> TMVA::Tools::fgTools{0};; 69 ; 70TMVA::Tools& TMVA::gTools() { return TMVA::Tools::Instance(); }; 71TMVA::Tools& TMVA::Tools::Instance() {; 72 if(!fgTools) {; 73 Tools* tmp = new Tools();; 74 Tools* expected = 0;; 75 if(! fgTools.compare_exchange_strong(expected,tmp)) {; 76 //another thread beat us; 77 delete tmp;; 78 }; 79 }; 80 return *fgTools;; 81}; 82void TMVA::Tools::DestroyInstance() {; 83 //NOTE: there is no thread safe way to do this so; 84 // one must only call this method ones in an executable; 85 if (fgTools != 0) { delete fgTools.load(); fgTools=0; }; 86}; 87 ; 88////////////////////////////////////////////////////////////////////////////////; 89/// constructor; 90 ; 91TMVA::Tools::Tools() :; 92 fRegexp(""$&|!%^&()'<>?= ""),; 93 fLogger(new MsgLogger(""Tools"")),; 94 fXMLEngine(new TXMLEngine()); 95{; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// destructor; 100 ; 101TMVA::Tools::~Tools(); 102{; 103 delete fLogger;; 104 delete fXMLEngine;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// normalise to output range: [-1, 1]; 109 ; 110Double_t TMVA::Tools::NormVariable( Double_t x, Double_t xmin, Double_t xmax ); 111{; 112 return 2*(x - xmin)/(xmax - xmin) - 1.0;; 113}; 114 ; 115////////////////////////////////////////////////////////////////////////////////; 116/// compute ""separation"" defined as; 117/// \f[; 118/// <s2> = \frac{1}{2} \int_{-\infty}^{+\infty} \frac{(S(x) - B(x))^2}{(S(x) + B(x))} dx; 119/// \f]; 120 ; 121Double_t TMVA::Tools::GetSeparation( TH1* S, TH1* B ) const; 122{; 123 Double_t separation = 0;; 124 ; 125 // sanity checks; 126 // signal and background histograms must have same number of bins and; 127 // same limits; 128 if ((S->GetNbinsX() != B->GetNbinsX()) || (S->GetNbinsX() <= 0)) {; 129 Log() << kFATAL << ""<GetSeparation> signal and background""; 130 <",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:55828,Performance,perform,perform,55828,";; 1517 return 0;; 1518 }; 1519 ; 1520 UInt_t nvars=0, ntgts=0, nspcts=0;; 1521 if (transformBase); 1522 transformBase->CountVariableTypes( nvars, ntgts, nspcts );; 1523 else {; 1524 nvars =events.at(0)->GetNVariables ();; 1525 ntgts =events.at(0)->GetNTargets ();; 1526 nspcts=events.at(0)->GetNSpectators();; 1527 }; 1528 ; 1529 ; 1530 // init matrices; 1531 Int_t matNum = maxCls;; 1532 if (maxCls > 1 ) matNum++; // if more than one classes, then produce one matrix for all events as well (beside the matrices for each class); 1533 ; 1534 std::vector<TVectorD*>* vec = new std::vector<TVectorD*>(matNum);; 1535 std::vector<TMatrixD*>* mat2 = new std::vector<TMatrixD*>(matNum);; 1536 std::vector<Double_t> count(matNum);; 1537 count.assign(matNum,0);; 1538 ; 1539 Int_t cls = 0;; 1540 TVectorD* v;; 1541 TMatrixD* m;; 1542 UInt_t ivar=0, jvar=0;; 1543 for (cls = 0; cls < matNum ; cls++) {; 1544 vec->at(cls) = new TVectorD(nvars);; 1545 mat2->at(cls) = new TMatrixD(nvars,nvars);; 1546 v = vec->at(cls);; 1547 m = mat2->at(cls);; 1548 ; 1549 for (ivar=0; ivar<nvars; ivar++) {; 1550 (*v)(ivar) = 0;; 1551 for (jvar=0; jvar<nvars; jvar++) {; 1552 (*m)(ivar, jvar) = 0;; 1553 }; 1554 }; 1555 }; 1556 ; 1557 // perform event loop; 1558 for (UInt_t i=0; i<events.size(); i++) {; 1559 ; 1560 // fill the event; 1561 const Event * ev = events[i];; 1562 cls = ev->GetClass();; 1563 Double_t weight = ev->GetWeight();; 1564 ; 1565 std::vector<Float_t> input;; 1566 std::vector<Char_t> mask; // entries with kTRUE must not be transformed; 1567 // Bool_t hasMaskedEntries = kFALSE;; 1568 if (transformBase) {; 1569 /* hasMaskedEntries = */ transformBase->GetInput (ev, input, mask);; 1570 } else {; 1571 for (ivar=0; ivar<nvars; ++ivar) {; 1572 input.push_back (ev->GetValue(ivar));; 1573 }; 1574 }; 1575 ; 1576 if (maxCls > 1) {; 1577 v = vec->at(matNum-1);; 1578 m = mat2->at(matNum-1);; 1579 ; 1580 count.at(matNum-1)+=weight; // count used events; 1581 for (ivar=0; ivar<nvars; ivar++) {; 1582 ; 1583 D",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:2711,Safety,safe,safe,2711,"TMVA/MsgLogger.h""; 43#include ""TMVA/Types.h""; 44 ; 45#include ""TObjString.h""; 46#include ""TMath.h""; 47#include ""TString.h""; 48#include ""TTree.h""; 49#include ""TLeaf.h""; 50#include ""TH1.h""; 51#include ""TH2.h""; 52#include ""TList.h""; 53#include ""TSpline.h""; 54#include ""TVector.h""; 55#include ""TMatrixD.h""; 56#include ""TMatrixDSymEigen.h""; 57#include ""TVectorD.h""; 58#include ""TTreeFormula.h""; 59#include ""TXMLEngine.h""; 60#include ""TROOT.h""; 61 ; 62#include <algorithm>; 63#include <cstdlib>; 64#include <iomanip>; 65 ; 66using std::vector, std::setw, std::istream, std::ostream;; 67 ; 68std::atomic<TMVA::Tools*> TMVA::Tools::fgTools{0};; 69 ; 70TMVA::Tools& TMVA::gTools() { return TMVA::Tools::Instance(); }; 71TMVA::Tools& TMVA::Tools::Instance() {; 72 if(!fgTools) {; 73 Tools* tmp = new Tools();; 74 Tools* expected = 0;; 75 if(! fgTools.compare_exchange_strong(expected,tmp)) {; 76 //another thread beat us; 77 delete tmp;; 78 }; 79 }; 80 return *fgTools;; 81}; 82void TMVA::Tools::DestroyInstance() {; 83 //NOTE: there is no thread safe way to do this so; 84 // one must only call this method ones in an executable; 85 if (fgTools != 0) { delete fgTools.load(); fgTools=0; }; 86}; 87 ; 88////////////////////////////////////////////////////////////////////////////////; 89/// constructor; 90 ; 91TMVA::Tools::Tools() :; 92 fRegexp(""$&|!%^&()'<>?= ""),; 93 fLogger(new MsgLogger(""Tools"")),; 94 fXMLEngine(new TXMLEngine()); 95{; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// destructor; 100 ; 101TMVA::Tools::~Tools(); 102{; 103 delete fLogger;; 104 delete fXMLEngine;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// normalise to output range: [-1, 1]; 109 ; 110Double_t TMVA::Tools::NormVariable( Double_t x, Double_t xmin, Double_t xmax ); 111{; 112 return 2*(x - xmin)/(xmax - xmin) - 1.0;; 113}; 114 ; 115/////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:3955,Safety,sanity check,sanity checks,3955," Double_t xmin, Double_t xmax ); 111{; 112 return 2*(x - xmin)/(xmax - xmin) - 1.0;; 113}; 114 ; 115////////////////////////////////////////////////////////////////////////////////; 116/// compute ""separation"" defined as; 117/// \f[; 118/// <s2> = \frac{1}{2} \int_{-\infty}^{+\infty} \frac{(S(x) - B(x))^2}{(S(x) + B(x))} dx; 119/// \f]; 120 ; 121Double_t TMVA::Tools::GetSeparation( TH1* S, TH1* B ) const; 122{; 123 Double_t separation = 0;; 124 ; 125 // sanity checks; 126 // signal and background histograms must have same number of bins and; 127 // same limits; 128 if ((S->GetNbinsX() != B->GetNbinsX()) || (S->GetNbinsX() <= 0)) {; 129 Log() << kFATAL << ""<GetSeparation> signal and background""; 130 << "" histograms have different number of bins: ""; 131 << S->GetNbinsX() << "" : "" << B->GetNbinsX() << Endl;; 132 }; 133 ; 134 if (S->GetXaxis()->GetXmin() != B->GetXaxis()->GetXmin() ||; 135 S->GetXaxis()->GetXmax() != B->GetXaxis()->GetXmax() ||; 136 S->GetXaxis()->GetXmax() <= S->GetXaxis()->GetXmin()) {; 137 Log() << kINFO << S->GetXaxis()->GetXmin() << "" "" << B->GetXaxis()->GetXmin(); 138 << "" "" << S->GetXaxis()->GetXmax() << "" "" << B->GetXaxis()->GetXmax(); 139 << "" "" << S->GetXaxis()->GetXmax() << "" "" << S->GetXaxis()->GetXmin() << Endl;; 140 Log() << kFATAL << ""<GetSeparation> signal and background""; 141 << "" histograms have different or invalid dimensions:"" << Endl;; 142 }; 143 ; 144 Int_t nstep = S->GetNbinsX();; 145 Double_t intBin = (S->GetXaxis()->GetXmax() - S->GetXaxis()->GetXmin())/nstep;; 146 Double_t nS = S->GetSumOfWeights()*intBin;; 147 Double_t nB = B->GetSumOfWeights()*intBin;; 148 ; 149 if (nS > 0 && nB > 0) {; 150 for (Int_t bin=0; bin<nstep; bin++) {; 151 Double_t s = S->GetBinContent( bin+1 )/Double_t(nS);; 152 Double_t b = B->GetBinContent( bin+1 )/Double_t(nB);; 153 // separation; 154 if (s + b > 0) separation += (s - b)*(s - b)/(s + b);; 155 }; 156 separation *= (0.5*intBin);; 157 }; 158 else {; 159 Log() << kWARNING << ""<GetSeparation> histogra",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:6082,Safety,sanity check,sanity check,6082,"GetSumOfWeights()*intBin;; 148 ; 149 if (nS > 0 && nB > 0) {; 150 for (Int_t bin=0; bin<nstep; bin++) {; 151 Double_t s = S->GetBinContent( bin+1 )/Double_t(nS);; 152 Double_t b = B->GetBinContent( bin+1 )/Double_t(nB);; 153 // separation; 154 if (s + b > 0) separation += (s - b)*(s - b)/(s + b);; 155 }; 156 separation *= (0.5*intBin);; 157 }; 158 else {; 159 Log() << kWARNING << ""<GetSeparation> histograms with zero entries: ""; 160 << nS << "" : "" << nB << "" cannot compute separation""; 161 << Endl;; 162 separation = 0;; 163 }; 164 ; 165 return separation;; 166}; 167 ; 168////////////////////////////////////////////////////////////////////////////////; 169/// compute ""separation"" defined as; 170/// \f[; 171/// <s2> = \frac{1}{2} \int_{-\infty}^{+\infty} \frac{(S(x) - B(x))^2}{(S(x) + B(x))} dx; 172/// \f]; 173 ; 174Double_t TMVA::Tools::GetSeparation( const PDF& pdfS, const PDF& pdfB ) const; 175{; 176 Double_t xmin = pdfS.GetXmin();; 177 Double_t xmax = pdfS.GetXmax();; 178 // sanity check; 179 if (xmin != pdfB.GetXmin() || xmax != pdfB.GetXmax()) {; 180 Log() << kFATAL << ""<GetSeparation> Mismatch in PDF limits: ""; 181 << xmin << "" "" << pdfB.GetXmin() << xmax << "" "" << pdfB.GetXmax() << Endl;; 182 }; 183 ; 184 Double_t separation = 0;; 185 Int_t nstep = 100;; 186 Double_t intBin = (xmax - xmin)/Double_t(nstep);; 187 for (Int_t bin=0; bin<nstep; bin++) {; 188 Double_t x = (bin + 0.5)*intBin + xmin;; 189 Double_t s = pdfS.GetVal( x );; 190 Double_t b = pdfB.GetVal( x );; 191 // separation; 192 if (s + b > 0) separation += (s - b)*(s - b)/(s + b);; 193 }; 194 separation *= (0.5*intBin);; 195 ; 196 return separation;; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// sanity check; 201 ; 202void TMVA::Tools::ComputeStat( const std::vector<TMVA::Event*>& events, std::vector<Float_t>* valVec,; 203 Double_t& meanS, Double_t& meanB,; 204 Double_t& rmsS, Double_t& rmsB,; 205 Double_t& xmin, Double_t& xmax,; 206 Int_t sign",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:6837,Safety,sanity check,sanity check,6837,"const PDF& pdfB ) const; 175{; 176 Double_t xmin = pdfS.GetXmin();; 177 Double_t xmax = pdfS.GetXmax();; 178 // sanity check; 179 if (xmin != pdfB.GetXmin() || xmax != pdfB.GetXmax()) {; 180 Log() << kFATAL << ""<GetSeparation> Mismatch in PDF limits: ""; 181 << xmin << "" "" << pdfB.GetXmin() << xmax << "" "" << pdfB.GetXmax() << Endl;; 182 }; 183 ; 184 Double_t separation = 0;; 185 Int_t nstep = 100;; 186 Double_t intBin = (xmax - xmin)/Double_t(nstep);; 187 for (Int_t bin=0; bin<nstep; bin++) {; 188 Double_t x = (bin + 0.5)*intBin + xmin;; 189 Double_t s = pdfS.GetVal( x );; 190 Double_t b = pdfB.GetVal( x );; 191 // separation; 192 if (s + b > 0) separation += (s - b)*(s - b)/(s + b);; 193 }; 194 separation *= (0.5*intBin);; 195 ; 196 return separation;; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// sanity check; 201 ; 202void TMVA::Tools::ComputeStat( const std::vector<TMVA::Event*>& events, std::vector<Float_t>* valVec,; 203 Double_t& meanS, Double_t& meanB,; 204 Double_t& rmsS, Double_t& rmsB,; 205 Double_t& xmin, Double_t& xmax,; 206 Int_t signalClass, Bool_t norm ); 207{; 208 if (0 == valVec); 209 Log() << kFATAL << ""<Tools::ComputeStat> value vector is zero pointer"" << Endl;; 210 ; 211 if ( events.size() != valVec->size() ); 212 Log() << kWARNING << ""<Tools::ComputeStat> event and value vector have different lengths ""; 213 << events.size() << ""!="" << valVec->size() << Endl;; 214 ; 215 Long64_t entries = valVec->size();; 216 ; 217 // first fill signal and background in arrays before analysis; 218 Double_t* varVecS = new Double_t[entries];; 219 Double_t* varVecB = new Double_t[entries];; 220 Double_t* wgtVecS = new Double_t[entries];; 221 Double_t* wgtVecB = new Double_t[entries];; 222 xmin = +DBL_MAX;; 223 xmax = -DBL_MAX;; 224 Long64_t nEventsS = 0;; 225 Long64_t nEventsB = 0;; 226 Double_t xmin_ = 0, xmax_ = 0;; 227 ; 228 if (norm) {; 229 xmin_ = *std::min( valVec->begin(), valVec->end() );; 230 xmax_ = ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:9958,Safety,sanity check,sanity check,9958,"; // this is signal; 243 varVecB[nEventsB++] = theVar; // this is background; 244 }; 245 ; 246 if (theVar > xmax) xmax = theVar;; 247 if (theVar < xmin) xmin = theVar;; 248 }; 249 // ++nEventsS;; 250 // ++nEventsB;; 251 ; 252 // basic statistics; 253 // !!! TMath::Mean allows for weights, but NOT for negative weights; 254 // and TMath::RMS doesn't allow for weights all together...; 255 meanS = TMVA::Tools::Mean( nEventsS, varVecS, wgtVecS );; 256 meanB = TMVA::Tools::Mean( nEventsB, varVecB, wgtVecB );; 257 rmsS = TMVA::Tools::RMS ( nEventsS, varVecS, wgtVecS );; 258 rmsB = TMVA::Tools::RMS ( nEventsB, varVecB, wgtVecB );; 259 ; 260 delete [] varVecS;; 261 delete [] varVecB;; 262 delete [] wgtVecS;; 263 delete [] wgtVecB;; 264}; 265 ; 266////////////////////////////////////////////////////////////////////////////////; 267/// square-root of symmetric matrix; 268/// of course the resulting sqrtMat is also symmetric, but it's easier to; 269/// treat it as a general matrix; 270 ; 271TMatrixD* TMVA::Tools::GetSQRootMatrix( TMatrixDSym* symMat ); 272{; 273 Int_t n = symMat->GetNrows();; 274 ; 275 // compute eigenvectors; 276 TMatrixDSymEigen* eigen = new TMatrixDSymEigen( *symMat );; 277 ; 278 // D = ST C S; 279 TMatrixD* si = new TMatrixD( eigen->GetEigenVectors() );; 280 TMatrixD* s = new TMatrixD( *si ); // copy; 281 si->Transpose( *si ); // invert (= transpose); 282 ; 283 // diagonal matrices; 284 TMatrixD* d = new TMatrixD( n, n);; 285 d->Mult( (*si), (*symMat) ); (*d) *= (*s);; 286 ; 287 // sanity check: matrix must be diagonal and positive definit; 288 Int_t i, j;; 289 Double_t epsilon = 1.0e-8;; 290 for (i=0; i<n; i++) {; 291 for (j=0; j<n; j++) {; 292 if ((i != j && TMath::Abs((*d)(i,j))/TMath::Sqrt((*d)(i,i)*(*d)(j,j)) > epsilon) ||; 293 (i == j && (*d)(i,i) < 0)) {; 294 //d->Print();; 295 Log() << kWARNING << ""<GetSQRootMatrix> error in matrix diagonalization; printed S and B"" << Endl;; 296 }; 297 }; 298 }; 299 ; 300 // make exactly diagonal; 301 for (i=0; i<n; ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:11190,Safety,sanity check,sanity check,11190," epsilon) ||; 293 (i == j && (*d)(i,i) < 0)) {; 294 //d->Print();; 295 Log() << kWARNING << ""<GetSQRootMatrix> error in matrix diagonalization; printed S and B"" << Endl;; 296 }; 297 }; 298 }; 299 ; 300 // make exactly diagonal; 301 for (i=0; i<n; i++) for (j=0; j<n; j++) if (j != i) (*d)(i,j) = 0;; 302 ; 303 // compute the square-root C' of covariance matrix: C = C'*C'; 304 for (i=0; i<n; i++) (*d)(i,i) = TMath::Sqrt((*d)(i,i));; 305 ; 306 TMatrixD* sqrtMat = new TMatrixD( n, n );; 307 sqrtMat->Mult( (*s), (*d) );; 308 (*sqrtMat) *= (*si);; 309 ; 310 // invert square-root matrices; 311 sqrtMat->Invert();; 312 ; 313 delete eigen;; 314 delete s;; 315 delete si;; 316 delete d;; 317 ; 318 return sqrtMat;; 319}; 320 ; 321////////////////////////////////////////////////////////////////////////////////; 322/// turns covariance into correlation matrix; 323 ; 324const TMatrixD* TMVA::Tools::GetCorrelationMatrix( const TMatrixD* covMat ); 325{; 326 ; 327 if (covMat == 0) return 0;; 328 // sanity check; 329 Int_t nvar = covMat->GetNrows();; 330 if (nvar != covMat->GetNcols()); 331 Log() << kFATAL << ""<GetCorrelationMatrix> input matrix not quadratic"" << Endl;; 332 ; 333 Log() << kWARNING;; 334 TMatrixD* corrMat = new TMatrixD( nvar, nvar );; 335 for (Int_t ivar=0; ivar<nvar; ivar++) {; 336 for (Int_t jvar=0; jvar<nvar; jvar++) {; 337 if (ivar != jvar) {; 338 Double_t d = (*covMat)(ivar, ivar)*(*covMat)(jvar, jvar);; 339 if (d > 1E-20) {; 340 (*corrMat)(ivar, jvar) = (*covMat)(ivar, jvar)/TMath::Sqrt(d);; 341 } else {; 342 Log() << ""<GetCorrelationMatrix> zero variances for variables ""; 343 << ""("" << ivar << "", "" << jvar << "")"" << Endl;; 344 (*corrMat)(ivar, jvar) = 0;; 345 }; 346 if (TMath::Abs( (*corrMat)(ivar,jvar)) > 1){; 347 Log() << kWARNING; 348 << "" Element corr(""<<ivar<<"",""<<ivar<<"")="" << (*corrMat)(ivar,jvar); 349 << "" sigma2=""<<d; 350 << "" cov(""<<ivar<<"",""<<ivar<<"")="" <<(*covMat)(ivar, ivar); 351 << "" cov(""<<jvar<<"",""<<jvar<<"")="" <<(*covMat)(jvar, jvar); 352 << Endl;;",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:15594,Safety,sanity check,sanity check,15594,"////////////////////////////////////////; 425/// parse option string for ANN methods; 426/// default settings (should be defined in theOption string); 427///; 428/// format and syntax of option string: ""3000:N:N+2:N-3:6""; 429///; 430/// where:; 431/// - 3000 - number of training cycles (epochs); 432/// - N - number of nodes in first hidden layer, where N is the number; 433/// of discriminating variables used (note that the first ANN; 434/// layer necessarily has N nodes, and hence is not given).; 435/// - N+2 - number of nodes in 2nd hidden layer (2 nodes more than; 436/// number of variables); 437/// - N-3 - number of nodes in 3rd hidden layer (3 nodes less than; 438/// number of variables); 439/// - 6 - 6 nodes in last (4th) hidden layer (note that the last ANN; 440/// layer in MVA has 2 nodes, each one for signal and background; 441/// classes); 442 ; 443vector<Int_t>* TMVA::Tools::ParseANNOptionString( TString theOptions, Int_t nvar,; 444 vector<Int_t>* nodes ); 445{; 446 TList* list = TMVA::Tools::ParseFormatLine( theOptions, "":"" );; 447 ; 448 ; 449 // sanity check; 450 if (list->GetSize() < 1) {; 451 Log() << kFATAL << ""<ParseANNOptionString> unrecognized option string: "" << theOptions << Endl;; 452 }; 453 ; 454 // add number of cycles; 455 nodes->push_back( atoi( ((TObjString*)list->At(0))->GetString() ) );; 456 ; 457 Int_t a;; 458 if (list->GetSize() > 1) {; 459 for (Int_t i=1; i<list->GetSize(); i++) {; 460 TString s = ((TObjString*)list->At(i))->GetString();; 461 s.ToUpper();; 462 if (s(0) == 'N') {; 463 if (s.Length() > 1) nodes->push_back( nvar + atoi(&s[1]) );; 464 else nodes->push_back( nvar );; 465 }; 466 else if ((a = atoi( s )) > 0) nodes->push_back( atoi(s ) );; 467 else {; 468 Log() << kFATAL << ""<ParseANNOptionString> unrecognized option string: "" << theOptions << Endl;; 469 }; 470 }; 471 }; 472 ; 473 return nodes;; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// check quality of splining by",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:22845,Safety,sanity check,sanity check,22845,"RebinY(2);; 629 ; 630 Double_t corrRatio = 0.;; 631 Double_t y_mean = h.ProjectionY()->GetMean();; 632 for (Int_t ix=1; ix<=h.GetNbinsX(); ix++) {; 633 corrRatio += (h.Integral(ix,ix,1,h.GetNbinsY())/hi)*pow((GetYMean_binX(h,ix)-y_mean),2);; 634 }; 635 corrRatio /= pow(h.ProjectionY()->GetRMS(),2);; 636 return corrRatio;; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Compute the mean in Y for a given bin X of a 2D histogram; 641 ; 642Double_t TMVA::Tools::GetYMean_binX( const TH2& h, Int_t bin_x ); 643{; 644 if (h.Integral(bin_x,bin_x,1,h.GetNbinsY()) == 0.) {return 0;}; 645 Double_t y_bin_mean = 0.;; 646 TH1* py = h.ProjectionY();; 647 for (Int_t y = 1; y <= h.GetNbinsY(); y++){; 648 y_bin_mean += h.GetBinContent(bin_x,y)*py->GetBinCenter(y);; 649 }; 650 y_bin_mean /= h.Integral(bin_x,bin_x,1,h.GetNbinsY());; 651 return y_bin_mean;; 652}; 653 ; 654////////////////////////////////////////////////////////////////////////////////; 655/// Transpose quadratic histogram; 656 ; 657TH2F* TMVA::Tools::TransposeHist( const TH2F& h ); 658{; 659 // sanity check; 660 if (h.GetNbinsX() != h.GetNbinsY()) {; 661 Log() << kFATAL << ""<TransposeHist> cannot transpose non-quadratic histogram"" << Endl;; 662 }; 663 ; 664 TH2F *transposedHisto = new TH2F( h );; 665 for (Int_t ix=1; ix <= h.GetNbinsX(); ix++){; 666 for (Int_t iy=1; iy <= h.GetNbinsY(); iy++){; 667 transposedHisto->SetBinContent(iy,ix,h.GetBinContent(ix,iy));; 668 }; 669 }; 670 ; 671 // copy stats (thanks to Swagato Banerjee for pointing out the missing stats information); 672 Double_t stats_old[7];; 673 Double_t stats_new[7];; 674 ; 675 h.GetStats(stats_old);; 676 stats_new[0] = stats_old[0];; 677 stats_new[1] = stats_old[1];; 678 stats_new[2] = stats_old[4];; 679 stats_new[3] = stats_old[5];; 680 stats_new[4] = stats_old[2];; 681 stats_new[5] = stats_old[3];; 682 stats_new[6] = stats_old[6];; 683 transposedHisto->PutStats(stats_new);; 684 ; 685 return transposedHis",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:30863,Safety,sanity check,sanity check,30863,"tic const TString gClr_whiteonblue = ""\033[1;44m""; // white on blue background; 849 static const TString gClr_whiteongreen = ""\033[1;42m""; // white on green background; 850 static const TString gClr_grey_bg = ""\033[47m""; // grey background; 851 ; 852 static const TString gClr_reset = ""\033[0m""; // reset; 853 ; 854 if (!gConfig().UseColor()) return gClr_none;; 855 ; 856 if (c == ""white"" ) return gClr_white;; 857 if (c == ""blue"" ) return gClr_blue;; 858 if (c == ""black"" ) return gClr_black;; 859 if (c == ""lightblue"") return gClr_cyan_b;; 860 if (c == ""yellow"") return gClr_yellow;; 861 if (c == ""red"" ) return gClr_red;; 862 if (c == ""dred"" ) return gClr_darkred;; 863 if (c == ""dgreen"") return gClr_darkgreen;; 864 if (c == ""lgreenb"") return gClr_lgreen_b;; 865 if (c == ""dyellow"") return gClr_darkyellow;; 866 ; 867 if (c == ""bold"") return gClr_bold;; 868 if (c == ""bblack"") return gClr_black_b;; 869 ; 870 if (c == ""blue_bgd"") return gClr_blue_bg;; 871 if (c == ""red_bgd"" ) return gClr_red_bg;; 872 ; 873 if (c == ""white_on_blue"" ) return gClr_whiteonblue;; 874 if (c == ""white_on_green"") return gClr_whiteongreen;; 875 ; 876 if (c == ""reset"") return gClr_reset;; 877 ; 878 std::cout << ""Unknown color "" << c << std::endl;; 879 exit(1);; 880 ; 881 return gClr_none;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// formatted output of simple table; 886 ; 887void TMVA::Tools::FormattedOutput( const std::vector<Double_t>& values, const std::vector<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:32435,Safety,sanity check,sanity check,32435,"TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) l",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:32725,Safety,abort,abort,32725,"gger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:34159,Safety,sanity check,sanity check,34159,"sh_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:72446,Safety,sanity check,sanity checkDefinition,72446,":EventDefinition Event.h:51; TMVA::Event::GetValueFloat_t GetValue(UInt_t ivar) constreturn value of i'th variableDefinition Event.cxx:236; TMVA::Event::GetWeightDouble_t GetWeight() constreturn the event weight - depending on whether the flag IgnoreNegWeightsInTraining is or not.Definition Event.cxx:389; TMVA::Event::GetClassUInt_t GetClass() constDefinition Event.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::HistoHasEquidistantBinsBool_t HistoHasEquidistantBins(const TH1 &h)Definition Tools.cxx:1486; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::NormVariableDouble_t NormVariable(Double_t x, Double_t xmin, Double_t xmax)normalise to output range: [-1, 1]Definition Tools.cxx:110; TMVA::Tools::WriteFloatArbitraryPrecisionvoid WriteFloatArbitraryPrecision(Float",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:30819,Testability,log,logger,30819,"tic const TString gClr_whiteonblue = ""\033[1;44m""; // white on blue background; 849 static const TString gClr_whiteongreen = ""\033[1;42m""; // white on green background; 850 static const TString gClr_grey_bg = ""\033[47m""; // grey background; 851 ; 852 static const TString gClr_reset = ""\033[0m""; // reset; 853 ; 854 if (!gConfig().UseColor()) return gClr_none;; 855 ; 856 if (c == ""white"" ) return gClr_white;; 857 if (c == ""blue"" ) return gClr_blue;; 858 if (c == ""black"" ) return gClr_black;; 859 if (c == ""lightblue"") return gClr_cyan_b;; 860 if (c == ""yellow"") return gClr_yellow;; 861 if (c == ""red"" ) return gClr_red;; 862 if (c == ""dred"" ) return gClr_darkred;; 863 if (c == ""dgreen"") return gClr_darkgreen;; 864 if (c == ""lgreenb"") return gClr_lgreen_b;; 865 if (c == ""dyellow"") return gClr_darkyellow;; 866 ; 867 if (c == ""bold"") return gClr_bold;; 868 if (c == ""bblack"") return gClr_black_b;; 869 ; 870 if (c == ""blue_bgd"") return gClr_blue_bg;; 871 if (c == ""red_bgd"" ) return gClr_red_bg;; 872 ; 873 if (c == ""white_on_blue"" ) return gClr_whiteonblue;; 874 if (c == ""white_on_green"") return gClr_whiteongreen;; 875 ; 876 if (c == ""reset"") return gClr_reset;; 877 ; 878 std::cout << ""Unknown color "" << c << std::endl;; 879 exit(1);; 880 ; 881 return gClr_none;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// formatted output of simple table; 886 ; 887void TMVA::Tools::FormattedOutput( const std::vector<Double_t>& values, const std::vector<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:30952,Testability,log,logger,30952,"en_b;; 865 if (c == ""dyellow"") return gClr_darkyellow;; 866 ; 867 if (c == ""bold"") return gClr_bold;; 868 if (c == ""bblack"") return gClr_black_b;; 869 ; 870 if (c == ""blue_bgd"") return gClr_blue_bg;; 871 if (c == ""red_bgd"" ) return gClr_red_bg;; 872 ; 873 if (c == ""white_on_blue"" ) return gClr_whiteonblue;; 874 if (c == ""white_on_green"") return gClr_whiteongreen;; 875 ; 876 if (c == ""reset"") return gClr_reset;; 877 ; 878 std::cout << ""Unknown color "" << c << std::endl;; 879 exit(1);; 880 ; 881 return gClr_none;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// formatted output of simple table; 886 ; 887void TMVA::Tools::FormattedOutput( const std::vector<Double_t>& values, const std::vector<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger <",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:31603,Testability,log,logger,31603,"tor<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:31623,Testability,log,logger,31623,"tor<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:31668,Testability,log,logger,31668,"tor<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:31715,Testability,log,logger,31715,"tor<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:31766,Testability,log,logger,31766,"tor<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:31817,Testability,log,logger,31817,"tor<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:31837,Testability,log,logger,31837,"tor<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:31930,Testability,log,logger,31930,"tor<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:31975,Testability,log,logger,31975,"tor<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ivar<nvar; ivar++) maxL = TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:32043,Testability,log,logger,32043,"TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) l",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:32124,Testability,log,logger,32124,"TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) l",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:32144,Testability,log,logger,32144,"TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) l",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:32412,Testability,log,logger,32412,"TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) l",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:32581,Testability,log,logger,32581,"er << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<n",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33254,Testability,log,logger,33254,"D& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t max",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33274,Testability,log,logger,33274,"D& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t max",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33319,Testability,log,logger,33319,"D& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t max",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33394,Testability,log,logger,33394,"D& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t max",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33444,Testability,log,logger,33444,"D& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t max",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33537,Testability,log,logger,33537,"D& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t max",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33628,Testability,log,logger,33628,"D& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t max",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33719,Testability,log,logger,33719,"sh_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33800,Testability,log,logger,33800,"sh_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:33820,Testability,log,logger,33820,"sh_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:34136,Testability,log,logger,34136,"sh_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35064,Testability,log,logger,35064,"tic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35085,Testability,log,logger,35085,"tic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35133,Testability,log,logger,35133,"tic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35210,Testability,log,logger,35210,"tic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35265,Testability,log,logger,35265,"tic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35363,Testability,log,logger,35363,"tic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35460,Testability,log,logger,35460,"tic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35553,Testability,log,logger,35553," maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit, Bool_t normalised ); 1049{; 1050 TString retval = ( normalised ? ""(1/N) "" : """" );; 1051 retval += TString::Format( ""dN_{ }/^{ }%.3g %s"", h.GetXaxis()->GetBinWidth(1), unit.Data() );; 1052 return retval;; 1053}; 1054 ; 1055////////////////////////////////////////////////////////////////////////////////; 1056/// writes a float value with the available precision to a stream; 1057 ; 1058void TMVA::Tools::WriteFloatArbitraryPrecision( Float_t val, ostream& os ); 1059{; 1060 os << val << "" :: "";; 1061 void * c = &val;; 1062 for (int i=0; i<4; i++) {; 1063 Int_t ic = *((char*)c+i)-'\0';; 1064 if (ic<0) ic+=256;; 1065 os << ic << "" "";; 1066 }; 1067 os << "":: "";; 1068}; 1069 ; 1070/////////////////////////////////////////////",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35638,Testability,log,logger,35638," maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit, Bool_t normalised ); 1049{; 1050 TString retval = ( normalised ? ""(1/N) "" : """" );; 1051 retval += TString::Format( ""dN_{ }/^{ }%.3g %s"", h.GetXaxis()->GetBinWidth(1), unit.Data() );; 1052 return retval;; 1053}; 1054 ; 1055////////////////////////////////////////////////////////////////////////////////; 1056/// writes a float value with the available precision to a stream; 1057 ; 1058void TMVA::Tools::WriteFloatArbitraryPrecision( Float_t val, ostream& os ); 1059{; 1060 os << val << "" :: "";; 1061 void * c = &val;; 1062 for (int i=0; i<4; i++) {; 1063 Int_t ic = *((char*)c+i)-'\0';; 1064 if (ic<0) ic+=256;; 1065 os << ic << "" "";; 1066 }; 1067 os << "":: "";; 1068}; 1069 ; 1070/////////////////////////////////////////////",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:35659,Testability,log,logger,35659," maxLh+1;; 1012 for (UInt_t icol=0; icol<nhvar; icol++) clen += hLengths[icol]+1;; 1013 ; 1014 // bar line; 1015 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1016 logger << Endl;; 1017 ; 1018 // title bar; 1019 logger << setw(maxL+1) << "" "";; 1020 for (UInt_t icol=0; icol<nhvar; icol++) logger << setw(hLengths[icol]+1) << horiz[icol];; 1021 logger << Endl;; 1022 ; 1023 // the numbers; 1024 for (UInt_t irow=0; irow<nvvar; irow++) {; 1025 logger << setw(maxL) << vert[irow] << "":"";; 1026 for (UInt_t icol=0; icol<nhvar; icol++) {; 1027 logger << setw(hLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 1028 }; 1029 logger << Endl;; 1030 }; 1031 ; 1032 // bar line; 1033 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 1034 logger << Endl;; 1035}; 1036 ; 1037////////////////////////////////////////////////////////////////////////////////; 1038/// histogramming utility; 1039 ; 1040TString TMVA::Tools::GetXTitleWithUnit( const TString& title, const TString& unit ); 1041{; 1042 return ( unit == """" ? title : ( title + "" ["" + unit + ""]"" ) );; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit, Bool_t normalised ); 1049{; 1050 TString retval = ( normalised ? ""(1/N) "" : """" );; 1051 retval += TString::Format( ""dN_{ }/^{ }%.3g %s"", h.GetXaxis()->GetBinWidth(1), unit.Data() );; 1052 return retval;; 1053}; 1054 ; 1055////////////////////////////////////////////////////////////////////////////////; 1056/// writes a float value with the available precision to a stream; 1057 ; 1058void TMVA::Tools::WriteFloatArbitraryPrecision( Float_t val, ostream& os ); 1059{; 1060 os << val << "" :: "";; 1061 void * c = &val;; 1062 for (int i=0; i<4; i++) {; 1063 Int_t ic = *((char*)c+i)-'\0';; 1064 if (ic<0) ic+=256;; 1065 os << ic << "" "";; 1066 }; 1067 os << "":: "";; 1068}; 1069 ; 1070/////////////////////////////////////////////",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:45977,Testability,log,logger,45977,"DATE << std::endl;; 1307 std::cout << "" "" << ""Copyright (C) 2005-2010 CERN, MPI-K Heidelberg, Us of Bonn and Victoria"" << std::endl;; 1308 std::cout << "" "" << ""Home page: http://tmva.sf.net"" << std::endl;; 1309 std::cout << "" "" << ""Citation info: http://tmva.sf.net/citeTMVA.html"" << std::endl;; 1310 std::cout << "" "" << ""License: http://tmva.sf.net/LICENSE"" << std::endl << std::endl;; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// prints the TMVA release number and date; 1315 ; 1316void TMVA::Tools::TMVAVersionMessage( MsgLogger& logger ); 1317{; 1318 logger << ""___________TMVA Version "" << TMVA_RELEASE << "", "" << TMVA_RELEASE_DATE; 1319 << """" << Endl;; 1320}; 1321 ; 1322////////////////////////////////////////////////////////////////////////////////; 1323/// prints the ROOT release number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LA",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:45999,Testability,log,logger,45999,"DATE << std::endl;; 1307 std::cout << "" "" << ""Copyright (C) 2005-2010 CERN, MPI-K Heidelberg, Us of Bonn and Victoria"" << std::endl;; 1308 std::cout << "" "" << ""Home page: http://tmva.sf.net"" << std::endl;; 1309 std::cout << "" "" << ""Citation info: http://tmva.sf.net/citeTMVA.html"" << std::endl;; 1310 std::cout << "" "" << ""License: http://tmva.sf.net/LICENSE"" << std::endl << std::endl;; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// prints the TMVA release number and date; 1315 ; 1316void TMVA::Tools::TMVAVersionMessage( MsgLogger& logger ); 1317{; 1318 logger << ""___________TMVA Version "" << TMVA_RELEASE << "", "" << TMVA_RELEASE_DATE; 1319 << """" << Endl;; 1320}; 1321 ; 1322////////////////////////////////////////////////////////////////////////////////; 1323/// prints the ROOT release number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LA",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:46312,Testability,log,logger,46312,"DATE << std::endl;; 1307 std::cout << "" "" << ""Copyright (C) 2005-2010 CERN, MPI-K Heidelberg, Us of Bonn and Victoria"" << std::endl;; 1308 std::cout << "" "" << ""Home page: http://tmva.sf.net"" << std::endl;; 1309 std::cout << "" "" << ""Citation info: http://tmva.sf.net/citeTMVA.html"" << std::endl;; 1310 std::cout << "" "" << ""License: http://tmva.sf.net/LICENSE"" << std::endl << std::endl;; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// prints the TMVA release number and date; 1315 ; 1316void TMVA::Tools::TMVAVersionMessage( MsgLogger& logger ); 1317{; 1318 logger << ""___________TMVA Version "" << TMVA_RELEASE << "", "" << TMVA_RELEASE_DATE; 1319 << """" << Endl;; 1320}; 1321 ; 1322////////////////////////////////////////////////////////////////////////////////; 1323/// prints the ROOT release number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LA",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:46714,Testability,log,logger,46714,"DATE << std::endl;; 1307 std::cout << "" "" << ""Copyright (C) 2005-2010 CERN, MPI-K Heidelberg, Us of Bonn and Victoria"" << std::endl;; 1308 std::cout << "" "" << ""Home page: http://tmva.sf.net"" << std::endl;; 1309 std::cout << "" "" << ""Citation info: http://tmva.sf.net/citeTMVA.html"" << std::endl;; 1310 std::cout << "" "" << ""License: http://tmva.sf.net/LICENSE"" << std::endl << std::endl;; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// prints the TMVA release number and date; 1315 ; 1316void TMVA::Tools::TMVAVersionMessage( MsgLogger& logger ); 1317{; 1318 logger << ""___________TMVA Version "" << TMVA_RELEASE << "", "" << TMVA_RELEASE_DATE; 1319 << """" << Endl;; 1320}; 1321 ; 1322////////////////////////////////////////////////////////////////////////////////; 1323/// prints the ROOT release number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LA",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:46740,Testability,log,logger,46740,"DATE << std::endl;; 1307 std::cout << "" "" << ""Copyright (C) 2005-2010 CERN, MPI-K Heidelberg, Us of Bonn and Victoria"" << std::endl;; 1308 std::cout << "" "" << ""Home page: http://tmva.sf.net"" << std::endl;; 1309 std::cout << "" "" << ""Citation info: http://tmva.sf.net/citeTMVA.html"" << std::endl;; 1310 std::cout << "" "" << ""License: http://tmva.sf.net/LICENSE"" << std::endl << std::endl;; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// prints the TMVA release number and date; 1315 ; 1316void TMVA::Tools::TMVAVersionMessage( MsgLogger& logger ); 1317{; 1318 logger << ""___________TMVA Version "" << TMVA_RELEASE << "", "" << TMVA_RELEASE_DATE; 1319 << """" << Endl;; 1320}; 1321 ; 1322////////////////////////////////////////////////////////////////////////////////; 1323/// prints the ROOT release number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LA",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47123,Testability,log,logger,47123,"number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LAPP & MPI-K Heidelberg and Victoria U."" << Endl;; 1351 logger << ""Home page https://root.cern/manual/tmva/"" << Endl;; 1352 break;; 1353 ; 1354 case kIsometricWelcomeMsg:; 1355 logger << "" ___ ___ ___ ___ "" << Endl;; 1356 logger << "" /\\ \\ /\\__\\ /\\__\\ /\\ \\ "" << Endl;; 1357 logger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << E",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47234,Testability,log,logger,47234,"number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LAPP & MPI-K Heidelberg and Victoria U."" << Endl;; 1351 logger << ""Home page https://root.cern/manual/tmva/"" << Endl;; 1352 break;; 1353 ; 1354 case kIsometricWelcomeMsg:; 1355 logger << "" ___ ___ ___ ___ "" << Endl;; 1356 logger << "" /\\ \\ /\\__\\ /\\__\\ /\\ \\ "" << Endl;; 1357 logger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << E",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47339,Testability,log,logger,47339,"number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LAPP & MPI-K Heidelberg and Victoria U."" << Endl;; 1351 logger << ""Home page https://root.cern/manual/tmva/"" << Endl;; 1352 break;; 1353 ; 1354 case kIsometricWelcomeMsg:; 1355 logger << "" ___ ___ ___ ___ "" << Endl;; 1356 logger << "" /\\ \\ /\\__\\ /\\__\\ /\\ \\ "" << Endl;; 1357 logger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << E",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47436,Testability,log,logger,47436,"29 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LAPP & MPI-K Heidelberg and Victoria U."" << Endl;; 1351 logger << ""Home page https://root.cern/manual/tmva/"" << Endl;; 1352 break;; 1353 ; 1354 case kIsometricWelcomeMsg:; 1355 logger << "" ___ ___ ___ ___ "" << Endl;; 1356 logger << "" /\\ \\ /\\__\\ /\\__\\ /\\ \\ "" << Endl;; 1357 logger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _|",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47557,Testability,log,logger,47557,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47602,Testability,log,logger,47602,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47661,Testability,log,logger,47661,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47721,Testability,log,logger,47721,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47785,Testability,log,logger,47785,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47861,Testability,log,logger,47861,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:47952,Testability,log,logger,47952,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48033,Testability,log,logger,48033,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48092,Testability,log,logger,48092,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48150,Testability,log,logger,48150,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48196,Testability,log,logger,48196,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48296,Testability,log,logger,48296,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48318,Testability,log,logger,48318,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48374,Testability,log,logger,48374,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48428,Testability,log,logger,48428,,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48484,Testability,log,logger,48484,""" << Endl;; 1352 break;; 1353 ; 1354 case kIsometricWelcomeMsg:; 1355 logger << "" ___ ___ ___ ___ "" << Endl;; 1356 logger << "" /\\ \\ /\\__\\ /\\__\\ /\\ \\ "" << Endl;; 1357 logger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48534,Testability,log,logger,48534,"icWelcomeMsg:; 1355 logger << "" ___ ___ ___ ___ "" << Endl;; 1356 logger << "" /\\ \\ /\\__\\ /\\__\\ /\\ \\ "" << Endl;; 1357 logger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48637,Testability,log,logger,48637," \\ "" << Endl;; 1357 logger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48659,Testability,log,logger,48659,"ogger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48715,Testability,log,logger,48715,"58 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48769,Testability,log,logger,48769," Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48825,Testability,log,logger,48825," /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48875,Testability,log,logger,48875,":\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48977,Testability,log,logger,48977,"/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""______________________",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:48999,Testability,log,logger,48999,"/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49055,Testability,log,logger,49055,"|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << C",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49109,Testability,log,logger,49109,"/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhit",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49165,Testability,log,logger,49165,"~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49215,Testability,log,logger,49215,"__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49319,Testability,log,logger,49319,"er << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49366,Testability,log,logger,49366,"1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << """,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49417,Testability,log,logger,49417,";; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << C",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49471,Testability,log,logger,49471,"dl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49582,Testability,log,logger,49582,"375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49629,Testability,log,logger,49629,"1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""______________",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49680,Testability,log,logger,49680," _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger <<",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49737,Testability,log,logger,49737,"_/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49792,Testability,log,logger,49792," _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:49911,Testability,log,logger,49911,"<< Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 l",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:50033,Testability,log,logger,50033,"| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437///////////////////////////////",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:50284,Testability,log,logger,50284,"; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A.",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:50587,Testability,log,logger,50587,"; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A.",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:50675,Testability,log,logger,50675,"; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A.",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:50777,Testability,log,logger,50777,"; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A.",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:50914,Testability,log,logger,50914,"; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A.",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51174,Testability,log,logger,51174,"; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A.",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51270,Testability,log,logger,51270,"; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ "" << Endl;; 1405 logger << "" | | | |\\/| |\\ \\ / / _ \\ "" << Endl;; 1406 logger << "" | | | | | | \\ V / ___ \\ "" << Endl;; 1407 logger << "" |_| |_| |_| \\_/_/ \\_\\ "" << Endl << Endl;; 1408 break;; 1409 ; 1410 case kOriginalWelcomeMsgColor:; 1411 logger << kINFO << """" << Color(""red""); 1412 << ""_______________________________________"" << Color(""reset"") << Endl;; 1413 logger << kINFO << """" << Color(""blue""); 1414 << Color(""red_bgd"") << Color(""bwhite"") << "" // "" << Color(""reset""); 1415 << Color(""white"") << Color(""blue_bgd""); 1416 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Color(""reset"") << Endl;; 1417 logger << kINFO << """"<< Color(""blue""); 1418 << Color(""red_bgd"") << Color(""white"") << ""// "" << Color(""reset""); 1419 << Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A.",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51372,Testability,log,logger,51372,"< Color(""white"") << Color(""blue_bgd""); 1420 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Color(""reset"") << Endl;; 1421 break;; 1422 ; 1423 case kOriginalWelcomeMsgBW:; 1424 logger << kINFO << """"; 1425 << ""_______________________________________"" << Endl;; 1426 logger << kINFO << "" // ""; 1427 << ""|\\ /|| \\ // /\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\ "" << Endl;; 1428 logger << kINFO << ""// ""; 1429 << ""| \\/ || \\// /--\\\\\\\\\\\\\\\\\\\\\\\\ \\ \\ \\"" << Endl;; 1430 break;; 1431 ; 1432 default:; 1433 logger << kFATAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << """,MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51533,Testability,log,logger,51533,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51579,Testability,log,logger,51579,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51677,Testability,log,logger,51677,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51766,Testability,log,logger,51766,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51854,Testability,log,logger,51854,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51901,Testability,log,logger,51901,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51948,Testability,log,logger,51948,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:51993,Testability,log,logger,51993,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52038,Testability,log,logger,52038,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52096,Testability,log,logger,52096,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52151,Testability,log,logger,52151,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52230,Testability,log,logger,52230,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52298,Testability,log,logger,52298,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52343,Testability,log,logger,52343,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52390,Testability,log,logger,52390,"TAL << ""unknown message type: "" << msgType << Endl;; 1434 }; 1435}; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438/// kinds of TMVA citation; 1439 ; 1440void TMVA::Tools::TMVACitation( MsgLogger& logger, ECitation citType ); 1441{; 1442 switch (citType) {; 1443 ; 1444 case kPlainText:; 1445 logger << ""A. Hoecker, P. Speckmayer, J. Stelzer, J. Therhaag, E. von Toerne, H. Voss"" << Endl;; 1446 logger << ""\""TMVA - Toolkit for Multivariate Data Analysis\"" PoS ACAT:040,2007. e-Print: physics/0703039"" << Endl;; 1447 break;; 1448 ; 1449 case kBibTeX:; 1450 logger << ""@Article{TMVA2007,"" << Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52493,Testability,log,logger,52493,"Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset"") << Endl;; 1478 logger << kINFO << gTools().Color(""bold""); 1479 << ""For citation information, please visit: http://tmva.sf.net/citeTMVA.html""; 1480 << gTools().Color(""reset"") << Endl;; 1481 }; 1482}; 1483 ; 1484////////////////////////////////////////////////////////////////////////////////; 1485 ; 1486Bool_t TMVA::Tools::HistoHasEquidistantBins(const TH1& h); 1487{; 1488 return !(h.GetXaxis()->GetXbins()->fN);; 1489}; 1490 ; 1491////////////////////////////////////////////////////////////////////////////////; 1492 ; 1493std::vector<TMatrixDSym*>*; 1494TMVA::Tools::CalcCovarianceMatrices( const std::vector<const Event*>& events, I",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52572,Testability,log,logger,52572,"Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset"") << Endl;; 1478 logger << kINFO << gTools().Color(""bold""); 1479 << ""For citation information, please visit: http://tmva.sf.net/citeTMVA.html""; 1480 << gTools().Color(""reset"") << Endl;; 1481 }; 1482}; 1483 ; 1484////////////////////////////////////////////////////////////////////////////////; 1485 ; 1486Bool_t TMVA::Tools::HistoHasEquidistantBins(const TH1& h); 1487{; 1488 return !(h.GetXaxis()->GetXbins()->fN);; 1489}; 1490 ; 1491////////////////////////////////////////////////////////////////////////////////; 1492 ; 1493std::vector<TMatrixDSym*>*; 1494TMVA::Tools::CalcCovarianceMatrices( const std::vector<const Event*>& events, I",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52628,Testability,log,logger,52628,"Endl;; 1451 logger << "" author = \""Hoecker, Andreas and Speckmayer, Peter and Stelzer, Joerg "" << Endl;; 1452 logger << "" and Therhaag, Jan and von Toerne, Eckhard and Voss, Helge\"","" << Endl;; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset"") << Endl;; 1478 logger << kINFO << gTools().Color(""bold""); 1479 << ""For citation information, please visit: http://tmva.sf.net/citeTMVA.html""; 1480 << gTools().Color(""reset"") << Endl;; 1481 }; 1482}; 1483 ; 1484////////////////////////////////////////////////////////////////////////////////; 1485 ; 1486Bool_t TMVA::Tools::HistoHasEquidistantBins(const TH1& h); 1487{; 1488 return !(h.GetXaxis()->GetXbins()->fN);; 1489}; 1490 ; 1491////////////////////////////////////////////////////////////////////////////////; 1492 ; 1493std::vector<TMatrixDSym*>*; 1494TMVA::Tools::CalcCovarianceMatrices( const std::vector<const Event*>& events, I",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52681,Testability,log,logger,52681,";; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset"") << Endl;; 1478 logger << kINFO << gTools().Color(""bold""); 1479 << ""For citation information, please visit: http://tmva.sf.net/citeTMVA.html""; 1480 << gTools().Color(""reset"") << Endl;; 1481 }; 1482}; 1483 ; 1484////////////////////////////////////////////////////////////////////////////////; 1485 ; 1486Bool_t TMVA::Tools::HistoHasEquidistantBins(const TH1& h); 1487{; 1488 return !(h.GetXaxis()->GetXbins()->fN);; 1489}; 1490 ; 1491////////////////////////////////////////////////////////////////////////////////; 1492 ; 1493std::vector<TMatrixDSym*>*; 1494TMVA::Tools::CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); 1495{; 1496 std::vector<Event*> eventVector;; 1497 for (std::vector<const Event*>::const_iterator it = events.begin(), itEnd = events.end(",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52785,Testability,log,logger,52785,";; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset"") << Endl;; 1478 logger << kINFO << gTools().Color(""bold""); 1479 << ""For citation information, please visit: http://tmva.sf.net/citeTMVA.html""; 1480 << gTools().Color(""reset"") << Endl;; 1481 }; 1482}; 1483 ; 1484////////////////////////////////////////////////////////////////////////////////; 1485 ; 1486Bool_t TMVA::Tools::HistoHasEquidistantBins(const TH1& h); 1487{; 1488 return !(h.GetXaxis()->GetXbins()->fN);; 1489}; 1490 ; 1491////////////////////////////////////////////////////////////////////////////////; 1492 ; 1493std::vector<TMatrixDSym*>*; 1494TMVA::Tools::CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); 1495{; 1496 std::vector<Event*> eventVector;; 1497 for (std::vector<const Event*>::const_iterator it = events.begin(), itEnd = events.end(",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52823,Testability,log,logger,52823,";; 1453 logger << "" title = \""{TMVA: Toolkit for multivariate data analysis}\"","" << Endl;; 1454 logger << "" journal = \""PoS\"","" << Endl;; 1455 logger << "" volume = \""ACAT\"","" << Endl;; 1456 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset"") << Endl;; 1478 logger << kINFO << gTools().Color(""bold""); 1479 << ""For citation information, please visit: http://tmva.sf.net/citeTMVA.html""; 1480 << gTools().Color(""reset"") << Endl;; 1481 }; 1482}; 1483 ; 1484////////////////////////////////////////////////////////////////////////////////; 1485 ; 1486Bool_t TMVA::Tools::HistoHasEquidistantBins(const TH1& h); 1487{; 1488 return !(h.GetXaxis()->GetXbins()->fN);; 1489}; 1490 ; 1491////////////////////////////////////////////////////////////////////////////////; 1492 ; 1493std::vector<TMatrixDSym*>*; 1494TMVA::Tools::CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); 1495{; 1496 std::vector<Event*> eventVector;; 1497 for (std::vector<const Event*>::const_iterator it = events.begin(), itEnd = events.end(",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:52946,Testability,log,logger,52946,"56 logger << "" year = \""2007\"","" << Endl;; 1457 logger << "" pages = \""040\"","" << Endl;; 1458 logger << "" eprint = \""physics/0703039\"","" << Endl;; 1459 logger << "" archivePrefix = \""arXiv\"","" << Endl;; 1460 logger << "" SLACcitation = \""%%CITATION = PHYSICS/0703039;%%\"""" << Endl;; 1461 logger << ""}"" << Endl;; 1462 break;; 1463 ; 1464 case kLaTeX:; 1465 logger << ""%\\cite{TMVA2007}"" << Endl;; 1466 logger << ""\\bibitem{TMVA2007}"" << Endl;; 1467 logger << "" A.~Hoecker, P.~Speckmayer, J.~Stelzer, J.~Therhaag, E.~von Toerne, H.~Voss"" << Endl;; 1468 logger << "" %``TMVA: Toolkit for multivariate data analysis,''"" << Endl;; 1469 logger << "" PoS A {\\bf CAT} (2007) 040"" << Endl;; 1470 logger << "" [arXiv:physics/0703039]."" << Endl;; 1471 logger << "" %%CITATION = POSCI,ACAT,040;%%"" << Endl;; 1472 break;; 1473 ; 1474 case kHtmlLink:; 1475 // logger << kINFO << "" "" << Endl;; 1476 logger << kHEADER << gTools().Color(""bold""); 1477 << ""Thank you for using TMVA!"" << gTools().Color(""reset"") << Endl;; 1478 logger << kINFO << gTools().Color(""bold""); 1479 << ""For citation information, please visit: http://tmva.sf.net/citeTMVA.html""; 1480 << gTools().Color(""reset"") << Endl;; 1481 }; 1482}; 1483 ; 1484////////////////////////////////////////////////////////////////////////////////; 1485 ; 1486Bool_t TMVA::Tools::HistoHasEquidistantBins(const TH1& h); 1487{; 1488 return !(h.GetXaxis()->GetXbins()->fN);; 1489}; 1490 ; 1491////////////////////////////////////////////////////////////////////////////////; 1492 ; 1493std::vector<TMatrixDSym*>*; 1494TMVA::Tools::CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); 1495{; 1496 std::vector<Event*> eventVector;; 1497 for (std::vector<const Event*>::const_iterator it = events.begin(), itEnd = events.end(); it != itEnd; ++it); 1498 {; 1499 eventVector.push_back (new Event(*(*it)));; 1500 }; 1501 std::vector<TMatrixDSym*>* returnValue = CalcCovarianceMatrices (eventVector, maxCls, transfo",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:72754,Testability,log,logger,72754,"lassUInt_t GetClass() constDefinition Event.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::HistoHasEquidistantBinsBool_t HistoHasEquidistantBins(const TH1 &h)Definition Tools.cxx:1486; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::NormVariableDouble_t NormVariable(Double_t x, Double_t xmin, Double_t xmax)normalise to output range: [-1, 1]Definition Tools.cxx:110; TMVA::Tools::WriteFloatArbitraryPrecisionvoid WriteFloatArbitraryPrecision(Float_t val, std::ostream &os)writes a float value with the available precision to a streamDefinition Tools.cxx:1058; TMVA::Tools::GetYTitleWithUnitTString GetYTitleWithUnit(const TH1 &h, const TString &unit, Bool_t normalised)histogramming utilityDefinition Tools.cxx:1048; TMVA::Tools::GetSeparationDouble_t GetSeparation(TH1 *S",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:74634,Testability,log,logger,74634,"ols::GetSeparationDouble_t GetSeparation(TH1 *S, TH1 *B) constcompute ""separation"" defined asDefinition Tools.cxx:121; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::GetSQRootMatrixTMatrixD * GetSQRootMatrix(TMatrixDSym *symMat)square-root of symmetric matrix of course the resulting sqrtMat is also symmetric,...Definition Tools.cxx:271; TMVA::Tools::MVADiffstd::vector< Double_t > MVADiff(std::vector< Double_t > &, std::vector< Double_t > &)computes difference between two vectorsDefinition Tools.cxx:506; TMVA::Tools::GetIndexMinElementInt_t GetIndexMinElement(std::vector< Double_t > &)find index of minimum entry in vectorDefinition Tools.cxx:765; TMVA::Tools::projNormTH1FTH1 * projNormTH1F(TTree *theTree, const TString &theVarName, const TString &name, Int_t nbins, Double_t xmin, Double_t xmax, const TString &cut)projects variable from tree into normalised histogramDefinition Tools.cxx:366; TMVA::Tools::ROOTVersionMessagevoid ROOTVersionMessage(MsgLogger &logger)prints the ROOT release number and dateDefinition Tools.cxx:1325; TMVA::Tools::ReplaceRegularExpressionsTString ReplaceRegularExpressions(const TString &s, const TString &replace=""+"")replace regular expressions helper function to remove all occurrences ""$!%^&()'<>?...Definition Tools.cxx:798; TMVA::Tools::ReadTVectorDFromXMLvoid ReadTVectorDFromXML(void *node, const char *name, TVectorD *vec)Definition Tools.cxx:1267; TMVA::Tools::GetCumulativeDistTH1 * GetCumulativeDist(TH1 *h)get the cumulative distribution of a histogramDefinition Tools.cxx:1756; TMVA::Tools::ReadFloatArbitraryPrecisionvoid ReadFloatArbitraryPrecision(Float_t &val, std::istream &is)reads a float value with the available precision from a streamDefinition Tools.cxx:1073; TMVA::Tools::AddRawLineBool_t AddRawLine(void *node, const char *raw)XML helpers.Definition Tools.cxx:1190; TMVA::Tools::~Tools~Tools()destructorDefinition Tools.cxx:101; TMVA::Tools::ContainsRegularExpressionBool_t ContainsRegularExpress",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:80431,Testability,log,logger,80431,":Tools::NormHistDouble_t NormHist(TH1 *theHist, Double_t norm=1.0)normalises histogramDefinition Tools.cxx:383; TMVA::Tools::AddChildvoid * AddChild(void *parent, const char *childname, const char *content=nullptr, bool isRootNode=false)add child nodeDefinition Tools.cxx:1124; TMVA::Tools::UsefulSortAscendingvoid UsefulSortAscending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:538; TMVA::Tools::GetYMean_binXDouble_t GetYMean_binX(const TH2 &, Int_t bin_x)Compute the mean in Y for a given bin X of a 2D histogram.Definition Tools.cxx:642; TMVA::Tools::CalcCovarianceMatricesstd::vector< TMatrixDSym * > * CalcCovarianceMatrices(const std::vector< Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr)compute covariance matricesDefinition Tools.cxx:1513; TMVA::Tools::TMVACitationvoid TMVACitation(MsgLogger &logger, ECitation citType=kPlainText)kinds of TMVA citationDefinition Tools.cxx:1440; TMVA::Tools::TMVAVersionMessagevoid TMVAVersionMessage(MsgLogger &logger)prints the TMVA release number and dateDefinition Tools.cxx:1316; TMVA::Tools::TMVAWelcomeMessagevoid TMVAWelcomeMessage()direct output, eg, when starting ROOT session -> no use of Logger hereDefinition Tools.cxx:1302; TMVA::Tools::ParseANNOptionStringstd::vector< Int_t > * ParseANNOptionString(TString theOptions, Int_t nvar, std::vector< Int_t > *nodes)parse option string for ANN methods default settings (should be defined in theOption string)Definition Tools.cxx:443; TMVA::Tools::GetIndexMaxElementInt_t GetIndexMaxElement(std::vector< Double_t > &)find index of maximum entry in vectorDefinition Tools.cxx:748; TMVA::Tools::TransposeHistTH2F * TransposeHist(const TH2F &)Transpose quadratic histogram.Definition Tools.cxx:657; TMVA::Tools::EWelcomeMessageEWelcomeMessageDefinition Tools.h:198; TMVA::Tools::HasAttrBool_t HasAttr(void *node",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:80583,Testability,log,logger,80583," AddChild(void *parent, const char *childname, const char *content=nullptr, bool isRootNode=false)add child nodeDefinition Tools.cxx:1124; TMVA::Tools::UsefulSortAscendingvoid UsefulSortAscending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:538; TMVA::Tools::GetYMean_binXDouble_t GetYMean_binX(const TH2 &, Int_t bin_x)Compute the mean in Y for a given bin X of a 2D histogram.Definition Tools.cxx:642; TMVA::Tools::CalcCovarianceMatricesstd::vector< TMatrixDSym * > * CalcCovarianceMatrices(const std::vector< Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr)compute covariance matricesDefinition Tools.cxx:1513; TMVA::Tools::TMVACitationvoid TMVACitation(MsgLogger &logger, ECitation citType=kPlainText)kinds of TMVA citationDefinition Tools.cxx:1440; TMVA::Tools::TMVAVersionMessagevoid TMVAVersionMessage(MsgLogger &logger)prints the TMVA release number and dateDefinition Tools.cxx:1316; TMVA::Tools::TMVAWelcomeMessagevoid TMVAWelcomeMessage()direct output, eg, when starting ROOT session -> no use of Logger hereDefinition Tools.cxx:1302; TMVA::Tools::ParseANNOptionStringstd::vector< Int_t > * ParseANNOptionString(TString theOptions, Int_t nvar, std::vector< Int_t > *nodes)parse option string for ANN methods default settings (should be defined in theOption string)Definition Tools.cxx:443; TMVA::Tools::GetIndexMaxElementInt_t GetIndexMaxElement(std::vector< Double_t > &)find index of maximum entry in vectorDefinition Tools.cxx:748; TMVA::Tools::TransposeHistTH2F * TransposeHist(const TH2F &)Transpose quadratic histogram.Definition Tools.cxx:657; TMVA::Tools::EWelcomeMessageEWelcomeMessageDefinition Tools.h:198; TMVA::Tools::HasAttrBool_t HasAttr(void *node, const char *attrname)add attribute from xmlDefinition Tools.cxx:1094; TMVA::Tools::GetNextChildvoid * GetNextChild(void *prevchild, const ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:86459,Testability,log,logarithm,86459,"of a tree using selections.Definition TTree.cxx:7498; TVectorT< Double_t >; TXMLEngineDefinition TXMLEngine.h:26; TXMLEngine::NewChildXMLNodePointer_t NewChild(XMLNodePointer_t parent, XMLNsPointer_t ns, const char *name, const char *content=nullptr)create new child element for parent nodeDefinition TXMLEngine.cxx:715; TXMLEngine::NewAttrXMLAttrPointer_t NewAttr(XMLNodePointer_t xmlnode, XMLNsPointer_t, const char *name, const char *value)creates new attribute for xmlnode, namespaces are not supported for attributesDefinition TXMLEngine.cxx:586; TXMLEngine::AddCommentBool_t AddComment(XMLNodePointer_t parent, const char *comment)Adds comment line to the node.Definition TXMLEngine.cxx:878; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMVA::gConfigConfig & gConfig(); TMVA::gToolsTools & gTools(); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::RMSDouble_t RMS(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the Standard Deviation of an array a with length n.Definition TMath.h:1188; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MeanDouble_t Mean(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the weighted mean of an array a with length n.Definition TMath.h:1089; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699; vecDefinition civetweb.c:1855; mTMarker mDefinition textangle.C:8; Config.h; Types.h; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. tmvatmvasrcTools.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:30625,Usability,simpl,simple,30625,"tic const TString gClr_whiteonblue = ""\033[1;44m""; // white on blue background; 849 static const TString gClr_whiteongreen = ""\033[1;42m""; // white on green background; 850 static const TString gClr_grey_bg = ""\033[47m""; // grey background; 851 ; 852 static const TString gClr_reset = ""\033[0m""; // reset; 853 ; 854 if (!gConfig().UseColor()) return gClr_none;; 855 ; 856 if (c == ""white"" ) return gClr_white;; 857 if (c == ""blue"" ) return gClr_blue;; 858 if (c == ""black"" ) return gClr_black;; 859 if (c == ""lightblue"") return gClr_cyan_b;; 860 if (c == ""yellow"") return gClr_yellow;; 861 if (c == ""red"" ) return gClr_red;; 862 if (c == ""dred"" ) return gClr_darkred;; 863 if (c == ""dgreen"") return gClr_darkgreen;; 864 if (c == ""lgreenb"") return gClr_lgreen_b;; 865 if (c == ""dyellow"") return gClr_darkyellow;; 866 ; 867 if (c == ""bold"") return gClr_bold;; 868 if (c == ""bblack"") return gClr_black_b;; 869 ; 870 if (c == ""blue_bgd"") return gClr_blue_bg;; 871 if (c == ""red_bgd"" ) return gClr_red_bg;; 872 ; 873 if (c == ""white_on_blue"" ) return gClr_whiteonblue;; 874 if (c == ""white_on_green"") return gClr_whiteongreen;; 875 ; 876 if (c == ""reset"") return gClr_reset;; 877 ; 878 std::cout << ""Unknown color "" << c << std::endl;; 879 exit(1);; 880 ; 881 return gClr_none;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// formatted output of simple table; 886 ; 887void TMVA::Tools::FormattedOutput( const std::vector<Double_t>& values, const std::vector<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:62293,Usability,learn,learned,62293,"length n.; 1739/// Note that this function returns the sigma(standard deviation) and; 1740/// not the root mean square of the array.; 1741 ; 1742template <typename T>; 1743Double_t TMVA::Tools::RMS(Long64_t n, const T *a, const Double_t *w); 1744{; 1745 ; 1746 if (w) {; 1747 return TMVA::Tools::RMS(a, a+n, w);; 1748 } else {; 1749 return TMath::RMS(a, a+n);; 1750 }; 1751}; 1752 ; 1753////////////////////////////////////////////////////////////////////////////////; 1754/// get the cumulative distribution of a histogram; 1755 ; 1756TH1* TMVA::Tools::GetCumulativeDist( TH1* h); 1757{; 1758 TH1* cumulativeDist= (TH1*) h->Clone(TString::Format(""%sCumul"",h->GetTitle()));; 1759 //cumulativeDist->Smooth(5); // with this, I get less beautiful ROC curves, hence out!; 1760 ; 1761 Float_t partialSum = 0;; 1762 Float_t inverseSum = 0.;; 1763 ; 1764 Float_t val;; 1765 for (Int_t ibinEnd=1, ibin=cumulativeDist->GetNbinsX(); ibin >=ibinEnd ; ibin--){; 1766 val = cumulativeDist->GetBinContent(ibin);; 1767 if (val>0) inverseSum += val;; 1768 }; 1769 inverseSum = 1/inverseSum; // as I learned multiplications are much faster than division, and later I need one per bin. Well, not that it would really matter here I guess :); 1770 ; 1771 for (Int_t ibinEnd=1, ibin=cumulativeDist->GetNbinsX(); ibin >=ibinEnd ; ibin--){; 1772 val = cumulativeDist->GetBinContent(ibin);; 1773 if (val>0) partialSum += val;; 1774 cumulativeDist->SetBinContent(ibin,partialSum*inverseSum);; 1775 }; 1776 return cumulativeDist;; 1777}; 1778 ; 1779void TMVA::Tools::ReadAttr(void *node, const char *attrname, float &value); 1780{; 1781 // read attribute from xml; 1782 const char *val = xmlengine().GetAttr(node, attrname);; 1783 if (val == nullptr) {; 1784 const char *nodename = xmlengine().GetNodeName(node);; 1785 Log() << kFATAL << ""Trying to read non-existing attribute '"" << attrname << ""' from xml node '"" << nodename << ""'""; 1786 << Endl;; 1787 } else; 1788 value = atof(val);; 1789}; 1790 ; 1791void TMVA::Tools::Re",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8cxx_source.html:72806,Usability,simpl,simple,72806,"ogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::HistoHasEquidistantBinsBool_t HistoHasEquidistantBins(const TH1 &h)Definition Tools.cxx:1486; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::NormVariableDouble_t NormVariable(Double_t x, Double_t xmin, Double_t xmax)normalise to output range: [-1, 1]Definition Tools.cxx:110; TMVA::Tools::WriteFloatArbitraryPrecisionvoid WriteFloatArbitraryPrecision(Float_t val, std::ostream &os)writes a float value with the available precision to a streamDefinition Tools.cxx:1058; TMVA::Tools::GetYTitleWithUnitTString GetYTitleWithUnit(const TH1 &h, const TString &unit, Bool_t normalised)histogramming utilityDefinition Tools.cxx:1048; TMVA::Tools::GetSeparationDouble_t GetSeparation(TH1 *S, TH1 *B) constcompute ""separation"" defined asDefinition Tools.cxx:121; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools",MatchSource.WIKI,doc/master/Tools_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html
https://root.cern/doc/master/Tools_8h.html:522,Integrability,depend,dependency,522,". ROOT: tmva/tmva/inc/TMVA/Tools.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; Tools.h File Reference. #include <vector>; #include <string>; #include <sstream>; #include <iostream>; #include <atomic>; #include ""TXMLEngine.h""; #include ""TMatrixDSymfwd.h""; #include ""TMatrixDfwd.h""; #include ""TVectorDfwd.h""; #include ""TMVA/Types.h""; #include ""TMVA/VariableTransformBase.h""; #include ""TString.h""; #include ""TMVA/MsgLogger.h"". Include dependency graph for Tools.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TMVA::RandomGenerator< TRandomLike, UIntType, max_val >;  ; class  TMVA::Tools;  Global auxiliary applications and data treatment routines. More...;  . Namespaces; namespace  TMVA;  create variable transformations ;  . Functions; Tools & TMVA::gTools ();  . tmvatmvaincTMVATools.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:25 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Tools_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8h.html
https://root.cern/doc/master/Tools_8h.html:941,Integrability,rout,routines,941,". ROOT: tmva/tmva/inc/TMVA/Tools.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; Tools.h File Reference. #include <vector>; #include <string>; #include <sstream>; #include <iostream>; #include <atomic>; #include ""TXMLEngine.h""; #include ""TMatrixDSymfwd.h""; #include ""TMatrixDfwd.h""; #include ""TVectorDfwd.h""; #include ""TMVA/Types.h""; #include ""TMVA/VariableTransformBase.h""; #include ""TString.h""; #include ""TMVA/MsgLogger.h"". Include dependency graph for Tools.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TMVA::RandomGenerator< TRandomLike, UIntType, max_val >;  ; class  TMVA::Tools;  Global auxiliary applications and data treatment routines. More...;  . Namespaces; namespace  TMVA;  create variable transformations ;  . Functions; Tools & TMVA::gTools ();  . tmvatmvaincTMVATools.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:25 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Tools_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8h.html
https://root.cern/doc/master/Tools_8h.html:1000,Modifiability,variab,variable,1000,". ROOT: tmva/tmva/inc/TMVA/Tools.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; Tools.h File Reference. #include <vector>; #include <string>; #include <sstream>; #include <iostream>; #include <atomic>; #include ""TXMLEngine.h""; #include ""TMatrixDSymfwd.h""; #include ""TMatrixDfwd.h""; #include ""TVectorDfwd.h""; #include ""TMVA/Types.h""; #include ""TMVA/VariableTransformBase.h""; #include ""TString.h""; #include ""TMVA/MsgLogger.h"". Include dependency graph for Tools.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TMVA::RandomGenerator< TRandomLike, UIntType, max_val >;  ; class  TMVA::Tools;  Global auxiliary applications and data treatment routines. More...;  . Namespaces; namespace  TMVA;  create variable transformations ;  . Functions; Tools & TMVA::gTools ();  . tmvatmvaincTMVATools.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:25 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Tools_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Tools_8h.html
https://root.cern/doc/master/tornado_8C.html:3586,Modifiability,plug-in,plug-in,3586,"void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TBenchmark::GetCpuTimeFloat_t GetCpuTime(const char *name)Returns Cpu time used by Benchmark name.Definition TBenchmark.cxx:117; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPolyMarker3DA 3D polymarker.Definition TPolyMarker3D.h:33; TPolyMarker3D::SetPointvoid SetPoint(Int_t n, Double_t x, Double_t y, Double_t z)Set point n to x, y, z.Definition TPolyMarker3D.cxx:535; TPolyMarker3D::Drawvoid Draw(Option_t *option="""") overrideDraws 3-D polymarker with its current attributes.Definition TPolyMarker3D.cxx:242; TViewSee TView3D.Definition TView.h:25; TView::CreateViewstatic TView * CreateView(Int_t system=1, const Double_t *rmin=nullptr, const Double_t *rmax=nullptr)Create a concrete default 3-d view via the plug-in manager.Definition TView.cxx:27; TView::SetRangevirtual void SetRange(const Double_t *min, const Double_t *max)=0; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; tornadoDefinition tornado.py:1; AuthorRene Brun ; Definition in file tornado.C. tutorialsgraphicstornado.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tornado_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tornado_8C.html
https://root.cern/doc/master/tornado_8py.html:1951,Modifiability,plug-in,plug-in,1951,"ials » PyRoot tutorials. Detailed Description; Tornado example. ; . ; from ROOT import TCanvas, TView, TPolyMarker3D, TPaveText; from ROOT import gROOT, gBenchmark; from math import cos, sin, pi; ; gBenchmark.Start( 'tornado' ); ; d = 16; numberOfPoints = 200; numberOfCircles = 40; ; # create and open a canvas; sky = TCanvas( 'sky', 'Tornado', 300, 10, 700, 500 ); sky.SetFillColor( 14 ); ; # creating view; view = TView.CreateView(); rng = numberOfCircles * d; view.SetRange( 0, 0, 0, 4.0*rng, 2.0*rng, rng ); ; polymarkers = []; for j in range( d, numberOfCircles * d, d ):; ; # create a PolyMarker3D; pm3d = TPolyMarker3D( numberOfPoints ); ; # set points; for i in range( 1, numberOfPoints ) :; csin = sin( 2*pi / numberOfPoints * i ) + 1; ccos = cos( 2*pi / numberOfPoints * i ) + 1; esin = sin( 2*pi / (numberOfCircles*d) * j ) + 1; x = j * ( csin + esin );; y = j * ccos;; z = j;; pm3d.SetPoint( i, x, y, z );; ; # set marker size, color & style; pm3d.SetMarkerSize( 1 ); pm3d.SetMarkerColor( 2 + ( d == ( j & d ) ) ); pm3d.SetMarkerStyle( 3 ); ; # draw; pm3d.Draw(); ; # save a reference; polymarkers.append( pm3d ); ; gBenchmark.Show( 'tornado' ); ; ct = gBenchmark.GetCpuTime( 'tornado' ); timeStr = 'Execution time: %g sec.' % ct; ; text = TPaveText( 0.1, 0.81, 0.9, 0.97 ); text.SetFillColor( 42 ); text.AddText( 'PyROOT example: tornado.py' ); text.AddText( timeStr ); text.Draw(); ; sky.Update(); TCanvasThe Canvas class.Definition TCanvas.h:23; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPolyMarker3DA 3D polymarker.Definition TPolyMarker3D.h:33; TView::CreateViewstatic TView * CreateView(Int_t system=1, const Double_t *rmin=nullptr, const Double_t *rmax=nullptr)Create a concrete default 3-d view via the plug-in manager.Definition TView.cxx:27; AuthorWim Lavrijsen ; Definition in file tornado.py. tutorialspyroottornado.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tornado_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tornado_8py.html
https://root.cern/doc/master/TPad_8cxx_source.html:10417,Availability,error,error,10417," = gStyle->GetOptLogx();; 311 fLogy = gStyle->GetOptLogy();; 312 fLogz = gStyle->GetOptLogz();; 313 ; 314 fFixedAspectRatio = kFALSE;; 315 fAspectRatio = 0.;; 316 ; 317 fNumPaletteColor = 0;; 318 fNextPaletteColor = 0;; 319 fCGnx = 0;; 320 fCGny = 0;; 321 ; 322 fViewer3D = nullptr;; 323 ; 324 if (fCanvas) fGLDevice = fCanvas->GetGLDevice();; 325 // Set default world coordinates to NDC [0,1]; 326 fX1 = 0;; 327 fX2 = 1;; 328 fY1 = 0;; 329 fY2 = 1;; 330 ; 331 if (!gPad) {; 332 Error(""TPad"", ""You must create a TCanvas before creating a TPad"");; 333 MakeZombie();; 334 return;; 335 }; 336 ; 337 TContext ctxt(kTRUE);; 338 ; 339 Bool_t zombie = kFALSE;; 340 ; 341 if ((xlow < 0) || (xlow > 1) || (ylow < 0) || (ylow > 1)) {; 342 Error(""TPad"", ""illegal bottom left position: x=%f, y=%f"", xlow, ylow);; 343 zombie = kTRUE;; 344 } else if ((xup < 0) || (xup > 1) || (yup < 0) || (yup > 1)) {; 345 Error(""TPad"", ""illegal top right position: x=%f, y=%f"", xup, yup);; 346 zombie = kTRUE;; 347 } else if (xup-xlow <= 0) {; 348 Error(""TPad"", ""illegal width: %f"", xup-xlow);; 349 zombie = kTRUE;; 350 } else if (yup-ylow <= 0) {; 351 Error(""TPad"", ""illegal height: %f"", yup-ylow);; 352 zombie = kTRUE;; 353 }; 354 ; 355 if (zombie) {; 356 // error in creating pad occurred, make this pad a zombie; 357 MakeZombie();; 358 return;; 359 }; 360 ; 361 ; 362 fLogx = gStyle->GetOptLogx();; 363 fLogy = gStyle->GetOptLogy();; 364 fLogz = gStyle->GetOptLogz();; 365 ; 366 fUxmin = fUymin = fUxmax = fUymax = 0;; 367 ; 368 // Set pad parameters and Compute conversion coefficients; 369 SetPad(name, title, xlow, ylow, xup, yup, color, bordersize, bordermode);; 370 Range(0, 0, 1, 1);; 371 SetBit(kMustCleanup);; 372 SetBit(kCanDelete);; 373}; 374 ; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Pad destructor.; 378 ; 379TPad::~TPad(); 380{; 381 if (ROOT::Detail::HasBeenDeleted(this)) return;; 382 Close();; 383 CloseToolTip(fTip);; 384 DeleteToolTip(fTip);; 385 au",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:20814,Availability,failure,failure,20814,");; 638 TList * hlist = ((THStack *)o)->GetHists();; 639 TIter nexthist(hlist);; 640 while ((obj = nexthist())) {; 641 TH1 *hist = (TH1*) obj;; 642 if (strlen(hist->GetTitle())); 643 mes = hist->GetTitle();; 644 else if (strlen(hist->GetName())); 645 mes = hist->GetName();; 646 else; 647 mes = hist->ClassName();; 648 if (option && strlen(option)); 649 opt = option;; 650 else; 651 opt = ""lpf"";; 652 leg->AddEntry( obj, mes.Data(), opt );; 653 }; 654 }; 655 opt = """";; 656 }; 657 if (leg) {; 658 TContext ctxt(this, kTRUE);; 659 leg->Draw();; 660 } else {; 661 Info(""BuildLegend"", ""No object(s) to build a TLegend."");; 662 }; 663 return leg;; 664}; 665 ; 666////////////////////////////////////////////////////////////////////////////////; 667/// Set Current pad.; 668///; 669/// When a canvas/pad is divided via TPad::Divide, one can directly; 670/// set the current path to one of the subdivisions.; 671/// See TPad::Divide for the convention to number sub-pads.; 672///; 673/// Returns the new current pad, or 0 in case of failure.; 674///; 675/// For example:; 676/// ~~~ {.cpp}; 677/// c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; 678/// ~~~; 679/// To set the current pad to the bottom right pad, do; 680/// ~~~ {.cpp}; 681/// c1.cd(6);; 682/// ~~~; 683/// Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; 684/// to c1 itself.; 685///; 686/// Note2: after a statement like c1.cd(6), the global variable gPad; 687/// points to the current pad. One can use gPad to set attributes; 688/// of the current pad.; 689///; 690/// Note3: One can get a pointer to one of the sub-pads of pad with:; 691/// TPad *subpad = (TPad*)pad->GetPad(subpadnumber);; 692 ; 693TVirtualPad *TPad::cd(Int_t subpadnumber); 694{; 695 if (!subpadnumber) {; 696 gPad = this;; 697 if (!gPad->IsBatch() && GetPainter()) GetPainter()->SelectDrawable(fPixmapID);; 698 if (!fPrimitives) fPrimitives = new TList;; 699 return gPad;; 700 }; 701 ; 702 if (!fPrimitives) fPrimitives = new TL",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:148579,Availability,avail,available,148579,"//////; 4645/// Search for an object at pixel position px,py.; 4646///; 4647/// Check if point is in this pad.; 4648///; 4649/// If yes, check if it is in one of the sub-pads; 4650///; 4651/// If found in the pad, compute closest distance of approach; 4652/// to each primitive.; 4653///; 4654/// If one distance of approach is found to be within the limit Distancemaximum; 4655/// the corresponding primitive is selected and the routine returns.; 4656 ; 4657TPad *TPad::Pick(Int_t px, Int_t py, TObjLink *&pickobj); 4658{; 4659 //the two following statements are necessary under NT (multithreaded); 4660 //when a TCanvas object is being created and a thread calling TPad::Pick; 4661 //before the TPad constructor has completed in the other thread; 4662 if (!gPad) return nullptr; //Andy Haas; 4663 if (!GetListOfPrimitives()) return nullptr; //Andy Haas; 4664 ; 4665 Int_t dist;; 4666 // Search if point is in pad itself; 4667 Double_t x = AbsPixeltoX(px);; 4668 Double_t y = AbsPixeltoY(py);; 4669 if (this != gPad->GetCanvas()) {; 4670 if (!((x >= fX1 && x <= fX2) && (y >= fY1 && y <= fY2))) return nullptr;; 4671 }; 4672 ; 4673 // search for a primitive in this pad or its sub-pads; 4674 static TObjOptLink dummyLink(nullptr,""""); //place holder for when no link available; 4675 ; 4676 TContext ctxt(this, kFALSE); // since no drawing will be done, don't use cd() for efficiency reasons; 4677 ; 4678 TPad *pick = nullptr;; 4679 TPad *picked = this;; 4680 pickobj = nullptr;; 4681 if (DistancetoPrimitive(px,py) < fgMaxPickDistance) {; 4682 dummyLink.SetObject(this);; 4683 pickobj = &dummyLink;; 4684 }; 4685 ; 4686 // Loop backwards over the list of primitives. The first non-pad primitive; 4687 // found is the selected one. However, we have to keep going down the; 4688 // list to see if there is maybe a pad overlaying the primitive. In that; 4689 // case look into the pad for a possible primitive. Once a pad has been; 4690 // found we can terminate the loop.; 4691 Bool_t gotPrim = kFALSE;",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:149074,Availability,down,down,149074,"dy Haas; 4663 if (!GetListOfPrimitives()) return nullptr; //Andy Haas; 4664 ; 4665 Int_t dist;; 4666 // Search if point is in pad itself; 4667 Double_t x = AbsPixeltoX(px);; 4668 Double_t y = AbsPixeltoY(py);; 4669 if (this != gPad->GetCanvas()) {; 4670 if (!((x >= fX1 && x <= fX2) && (y >= fY1 && y <= fY2))) return nullptr;; 4671 }; 4672 ; 4673 // search for a primitive in this pad or its sub-pads; 4674 static TObjOptLink dummyLink(nullptr,""""); //place holder for when no link available; 4675 ; 4676 TContext ctxt(this, kFALSE); // since no drawing will be done, don't use cd() for efficiency reasons; 4677 ; 4678 TPad *pick = nullptr;; 4679 TPad *picked = this;; 4680 pickobj = nullptr;; 4681 if (DistancetoPrimitive(px,py) < fgMaxPickDistance) {; 4682 dummyLink.SetObject(this);; 4683 pickobj = &dummyLink;; 4684 }; 4685 ; 4686 // Loop backwards over the list of primitives. The first non-pad primitive; 4687 // found is the selected one. However, we have to keep going down the; 4688 // list to see if there is maybe a pad overlaying the primitive. In that; 4689 // case look into the pad for a possible primitive. Once a pad has been; 4690 // found we can terminate the loop.; 4691 Bool_t gotPrim = kFALSE; // true if found a non pad primitive; 4692 TObjLink *lnk = GetListOfPrimitives()->LastLink();; 4693 ; 4694 //We can have 3d stuff in pad. If canvas prefers to draw; 4695 //such stuff with OpenGL, the selection of 3d objects is; 4696 //a gl viewer business so, in first cycle we do not; 4697 //call DistancetoPrimitive for TAtt3D descendants.; 4698 //In case of gl we first try to select 2d object first.; 4699 ; 4700 while (lnk) {; 4701 TObject *obj = lnk->GetObject();; 4702 ; 4703 //If canvas prefers GL, all 3d objects must be drawn/selected by; 4704 //gl viewer; 4705 if (obj->InheritsFrom(TAtt3D::Class()) && fEmbeddedGL) {; 4706 lnk = lnk->Prev();; 4707 continue;; 4708 }; 4709 ; 4710 fPadPointer = obj;; 4711 if (obj->InheritsFrom(TPad::Class())) {; 4712 pick = ((TPad*)obj)->Pi",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:154018,Availability,avail,available,154018," 4812 if (obj->InheritsFrom(TImage::Class())) {; 4813 return kTRUE;; 4814 } else if (obj->InheritsFrom(TPad::Class())) {; 4815 if (ContainsTImage(((TPad*)obj)->GetListOfPrimitives())) {; 4816 return kTRUE;; 4817 }; 4818 }; 4819 }; 4820 return kFALSE;; 4821}; 4822 ; 4823////////////////////////////////////////////////////////////////////////////////; 4824/// Save Canvas contents in a file in one of various formats.; 4825///; 4826/// \anchor TPadPrint; 4827/// option can be:; 4828///; 4829/// - `ps`: a Postscript file is produced (default). [See special cases](\ref TPadPrintPS).; 4830/// - `Portrait`: Postscript file is produced (Portrait); 4831/// - `Landscape`: Postscript file is produced (Landscape); 4832/// - `eps`: an Encapsulated Postscript file is produced; 4833/// - `Preview`: an [Encapsulated Postscript file with preview](\ref TPadPrintPreview) is produced.; 4834/// - `pdf`: a PDF file is produced NOTE: TMathText will be converted to TLatex; q.e.d., symbols only available in TMathText will not render properly.; 4835/// - `Title:`: The character string after `Title:` becomes a table; 4836/// of content entry (for PDF files).; 4837/// - `EmbedFonts`: a [PDF file with embedded fonts](\ref TPadPrintEmbedFonts) is generated.; 4838/// - `svg`: a SVG file is produced; 4839/// - `tex`: a TeX file is produced; 4840/// - `Standalone`: a [standalone TeX file](\ref TPadPrintStandalone) is produced.; 4841/// - `gif`: a GIF file is produced; 4842/// - `gif+NN`: an animated GIF file is produced, where NN is delay in 10ms units NOTE: See other variants for looping animation in TASImage::WriteImage; 4843/// - `xpm`: a XPM file is produced; 4844/// - `png`: a PNG file is produced; 4845/// - `jpg`: a JPEG file is produced. NOTE: JPEG's lossy compression will make all sharp edges fuzzy.; 4846/// - `tiff`: a TIFF file is produced; 4847/// - `cxx`: a C++ macro file is produced; 4848/// - `xml`: a XML file; 4849/// - `json`: a JSON file; 4850/// - `root`: a ROOT binary file; 4851///",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:182372,Availability,avail,available,182372,"f]; 5605/// \f[ y = ymin \times e^{(beta \times pylow)} \times e^{(-beta \times py)}\f]; 5606/// \f[ \Rightarrow y = fPixeltoYk \times e^{(fPixeltoY \times py)} \f]; 5607/// \f[ fPixeltoYk = ymin \times e^{(beta \times pylow)} \f]; 5608/// \f[ fPixeltoY = -beta \f]; 5609///; 5610/// #### Conversion from World coordinates to pixel coordinates; 5611///; 5612/// \f[ px = pxlow + u*pxrange \f]; 5613/// \f[ = pxlow + Log(x/xmin)/alfa \f]; 5614/// \f[ = pxlow -Log(xmin)/alfa + Log(x)/alfa \f]; 5615/// \f[ = fXtoPixelk + fXtoPixel*Log(x) \f]; 5616/// \f[ \Rightarrow fXtoPixelk = pxlow -Log(xmin)/alfa \f]; 5617/// \f[ \Rightarrow fXtoPixel = 1/alfa \f]; 5618///; 5619/// \f[ py = pylow - Log(y/ymin)/beta \f]; 5620/// \f[ = fYtoPixelk + fYtoPixel*Log(y) \f]; 5621/// \f[ \Rightarrow fYtoPixelk = pylow - Log(ymin)/beta \f]; 5622/// \f[ fYtoPixel = 1/beta \f]; 5623 ; 5624void TPad::ResizePad(Option_t *option); 5625{; 5626 ; 5627 if (!gPad) {; 5628 Error(""ResizePad"", ""Cannot resize pad. No current pad available."");; 5629 return;; 5630 }; 5631 if (gPad->GetWw()==0.0||gPad->GetWh()==0.0) {; 5632 Warning(""ResizePad"", ""gPad has at least one zero dimension."");; 5633 return;; 5634 }; 5635 if (fX1==fX2||fY1==fY2) {; 5636 Warning(""ResizePad"", ""The pad has at least one zero dimension."");; 5637 return;; 5638 }; 5639 // Recompute subpad positions in case pad has been moved/resized; 5640 TPad *parent = fMother;; 5641 if (this == gPad->GetCanvas()) {; 5642 fAbsXlowNDC = fXlowNDC;; 5643 fAbsYlowNDC = fYlowNDC;; 5644 fAbsWNDC = fWNDC;; 5645 fAbsHNDC = fHNDC;; 5646 }; 5647 else {; 5648 if (parent->GetAbsHNDC()==0.0||parent->GetAbsWNDC()==0.0||fHNDC==0.0||fWNDC==0.0) {; 5649 Warning(""ResizePad"", ""The parent pad has at least one zero dimension."");; 5650 return;; 5651 }; 5652 fAbsXlowNDC = fXlowNDC*parent->GetAbsWNDC() + parent->GetAbsXlowNDC();; 5653 fAbsYlowNDC = fYlowNDC*parent->GetAbsHNDC() + parent->GetAbsYlowNDC();; 5654 fAbsWNDC = fWNDC*parent->GetAbsWNDC();; 5655 fAbsHNDC = fHNDC*parent->Ge",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:187470,Availability,avail,available,187470,") {; 5736 if (gVirtualX->ResizePixmap(fPixmapID, w, h)) {; 5737 Resized();; 5738 Modified(kTRUE);; 5739 }; 5740 }; 5741 }; 5742 }; 5743 }; 5744 if (fView) {; 5745 if (gPad == this) {; 5746 fView->ResizePad();; 5747 } else {; 5748 TContext ctxt(this, kTRUE);; 5749 fView->ResizePad();; 5750 }; 5751 }; 5752}; 5753 ; 5754////////////////////////////////////////////////////////////////////////////////; 5755/// Save the pad content in a file.; 5756///; 5757/// The file's format used to save the pad is determined by the `filename` extension:; 5758///; 5759/// - if `filename` is empty, the file produced is `padname.ps`; 5760/// - if `filename` starts with a dot, the padname is added in front; 5761/// - if `filename` ends with `.ps`, a Postscript file is produced; 5762/// - if `filename` ends with `.eps`, an Encapsulated Postscript file is produced; 5763/// - if `filename` ends with `.pdf`, a PDF file is produced NOTE: TMathText will be converted to TLatex; q.e.d., symbols only available in TMathText will not render properly.; 5764/// - if `filename` ends with `.svg`, a SVG file is produced; 5765/// - if `filename` ends with `.tex`, a TeX file is produced; 5766/// - if `filename` ends with `.gif`, a GIF file is produced; 5767/// - if `filename` ends with `.gif+NN`, an animated GIF file is produced See comments in TASImage::WriteImage for meaning of NN and other .gif sufix variants; 5768/// - if `filename` ends with `.xpm`, a XPM file is produced; 5769/// - if `filename` ends with `.png`, a PNG file is produced; 5770/// - if `filename` ends with `.bmp`, a BMP file is produced; 5771/// - if `filename` ends with `.jpg` or `.jpeg` a JPEG file is produced NOTE: JPEG's lossy compression will make all sharp edges fuzzy.; 5772/// - if `filename` ends with `.tiff`, a TIFF file is produced; 5773/// - if `filename` ends with `.C`, `.cxx`,`.cpp` or `.cc`, a C++ macro file is produced; 5774/// - if `filename` ends with `.root`, a Root file is produced; 5775/// - if `filename` ends with `.",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:241264,Availability,down,down,241264,"ewer = TVirtualViewer3D::Viewer3D(this, type);; 7181 ; 7182 if (!newViewer) {; 7183 Warning(""GetViewer3D"", ""Cannot create 3D viewer of type: %s"", type);; 7184 // Return the existing viewer; 7185 return fViewer3D;; 7186 }; 7187 ; 7188 if (strstr(type, ""gl"") && !strstr(type, ""ogl"")) {; 7189 fEmbeddedGL = kTRUE;; 7190 fCopyGLDevice = kTRUE;; 7191 Modified();; 7192 } else {; 7193 createdExternal = kTRUE;; 7194 }; 7195 ; 7196 } else {; 7197 newViewer = new TViewer3DPad(*this);; 7198 }; 7199 ; 7200 // If we had a previous viewer destroy it now; 7201 // In this case we do take responsibility for destroying viewer; 7202 // c.f. ReleaseViewer3D; 7203 delete fViewer3D;; 7204 ; 7205 // Set and return new viewer; 7206 fViewer3D = newViewer;; 7207 ; 7208 // Ensure any new external viewer is painted; 7209 // For internal TViewer3DPad type we assume this is being; 7210 // create on demand due to a paint - so this is not required; 7211 if (createdExternal) {; 7212 Modified();; 7213 Update();; 7214 }; 7215 ; 7216 return fViewer3D;; 7217}; 7218 ; 7219////////////////////////////////////////////////////////////////////////////////; 7220/// Release current (external) viewer; 7221 ; 7222void TPad::ReleaseViewer3D(Option_t * /*type*/ ); 7223{; 7224 fViewer3D = nullptr;; 7225 ; 7226 // We would like to ensure the pad is repainted; 7227 // when external viewer is closed down. However; 7228 // a modify/paint call here will repaint the pad; 7229 // before the external viewer window actually closes.; 7230 // So the pad would have to be redraw twice over.; 7231 // Currently we just have to live with the pad staying blank; 7232 // any click in pad will refresh.; 7233}; 7234 ; 7235////////////////////////////////////////////////////////////////////////////////; 7236/// Get GL device.; 7237 ; 7238Int_t TPad::GetGLDevice(); 7239{; 7240 return fGLDevice;; 7241}; 7242 ; 7243////////////////////////////////////////////////////////////////////////////////; 7244/// Emit RecordPave() signal.; 7245 ; 7246",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:286544,Availability,error,error,286544,"is object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadThe most important graphics class in the ROO",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:318893,Availability,down,down,318893,"stogram/graph frame.Definition TPad.cxx:3793; TPad::GetAbsYlowNDCDouble_t GetAbsYlowNDC() const overrideDefinition TPad.h:221; TPad::fUxmaxDouble_t fUxmaxMaximum value on the X axis.Definition TPad.h:76; TPad::AddFirstvoid AddFirst(TObject *obj, Option_t *opt="""", Bool_t modified=kTRUE) overrideAdd an object as first in list of primitives with speicified draw option When.Definition TPad.cxx:439; TPad::fY2Double_t fY2Y of upper Y coordinate.Definition TPad.h:39; TPad::fAbsPixeltoYkDouble_t fAbsPixeltoYkConversion coefficient for absolute pixel to Y World.Definition TPad.h:58; TPad::GetSelectedPadTVirtualPad * GetSelectedPad() const overrideGet selected pad.Definition TPad.cxx:2811; TPad::PaintPolyLine3Dvoid PaintPolyLine3D(Int_t n, Double_t *p) overridePaint 3-D polyline in the CurrentPad.Definition TPad.cxx:4511; TPad::GetPadTVirtualPad * GetPad(Int_t subpadnumber) const overrideGet a pointer to subpadnumber of this pad.Definition TPad.cxx:3000; TPad::fBorderModeShort_t fBorderModeBordermode (-1=down, 0 = no border, 1=up)Definition TPad.h:98; TPad::SetLogxvoid SetLogx(Int_t value=1) overrideSet Lin/Log scale for X.Definition TPad.cxx:6086; TPad::ReleaseViewer3Dvoid ReleaseViewer3D(Option_t *type="""") overrideRelease current (external) viewer.Definition TPad.cxx:7222; TPad::SetCrosshairvoid SetCrosshair(Int_t crhair=1) overrideSet crosshair active/inactive.Definition TPad.cxx:6664; TPad::SetDoubleBuffervoid SetDoubleBuffer(Int_t mode=1) overrideSet double buffer mode ON or OFF.Definition TPad.cxx:2919; TPad::fNextPaletteColorInt_t fNextPaletteColorNext automatic color.Definition TPad.h:117; TPad::SetBBoxCenterXvoid SetBBoxCenterX(const Int_t x) overrideSet X coordinate of the center of the Pad.Definition TPad.cxx:7309; TPad::GetLogxInt_t GetLogx() const overrideDefinition TPad.h:256; TPad::fPadPointerTObject * fPadPointer! free pointerDefinition TPad.h:113; TPad::GetX2Double_t GetX2() const overrideDefinition TPad.h:241; TPad::CreateToolTipTObject * CreateToolTip(const ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:337746,Availability,down,downward,337746,"tion legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17; leglegDefinition legend1.C:34; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x rad",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:338049,Availability,mask,mask,338049,"ory has been deleted.Definition TObject.h:402; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v2@ v2Definition rootcling_impl.cxx:3702",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:73766,Deployability,release,released,73766,";; 2288 ; 2289 gVirtualX->SetLineColor(-1);; 2290 gVirtualX->SetLineWidth(-1);; 2291 ; 2292 if (px != pxorg || py != pyorg) {; 2293 ; 2294 // Get parent corners pixels coordinates; 2295 Int_t parentpx1 = fMother->XtoAbsPixel(parent->GetX1());; 2296 Int_t parentpx2 = fMother->XtoAbsPixel(parent->GetX2());; 2297 Int_t parentpy1 = fMother->YtoAbsPixel(parent->GetY1());; 2298 Int_t parentpy2 = fMother->YtoAbsPixel(parent->GetY2());; 2299 ; 2300 // Get pad new corners pixels coordinates; 2301 Int_t apx1 = XtoAbsPixel(x1); if (apx1 < parentpx1) {apx1 = parentpx1; }; 2302 Int_t apx2 = XtoAbsPixel(x2); if (apx2 > parentpx2) {apx2 = parentpx2; }; 2303 Int_t apy1 = YtoAbsPixel(y1); if (apy1 > parentpy1) {apy1 = parentpy1; }; 2304 Int_t apy2 = YtoAbsPixel(y2); if (apy2 < parentpy2) {apy2 = parentpy2; }; 2305 ; 2306 // Compute new pad positions in the NDC space of parent; 2307 fXlowNDC = Double_t(apx1 - parentpx1)/Double_t(parentpx2 - parentpx1);; 2308 fYlowNDC = Double_t(apy1 - parentpy1)/Double_t(parentpy2 - parentpy1);; 2309 fWNDC = Double_t(apx2 - apx1)/Double_t(parentpx2 - parentpx1);; 2310 fHNDC = Double_t(apy2 - apy1)/Double_t(parentpy2 - parentpy1);; 2311 }; 2312 ; 2313 // Reset pad parameters and recompute conversion coefficients; 2314 ResizePad();; 2315 ; 2316 ; 2317 // emit signal; 2318 RangeChanged();; 2319 }; 2320 ; 2321 break;; 2322 ; 2323 case kButton1Locate:; 2324 ; 2325 ExecuteEvent(kButton1Down, px, py);; 2326 ; 2327 while (true) {; 2328 px = py = 0;; 2329 event = gVirtualX->RequestLocator(1, 1, px, py);; 2330 ; 2331 ExecuteEvent(kButton1Motion, px, py);; 2332 ; 2333 if (event != -1) { // button is released; 2334 ExecuteEvent(kButton1Up, px, py);; 2335 return;; 2336 }; 2337 }; 2338 ; 2339 case kButton2Down:; 2340 ; 2341 Pop();; 2342 break;; 2343 ; 2344 }; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Execute action corresponding to one event for a TAxis object; 2349/// (called by TAxis::ExecuteEvent.",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:74344,Deployability,release,released,74344,"ouble_t(apy2 - apy1)/Double_t(parentpy2 - parentpy1);; 2311 }; 2312 ; 2313 // Reset pad parameters and recompute conversion coefficients; 2314 ResizePad();; 2315 ; 2316 ; 2317 // emit signal; 2318 RangeChanged();; 2319 }; 2320 ; 2321 break;; 2322 ; 2323 case kButton1Locate:; 2324 ; 2325 ExecuteEvent(kButton1Down, px, py);; 2326 ; 2327 while (true) {; 2328 px = py = 0;; 2329 event = gVirtualX->RequestLocator(1, 1, px, py);; 2330 ; 2331 ExecuteEvent(kButton1Motion, px, py);; 2332 ; 2333 if (event != -1) { // button is released; 2334 ExecuteEvent(kButton1Up, px, py);; 2335 return;; 2336 }; 2337 }; 2338 ; 2339 case kButton2Down:; 2340 ; 2341 Pop();; 2342 break;; 2343 ; 2344 }; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Execute action corresponding to one event for a TAxis object; 2349/// (called by TAxis::ExecuteEvent.); 2350/// This member function is called when an axis is clicked with the locator; 2351///; 2352/// The axis range is set between the position where the mouse is pressed; 2353/// and the position where it is released.; 2354///; 2355/// If the mouse position is outside the current axis range when it is released; 2356/// the axis is unzoomed with the corresponding proportions.; 2357///; 2358/// Note that the mouse does not need to be in the pad or even canvas; 2359/// when it is released.; 2360 ; 2361void TPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis *axis); 2362{; 2363 if (!IsEditable()) return;; 2364 if (!axis) return;; 2365 SetCursor(kHand);; 2366 ; 2367 TView *view = GetView();; 2368 static Int_t axisNumber;; 2369 static Double_t ratio1, ratio2;; 2370 static Int_t px1old, py1old, px2old, py2old;; 2371 Int_t nbd, inc, bin1, bin2, first, last;; 2372 Double_t temp, xmin,xmax;; 2373 Bool_t opaque = gPad->OpaqueMoving();; 2374 static std::unique_ptr<TBox> zoombox;; 2375 Double_t zbx1=0,zbx2=0,zby1=0,zby2=0;; 2376 ; 2377 // The CONT4 option, used to paint TH2, is a special case; ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:74439,Deployability,release,released,74439,"l; 2318 RangeChanged();; 2319 }; 2320 ; 2321 break;; 2322 ; 2323 case kButton1Locate:; 2324 ; 2325 ExecuteEvent(kButton1Down, px, py);; 2326 ; 2327 while (true) {; 2328 px = py = 0;; 2329 event = gVirtualX->RequestLocator(1, 1, px, py);; 2330 ; 2331 ExecuteEvent(kButton1Motion, px, py);; 2332 ; 2333 if (event != -1) { // button is released; 2334 ExecuteEvent(kButton1Up, px, py);; 2335 return;; 2336 }; 2337 }; 2338 ; 2339 case kButton2Down:; 2340 ; 2341 Pop();; 2342 break;; 2343 ; 2344 }; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Execute action corresponding to one event for a TAxis object; 2349/// (called by TAxis::ExecuteEvent.); 2350/// This member function is called when an axis is clicked with the locator; 2351///; 2352/// The axis range is set between the position where the mouse is pressed; 2353/// and the position where it is released.; 2354///; 2355/// If the mouse position is outside the current axis range when it is released; 2356/// the axis is unzoomed with the corresponding proportions.; 2357///; 2358/// Note that the mouse does not need to be in the pad or even canvas; 2359/// when it is released.; 2360 ; 2361void TPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis *axis); 2362{; 2363 if (!IsEditable()) return;; 2364 if (!axis) return;; 2365 SetCursor(kHand);; 2366 ; 2367 TView *view = GetView();; 2368 static Int_t axisNumber;; 2369 static Double_t ratio1, ratio2;; 2370 static Int_t px1old, py1old, px2old, py2old;; 2371 Int_t nbd, inc, bin1, bin2, first, last;; 2372 Double_t temp, xmin,xmax;; 2373 Bool_t opaque = gPad->OpaqueMoving();; 2374 static std::unique_ptr<TBox> zoombox;; 2375 Double_t zbx1=0,zbx2=0,zby1=0,zby2=0;; 2376 ; 2377 // The CONT4 option, used to paint TH2, is a special case; it uses a 3D; 2378 // drawing technique to paint a 2D plot.; 2379 TString opt = axis->GetParent()->GetDrawOption();; 2380 opt.ToLower();; 2381 Bool_t kCont4 = kFALSE;; 2382 if (strstr(opt,""",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:74618,Deployability,release,released,74618,"326 ; 2327 while (true) {; 2328 px = py = 0;; 2329 event = gVirtualX->RequestLocator(1, 1, px, py);; 2330 ; 2331 ExecuteEvent(kButton1Motion, px, py);; 2332 ; 2333 if (event != -1) { // button is released; 2334 ExecuteEvent(kButton1Up, px, py);; 2335 return;; 2336 }; 2337 }; 2338 ; 2339 case kButton2Down:; 2340 ; 2341 Pop();; 2342 break;; 2343 ; 2344 }; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Execute action corresponding to one event for a TAxis object; 2349/// (called by TAxis::ExecuteEvent.); 2350/// This member function is called when an axis is clicked with the locator; 2351///; 2352/// The axis range is set between the position where the mouse is pressed; 2353/// and the position where it is released.; 2354///; 2355/// If the mouse position is outside the current axis range when it is released; 2356/// the axis is unzoomed with the corresponding proportions.; 2357///; 2358/// Note that the mouse does not need to be in the pad or even canvas; 2359/// when it is released.; 2360 ; 2361void TPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis *axis); 2362{; 2363 if (!IsEditable()) return;; 2364 if (!axis) return;; 2365 SetCursor(kHand);; 2366 ; 2367 TView *view = GetView();; 2368 static Int_t axisNumber;; 2369 static Double_t ratio1, ratio2;; 2370 static Int_t px1old, py1old, px2old, py2old;; 2371 Int_t nbd, inc, bin1, bin2, first, last;; 2372 Double_t temp, xmin,xmax;; 2373 Bool_t opaque = gPad->OpaqueMoving();; 2374 static std::unique_ptr<TBox> zoombox;; 2375 Double_t zbx1=0,zbx2=0,zby1=0,zby2=0;; 2376 ; 2377 // The CONT4 option, used to paint TH2, is a special case; it uses a 3D; 2378 // drawing technique to paint a 2D plot.; 2379 TString opt = axis->GetParent()->GetDrawOption();; 2380 opt.ToLower();; 2381 Bool_t kCont4 = kFALSE;; 2382 if (strstr(opt,""cont4"")) {; 2383 view = nullptr;; 2384 kCont4 = kTRUE;; 2385 }; 2386 ; 2387 switch (event) {; 2388 ; 2389 case kButton1Down:; 2390 axisNu",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:83213,Deployability,update,update,83213,"!strcmp(axis->GetName(),""yaxis"")) axisNumber = 2;; 2627 if (ratio2 - ratio1 > 0.05) {; 2628 //update object owning this axis; 2629 TH1 *hobj1 = (TH1*)axis->GetParent();; 2630 bin1 = axis->FindFixBin(xmin);; 2631 bin2 = axis->FindFixBin(xmax);; 2632 bin1 = TMath::Max(bin1, 1);; 2633 bin2 = TMath::Min(bin2, axis->GetNbins());; 2634 if (axisNumber == 1) axis->SetRange(bin1,bin2);; 2635 if (axisNumber == 2 && hobj1) {; 2636 if (hobj1->GetDimension() == 1) {; 2637 if (hobj1->GetNormFactor() != 0) {; 2638 Double_t norm = hobj1->GetSumOfWeights()/hobj1->GetNormFactor();; 2639 xmin *= norm;; 2640 xmax *= norm;; 2641 }; 2642 hobj1->SetMinimum(xmin);; 2643 hobj1->SetMaximum(xmax);; 2644 hobj1->SetBit(TH1::kIsZoomed);; 2645 } else {; 2646 axis->SetRange(bin1,bin2);; 2647 }; 2648 }; 2649 //update all histograms in the pad; 2650 TIter next(GetListOfPrimitives());; 2651 TObject *obj;; 2652 while ((obj= next())) {; 2653 if (!obj->InheritsFrom(TH1::Class())) continue;; 2654 TH1 *hobj = (TH1*)obj;; 2655 if (hobj == hobj1) continue;; 2656 bin1 = hobj->GetXaxis()->FindFixBin(xmin);; 2657 bin2 = hobj->GetXaxis()->FindFixBin(xmax);; 2658 if (axisNumber == 1) {; 2659 hobj->GetXaxis()->SetRange(bin1,bin2);; 2660 } else if (axisNumber == 2) {; 2661 if (hobj->GetDimension() == 1) {; 2662 Double_t xxmin = xmin;; 2663 Double_t xxmax = xmax;; 2664 if (hobj->GetNormFactor() != 0) {; 2665 Double_t norm = hobj->GetSumOfWeights()/hobj->GetNormFactor();; 2666 xxmin *= norm;; 2667 xxmax *= norm;; 2668 }; 2669 hobj->SetMinimum(xxmin);; 2670 hobj->SetMaximum(xxmax);; 2671 hobj->SetBit(TH1::kIsZoomed);; 2672 } else {; 2673 bin1 = hobj->GetYaxis()->FindFixBin(xmin);; 2674 bin2 = hobj->GetYaxis()->FindFixBin(xmax);; 2675 hobj->GetYaxis()->SetRange(bin1,bin2);; 2676 }; 2677 }; 2678 }; 2679 Modified(kTRUE);; 2680 }; 2681 }; 2682 if (!opaque) {; 2683 gVirtualX->SetLineColor(-1);; 2684 } else {; 2685 if (zoombox) {; 2686 zoombox.reset();; 2687 gPad->Modified();; 2688 gPad->Update();; 2689 }; 2690 }; 2691 bre",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:83908,Deployability,update,update,83908,"!strcmp(axis->GetName(),""yaxis"")) axisNumber = 2;; 2627 if (ratio2 - ratio1 > 0.05) {; 2628 //update object owning this axis; 2629 TH1 *hobj1 = (TH1*)axis->GetParent();; 2630 bin1 = axis->FindFixBin(xmin);; 2631 bin2 = axis->FindFixBin(xmax);; 2632 bin1 = TMath::Max(bin1, 1);; 2633 bin2 = TMath::Min(bin2, axis->GetNbins());; 2634 if (axisNumber == 1) axis->SetRange(bin1,bin2);; 2635 if (axisNumber == 2 && hobj1) {; 2636 if (hobj1->GetDimension() == 1) {; 2637 if (hobj1->GetNormFactor() != 0) {; 2638 Double_t norm = hobj1->GetSumOfWeights()/hobj1->GetNormFactor();; 2639 xmin *= norm;; 2640 xmax *= norm;; 2641 }; 2642 hobj1->SetMinimum(xmin);; 2643 hobj1->SetMaximum(xmax);; 2644 hobj1->SetBit(TH1::kIsZoomed);; 2645 } else {; 2646 axis->SetRange(bin1,bin2);; 2647 }; 2648 }; 2649 //update all histograms in the pad; 2650 TIter next(GetListOfPrimitives());; 2651 TObject *obj;; 2652 while ((obj= next())) {; 2653 if (!obj->InheritsFrom(TH1::Class())) continue;; 2654 TH1 *hobj = (TH1*)obj;; 2655 if (hobj == hobj1) continue;; 2656 bin1 = hobj->GetXaxis()->FindFixBin(xmin);; 2657 bin2 = hobj->GetXaxis()->FindFixBin(xmax);; 2658 if (axisNumber == 1) {; 2659 hobj->GetXaxis()->SetRange(bin1,bin2);; 2660 } else if (axisNumber == 2) {; 2661 if (hobj->GetDimension() == 1) {; 2662 Double_t xxmin = xmin;; 2663 Double_t xxmax = xmax;; 2664 if (hobj->GetNormFactor() != 0) {; 2665 Double_t norm = hobj->GetSumOfWeights()/hobj->GetNormFactor();; 2666 xxmin *= norm;; 2667 xxmax *= norm;; 2668 }; 2669 hobj->SetMinimum(xxmin);; 2670 hobj->SetMaximum(xxmax);; 2671 hobj->SetBit(TH1::kIsZoomed);; 2672 } else {; 2673 bin1 = hobj->GetYaxis()->FindFixBin(xmin);; 2674 bin2 = hobj->GetYaxis()->FindFixBin(xmax);; 2675 hobj->GetYaxis()->SetRange(bin1,bin2);; 2676 }; 2677 }; 2678 }; 2679 Modified(kTRUE);; 2680 }; 2681 }; 2682 if (!opaque) {; 2683 gVirtualX->SetLineColor(-1);; 2684 } else {; 2685 if (zoombox) {; 2686 zoombox.reset();; 2687 gPad->Modified();; 2688 gPad->Update();; 2689 }; 2690 }; 2691 bre",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:92749,Deployability,update,update,92749," UInt_t wh); 2904{; 2905 if (fCanvas) fCanvas->SetCanvasSize(ww,wh);; 2906}; 2907 ; 2908////////////////////////////////////////////////////////////////////////////////; 2909/// Set cursor type.; 2910 ; 2911void TPad::SetCursor(ECursor cursor); 2912{; 2913 if (fCanvas) fCanvas->SetCursor(cursor);; 2914}; 2915 ; 2916////////////////////////////////////////////////////////////////////////////////; 2917/// Set double buffer mode ON or OFF.; 2918 ; 2919void TPad::SetDoubleBuffer(Int_t mode); 2920{; 2921 if (fCanvas) fCanvas->SetDoubleBuffer(mode);; 2922}; 2923 ; 2924////////////////////////////////////////////////////////////////////////////////; 2925/// Set selected.; 2926 ; 2927void TPad::SetSelected(TObject *obj); 2928{; 2929 if (fCanvas) fCanvas->SetSelected(obj);; 2930}; 2931 ; 2932////////////////////////////////////////////////////////////////////////////////; 2933/// Update pad.; 2934 ; 2935void TPad::Update(); 2936{; 2937 if (fCanvas) fCanvas->Update();; 2938}; 2939 ; 2940////////////////////////////////////////////////////////////////////////////////; 2941/// Asynchronous pad update.; 2942/// In case of web-based canvas triggers update of the canvas on the client side,; 2943/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2944/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2945/// In case of normal canvas just canvas->Update() is performed.; 2946 ; 2947void TPad::UpdateAsync(); 2948{; 2949 if (fCanvas) fCanvas->UpdateAsync();; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Get frame.; 2954 ; 2955TFrame *TPad::GetFrame(); 2956{; 2957 if (!fPrimitives) fPrimitives = new TList;; 2958 TFrame *frame = (TFrame*)GetListOfPrimitives()->FindObject(fFrame);; 2959 if (!frame) frame = (TFrame*)GetListOfPrimitives()->FindObject(""TFrame"");; 2960 fFrame = frame;; 2961 if (!fFrame) {; 2962 if (!frame) fFrame = new TFrame(0,0,1,1);; 2963 In",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:92803,Deployability,update,update,92803,"Set cursor type.; 2910 ; 2911void TPad::SetCursor(ECursor cursor); 2912{; 2913 if (fCanvas) fCanvas->SetCursor(cursor);; 2914}; 2915 ; 2916////////////////////////////////////////////////////////////////////////////////; 2917/// Set double buffer mode ON or OFF.; 2918 ; 2919void TPad::SetDoubleBuffer(Int_t mode); 2920{; 2921 if (fCanvas) fCanvas->SetDoubleBuffer(mode);; 2922}; 2923 ; 2924////////////////////////////////////////////////////////////////////////////////; 2925/// Set selected.; 2926 ; 2927void TPad::SetSelected(TObject *obj); 2928{; 2929 if (fCanvas) fCanvas->SetSelected(obj);; 2930}; 2931 ; 2932////////////////////////////////////////////////////////////////////////////////; 2933/// Update pad.; 2934 ; 2935void TPad::Update(); 2936{; 2937 if (fCanvas) fCanvas->Update();; 2938}; 2939 ; 2940////////////////////////////////////////////////////////////////////////////////; 2941/// Asynchronous pad update.; 2942/// In case of web-based canvas triggers update of the canvas on the client side,; 2943/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2944/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2945/// In case of normal canvas just canvas->Update() is performed.; 2946 ; 2947void TPad::UpdateAsync(); 2948{; 2949 if (fCanvas) fCanvas->UpdateAsync();; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Get frame.; 2954 ; 2955TFrame *TPad::GetFrame(); 2956{; 2957 if (!fPrimitives) fPrimitives = new TList;; 2958 TFrame *frame = (TFrame*)GetListOfPrimitives()->FindObject(fFrame);; 2959 if (!frame) frame = (TFrame*)GetListOfPrimitives()->FindObject(""TFrame"");; 2960 fFrame = frame;; 2961 if (!fFrame) {; 2962 if (!frame) fFrame = new TFrame(0,0,1,1);; 2963 Int_t framecolor = GetFrameFillColor();; 2964 if (!framecolor) framecolor = GetFillColor();; 2965 fFrame->SetFillColor(framecolor);; 2966 fFrame->SetFillStyle(GetFrameFillStyle());",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:92881,Deployability,update,update,92881,"Set cursor type.; 2910 ; 2911void TPad::SetCursor(ECursor cursor); 2912{; 2913 if (fCanvas) fCanvas->SetCursor(cursor);; 2914}; 2915 ; 2916////////////////////////////////////////////////////////////////////////////////; 2917/// Set double buffer mode ON or OFF.; 2918 ; 2919void TPad::SetDoubleBuffer(Int_t mode); 2920{; 2921 if (fCanvas) fCanvas->SetDoubleBuffer(mode);; 2922}; 2923 ; 2924////////////////////////////////////////////////////////////////////////////////; 2925/// Set selected.; 2926 ; 2927void TPad::SetSelected(TObject *obj); 2928{; 2929 if (fCanvas) fCanvas->SetSelected(obj);; 2930}; 2931 ; 2932////////////////////////////////////////////////////////////////////////////////; 2933/// Update pad.; 2934 ; 2935void TPad::Update(); 2936{; 2937 if (fCanvas) fCanvas->Update();; 2938}; 2939 ; 2940////////////////////////////////////////////////////////////////////////////////; 2941/// Asynchronous pad update.; 2942/// In case of web-based canvas triggers update of the canvas on the client side,; 2943/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2944/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2945/// In case of normal canvas just canvas->Update() is performed.; 2946 ; 2947void TPad::UpdateAsync(); 2948{; 2949 if (fCanvas) fCanvas->UpdateAsync();; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Get frame.; 2954 ; 2955TFrame *TPad::GetFrame(); 2956{; 2957 if (!fPrimitives) fPrimitives = new TList;; 2958 TFrame *frame = (TFrame*)GetListOfPrimitives()->FindObject(fFrame);; 2959 if (!frame) frame = (TFrame*)GetListOfPrimitives()->FindObject(""TFrame"");; 2960 fFrame = frame;; 2961 if (!fFrame) {; 2962 if (!frame) fFrame = new TFrame(0,0,1,1);; 2963 Int_t framecolor = GetFrameFillColor();; 2964 if (!framecolor) framecolor = GetFillColor();; 2965 fFrame->SetFillColor(framecolor);; 2966 fFrame->SetFillStyle(GetFrameFillStyle());",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:272118,Deployability,update,update,272118,"rideDefinition TCanvas.h:176; TCanvas::SupportAlphastatic Bool_t SupportAlpha()Static function returning ""true"" if transparency is supported.Definition TCanvas.cxx:2476; TCanvas::GetEventYInt_t GetEventY() const overrideDefinition TCanvas.h:137; TCanvas::IsBatchBool_t IsBatch() const overrideDefinition TCanvas.h:171; TCanvas::GetCanvasPainterTVirtualPadPainter * GetCanvasPainter()Access and (probably) creation of pad painter.Definition TCanvas.cxx:2616; TCanvas::GetHighLightColorColor_t GetHighLightColor() const overrideDefinition TCanvas.h:138; TCanvas::IsGrayscaleBool_t IsGrayscale()Check whether this canvas is to be drawn in grayscale mode.Definition TCanvas.cxx:2567; TCanvas::SaveSourcevoid SaveSource(const char *filename="""", Option_t *option="""")Save primitives in this canvas as a C++ macro file.Definition TCanvas.cxx:1822; TCanvas::HandleInputvirtual void HandleInput(EEventType button, Int_t x, Int_t y)Handle Input Events.Definition TCanvas.cxx:1234; TCanvas::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TCanvas.cxx:2545; TCanvas::GetSelectedTObject * GetSelected() const overrideDefinition TCanvas.h:141; TCanvas::GetEventXInt_t GetEventX() const overrideDefinition TCanvas.h:136; TCanvas::SetCanvasSizevoid SetCanvasSize(UInt_t ww, UInt_t wh) overrideSet Width and Height of canvas to ww and wh respectively.Definition TCanvas.cxx:1975; TCanvas::GetSelectedPadTVirtualPad * GetSelectedPad() const overrideDefinition TCanvas.h:146; TCanvas::SetCursorvoid SetCursor(ECursor cursor) overrideSet cursor.Definition TCanvas.cxx:1989; TCanvas::GetCanvasIDInt_t GetCanvasID() const overrideDefinition TCanvas.h:157; TCanvas::GetWindowWidthUInt_t GetWindowWidth() constDefinition TCanvas.h:161; TCanvas::FeedbackModevoid FeedbackMode(Bool_t set)Turn rubberband feedback mode on or off.Definition TCanvas.cxx:1128; TCanvas::SetClickSelectedvoid SetClickSelected(TObject *obj)Definition TCanvas.h:209; TCanvas::GetPadSaveTVirtualPad * GetPadSave() const override",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:299158,Deployability,update,update,299158,"rtual void DrawCrosshair()Function called to draw a crosshair in the canvas.Definition TPad.cxx:1605; TPad::YtoPadDouble_t YtoPad(Double_t y) const overrideConvert y from Y to pad.Definition TPad.cxx:3572; TPad::RangeChangedvirtual void RangeChanged()Definition TPad.h:316; TPad::fUyminDouble_t fUyminMinimum value on the Y axis.Definition TPad.h:75; TPad::SetPadvoid SetPad(const char *name, const char *title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color=35, Short_t bordersize=5, Short_t bordermode=-1) overrideSet all pad parameters.Definition TPad.cxx:6171; TPad::SetCursorvoid SetCursor(ECursor cursor) overrideSet cursor type.Definition TPad.cxx:2911; TPad::GetCanvasIDInt_t GetCanvasID() const overrideGet canvas identifier.Definition TPad.cxx:2738; TPad::fLogzInt_t fLogz(=0 if Z linear scale, =1 if log scale)Definition TPad.h:93; TPad::fYtoPixelkDouble_t fYtoPixelkConversion coefficient for Y World to pixel.Definition TPad.h:45; TPad::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TPad.cxx:2947; TPad::TPadTPad()Pad default constructor.Definition TPad.cxx:132; TPad::AbsPixeltoXDouble_t AbsPixeltoX(Int_t px) overrideDefinition TPad.h:168; TPad::UseCurrentStylevoid UseCurrentStyle() overrideForce a copy of current style for all objects in pad.Definition TPad.cxx:6927; TPad::GetMaxPickDistancestatic Int_t GetMaxPickDistance()Static function (see also TPad::SetMaxPickDistance)Definition TPad.cxx:2794; TPad::VtoAbsPixelInt_t VtoAbsPixel(Double_t v) const overrideConvert Y NDC to absolute pixel.Definition TPad.cxx:7467; TPad::Rangevoid Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2) overrideSet world coordinate system for the pad.Definition TPad.cxx:5331; TPad::fUtoPixelkDouble_t fUtoPixelkConversion coefficient for U NDC to pixel.Definition TPad.h:49; TPad::fPixeltoXkDouble_t fPixeltoXkConversion coefficient for pixel to X World.Definition TPad.h:56; TPad::IsModifiedBool_t IsModified() const overrideDefinition ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:15093,Energy Efficiency,power,powerful,15093,"ls:; 468/// macros exec1.C and exec2.C.; 469///; 470/// ### Example1 of use of exec1.C; 471///; 472/// ~~~ {.cpp}; 473/// Root > TFile f(""hsimple.root""); 474/// Root > hpx.Draw(); 475/// Root > c1.AddExec(""ex1"","".x exec1.C""); 476/// ~~~; 477///; 478/// At this point you can use the mouse to click on the contour of; 479/// the histogram hpx. When the mouse is clicked, the bin number and its; 480/// contents are printed.; 481///; 482/// ### Example2 of use of exec1.C; 483///; 484/// ~~~ {.cpp}; 485/// Root > TFile f(""hsimple.root""); 486/// Root > hpxpy.Draw(); 487/// Root > c1.AddExec(""ex2"","".x exec2.C""); 488/// ~~~; 489///; 490/// When moving the mouse in the canvas, a second canvas shows the; 491/// projection along X of the bin corresponding to the Y position; 492/// of the mouse. The resulting histogram is fitted with a gaussian.; 493/// A ""dynamic"" line shows the current bin position in Y.; 494/// This more elaborated example can be used as a starting point; 495/// to develop more powerful interactive applications exploiting the C++; 496/// interpreter as a development engine.; 497 ; 498void TPad::AddExec(const char *name, const char *command); 499{; 500 if (!fExecs) fExecs = new TList;; 501 TExec *ex = new TExec(name,command);; 502 fExecs->Add(ex);; 503}; 504 ; 505////////////////////////////////////////////////////////////////////////////////; 506/// Execute the list of Execs when a pad event occurs.; 507 ; 508void TPad::AutoExec(); 509{; 510 if (GetCrosshair()); 511 DrawCrosshair();; 512 ; 513 if (!fExecs); 514 return;; 515 TIter next(fExecs);; 516 while (auto exec = (TExec*)next()); 517 exec->Exec();; 518}; 519 ; 520////////////////////////////////////////////////////////////////////////////////; 521/// Browse pad.; 522 ; 523void TPad::Browse(TBrowser *b); 524{; 525 cd();; 526 if (fPrimitives) fPrimitives->Browse(b);; 527}; 528 ; 529////////////////////////////////////////////////////////////////////////////////; 530/// Build a legend from the graphical object",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:28845,Energy Efficiency,allocate,allocated,28845,"/////////////////; 899/// Compute the endpoint codes for TPad::Clip.; 900 ; 901Int_t TPad::ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); 902{; 903 Int_t code = 0;; 904 if (x < xcl1) code = code | 0x1;; 905 if (x > xcl2) code = code | 0x2;; 906 if (y < ycl1) code = code | 0x4;; 907 if (y > ycl2) code = code | 0x8;; 908 return code;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Clip polygon using the Sutherland-Hodgman algorithm.; 913///; 914/// \param[in] n Number of points in the polygon to; 915/// be clipped; 916/// \param[in] x,y Polygon x[n], y[n] do be clipped vertices; 917/// \param[in] xclipl,yclipb,xclipr,yclipt Clipping boundary; 918/// \param[out] nn Number of points in xc and yc; 919/// \param[out] xc,yc Clipped polygon vertices. The Int_t; 920/// returned by this function is; 921/// the number of points in the clipped; 922/// polygon. These vectors must; 923/// be allocated by the calling function.; 924/// A size of 2*n for each is; 925/// enough.; 926///; 927/// Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; 928/// strategy: It solves a series of simple and identical problems that, when; 929/// combined, solve the overall problem. The simple problem is to clip a polygon; 930/// against a single infinite clip edge. Four clip edges, each defining one boundary; 931/// of the clip rectangle, successively clip a polygon against a clip rectangle.; 932///; 933/// Steps of Sutherland-Hodgman's polygon-clipping algorithm:; 934///; 935/// * Polygons can be clipped against each edge of the window one at a time.; 936/// Windows/edge intersections, if any, are easy to find since the X or Y coordinates; 937/// are already known.; 938/// * Vertices which are kept after clipping against one window edge are saved for; 939/// clipping against the remaining edges.; 940/// * Note that the number of vertices usually changes and will of",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:337667,Energy Efficiency,power,power,337667,", Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17; leglegDefinition legend1.C:34; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definit",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:338397,Energy Efficiency,power,power,338397,"nt(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v1@ v1Definition rootcling_impl.cxx:3701; invvoid inv(rsa_NUMBER *, rsa_NUMBER *, rsa_NUMBER *)Definition rsaaux.cxx:949; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361; Rectangle_t::fXShort_t fXDefinition GuiTypes.h:362; Re",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:23421,Integrability,rout,routine,23421," bit with `mypad->SetBit(TPad::kClearAfterCR)`; 721 ; 722void TPad::Clear(Option_t *option); 723{; 724 if (!IsEditable()) return;; 725 ; 726 R__LOCKGUARD(gROOTMutex);; 727 ; 728 if (!fPadPaint) {; 729 SafeDelete(fView);; 730 if (fPrimitives) fPrimitives->Clear(option);; 731 if (fFrame) {; 732 if (! ROOT::Detail::HasBeenDeleted(fFrame)) delete fFrame;; 733 fFrame = nullptr;; 734 }; 735 }; 736 if (fCanvas) fCanvas->Cleared(this);; 737 ; 738 cd();; 739 ; 740 if (TestBit(kClearAfterCR)) {; 741 // Intentional do not use the return value of getchar,; 742 // we just want to get it and forget it; 743 getchar();; 744 }; 745 ; 746 if (!gPad->IsBatch() && GetPainter()) GetPainter()->ClearDrawable();; 747 if (gVirtualPS && gPad == gPad->GetCanvas()) gVirtualPS->NewPage();; 748 ; 749 PaintBorder(GetFillColor(), kTRUE);; 750 fCrosshairPos = 0;; 751 fNumPaletteColor = 0;; 752 fCollideGrid.clear();; 753 fCGnx = 0;; 754 fCGny = 0;; 755 ResetBit(TGraph::kClipFrame);; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Clipping routine: Cohen Sutherland algorithm.; 760///; 761/// - If Clip ==2 the segment is outside the boundary.; 762/// - If Clip ==1 the segment has one point outside the boundary.; 763/// - If Clip ==0 the segment is inside the boundary.; 764///; 765/// \param[inout] x[],y[] Segment coordinates (2 points); 766/// \param[in] xclipl,yclipb,xclipr,yclipt Clipping boundary; 767 ; 768Int_t TPad::Clip(Float_t *x, Float_t *y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); 769{; 770 const Float_t kP=10000;; 771 Int_t clip = 0;; 772 ; 773 for (Int_t i=0;i<2;i++) {; 774 if (TMath::Abs(xclipl-x[i]) <= TMath::Abs(xclipr-xclipl)/kP) x[i] = xclipl;; 775 if (TMath::Abs(xclipr-x[i]) <= TMath::Abs(xclipr-xclipl)/kP) x[i] = xclipr;; 776 if (TMath::Abs(yclipb-y[i]) <= TMath::Abs(yclipt-yclipb)/kP) y[i] = yclipb;; 777 if (TMath::Abs(yclipt-y[i]) <= TMath::Abs(yclipt-yclipb)/kP) y[i] = yclipt;; 778 }; 779 ; 780 // Comp",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:89777,Integrability,depend,depending,89777,2808////////////////////////////////////////////////////////////////////////////////; 2809/// Get selected pad.; 2810 ; 2811TVirtualPad *TPad::GetSelectedPad() const; 2812{; 2813 if (fCanvas == this) return nullptr;; 2814 return fCanvas ? fCanvas->GetSelectedPad() : nullptr;; 2815}; 2816 ; 2817////////////////////////////////////////////////////////////////////////////////; 2818/// Get save pad.; 2819 ; 2820TVirtualPad *TPad::GetPadSave() const; 2821{; 2822 if (fCanvas == this) return nullptr;; 2823 return fCanvas ? fCanvas->GetPadSave() : nullptr;; 2824}; 2825 ; 2826////////////////////////////////////////////////////////////////////////////////; 2827/// Get Wh.; 2828 ; 2829UInt_t TPad::GetWh() const; 2830{; 2831 return fCanvas ? fCanvas->GetWh() : 0;; 2832}; 2833 ; 2834////////////////////////////////////////////////////////////////////////////////; 2835/// Get Ww.; 2836 ; 2837UInt_t TPad::GetWw() const; 2838{; 2839 return fCanvas ? fCanvas->GetWw() : 0;; 2840}; 2841 ; 2842////////////////////////////////////////////////////////////////////////////////; 2843/// Hide tool tip depending on the event type. Typically tool tips; 2844/// are hidden when event is not a kMouseEnter and not a kMouseMotion; 2845/// event.; 2846 ; 2847void TPad::HideToolTip(Int_t event); 2848{; 2849 if (event != kMouseEnter && event != kMouseMotion && fTip); 2850 gPad->CloseToolTip(fTip);; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// Is pad in batch mode ?; 2855 ; 2856Bool_t TPad::IsBatch() const; 2857{; 2858 return fCanvas ? fCanvas->IsBatch() : kFALSE;; 2859}; 2860 ; 2861////////////////////////////////////////////////////////////////////////////////; 2862/// Is pad retained ?; 2863 ; 2864Bool_t TPad::IsRetained() const; 2865{; 2866 return fCanvas ? fCanvas->IsRetained() : kFALSE;; 2867}; 2868 ; 2869////////////////////////////////////////////////////////////////////////////////; 2870/// Is web ?; 2871Bool_t TPad::IsWeb() const;,MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:115256,Integrability,depend,depending,115256,"ene if we opened it. This must be done after modified; 3634 // flag is cleared, as some viewers will invoke another paint by marking pad modified again; 3635 if (began3DScene) {; 3636 fViewer3D->EndScene();; 3637 }; 3638}; 3639 ; 3640////////////////////////////////////////////////////////////////////////////////; 3641/// Paint the pad border.; 3642/// Draw first a box as a normal filled box; 3643 ; 3644void TPad::PaintBorder(Color_t color, Bool_t tops); 3645{; 3646 if (color >= 0) {; 3647 TAttLine::Modify(); //Change line attributes only if necessary; 3648 TAttFill::Modify(); //Change fill area attributes only if necessary; 3649 ; 3650 //With Cocoa we have a transparency. But we also have; 3651 //pixmaps, and if you just paint a new content over the old one; 3652 //with alpha < 1., you'll be able to see the old content.; 3653 if (!gROOT->IsBatch() && gVirtualX->InheritsFrom(""TGCocoa"") && GetPainter()); 3654 GetPainter()->ClearDrawable();; 3655 ; 3656 PaintBox(fX1,fY1,fX2,fY2);; 3657 }; 3658 if (color < 0) color = -color;; 3659 // then paint 3d frame (depending on bordermode); 3660 if (IsTransparent()) return;; 3661 // Paint a 3D frame around the pad.; 3662 ; 3663 if (fBorderMode == 0) return;; 3664 Int_t bordersize = fBorderSize;; 3665 if (bordersize <= 0) bordersize = 2;; 3666 ; 3667 const Double_t realBsX = bordersize / (GetAbsWNDC() * GetWw()) * (fX2 - fX1);; 3668 const Double_t realBsY = bordersize / (GetAbsHNDC() * GetWh()) * (fY2 - fY1);; 3669 ; 3670 Short_t px1,py1,px2,py2;; 3671 Double_t xl, xt, yl, yt;; 3672 ; 3673 // GetColorDark() and GetColorBright() use GetFillColor(); 3674 Color_t oldcolor = GetFillColor();; 3675 SetFillColor(color);; 3676 TAttFill::Modify();; 3677 Color_t light = 0, dark = 0;; 3678 if (color != 0) {; 3679 light = TColor::GetColorBright(color);; 3680 dark = TColor::GetColorDark(color);; 3681 }; 3682 ; 3683 // Compute real left bottom & top right of the box in pixels; 3684 px1 = XtoPixel(fX1); py1 = YtoPixel(fY1);; 3685 px2 = XtoPixel(f",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:132862,Integrability,rout,routine,132862,"LineWidth();; 4124 lss = GetPainter()->GetLineStyle();; 4125 lcs = GetPainter()->GetLineColor();; 4126 GetPainter()->SetLineStyle(1);; 4127 GetPainter()->SetLineWidth(lw);; 4128 GetPainter()->SetLineColor(GetPainter()->GetFillColor());; 4129 }; 4130 if (gVirtualPS) {; 4131 lws2 = gVirtualPS->GetLineWidth();; 4132 lss2 = gVirtualPS->GetLineStyle();; 4133 lcs2 = gVirtualPS->GetLineColor();; 4134 gVirtualPS->SetLineStyle(1);; 4135 gVirtualPS->SetLineWidth(lw);; 4136 gVirtualPS->SetLineColor(gVirtualPS->GetFillColor());; 4137 }; 4138 ; 4139 // Draw the hatches; 4140 if (ang1[iAng1] != 5.) PaintHatches(dy, ang1[iAng1], nn, xx, yy);; 4141 if (ang2[iAng2] != 5.) PaintHatches(dy, ang2[iAng2], nn, xx, yy);; 4142 ; 4143 // Restore the line attributes; 4144 if (!gPad->IsBatch() && GetPainter()) {; 4145 GetPainter()->SetLineStyle(lss);; 4146 GetPainter()->SetLineWidth(lws);; 4147 GetPainter()->SetLineColor(lcs);; 4148 }; 4149 if (gVirtualPS) {; 4150 gVirtualPS->SetLineStyle(lss2);; 4151 gVirtualPS->SetLineWidth(lws2);; 4152 gVirtualPS->SetLineColor(lcs2);; 4153 }; 4154}; 4155 ; 4156////////////////////////////////////////////////////////////////////////////////; 4157/// This routine draw hatches inclined with the; 4158/// angle ""angle"" and spaced of ""dy"" in normalized device; 4159/// coordinates in the surface defined by n,xx,yy.; 4160 ; 4161void TPad::PaintHatches(Double_t dy, Double_t angle,; 4162 Int_t nn, Double_t *xx, Double_t *yy); 4163{; 4164 Int_t i, i1, i2, nbi, m, inv;; 4165 Double_t ratiox, ratioy, ymin, ymax, yrot, ycur;; 4166 const Double_t angr = TMath::Pi()*(180.-angle)/180.;; 4167 const Double_t epsil = 0.0001;; 4168 const Int_t maxnbi = 100;; 4169 Double_t xli[maxnbi], xlh[2], ylh[2], xt1, xt2, yt1, yt2;; 4170 Double_t ll, x, y, x1, x2, y1, y2, a, b, xi, xip, xin, yi, yip;; 4171 ; 4172 Double_t rwxmin = gPad->GetX1();; 4173 Double_t rwxmax = gPad->GetX2();; 4174 Double_t rwymin = gPad->GetY1();; 4175 Double_t rwymax = gPad->GetY2();; 4176 ratiox = 1./(rwxmax-rwx",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:147742,Integrability,rout,routine,147742,"; 4624 }; 4625}; 4626 ; 4627////////////////////////////////////////////////////////////////////////////////; 4628/// Paint text in CurrentPad NDC coordinates.; 4629 ; 4630void TPad::PaintTextNDC(Double_t u, Double_t v, const wchar_t *text); 4631{; 4632 Modified();; 4633 ; 4634 if (!gPad->IsBatch() && GetPainter()); 4635 GetPainter()->DrawTextNDC(u, v, text, TVirtualPadPainter::kClear);; 4636 ; 4637 if (gVirtualPS) {; 4638 Double_t x = fX1 + u*(fX2 - fX1);; 4639 Double_t y = fY1 + v*(fY2 - fY1);; 4640 gVirtualPS->Text(x, y, text);; 4641 }; 4642}; 4643 ; 4644////////////////////////////////////////////////////////////////////////////////; 4645/// Search for an object at pixel position px,py.; 4646///; 4647/// Check if point is in this pad.; 4648///; 4649/// If yes, check if it is in one of the sub-pads; 4650///; 4651/// If found in the pad, compute closest distance of approach; 4652/// to each primitive.; 4653///; 4654/// If one distance of approach is found to be within the limit Distancemaximum; 4655/// the corresponding primitive is selected and the routine returns.; 4656 ; 4657TPad *TPad::Pick(Int_t px, Int_t py, TObjLink *&pickobj); 4658{; 4659 //the two following statements are necessary under NT (multithreaded); 4660 //when a TCanvas object is being created and a thread calling TPad::Pick; 4661 //before the TPad constructor has completed in the other thread; 4662 if (!gPad) return nullptr; //Andy Haas; 4663 if (!GetListOfPrimitives()) return nullptr; //Andy Haas; 4664 ; 4665 Int_t dist;; 4666 // Search if point is in pad itself; 4667 Double_t x = AbsPixeltoX(px);; 4668 Double_t y = AbsPixeltoY(py);; 4669 if (this != gPad->GetCanvas()) {; 4670 if (!((x >= fX1 && x <= fX2) && (y >= fY1 && y <= fY2))) return nullptr;; 4671 }; 4672 ; 4673 // search for a primitive in this pad or its sub-pads; 4674 static TObjOptLink dummyLink(nullptr,""""); //place holder for when no link available; 4675 ; 4676 TContext ctxt(this, kFALSE); // since no drawing will be done, don't use",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:163728,Integrability,synchroniz,synchronize,163728,");; 5049 return;; 5050 }; 5051 ; 5052 if (!GetCanvas()->IsBatch() && GetPainter()); 5053 GetPainter()->SelectDrawable(GetCanvasID());; 5054 ; 5055 ; 5056 if (!gROOT->IsBatch() && image) {; 5057 if ((gtype == TImage::kGif) && !ContainsTImage(fPrimitives)) {; 5058 Int_t wid = (this == GetCanvas()) ? GetCanvas()->GetCanvasID() : GetPixmapID();; 5059 Color_t hc = gPad->GetCanvas()->GetHighLightColor();; 5060 gPad->GetCanvas()->SetHighLightColor(-1);; 5061 gPad->Modified();; 5062 gPad->Update();; 5063 if (GetPainter()){; 5064 GetPainter()->SelectDrawable(wid);; 5065 GetPainter()->SaveImage(this, psname.Data(), gtype);; 5066 }; 5067 if (!gSystem->AccessPathName(psname.Data())) {; 5068 Info(""Print"", ""GIF file %s has been created"", psname.Data());; 5069 }; 5070 gPad->GetCanvas()->SetHighLightColor(hc);; 5071 return;; 5072 }; 5073 if (gtype != TImage::kUnknown) {; 5074 Color_t hc = gPad->GetCanvas()->GetHighLightColor();; 5075 gPad->GetCanvas()->SetHighLightColor(-1);; 5076 gPad->Modified();; 5077 gPad->Update();; 5078 gVirtualX->Update(1);; 5079 gSystem->Sleep(30); // synchronize; 5080 if (GetPainter()) GetPainter()->SaveImage(this, psname, gtype);; 5081 if (!gSystem->AccessPathName(psname)) {; 5082 Info(""Print"", ""file %s has been created"", psname.Data());; 5083 }; 5084 gPad->GetCanvas()->SetHighLightColor(hc);; 5085 } else {; 5086 Warning(""Print"", ""Unsupported image format %s"", psname.Data());; 5087 }; 5088 return;; 5089 }; 5090 ; 5091 //==============Save pad/canvas as a C++ script==============================; 5092 if (strstr(opt,""cxx"")) {; 5093 GetCanvas()->SaveSource(psname, """");; 5094 return;; 5095 }; 5096 ; 5097 //==============Save pad/canvas as a root file===============================; 5098 if (strstr(opt,""root"")) {; 5099 if (gDirectory) gDirectory->SaveObjectAs(this,psname.Data(),"""");; 5100 return;; 5101 }; 5102 ; 5103 //==============Save pad/canvas as a XML file================================; 5104 if (strstr(opt,""xml"")) {; 5105 // Plugin XML driver; 5106 if ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:185609,Integrability,message,message,185609,"anvas pixels to pad world coordinates; 5693 ; 5694 // Resize all sub-pads; 5695 TObject *obj;; 5696 if (!fPrimitives) fPrimitives = new TList;; 5697 TIter next(GetListOfPrimitives());; 5698 while ((obj = next())) {; 5699 if (obj->InheritsFrom(TPad::Class())); 5700 ((TPad*)obj)->ResizePad(option);; 5701 }; 5702 ; 5703 // Reset all current sizes; 5704 if (gPad->IsBatch()); 5705 fPixmapID = 0;; 5706 else {; 5707 if (GetPainter()){; 5708 GetPainter()->SetLineWidth(-1);; 5709 GetPainter()->SetTextSize(-1);; 5710 }; 5711 // create or re-create off-screen pixmap; 5712 if (fPixmapID) {; 5713 int w = TMath::Abs(XtoPixel(fX2) - XtoPixel(fX1));; 5714 int h = TMath::Abs(YtoPixel(fY2) - YtoPixel(fY1));; 5715 //protection in case of wrong pad parameters.; 5716 //without this protection, the OpenPixmap or ResizePixmap crashes with; 5717 //the message ""Error in <RootX11ErrorHandler>: BadValue (integer parameter out of range for operation)""; 5718 //resulting in a frozen xterm; 5719 if ( !(TMath::Finite(fX1)) || !(TMath::Finite(fX2)); 5720 || !(TMath::Finite(fY1)) || !(TMath::Finite(fY2)); 5721 || (TMath::IsNaN(fX1)) || (TMath::IsNaN(fX2)); 5722 || (TMath::IsNaN(fY1)) || (TMath::IsNaN(fY2))); 5723 Warning(""ResizePad"", ""Inf/NaN propagated to the pad. Check drawn objects."");; 5724 if (w <= 0 || w > 10000) {; 5725 Warning(""ResizePad"", ""%s width changed from %d to %d\n"",GetName(),w,10);; 5726 w = 10;; 5727 }; 5728 if (h <= 0 || h > 10000) {; 5729 Warning(""ResizePad"", ""%s height changed from %d to %d\n"",GetName(),h,10);; 5730 h = 10;; 5731 }; 5732 if (fPixmapID == -1) { // this case is handled via the ctor; 5733 if (GetPainter()) fPixmapID = GetPainter()->CreateDrawable(w, h);; 5734 } else {; 5735 if (gVirtualX) {; 5736 if (gVirtualX->ResizePixmap(fPixmapID, w, h)) {; 5737 Resized();; 5738 Modified(kTRUE);; 5739 }; 5740 }; 5741 }; 5742 }; 5743 }; 5744 if (fView) {; 5745 if (gPad == this) {; 5746 fView->ResizePad();; 5747 } else {; 5748 TContext ctxt(this, kTRUE);; 5749 fView->ResizePad();;",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:239838,Integrability,interface,interface,239838,"e); 7134{; 7135 ::Info(""TPad::x3d()"", ""This function is deprecated. Use %s->GetViewer3D(\""x3d\"") instead"",this->GetName());; 7136 ; 7137 // Default on GetViewer3D is pad - for x3d it was x3d...; 7138 if (!type || !type[0]) {; 7139 type = ""x3d"";; 7140 }; 7141 GetViewer3D(type);; 7142}; 7143 ; 7144////////////////////////////////////////////////////////////////////////////////; 7145/// Create/obtain handle to 3D viewer. Valid types are:; 7146/// - 'pad' - pad drawing via TViewer3DPad; 7147/// any others registered with plugin manager supporting TVirtualViewer3D; 7148/// If an invalid/null type is requested then the current viewer is returned; 7149/// (if any), otherwise a default 'pad' type is returned; 7150 ; 7151TVirtualViewer3D *TPad::GetViewer3D(Option_t *type); 7152{; 7153 Bool_t validType = kFALSE;; 7154 ; 7155 if ((!type || !*type || (strstr(type, ""gl"") && !strstr(type, ""ogl""))) && (!fCanvas || !fCanvas->UseGL())); 7156 type = ""pad"";; 7157 ; 7158 if (type && *type) {; 7159 if (gPluginMgr->FindHandler(""TVirtualViewer3D"", type)); 7160 validType = kTRUE;; 7161 }; 7162 ; 7163 // Invalid/null type requested?; 7164 if (!validType) {; 7165 // Return current viewer if there is one; 7166 if (fViewer3D); 7167 return fViewer3D;; 7168 // otherwise default to the pad; 7169 else; 7170 type = ""pad"";; 7171 }; 7172 ; 7173 // Ensure we can create the new viewer before removing any existing one; 7174 TVirtualViewer3D *newViewer = nullptr;; 7175 ; 7176 Bool_t createdExternal = kFALSE;; 7177 ; 7178 // External viewers need to be created via plugin manager via interface...; 7179 if (!strstr(type,""pad"")) {; 7180 newViewer = TVirtualViewer3D::Viewer3D(this, type);; 7181 ; 7182 if (!newViewer) {; 7183 Warning(""GetViewer3D"", ""Cannot create 3D viewer of type: %s"", type);; 7184 // Return the existing viewer; 7185 return fViewer3D;; 7186 }; 7187 ; 7188 if (strstr(type, ""gl"") && !strstr(type, ""ogl"")) {; 7189 fEmbeddedGL = kTRUE;; 7190 fCopyGLDevice = kTRUE;; 7191 Modified();; 7192 } else {; ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:270074,Integrability,interface,interface,270074,"n numbers.Definition TAxis.cxx:1052; TAxis::GetBinUpEdgevirtual Double_t GetBinUpEdge(Int_t bin) constReturn up edge of bin.Definition TAxis.cxx:528; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBoxCreate a Box.Definition TBox.h:22; TBox::SetY2virtual void SetY2(Double_t y2)Definition TBox.h:65; TBox::Classstatic TClass * Class(); TBox::SetX1virtual void SetX1(Double_t x1)Definition TBox.h:62; TBox::SetX2virtual void SetX2(Double_t x2)Definition TBox.h:63; TBox::SetY1virtual void SetY1(Double_t y1)Definition TBox.h:64; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TButtonA TButton object is a user interface object.Definition TButton.h:18; TButton::Classstatic TClass * Class(); TCanvasImpABC describing GUI independent main window (with menubar, scrollbars and a drawing area).Definition TCanvasImp.h:30; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::GetWindowHeightUInt_t GetWindowHeight() constDefinition TCanvas.h:162; TCanvas::GetClickSelectedTObject * GetClickSelected() constDefinition TCanvas.h:142; TCanvas::ClearPadSavevoid ClearPadSave()Definition TCanvas.h:140; TCanvas::GetClickSelectedPadTVirtualPad * GetClickSelectedPad() constDefinition TCanvas.h:147; TCanvas::SetClickSelectedPadvoid SetClickSelectedPad(TPad *pad)Definition TCanvas.h:211; TCanvas::SetSelectedPadvoid SetSelectedPad(TPad *pad)Definition TCanvas.h:210; TCanvas::SetDoubleBuffervoid SetDoubleBuffer(Int_t mode=1) overrideSet Double Buffer On/Off.Definition TCanvas.cxx:1998; TCanvas::GetCanvasImpTCanvasImp * GetCanvasImp() const overrideDefinition TCanvas.h:158; TCanvas::IsRetainedBool_t Is",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:285893,Integrability,message,message,285893,"ivevirtual Int_t DistancetoPrimitive(Int_t px, Int_t py)Computes distance from point (px,py) to the object.Definition TObject.cxx:271; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtu",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:286550,Integrability,message,message,286550,"is object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadThe most important graphics class in the ROO",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:287461,Integrability,message,message,287461,"TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::GetBorderModeShort_t GetBorderMode() const overrideDefinition TPad.h:199; TPad::OpaqueMovingBool_t OpaqueMoving() const overrideIs pad moving in opaque mode ?Definition TPad.cxx:2879; TPad::PaintTextNDCvoid PaintTextNDC(Double_t u, Double_t v, const char *text) overridePaint text in CurrentPad NDC coordinates.Definition TPad.cxx:4613; TPad::GetTickyInt_t GetTicky() const overrideDefinition TPad.h:239; TPad::Clipvirtual Int_t Clip(Float_t *x, Float_t *y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt)Clipping routine: Cohen Sutherland algorithm.Definition TPad.cxx:768; TPad::HideToolTipvirtual void HideToolTip(Int_t event)Hide tool tip depending on the event type.Definition TPad.cxx:2847; TPad::fAbsYlowNDCDouble_t fAbsYlowNDCAbsolute Y top left corner of pad in NDC [0,1].Definition TPad.h:70; TPad::fXtoAbsPixelkDouble_t fXtoAbsPixelkConversion coe",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:288112,Integrability,rout,routine,288112,"TObject.h:198; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::GetBorderModeShort_t GetBorderMode() const overrideDefinition TPad.h:199; TPad::OpaqueMovingBool_t OpaqueMoving() const overrideIs pad moving in opaque mode ?Definition TPad.cxx:2879; TPad::PaintTextNDCvoid PaintTextNDC(Double_t u, Double_t v, const char *text) overridePaint text in CurrentPad NDC coordinates.Definition TPad.cxx:4613; TPad::GetTickyInt_t GetTicky() const overrideDefinition TPad.h:239; TPad::Clipvirtual Int_t Clip(Float_t *x, Float_t *y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt)Clipping routine: Cohen Sutherland algorithm.Definition TPad.cxx:768; TPad::HideToolTipvirtual void HideToolTip(Int_t event)Hide tool tip depending on the event type.Definition TPad.cxx:2847; TPad::fAbsYlowNDCDouble_t fAbsYlowNDCAbsolute Y top left corner of pad in NDC [0,1].Definition TPad.h:70; TPad::fXtoAbsPixelkDouble_t fXtoAbsPixelkConversion coefficient for X World to absolute pixel.Definition TPad.h:41; TPad::SetAttMarkerPSvoid SetAttMarkerPS(Color_t color, Style_t style, Size_t msize) overrideSet postscript marker attributes.Definition TPad.cxx:6227; TPad::DivideSquarevirtual void DivideSquare(Int_t n, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)""n"" is the total number of sub-pads.Definition TPad.cxx:1341; TPad::AbsCoordinatesvoid AbsCoordinates(Bool_t set) overrideDefinition TPad.h:167; TPad::AbsPixeltoYDouble_t AbsPixeltoY(Int_t py) overrideDefinition TPad.h:169; TPad::Classstatic TClass * Class(); TPad::IsBatchBool_t IsBat",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:288241,Integrability,depend,depending,288241,"a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::GetBorderModeShort_t GetBorderMode() const overrideDefinition TPad.h:199; TPad::OpaqueMovingBool_t OpaqueMoving() const overrideIs pad moving in opaque mode ?Definition TPad.cxx:2879; TPad::PaintTextNDCvoid PaintTextNDC(Double_t u, Double_t v, const char *text) overridePaint text in CurrentPad NDC coordinates.Definition TPad.cxx:4613; TPad::GetTickyInt_t GetTicky() const overrideDefinition TPad.h:239; TPad::Clipvirtual Int_t Clip(Float_t *x, Float_t *y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt)Clipping routine: Cohen Sutherland algorithm.Definition TPad.cxx:768; TPad::HideToolTipvirtual void HideToolTip(Int_t event)Hide tool tip depending on the event type.Definition TPad.cxx:2847; TPad::fAbsYlowNDCDouble_t fAbsYlowNDCAbsolute Y top left corner of pad in NDC [0,1].Definition TPad.h:70; TPad::fXtoAbsPixelkDouble_t fXtoAbsPixelkConversion coefficient for X World to absolute pixel.Definition TPad.h:41; TPad::SetAttMarkerPSvoid SetAttMarkerPS(Color_t color, Style_t style, Size_t msize) overrideSet postscript marker attributes.Definition TPad.cxx:6227; TPad::DivideSquarevirtual void DivideSquare(Int_t n, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)""n"" is the total number of sub-pads.Definition TPad.cxx:1341; TPad::AbsCoordinatesvoid AbsCoordinates(Bool_t set) overrideDefinition TPad.h:167; TPad::AbsPixeltoYDouble_t AbsPixeltoY(Int_t py) overrideDefinition TPad.h:169; TPad::Classstatic TClass * Class(); TPad::IsBatchBool_t IsBatch() const overrideIs pad in batch mode ?Definition TPad.cxx:2856; TPad::GetUymaxDouble_t GetUymax() const overrideReturns the maximum y-coordinate value",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:290652,Integrability,rout,routine,290652,"on TPad.cxx:3118; TPad::VtoPixelInt_t VtoPixel(Double_t v) const overrideConvert Y NDC to pixel.Definition TPad.cxx:7446; TPad::PaintBordervoid PaintBorder(Color_t color, Bool_t tops)Paint the pad border.Definition TPad.cxx:3644; TPad::GetPhiDouble_t GetPhi() const overrideDefinition TPad.h:225; TPad::IsEditableBool_t IsEditable() const overrideDefinition TPad.h:272; TPad::FillCollideGridvoid FillCollideGrid(TObject *o)Initialise the grid used to find empty space when adding a box (Legend) in a pad.Definition TPad.cxx:3134; TPad::SetViewvoid SetView(TView *view=nullptr) overrideSet the current TView. Delete previous view if view=0.Definition TPad.cxx:6195; TPad::GetViewer3DTVirtualViewer3D * GetViewer3D(Option_t *type="""") overrideCreate/obtain handle to 3D viewer.Definition TPad.cxx:7151; TPad::fPixeltoYkDouble_t fPixeltoYkConversion coefficient for pixel to Y World.Definition TPad.h:59; TPad::PaintHatchesvoid PaintHatches(Double_t dy, Double_t angle, Int_t nn, Double_t *xx, Double_t *yy)This routine draw hatches inclined with the angle ""angle"" and spaced of ""dy"" in normalized device coo...Definition TPad.cxx:4161; TPad::PaintLine3Dvoid PaintLine3D(Float_t *p1, Float_t *p2) overridePaint 3-D line in the CurrentPad.Definition TPad.cxx:4356; TPad::fgMaxPickDistancestatic Int_t fgMaxPickDistanceMaximum Pick Distance.Definition TPad.h:115; TPad::ResizePadvoid ResizePad(Option_t *option="""") overrideCompute pad conversion coefficients.Definition TPad.cxx:5624; TPad::PaintPolyMarkervoid PaintPolyMarker(Int_t n, Float_t *x, Float_t *y, Option_t *option="""") overridePaint polymarker in CurrentPad World coordinates.Definition TPad.cxx:4525; TPad::fPhiDouble_t fPhiphi angle to view as lego/surfaceDefinition TPad.h:80; TPad::fPixeltoYDouble_t fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixelDefinition TPad.h:60; TPad::RecordLatexvirtual void RecordLatex(const TObject *obj)Emit RecordLatex() signal.Definition TPad.cxx:7254; TPad::fAbsXlowNDCDouble_t fAbsXlowNDCAbsolute X top left c",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:330246,Integrability,interface,interface,330246,"cessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TTextBase class for several text objects.Definition TText.h:22; TText::Paintvoid Paint(Option_t *option="""") overridePaint this text with its current attributes.Definition TText.cxx:687; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TViewSee TView3D.Definition TView.h:25; TView::WCtoNDCvirtual void WCtoNDC(const Float_t *pw, Float_t *pn)=0; TView::GetDistancetoAxisvirtual Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t &ratio)=0; TView::ResizePadvirtual void ResizePad()=0; TView::GetRangevirtual void GetRange(Float_t *min, Float_t *max)=0; TViewer3DPadProvides 3D viewer interface (TVirtualViewer3D) support on a pad.Definition TViewer3DPad.h:19; TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPS::Textvirtual void Text(Double_t x, Double_t y, const char *string)=0; TVirtualPS::NewPagevirtual void NewPage()=0; TVirtualPS::DrawPSvirtual void DrawPS(Int_t n, Float_t *xw, Float_t *yw)=0; TVirtualPS::DrawBoxvirtual void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2)=0; TVirtualPS::DrawPolyMarkervirtual void DrawPolyMarker(Int_t n, Float_t *x, Float_t *y)=0; TVirtualPS::Openvirtual void Open(const char *filename, Int_t type=-111)=0; TVirtualPS::DrawFramevirtual void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light)=0; TVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:330358,Integrability,interface,interface,330358,"pvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TTextBase class for several text objects.Definition TText.h:22; TText::Paintvoid Paint(Option_t *option="""") overridePaint this text with its current attributes.Definition TText.cxx:687; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TViewSee TView3D.Definition TView.h:25; TView::WCtoNDCvirtual void WCtoNDC(const Float_t *pw, Float_t *pn)=0; TView::GetDistancetoAxisvirtual Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t &ratio)=0; TView::ResizePadvirtual void ResizePad()=0; TView::GetRangevirtual void GetRange(Float_t *min, Float_t *max)=0; TViewer3DPadProvides 3D viewer interface (TVirtualViewer3D) support on a pad.Definition TViewer3DPad.h:19; TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPS::Textvirtual void Text(Double_t x, Double_t y, const char *string)=0; TVirtualPS::NewPagevirtual void NewPage()=0; TVirtualPS::DrawPSvirtual void DrawPS(Int_t n, Float_t *xw, Float_t *yw)=0; TVirtualPS::DrawBoxvirtual void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2)=0; TVirtualPS::DrawPolyMarkervirtual void DrawPolyMarker(Int_t n, Float_t *x, Float_t *y)=0; TVirtualPS::Openvirtual void Open(const char *filename, Int_t type=-111)=0; TVirtualPS::DrawFramevirtual void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light)=0; TVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas.Definition TVirtualPadPainter.h:19; TVirtualPadPainter::DrawBoxvirtual void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, EBoxMode mode)=0; TVirtualPadPainter::ClearDrawablevirtual void ClearDrawable()=0; TVirtualPadPainter::S",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:21229,Modifiability,variab,variable,21229,"5 opt = """";; 656 }; 657 if (leg) {; 658 TContext ctxt(this, kTRUE);; 659 leg->Draw();; 660 } else {; 661 Info(""BuildLegend"", ""No object(s) to build a TLegend."");; 662 }; 663 return leg;; 664}; 665 ; 666////////////////////////////////////////////////////////////////////////////////; 667/// Set Current pad.; 668///; 669/// When a canvas/pad is divided via TPad::Divide, one can directly; 670/// set the current path to one of the subdivisions.; 671/// See TPad::Divide for the convention to number sub-pads.; 672///; 673/// Returns the new current pad, or 0 in case of failure.; 674///; 675/// For example:; 676/// ~~~ {.cpp}; 677/// c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; 678/// ~~~; 679/// To set the current pad to the bottom right pad, do; 680/// ~~~ {.cpp}; 681/// c1.cd(6);; 682/// ~~~; 683/// Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; 684/// to c1 itself.; 685///; 686/// Note2: after a statement like c1.cd(6), the global variable gPad; 687/// points to the current pad. One can use gPad to set attributes; 688/// of the current pad.; 689///; 690/// Note3: One can get a pointer to one of the sub-pads of pad with:; 691/// TPad *subpad = (TPad*)pad->GetPad(subpadnumber);; 692 ; 693TVirtualPad *TPad::cd(Int_t subpadnumber); 694{; 695 if (!subpadnumber) {; 696 gPad = this;; 697 if (!gPad->IsBatch() && GetPainter()) GetPainter()->SelectDrawable(fPixmapID);; 698 if (!fPrimitives) fPrimitives = new TList;; 699 return gPad;; 700 }; 701 ; 702 if (!fPrimitives) fPrimitives = new TList;; 703 TIter next(fPrimitives);; 704 while (auto obj = next()) {; 705 if (obj->InheritsFrom(TPad::Class())) {; 706 Int_t n = ((TPad*)obj)->GetNumber();; 707 if (n == subpadnumber) {; 708 return ((TPad*)obj)->cd();; 709 }; 710 }; 711 }; 712 return nullptr;; 713}; 714 ; 715////////////////////////////////////////////////////////////////////////////////; 716/// Delete all pad primitives.; 717///; 718/// If the bit kClearAfterCR has been set for this pad",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:24581,Modifiability,variab,variable,24581,"79 ; 780 // Compute the first endpoint codes.; 781 Int_t code1 = ClippingCode(x[0],y[0],xclipl,yclipb,xclipr,yclipt);; 782 Int_t code2 = ClippingCode(x[1],y[1],xclipl,yclipb,xclipr,yclipt);; 783 ; 784 Double_t xt=0, yt=0;; 785 Int_t clipped = 0; //this variable could be used in a future version; 786 while(code1 + code2) {; 787 clipped = 1;; 788 ; 789 // The line lies entirely outside the clipping boundary; 790 if (code1&code2) {; 791 clip = 2;; 792 return clip;; 793 }; 794 ; 795 // The line is subdivided into several parts; 796 Int_t ic = code1;; 797 if (ic == 0) ic = code2;; 798 if (ic & 0x1) {; 799 yt = y[0] + (y[1]-y[0])*(xclipl-x[0])/(x[1]-x[0]);; 800 xt = xclipl;; 801 }; 802 if (ic & 0x2) {; 803 yt = y[0] + (y[1]-y[0])*(xclipr-x[0])/(x[1]-x[0]);; 804 xt = xclipr;; 805 }; 806 if (ic & 0x4) {; 807 xt = x[0] + (x[1]-x[0])*(yclipb-y[0])/(y[1]-y[0]);; 808 yt = yclipb;; 809 }; 810 if (ic & 0x8) {; 811 xt = x[0] + (x[1]-x[0])*(yclipt-y[0])/(y[1]-y[0]);; 812 yt = yclipt;; 813 }; 814 if (ic == code1) {; 815 x[0] = xt;; 816 y[0] = yt;; 817 code1 = ClippingCode(xt,yt,xclipl,yclipb,xclipr,yclipt);; 818 } else {; 819 x[1] = xt;; 820 y[1] = yt;; 821 code2 = ClippingCode(xt,yt,xclipl,yclipb,xclipr,yclipt);; 822 }; 823 }; 824 clip = clipped;; 825 return clip;; 826}; 827 ; 828/// @copydoc TPad::Clip(Float_t*,Float_t*,Float_t,Float_t,Float_t,Float_t); 829 ; 830Int_t TPad::Clip(Double_t *x, Double_t *y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); 831{; 832 const Double_t kP = 10000;; 833 Int_t clip = 0;; 834 ; 835 for (Int_t i=0;i<2;i++) {; 836 if (TMath::Abs(xclipl-x[i]) <= TMath::Abs(xclipr-xclipl)/kP) x[i] = xclipl;; 837 if (TMath::Abs(xclipr-x[i]) <= TMath::Abs(xclipr-xclipl)/kP) x[i] = xclipr;; 838 if (TMath::Abs(yclipb-y[i]) <= TMath::Abs(yclipt-yclipb)/kP) y[i] = yclipb;; 839 if (TMath::Abs(yclipt-y[i]) <= TMath::Abs(yclipt-yclipb)/kP) y[i] = yclipt;; 840 }; 841 ; 842 // Compute the first endpoint codes.; 843 Int_t code1 = 0;; 844 if (x[0] < xclipl",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:26751,Modifiability,variab,variable,26751,") <= TMath::Abs(yclipt-yclipb)/kP) y[i] = yclipb;; 839 if (TMath::Abs(yclipt-y[i]) <= TMath::Abs(yclipt-yclipb)/kP) y[i] = yclipt;; 840 }; 841 ; 842 // Compute the first endpoint codes.; 843 Int_t code1 = 0;; 844 if (x[0] < xclipl) code1 = code1 | 0x1;; 845 if (x[0] > xclipr) code1 = code1 | 0x2;; 846 if (y[0] < yclipb) code1 = code1 | 0x4;; 847 if (y[0] > yclipt) code1 = code1 | 0x8;; 848 Int_t code2 = 0;; 849 if (x[1] < xclipl) code2 = code2 | 0x1;; 850 if (x[1] > xclipr) code2 = code2 | 0x2;; 851 if (y[1] < yclipb) code2 = code2 | 0x4;; 852 if (y[1] > yclipt) code2 = code2 | 0x8;; 853 ; 854 Double_t xt=0, yt=0;; 855 Int_t clipped = 0; //this variable could be used in a future version; 856 while(code1 + code2) {; 857 clipped = 1;; 858 ; 859 // The line lies entirely outside the clipping boundary; 860 if (code1&code2) {; 861 clip = 2;; 862 return clip;; 863 }; 864 ; 865 // The line is subdivided into several parts; 866 Int_t ic = code1;; 867 if (ic == 0) ic = code2;; 868 if (ic & 0x1) {; 869 yt = y[0] + (y[1]-y[0])*(xclipl-x[0])/(x[1]-x[0]);; 870 xt = xclipl;; 871 }; 872 if (ic & 0x2) {; 873 yt = y[0] + (y[1]-y[0])*(xclipr-x[0])/(x[1]-x[0]);; 874 xt = xclipr;; 875 }; 876 if (ic & 0x4) {; 877 xt = x[0] + (x[1]-x[0])*(yclipb-y[0])/(y[1]-y[0]);; 878 yt = yclipb;; 879 }; 880 if (ic & 0x8) {; 881 xt = x[0] + (x[1]-x[0])*(yclipt-y[0])/(y[1]-y[0]);; 882 yt = yclipt;; 883 }; 884 if (ic == code1) {; 885 x[0] = xt;; 886 y[0] = yt;; 887 code1 = ClippingCode(xt,yt,xclipl,yclipb,xclipr,yclipt);; 888 } else {; 889 x[1] = xt;; 890 y[1] = yt;; 891 code2 = ClippingCode(xt,yt,xclipl,yclipb,xclipr,yclipt);; 892 }; 893 }; 894 clip = clipped;; 895 return clip;; 896}; 897 ; 898////////////////////////////////////////////////////////////////////////////////; 899/// Compute the endpoint codes for TPad::Clip.; 900 ; 901Int_t TPad::ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); 902{; 903 Int_t code = 0;; 904 if (x < xcl1) code = code | 0x1;;",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:38935,Modifiability,variab,variable,38935,"ny equal divisions (pads).; 1219/// - xmargin is the space along x between pads in percent of canvas.; 1220/// - ymargin is the space along y between pads in percent of canvas.; 1221/// - color is the color of the new pads. If 0, color is the canvas color.; 1222///; 1223/// Pads are automatically named `canvasname_n` where `n` is the division number; 1224/// starting from top left pad.; 1225///; 1226/// Example if canvasname=c1 , nx=2, ny=3:; 1227///; 1228/// \image html gpad_pad3.png; 1229///; 1230/// Once a pad is divided into sub-pads, one can set the current pad; 1231/// to a subpad with a given division number as illustrated above; 1232/// with TPad::cd(subpad_number).; 1233///; 1234/// For example, to set the current pad to c1_4, one can do:; 1235/// ~~~ {.cpp}; 1236/// c1->cd(4); 1237/// ~~~; 1238/// __Note1:__ c1.cd() is equivalent to c1.cd(0) and sets the current pad; 1239/// to c1 itself.; 1240///; 1241/// __Note2:__ after a statement like c1.cd(6), the global variable gPad; 1242/// points to the current pad. One can use gPad to set attributes; 1243/// of the current pad.; 1244///; 1245/// __Note3:__ in case xmargin <=0 and ymargin <= 0, there is no space; 1246/// between pads. The current pad margins are recomputed to; 1247/// optimize the layout.; 1248 ; 1249void TPad::Divide(Int_t nx, Int_t ny, Float_t xmargin, Float_t ymargin, Int_t color); 1250{; 1251 if (!IsEditable()) return;; 1252 ; 1253 if (gThreadXAR) {; 1254 void *arr[7];; 1255 arr[1] = this; arr[2] = (void*)&nx;arr[3] = (void*)& ny;; 1256 arr[4] = (void*)&xmargin; arr[5] = (void *)& ymargin; arr[6] = (void *)&color;; 1257 if ((*gThreadXAR)(""PDCD"", 7, arr, nullptr)) return;; 1258 }; 1259 ; 1260 TContext ctxt(kTRUE);; 1261 ; 1262 cd();; 1263 if (nx <= 0) nx = 1;; 1264 if (ny <= 0) ny = 1;; 1265 Int_t ix, iy;; 1266 Double_t x1, y1, x2, y2, dx, dy;; 1267 TPad *pad;; 1268 TString name, title;; 1269 Int_t n = 0;; 1270 if (color == 0) color = GetFillColor();; 1271 if (xmargin > 0 && ymargin > 0) {; 127",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:43720,Modifiability,inherit,inheritance,43720,"s->GetWindowWidth() > fCanvas->GetWindowHeight()) {; 1349 w = TMath::Ceil(TMath::Sqrt(n));; 1350 h = TMath::Floor(TMath::Sqrt(n));; 1351 if (w*h < n) w++;; 1352 } else {; 1353 h = TMath::Ceil(TMath::Sqrt(n));; 1354 w = TMath::Floor(TMath::Sqrt(n));; 1355 if (w*h < n) h++;; 1356 }; 1357 ; 1358 Divide( w, h, xmargin, ymargin, color);; 1359}; 1360 ; 1361////////////////////////////////////////////////////////////////////////////////; 1362/// Draw Pad in Current pad (re-parent pad if necessary).; 1363 ; 1364void TPad::Draw(Option_t *option); 1365{; 1366 // if no canvas opened yet create a default canvas; 1367 if (!gPad) {; 1368 gROOT->MakeDefCanvas();; 1369 }; 1370 ; 1371 // pad cannot be in itself and it can only be in one other pad at a time; 1372 if (!fPrimitives) fPrimitives = new TList;; 1373 if (gPad != this) {; 1374 if (fMother && !ROOT::Detail::HasBeenDeleted(fMother)); 1375 fMother->Remove(this, kFALSE);; 1376 TPad *oldMother = fMother;; 1377 fCanvas = gPad->GetCanvas();; 1378 //; 1379 fMother = (TPad*)gPad;; 1380 if (oldMother != fMother || fPixmapID == -1) ResizePad();; 1381 }; 1382 ; 1383 if (fCanvas && fCanvas->IsWeb()) {; 1384 Modified();; 1385 fCanvas->UpdateAsync();; 1386 } else {; 1387 Paint();; 1388 }; 1389 ; 1390 if (gPad->IsRetained() && gPad != this && fMother); 1391 fMother->Add(this, option);; 1392}; 1393 ; 1394////////////////////////////////////////////////////////////////////////////////; 1395/// Draw class inheritance tree of the class to which obj belongs.; 1396///; 1397/// If a class B inherits from a class A, description of B is drawn; 1398/// on the right side of description of A.; 1399///; 1400/// Member functions overridden by B are shown in class A with a blue line; 1401/// crossing-out the corresponding member function.; 1402 ; 1403void TPad::DrawClassObject(const TObject *classobj, Option_t *option); 1404{; 1405 if (!classobj) return;; 1406 char dname[256];; 1407 const Int_t kMAXLEVELS = 10;; 1408 TClass *clevel[kMAXLEVELS], *cl, *cll",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:43803,Modifiability,inherit,inherits,43803,"as opened yet create a default canvas; 1367 if (!gPad) {; 1368 gROOT->MakeDefCanvas();; 1369 }; 1370 ; 1371 // pad cannot be in itself and it can only be in one other pad at a time; 1372 if (!fPrimitives) fPrimitives = new TList;; 1373 if (gPad != this) {; 1374 if (fMother && !ROOT::Detail::HasBeenDeleted(fMother)); 1375 fMother->Remove(this, kFALSE);; 1376 TPad *oldMother = fMother;; 1377 fCanvas = gPad->GetCanvas();; 1378 //; 1379 fMother = (TPad*)gPad;; 1380 if (oldMother != fMother || fPixmapID == -1) ResizePad();; 1381 }; 1382 ; 1383 if (fCanvas && fCanvas->IsWeb()) {; 1384 Modified();; 1385 fCanvas->UpdateAsync();; 1386 } else {; 1387 Paint();; 1388 }; 1389 ; 1390 if (gPad->IsRetained() && gPad != this && fMother); 1391 fMother->Add(this, option);; 1392}; 1393 ; 1394////////////////////////////////////////////////////////////////////////////////; 1395/// Draw class inheritance tree of the class to which obj belongs.; 1396///; 1397/// If a class B inherits from a class A, description of B is drawn; 1398/// on the right side of description of A.; 1399///; 1400/// Member functions overridden by B are shown in class A with a blue line; 1401/// crossing-out the corresponding member function.; 1402 ; 1403void TPad::DrawClassObject(const TObject *classobj, Option_t *option); 1404{; 1405 if (!classobj) return;; 1406 char dname[256];; 1407 const Int_t kMAXLEVELS = 10;; 1408 TClass *clevel[kMAXLEVELS], *cl, *cll;; 1409 TBaseClass *base, *cinherit;; 1410 TText *ptext = nullptr;; 1411 TString opt=option;; 1412 Double_t x,y,dy,y1,v1,v2,dv;; 1413 Int_t nd,nf,nc,nkd,nkf,i,j;; 1414 TPaveText *pt;; 1415 Int_t maxlev = 4;; 1416 if (opt.Contains(""2"")) maxlev = 2;; 1417 if (opt.Contains(""3"")) maxlev = 3;; 1418 if (opt.Contains(""5"")) maxlev = 5;; 1419 if (opt.Contains(""6"")) maxlev = 6;; 1420 if (opt.Contains(""7"")) maxlev = 7;; 1421 ; 1422 // Clear and Set Pad range; 1423 Double_t xpad = 20.5;; 1424 Double_t ypad = 27.5;; 1425 Clear();; 1426 Range(0,0,xpad,ypad);; 1427 ; 1428 // Fi",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:49375,Modifiability,inherit,inheritance,49375,".5*dy;; 1539 } else ysep = y1;; 1540 ; 1541 // Draw Member Functions; 1542 Int_t fcount = 0;; 1543 i = 0;; 1544 x = 0.03;; 1545 y = ysep + 0.5*dy;; 1546 TMethod *m;; 1547 TIter nextm(cl->GetListOfMethods());; 1548 while ((m = (TMethod *) nextm())) {; 1549 if (; 1550 !strcmp( m->GetName(), ""Dictionary"" ) ||; 1551 !strcmp( m->GetName(), ""Class_Version"" ) ||; 1552 !strcmp( m->GetName(), ""DeclFileName"" ) ||; 1553 !strcmp( m->GetName(), ""DeclFileLine"" ) ||; 1554 !strcmp( m->GetName(), ""ImplFileName"" ) ||; 1555 !strcmp( m->GetName(), ""ImplFileLine"" ); 1556 ) continue;; 1557 fcount++;; 1558 if (fcount > nf) break;; 1559 if (i >= nkf) { i = 1; y = ysep - 0.5*dy; x += 1/Double_t(nc); }; 1560 else { i++; y -= dy; }; 1561 ; 1562 ptext = pt->AddText(x,(y-v1)/dv,m->GetName());; 1563 // Check if method is overloaded in a derived class; 1564 // If yes, Change the color of the text to blue; 1565 for (j=ilevel-1;j>=0;j--) {; 1566 if (cl == clevel[ilevel]) {; 1567 if (clevel[j]->GetMethodAny((char*)m->GetName())) {; 1568 ptext->SetTextColor(15);; 1569 break;; 1570 }; 1571 }; 1572 }; 1573 }; 1574 ; 1575 // Draw second inheritance classes for this class; 1576 cll = nullptr;; 1577 if (cinherit) {; 1578 cinherit = (TBaseClass*)lbase->After(cinherit);; 1579 if (cinherit) {; 1580 cl = cinherit->GetClassPointer();; 1581 cll = cl;; 1582 v2 = v1 -0.4;; 1583 dy = 0.35;; 1584 }; 1585 }; 1586 } while (cll);; 1587 }; 1588 Update();; 1589}; 1590 ; 1591////////////////////////////////////////////////////////////////////////////////; 1592/// Function called to draw a crosshair in the canvas; 1593///; 1594/// Example:; 1595/// ~~~ {.cpp}; 1596/// Root > TFile f(""hsimple.root"");; 1597/// Root > hpxpy.Draw();; 1598/// Root > c1.SetCrosshair();; 1599/// ~~~; 1600/// When moving the mouse in the canvas, a crosshair is drawn; 1601///; 1602/// - if the canvas fCrosshair = 1 , the crosshair spans the full canvas; 1603/// - if the canvas fCrosshair > 1 , the crosshair spans only the pad; 1604 ; 1605void TPad:",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:53258,Modifiability,variab,variable,53258,"the form ""stringt;stringx;stringy""; 1658/// the pad title is set to stringt, the x axis title to; 1659/// stringx, the y axis title to stringy.; 1660///; 1661/// #### Example:; 1662///; 1663/// Begin_Macro(source); 1664/// {; 1665/// auto c = new TCanvas(""c"",""c"",200,10,500,300);; 1666///; 1667/// const Int_t n = 50;; 1668/// auto g = new TGraph();; 1669/// for (Int_t i=0;i<n;i++) g->SetPoint(i,i*0.1,100*sin(i*0.1+0.2));; 1670///; 1671/// auto frame = c->DrawFrame(0, -110, 2, 110);; 1672/// frame->GetXaxis()->SetTitle(""X axis"");; 1673///; 1674/// g->Draw(""L*"");; 1675/// }; 1676/// End_Macro; 1677 ; 1678TH1F *TPad::DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char *title); 1679{; 1680 if (!IsEditable()); 1681 return nullptr;; 1682 ; 1683 if (this != gPad) {; 1684 Warning(""DrawFrame"", ""Must be called for the current pad only"");; 1685 if (gPad) return gPad->DrawFrame(xmin,ymin,xmax,ymax,title);; 1686 }; 1687 ; 1688 cd();; 1689 ; 1690 TH1F *hframe = (TH1F*)FindObject(""hframe"");; 1691 if (hframe) delete hframe;; 1692 Int_t nbins = 1000;; 1693 //if log scale in X, use variable bin size linear with log(x); 1694 //this gives a better precision when zooming on the axis; 1695 if (fLogx && xmin > 0 && xmax > xmin) {; 1696 Double_t xminl = TMath::Log(xmin);; 1697 Double_t xmaxl = TMath::Log(xmax);; 1698 Double_t dx = (xmaxl-xminl)/nbins;; 1699 std::vector<Double_t> xbins(nbins+1);; 1700 xbins[0] = xmin;; 1701 for (Int_t i=1;i<=nbins;i++) {; 1702 xbins[i] = TMath::Exp(xminl+i*dx);; 1703 }; 1704 hframe = new TH1F(""hframe"",title,nbins,xbins.data());; 1705 } else {; 1706 hframe = new TH1F(""hframe"",title,nbins,xmin,xmax);; 1707 }; 1708 hframe->SetBit(TH1::kNoStats);; 1709 hframe->SetBit(kCanDelete);; 1710 hframe->SetMinimum(ymin);; 1711 hframe->SetMaximum(ymax);; 1712 hframe->GetYaxis()->SetLimits(ymin,ymax);; 1713 hframe->SetDirectory(nullptr);; 1714 hframe->Draw("" "");; 1715 Update();; 1716 cd();; 1717 return hframe;; 1718}; 1719 ; 1720/////////////////",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:152881,Modifiability,inherit,inherited,152881," ; 4785 TListIter next(fMother->GetListOfPrimitives());; 4786 while (auto obj = next()); 4787 if (obj == this) {; 4788 TString opt = next.GetOption();; 4789 fMother->Remove(this, kFALSE); // do not issue modified; 4790 fMother->Add(this, opt.Data());; 4791 return;; 4792 }; 4793}; 4794 ; 4795////////////////////////////////////////////////////////////////////////////////; 4796/// This method is equivalent to `SaveAs(""filename"")`. See TPad::SaveAs for details.; 4797 ; 4798void TPad::Print(const char *filename) const; 4799{; 4800 ((TPad*)this)->SaveAs(filename);; 4801}; 4802 ; 4803////////////////////////////////////////////////////////////////////////////////; 4804/// Auxiliary function. Returns kTRUE if list contains an object inherited; 4805/// from TImage; 4806 ; 4807static Bool_t ContainsTImage(TList *li); 4808{; 4809 TIter next(li);; 4810 ; 4811 while (auto obj = next()) {; 4812 if (obj->InheritsFrom(TImage::Class())) {; 4813 return kTRUE;; 4814 } else if (obj->InheritsFrom(TPad::Class())) {; 4815 if (ContainsTImage(((TPad*)obj)->GetListOfPrimitives())) {; 4816 return kTRUE;; 4817 }; 4818 }; 4819 }; 4820 return kFALSE;; 4821}; 4822 ; 4823////////////////////////////////////////////////////////////////////////////////; 4824/// Save Canvas contents in a file in one of various formats.; 4825///; 4826/// \anchor TPadPrint; 4827/// option can be:; 4828///; 4829/// - `ps`: a Postscript file is produced (default). [See special cases](\ref TPadPrintPS).; 4830/// - `Portrait`: Postscript file is produced (Portrait); 4831/// - `Landscape`: Postscript file is produced (Landscape); 4832/// - `eps`: an Encapsulated Postscript file is produced; 4833/// - `Preview`: an [Encapsulated Postscript file with preview](\ref TPadPrintPreview) is produced.; 4834/// - `pdf`: a PDF file is produced NOTE: TMathText will be converted to TLatex; q.e.d., symbols only available in TMathText will not render properly.; 4835/// - `Title:`: The character string after `Title:` becomes a table; 4836",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:169303,Modifiability,plugin,pluginName,169303,"close = psname.EndsWith("")""); if (cclose) psname[psname.Length()-1] = 0;; 5217 copenb = psname.EndsWith(""[""); if (copenb) psname[psname.Length()-1] = 0;; 5218 ccloseb = psname.EndsWith(""]""); if (ccloseb) psname[psname.Length()-1] = 0;; 5219 }; 5220 gVirtualPS = (TVirtualPS*)gROOT->GetListOfSpecials()->FindObject(psname);; 5221 if (gVirtualPS) mustOpen = mustClose = kFALSE;; 5222 if (copen || copenb) mustClose = kFALSE;; 5223 if (cclose || ccloseb) mustClose = kTRUE;; 5224 ; 5225 Bool_t noScreen = kFALSE;; 5226 if (!GetCanvas()->IsBatch() && GetCanvas()->GetCanvasID() == -1) {; 5227 noScreen = kTRUE;; 5228 GetCanvas()->SetBatch(kTRUE);; 5229 }; 5230 Int_t pstype = 111;; 5231 Double_t xcanvas = GetCanvas()->XtoPixel(GetCanvas()->GetX2());; 5232 Double_t ycanvas = GetCanvas()->YtoPixel(GetCanvas()->GetY1());; 5233 Double_t ratio = ycanvas/xcanvas;; 5234 if (ratio < 1) pstype = 112;; 5235 if (strstr(opt,""Portrait"")) pstype = 111;; 5236 if (strstr(opt,""Landscape"")) pstype = 112;; 5237 if (strstr(opt,""eps"")) pstype = 113;; 5238 if (strstr(opt,""Preview"")) pstype = 113;; 5239 ; 5240 TContext ctxt(this, kTRUE);; 5241 TVirtualPS *psave = gVirtualPS;; 5242 ; 5243 if (!gVirtualPS || mustOpen) {; 5244 ; 5245 const char *pluginName = ""ps""; // Plugin Postscript driver; 5246 if (strstr(opt,""pdf"") || strstr(opt,""Title:"") || strstr(opt,""EmbedFonts"")); 5247 pluginName = ""pdf"";; 5248 else if (image); 5249 pluginName = ""image""; // Plugin TImageDump driver; 5250 ; 5251 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPS"", pluginName)) {; 5252 if (h->LoadPlugin() == -1); 5253 return;; 5254 h->ExecPlugin(0);; 5255 }; 5256 ; 5257 // Create a new Postscript, PDF or image file; 5258 if (gVirtualPS); 5259 gVirtualPS->SetName(psname);; 5260 const Ssiz_t titlePos = opt.Index(""Title:"");; 5261 if (titlePos != kNPOS) {; 5262 if (gVirtualPS); 5263 gVirtualPS->SetTitle(opt.Data()+titlePos+6);; 5264 opt.Replace(titlePos,opt.Length(),""pdf"");; 5265 }; 5266 if (gVirtualPS); 5267 gVirtualPS->O",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:169437,Modifiability,plugin,pluginName,169437,"close = psname.EndsWith("")""); if (cclose) psname[psname.Length()-1] = 0;; 5217 copenb = psname.EndsWith(""[""); if (copenb) psname[psname.Length()-1] = 0;; 5218 ccloseb = psname.EndsWith(""]""); if (ccloseb) psname[psname.Length()-1] = 0;; 5219 }; 5220 gVirtualPS = (TVirtualPS*)gROOT->GetListOfSpecials()->FindObject(psname);; 5221 if (gVirtualPS) mustOpen = mustClose = kFALSE;; 5222 if (copen || copenb) mustClose = kFALSE;; 5223 if (cclose || ccloseb) mustClose = kTRUE;; 5224 ; 5225 Bool_t noScreen = kFALSE;; 5226 if (!GetCanvas()->IsBatch() && GetCanvas()->GetCanvasID() == -1) {; 5227 noScreen = kTRUE;; 5228 GetCanvas()->SetBatch(kTRUE);; 5229 }; 5230 Int_t pstype = 111;; 5231 Double_t xcanvas = GetCanvas()->XtoPixel(GetCanvas()->GetX2());; 5232 Double_t ycanvas = GetCanvas()->YtoPixel(GetCanvas()->GetY1());; 5233 Double_t ratio = ycanvas/xcanvas;; 5234 if (ratio < 1) pstype = 112;; 5235 if (strstr(opt,""Portrait"")) pstype = 111;; 5236 if (strstr(opt,""Landscape"")) pstype = 112;; 5237 if (strstr(opt,""eps"")) pstype = 113;; 5238 if (strstr(opt,""Preview"")) pstype = 113;; 5239 ; 5240 TContext ctxt(this, kTRUE);; 5241 TVirtualPS *psave = gVirtualPS;; 5242 ; 5243 if (!gVirtualPS || mustOpen) {; 5244 ; 5245 const char *pluginName = ""ps""; // Plugin Postscript driver; 5246 if (strstr(opt,""pdf"") || strstr(opt,""Title:"") || strstr(opt,""EmbedFonts"")); 5247 pluginName = ""pdf"";; 5248 else if (image); 5249 pluginName = ""image""; // Plugin TImageDump driver; 5250 ; 5251 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPS"", pluginName)) {; 5252 if (h->LoadPlugin() == -1); 5253 return;; 5254 h->ExecPlugin(0);; 5255 }; 5256 ; 5257 // Create a new Postscript, PDF or image file; 5258 if (gVirtualPS); 5259 gVirtualPS->SetName(psname);; 5260 const Ssiz_t titlePos = opt.Index(""Title:"");; 5261 if (titlePos != kNPOS) {; 5262 if (gVirtualPS); 5263 gVirtualPS->SetTitle(opt.Data()+titlePos+6);; 5264 opt.Replace(titlePos,opt.Length(),""pdf"");; 5265 }; 5266 if (gVirtualPS); 5267 gVirtualPS->O",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:169485,Modifiability,plugin,pluginName,169485,"close = psname.EndsWith("")""); if (cclose) psname[psname.Length()-1] = 0;; 5217 copenb = psname.EndsWith(""[""); if (copenb) psname[psname.Length()-1] = 0;; 5218 ccloseb = psname.EndsWith(""]""); if (ccloseb) psname[psname.Length()-1] = 0;; 5219 }; 5220 gVirtualPS = (TVirtualPS*)gROOT->GetListOfSpecials()->FindObject(psname);; 5221 if (gVirtualPS) mustOpen = mustClose = kFALSE;; 5222 if (copen || copenb) mustClose = kFALSE;; 5223 if (cclose || ccloseb) mustClose = kTRUE;; 5224 ; 5225 Bool_t noScreen = kFALSE;; 5226 if (!GetCanvas()->IsBatch() && GetCanvas()->GetCanvasID() == -1) {; 5227 noScreen = kTRUE;; 5228 GetCanvas()->SetBatch(kTRUE);; 5229 }; 5230 Int_t pstype = 111;; 5231 Double_t xcanvas = GetCanvas()->XtoPixel(GetCanvas()->GetX2());; 5232 Double_t ycanvas = GetCanvas()->YtoPixel(GetCanvas()->GetY1());; 5233 Double_t ratio = ycanvas/xcanvas;; 5234 if (ratio < 1) pstype = 112;; 5235 if (strstr(opt,""Portrait"")) pstype = 111;; 5236 if (strstr(opt,""Landscape"")) pstype = 112;; 5237 if (strstr(opt,""eps"")) pstype = 113;; 5238 if (strstr(opt,""Preview"")) pstype = 113;; 5239 ; 5240 TContext ctxt(this, kTRUE);; 5241 TVirtualPS *psave = gVirtualPS;; 5242 ; 5243 if (!gVirtualPS || mustOpen) {; 5244 ; 5245 const char *pluginName = ""ps""; // Plugin Postscript driver; 5246 if (strstr(opt,""pdf"") || strstr(opt,""Title:"") || strstr(opt,""EmbedFonts"")); 5247 pluginName = ""pdf"";; 5248 else if (image); 5249 pluginName = ""image""; // Plugin TImageDump driver; 5250 ; 5251 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPS"", pluginName)) {; 5252 if (h->LoadPlugin() == -1); 5253 return;; 5254 h->ExecPlugin(0);; 5255 }; 5256 ; 5257 // Create a new Postscript, PDF or image file; 5258 if (gVirtualPS); 5259 gVirtualPS->SetName(psname);; 5260 const Ssiz_t titlePos = opt.Index(""Title:"");; 5261 if (titlePos != kNPOS) {; 5262 if (gVirtualPS); 5263 gVirtualPS->SetTitle(opt.Data()+titlePos+6);; 5264 opt.Replace(titlePos,opt.Length(),""pdf"");; 5265 }; 5266 if (gVirtualPS); 5267 gVirtualPS->O",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:169614,Modifiability,plugin,pluginName,169614,"close = psname.EndsWith("")""); if (cclose) psname[psname.Length()-1] = 0;; 5217 copenb = psname.EndsWith(""[""); if (copenb) psname[psname.Length()-1] = 0;; 5218 ccloseb = psname.EndsWith(""]""); if (ccloseb) psname[psname.Length()-1] = 0;; 5219 }; 5220 gVirtualPS = (TVirtualPS*)gROOT->GetListOfSpecials()->FindObject(psname);; 5221 if (gVirtualPS) mustOpen = mustClose = kFALSE;; 5222 if (copen || copenb) mustClose = kFALSE;; 5223 if (cclose || ccloseb) mustClose = kTRUE;; 5224 ; 5225 Bool_t noScreen = kFALSE;; 5226 if (!GetCanvas()->IsBatch() && GetCanvas()->GetCanvasID() == -1) {; 5227 noScreen = kTRUE;; 5228 GetCanvas()->SetBatch(kTRUE);; 5229 }; 5230 Int_t pstype = 111;; 5231 Double_t xcanvas = GetCanvas()->XtoPixel(GetCanvas()->GetX2());; 5232 Double_t ycanvas = GetCanvas()->YtoPixel(GetCanvas()->GetY1());; 5233 Double_t ratio = ycanvas/xcanvas;; 5234 if (ratio < 1) pstype = 112;; 5235 if (strstr(opt,""Portrait"")) pstype = 111;; 5236 if (strstr(opt,""Landscape"")) pstype = 112;; 5237 if (strstr(opt,""eps"")) pstype = 113;; 5238 if (strstr(opt,""Preview"")) pstype = 113;; 5239 ; 5240 TContext ctxt(this, kTRUE);; 5241 TVirtualPS *psave = gVirtualPS;; 5242 ; 5243 if (!gVirtualPS || mustOpen) {; 5244 ; 5245 const char *pluginName = ""ps""; // Plugin Postscript driver; 5246 if (strstr(opt,""pdf"") || strstr(opt,""Title:"") || strstr(opt,""EmbedFonts"")); 5247 pluginName = ""pdf"";; 5248 else if (image); 5249 pluginName = ""image""; // Plugin TImageDump driver; 5250 ; 5251 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPS"", pluginName)) {; 5252 if (h->LoadPlugin() == -1); 5253 return;; 5254 h->ExecPlugin(0);; 5255 }; 5256 ; 5257 // Create a new Postscript, PDF or image file; 5258 if (gVirtualPS); 5259 gVirtualPS->SetName(psname);; 5260 const Ssiz_t titlePos = opt.Index(""Title:"");; 5261 if (titlePos != kNPOS) {; 5262 if (gVirtualPS); 5263 gVirtualPS->SetTitle(opt.Data()+titlePos+6);; 5264 opt.Replace(titlePos,opt.Length(),""pdf"");; 5265 }; 5266 if (gVirtualPS); 5267 gVirtualPS->O",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:238791,Modifiability,plugin,plugin,238791,"e); 7134{; 7135 ::Info(""TPad::x3d()"", ""This function is deprecated. Use %s->GetViewer3D(\""x3d\"") instead"",this->GetName());; 7136 ; 7137 // Default on GetViewer3D is pad - for x3d it was x3d...; 7138 if (!type || !type[0]) {; 7139 type = ""x3d"";; 7140 }; 7141 GetViewer3D(type);; 7142}; 7143 ; 7144////////////////////////////////////////////////////////////////////////////////; 7145/// Create/obtain handle to 3D viewer. Valid types are:; 7146/// - 'pad' - pad drawing via TViewer3DPad; 7147/// any others registered with plugin manager supporting TVirtualViewer3D; 7148/// If an invalid/null type is requested then the current viewer is returned; 7149/// (if any), otherwise a default 'pad' type is returned; 7150 ; 7151TVirtualViewer3D *TPad::GetViewer3D(Option_t *type); 7152{; 7153 Bool_t validType = kFALSE;; 7154 ; 7155 if ((!type || !*type || (strstr(type, ""gl"") && !strstr(type, ""ogl""))) && (!fCanvas || !fCanvas->UseGL())); 7156 type = ""pad"";; 7157 ; 7158 if (type && *type) {; 7159 if (gPluginMgr->FindHandler(""TVirtualViewer3D"", type)); 7160 validType = kTRUE;; 7161 }; 7162 ; 7163 // Invalid/null type requested?; 7164 if (!validType) {; 7165 // Return current viewer if there is one; 7166 if (fViewer3D); 7167 return fViewer3D;; 7168 // otherwise default to the pad; 7169 else; 7170 type = ""pad"";; 7171 }; 7172 ; 7173 // Ensure we can create the new viewer before removing any existing one; 7174 TVirtualViewer3D *newViewer = nullptr;; 7175 ; 7176 Bool_t createdExternal = kFALSE;; 7177 ; 7178 // External viewers need to be created via plugin manager via interface...; 7179 if (!strstr(type,""pad"")) {; 7180 newViewer = TVirtualViewer3D::Viewer3D(this, type);; 7181 ; 7182 if (!newViewer) {; 7183 Warning(""GetViewer3D"", ""Cannot create 3D viewer of type: %s"", type);; 7184 // Return the existing viewer; 7185 return fViewer3D;; 7186 }; 7187 ; 7188 if (strstr(type, ""gl"") && !strstr(type, ""ogl"")) {; 7189 fEmbeddedGL = kTRUE;; 7190 fCopyGLDevice = kTRUE;; 7191 Modified();; 7192 } else {; ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:239819,Modifiability,plugin,plugin,239819,"e); 7134{; 7135 ::Info(""TPad::x3d()"", ""This function is deprecated. Use %s->GetViewer3D(\""x3d\"") instead"",this->GetName());; 7136 ; 7137 // Default on GetViewer3D is pad - for x3d it was x3d...; 7138 if (!type || !type[0]) {; 7139 type = ""x3d"";; 7140 }; 7141 GetViewer3D(type);; 7142}; 7143 ; 7144////////////////////////////////////////////////////////////////////////////////; 7145/// Create/obtain handle to 3D viewer. Valid types are:; 7146/// - 'pad' - pad drawing via TViewer3DPad; 7147/// any others registered with plugin manager supporting TVirtualViewer3D; 7148/// If an invalid/null type is requested then the current viewer is returned; 7149/// (if any), otherwise a default 'pad' type is returned; 7150 ; 7151TVirtualViewer3D *TPad::GetViewer3D(Option_t *type); 7152{; 7153 Bool_t validType = kFALSE;; 7154 ; 7155 if ((!type || !*type || (strstr(type, ""gl"") && !strstr(type, ""ogl""))) && (!fCanvas || !fCanvas->UseGL())); 7156 type = ""pad"";; 7157 ; 7158 if (type && *type) {; 7159 if (gPluginMgr->FindHandler(""TVirtualViewer3D"", type)); 7160 validType = kTRUE;; 7161 }; 7162 ; 7163 // Invalid/null type requested?; 7164 if (!validType) {; 7165 // Return current viewer if there is one; 7166 if (fViewer3D); 7167 return fViewer3D;; 7168 // otherwise default to the pad; 7169 else; 7170 type = ""pad"";; 7171 }; 7172 ; 7173 // Ensure we can create the new viewer before removing any existing one; 7174 TVirtualViewer3D *newViewer = nullptr;; 7175 ; 7176 Bool_t createdExternal = kFALSE;; 7177 ; 7178 // External viewers need to be created via plugin manager via interface...; 7179 if (!strstr(type,""pad"")) {; 7180 newViewer = TVirtualViewer3D::Viewer3D(this, type);; 7181 ; 7182 if (!newViewer) {; 7183 Warning(""GetViewer3D"", ""Cannot create 3D viewer of type: %s"", type);; 7184 // Return the existing viewer; 7185 return fViewer3D;; 7186 }; 7187 ; 7188 if (strstr(type, ""gl"") && !strstr(type, ""ogl"")) {; 7189 fEmbeddedGL = kTRUE;; 7190 fCopyGLDevice = kTRUE;; 7191 Modified();; 7192 } else {; ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:286396,Modifiability,inherit,inherits,286396,"har * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition T",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:316299,Modifiability,inherit,inheritance,316299,"ble_t fHNDCHeight of pad along Y in Normalized Coordinates (NDC)Definition TPad.h:67; TPad::ShowGuidelinesvoid ShowGuidelines(TObject *object, const Int_t event, const char mode='i', const bool cling=true) overrideShows lines to indicate if a TAttBBox2D object is aligned to the center or to another object,...Definition TPad.cxx:6350; TPad::GetCrosshairInt_t GetCrosshair() constReturn the crosshair type (from the mother canvas) crosshair type = 0 means no crosshair.Definition TPad.cxx:6651; TPad::GetRangeAxisvoid GetRangeAxis(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) overrideReturn pad axis coordinates range.Definition TPad.cxx:3043; TPad::SetBorderModevoid SetBorderMode(Short_t bordermode) overrideDefinition TPad.h:325; TPad::PaintBoxvoid PaintBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Option_t *option="""") overridePaint box in CurrentPad World coordinates.Definition TPad.cxx:3896; TPad::DrawClassObjectvoid DrawClassObject(const TObject *obj, Option_t *option="""") overrideDraw class inheritance tree of the class to which obj belongs.Definition TPad.cxx:1403; TPad::fCGnyInt_t fCGny! Size of the collide grid along yDefinition TPad.h:120; TPad::fXlowNDCDouble_t fXlowNDCX bottom left corner of pad in NDC [0,1].Definition TPad.h:62; TPad::GetPrimitiveTObject * GetPrimitive(const char *name) const overrideGet primitive.Definition TPad.cxx:2983; TPad::fUxminDouble_t fUxminMinimum value on the X axis.Definition TPad.h:74; TPad::GetAbsHNDCDouble_t GetAbsHNDC() const overrideDefinition TPad.h:223; TPad::SetBBoxCentervoid SetBBoxCenter(const TPoint &p) overrideSet center of the Pad.Definition TPad.cxx:7299; TPad::IsWebBool_t IsWeb() const overrideIs web ?Definition TPad.cxx:2871; TPad::SetSelectedvoid SetSelected(TObject *obj) overrideSet selected.Definition TPad.cxx:2927; TPad::GetSelectedTObject * GetSelected() const overrideGet selected.Definition TPad.cxx:2802; TPad::GetRangevoid GetRange(Double_t &x1, Double_t &y1, Double_t &x2, Double_t &y",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:2367,Performance,perform,performed,2367,"ude ""TString.h""; 45#include ""TDataMember.h""; 46#include ""TMethod.h""; 47#include ""TDataType.h""; 48#include ""TFrame.h""; 49#include ""TExec.h""; 50#include ""TDatime.h""; 51#include ""TColor.h""; 52#include ""TCanvas.h""; 53#include ""TPluginManager.h""; 54#include ""TEnv.h""; 55#include ""TImage.h""; 56#include ""TViewer3DPad.h""; 57#include ""TCreatePrimitives.h""; 58#include ""TLegend.h""; 59#include ""TAtt3D.h""; 60#include ""TVirtualPadPainter.h""; 61#include ""strlcpy.h""; 62#include ""snprintf.h""; 63 ; 64#include ""TVirtualMutex.h""; 65 ; 66static Int_t gReadLevel = 0;; 67 ; 68Int_t TPad::fgMaxPickDistance = 5;; 69 ; 70ClassImpQ(TPad); 71 ; 72/** \class TPad; 73\ingroup gpad; 74 ; 75The most important graphics class in the ROOT system.; 76 ; 77A Pad is contained in a Canvas.; 78 ; 79A Pad may contain other pads (unlimited pad hierarchy).; 80 ; 81A pad is a linked list of primitives of any type (graphics objects,; 82histograms, detectors, tracks, etc.).; 83 ; 84Adding a new element into a pad is in general performed by the Draw; 85member function of the object classes.; 86 ; 87It is important to realize that the pad is a linked list of references; 88to the original object.; 89For example, in case of a histogram, the histogram.Draw() operation; 90only stores a reference to the histogram object and not a graphical; 91representation of this histogram.; 92When the mouse is used to change (say the bin content), the bin content; 93of the original histogram is changed.; 94 ; 95The convention used in ROOT is that a Draw operation only adds; 96a reference to the object. The effective drawing is performed; 97when the canvas receives a signal to be painted.; 98 ; 99\image html gpad_pad1.png; 100 ; 101This signal is generally sent when typing carriage return in the; 102command input or when a graphical operation has been performed on one; 103of the pads of this canvas.; 104When a Canvas/Pad is repainted, the member function Paint for all; 105objects in the Pad linked list is invoked.; 106 ; 107\image ht",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:2958,Performance,perform,performed,2958,"assImpQ(TPad); 71 ; 72/** \class TPad; 73\ingroup gpad; 74 ; 75The most important graphics class in the ROOT system.; 76 ; 77A Pad is contained in a Canvas.; 78 ; 79A Pad may contain other pads (unlimited pad hierarchy).; 80 ; 81A pad is a linked list of primitives of any type (graphics objects,; 82histograms, detectors, tracks, etc.).; 83 ; 84Adding a new element into a pad is in general performed by the Draw; 85member function of the object classes.; 86 ; 87It is important to realize that the pad is a linked list of references; 88to the original object.; 89For example, in case of a histogram, the histogram.Draw() operation; 90only stores a reference to the histogram object and not a graphical; 91representation of this histogram.; 92When the mouse is used to change (say the bin content), the bin content; 93of the original histogram is changed.; 94 ; 95The convention used in ROOT is that a Draw operation only adds; 96a reference to the object. The effective drawing is performed; 97when the canvas receives a signal to be painted.; 98 ; 99\image html gpad_pad1.png; 100 ; 101This signal is generally sent when typing carriage return in the; 102command input or when a graphical operation has been performed on one; 103of the pads of this canvas.; 104When a Canvas/Pad is repainted, the member function Paint for all; 105objects in the Pad linked list is invoked.; 106 ; 107\image html gpad_pad2.png; 108 ; 109When the mouse is moved on the Pad, The member function DistancetoPrimitive; 110is called for all the elements in the pad. DistancetoPrimitive returns; 111the distance in pixels to this object.; 112 ; 113When the object is within the distance window, the member function; 114ExecuteEvent is called for this object.; 115 ; 116In ExecuteEvent, move, changes can be performed on the object.; 117 ; 118For examples of DistancetoPrimitive and ExecuteEvent functions,; 119see classes; 120~~~ {.cpp}; 121 TLine::DistancetoPrimitive, TLine::ExecuteEvent; 122 TBox::DistancetoPrimitive, ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:3186,Performance,perform,performed,3186,"Pad may contain other pads (unlimited pad hierarchy).; 80 ; 81A pad is a linked list of primitives of any type (graphics objects,; 82histograms, detectors, tracks, etc.).; 83 ; 84Adding a new element into a pad is in general performed by the Draw; 85member function of the object classes.; 86 ; 87It is important to realize that the pad is a linked list of references; 88to the original object.; 89For example, in case of a histogram, the histogram.Draw() operation; 90only stores a reference to the histogram object and not a graphical; 91representation of this histogram.; 92When the mouse is used to change (say the bin content), the bin content; 93of the original histogram is changed.; 94 ; 95The convention used in ROOT is that a Draw operation only adds; 96a reference to the object. The effective drawing is performed; 97when the canvas receives a signal to be painted.; 98 ; 99\image html gpad_pad1.png; 100 ; 101This signal is generally sent when typing carriage return in the; 102command input or when a graphical operation has been performed on one; 103of the pads of this canvas.; 104When a Canvas/Pad is repainted, the member function Paint for all; 105objects in the Pad linked list is invoked.; 106 ; 107\image html gpad_pad2.png; 108 ; 109When the mouse is moved on the Pad, The member function DistancetoPrimitive; 110is called for all the elements in the pad. DistancetoPrimitive returns; 111the distance in pixels to this object.; 112 ; 113When the object is within the distance window, the member function; 114ExecuteEvent is called for this object.; 115 ; 116In ExecuteEvent, move, changes can be performed on the object.; 117 ; 118For examples of DistancetoPrimitive and ExecuteEvent functions,; 119see classes; 120~~~ {.cpp}; 121 TLine::DistancetoPrimitive, TLine::ExecuteEvent; 122 TBox::DistancetoPrimitive, TBox::ExecuteEvent; 123 TH1::DistancetoPrimitive, TH1::ExecuteEvent; 124~~~; 125A Pad supports linear and log scales coordinate systems.; 126The transformation coeffi",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:3761,Performance,perform,performed,3761,"nge (say the bin content), the bin content; 93of the original histogram is changed.; 94 ; 95The convention used in ROOT is that a Draw operation only adds; 96a reference to the object. The effective drawing is performed; 97when the canvas receives a signal to be painted.; 98 ; 99\image html gpad_pad1.png; 100 ; 101This signal is generally sent when typing carriage return in the; 102command input or when a graphical operation has been performed on one; 103of the pads of this canvas.; 104When a Canvas/Pad is repainted, the member function Paint for all; 105objects in the Pad linked list is invoked.; 106 ; 107\image html gpad_pad2.png; 108 ; 109When the mouse is moved on the Pad, The member function DistancetoPrimitive; 110is called for all the elements in the pad. DistancetoPrimitive returns; 111the distance in pixels to this object.; 112 ; 113When the object is within the distance window, the member function; 114ExecuteEvent is called for this object.; 115 ; 116In ExecuteEvent, move, changes can be performed on the object.; 117 ; 118For examples of DistancetoPrimitive and ExecuteEvent functions,; 119see classes; 120~~~ {.cpp}; 121 TLine::DistancetoPrimitive, TLine::ExecuteEvent; 122 TBox::DistancetoPrimitive, TBox::ExecuteEvent; 123 TH1::DistancetoPrimitive, TH1::ExecuteEvent; 124~~~; 125A Pad supports linear and log scales coordinate systems.; 126The transformation coefficients are explained in TPad::ResizePad.; 127*/; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// Pad default constructor.; 131 ; 132TPad::TPad(); 133{; 134 fModified = kTRUE;; 135 fTip = nullptr;; 136 fPadPointer = nullptr;; 137 fPrimitives = nullptr;; 138 fExecs = nullptr;; 139 fCanvas = nullptr;; 140 fPadPaint = 0;; 141 fPixmapID = -1;; 142 fGLDevice = -1;; 143 fCopyGLDevice = kFALSE;; 144 fEmbeddedGL = kFALSE;; 145 fTheta = 30;; 146 fPhi = 30;; 147 fNumber = 0;; 148 fAbsCoord = kFALSE;; 149 fEditable = kTRUE;; 150 fCrosshair = 0;; 151 fCrosshairPos",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:39208,Performance,optimiz,optimize,39208," canvas color.; 1222///; 1223/// Pads are automatically named `canvasname_n` where `n` is the division number; 1224/// starting from top left pad.; 1225///; 1226/// Example if canvasname=c1 , nx=2, ny=3:; 1227///; 1228/// \image html gpad_pad3.png; 1229///; 1230/// Once a pad is divided into sub-pads, one can set the current pad; 1231/// to a subpad with a given division number as illustrated above; 1232/// with TPad::cd(subpad_number).; 1233///; 1234/// For example, to set the current pad to c1_4, one can do:; 1235/// ~~~ {.cpp}; 1236/// c1->cd(4); 1237/// ~~~; 1238/// __Note1:__ c1.cd() is equivalent to c1.cd(0) and sets the current pad; 1239/// to c1 itself.; 1240///; 1241/// __Note2:__ after a statement like c1.cd(6), the global variable gPad; 1242/// points to the current pad. One can use gPad to set attributes; 1243/// of the current pad.; 1244///; 1245/// __Note3:__ in case xmargin <=0 and ymargin <= 0, there is no space; 1246/// between pads. The current pad margins are recomputed to; 1247/// optimize the layout.; 1248 ; 1249void TPad::Divide(Int_t nx, Int_t ny, Float_t xmargin, Float_t ymargin, Int_t color); 1250{; 1251 if (!IsEditable()) return;; 1252 ; 1253 if (gThreadXAR) {; 1254 void *arr[7];; 1255 arr[1] = this; arr[2] = (void*)&nx;arr[3] = (void*)& ny;; 1256 arr[4] = (void*)&xmargin; arr[5] = (void *)& ymargin; arr[6] = (void *)&color;; 1257 if ((*gThreadXAR)(""PDCD"", 7, arr, nullptr)) return;; 1258 }; 1259 ; 1260 TContext ctxt(kTRUE);; 1261 ; 1262 cd();; 1263 if (nx <= 0) nx = 1;; 1264 if (ny <= 0) ny = 1;; 1265 Int_t ix, iy;; 1266 Double_t x1, y1, x2, y2, dx, dy;; 1267 TPad *pad;; 1268 TString name, title;; 1269 Int_t n = 0;; 1270 if (color == 0) color = GetFillColor();; 1271 if (xmargin > 0 && ymargin > 0) {; 1272 //general case; 1273 dy = 1/Double_t(ny);; 1274 dx = 1/Double_t(nx);; 1275 for (iy=0;iy<ny;iy++) {; 1276 y2 = 1 - iy*dy - ymargin;; 1277 y1 = y2 - dy + 2*ymargin;; 1278 if (y1 < 0) y1 = 0;; 1279 if (y1 > y2) continue;; 1280 for (ix=0;ix<nx",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:93087,Performance,perform,performed,93087,"ouble buffer mode ON or OFF.; 2918 ; 2919void TPad::SetDoubleBuffer(Int_t mode); 2920{; 2921 if (fCanvas) fCanvas->SetDoubleBuffer(mode);; 2922}; 2923 ; 2924////////////////////////////////////////////////////////////////////////////////; 2925/// Set selected.; 2926 ; 2927void TPad::SetSelected(TObject *obj); 2928{; 2929 if (fCanvas) fCanvas->SetSelected(obj);; 2930}; 2931 ; 2932////////////////////////////////////////////////////////////////////////////////; 2933/// Update pad.; 2934 ; 2935void TPad::Update(); 2936{; 2937 if (fCanvas) fCanvas->Update();; 2938}; 2939 ; 2940////////////////////////////////////////////////////////////////////////////////; 2941/// Asynchronous pad update.; 2942/// In case of web-based canvas triggers update of the canvas on the client side,; 2943/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2944/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2945/// In case of normal canvas just canvas->Update() is performed.; 2946 ; 2947void TPad::UpdateAsync(); 2948{; 2949 if (fCanvas) fCanvas->UpdateAsync();; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Get frame.; 2954 ; 2955TFrame *TPad::GetFrame(); 2956{; 2957 if (!fPrimitives) fPrimitives = new TList;; 2958 TFrame *frame = (TFrame*)GetListOfPrimitives()->FindObject(fFrame);; 2959 if (!frame) frame = (TFrame*)GetListOfPrimitives()->FindObject(""TFrame"");; 2960 fFrame = frame;; 2961 if (!fFrame) {; 2962 if (!frame) fFrame = new TFrame(0,0,1,1);; 2963 Int_t framecolor = GetFrameFillColor();; 2964 if (!framecolor) framecolor = GetFillColor();; 2965 fFrame->SetFillColor(framecolor);; 2966 fFrame->SetFillStyle(GetFrameFillStyle());; 2967 fFrame->SetLineColor(GetFrameLineColor());; 2968 fFrame->SetLineStyle(GetFrameLineStyle());; 2969 fFrame->SetLineWidth(GetFrameLineWidth());; 2970 fFrame->SetBorderSize(GetFrameBorderSize());; 2971 fFrame->SetBorderMode(GetFra",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:111409,Performance,perform,performs,111409,"uble_t X1 = fX1;; 3489 Double_t X2 = X1+xs;; 3490 ; 3491 for (int i = 0; i<fCGnx; i++) {; 3492 Y1 = fY1;; 3493 Y2 = Y1+ys;; 3494 for (int j = 0; j<fCGny; j++) {; 3495 if (GetLogx()) {; 3496 X1L = TMath::Power(10,X1);; 3497 X2L = TMath::Power(10,X2);; 3498 } else {; 3499 X1L = X1;; 3500 X2L = X2;; 3501 }; 3502 if (GetLogy()) {; 3503 Y1L = TMath::Power(10,Y1);; 3504 Y2L = TMath::Power(10,Y2);; 3505 } else {; 3506 Y1L = Y1;; 3507 Y2L = Y2;; 3508 }; 3509 if (!fCollideGrid[i + j*fCGnx]) {; 3510 box.SetFillColorAlpha(kBlack,t);; 3511 box.DrawBox(X1L, Y1L, X2L, Y2L);; 3512 } else {; 3513 box.SetFillColorAlpha(kRed,t);; 3514 box.DrawBox(X1L, Y1L, X2L, Y2L);; 3515 }; 3516 Y1 = Y2;; 3517 Y2 = Y1+ys;; 3518 if (t==0.15) t = 0.1;; 3519 else t = 0.15;; 3520 }; 3521 X1 = X2;; 3522 X2 = X1+xs;; 3523 }; 3524}; 3525 ; 3526////////////////////////////////////////////////////////////////////////////////; 3527/// Short cut to call Modified() and Update() in a single call.; 3528/// On Mac with Cocoa, it performs an additional ProcessEvents().; 3529 ; 3530void TPad::ModifiedUpdate(); 3531{; 3532 Modified();; 3533 Update();; 3534#ifdef R__HAS_COCOA; 3535 gSystem->ProcessEvents();; 3536#endif; 3537}; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Convert x from pad to X.; 3541 ; 3542Double_t TPad::PadtoX(Double_t x) const; 3543{; 3544 if (fLogx && x < 50) return Double_t(TMath::Exp(2.302585092994*x));; 3545 return x;; 3546}; 3547 ; 3548////////////////////////////////////////////////////////////////////////////////; 3549/// Convert y from pad to Y.; 3550 ; 3551Double_t TPad::PadtoY(Double_t y) const; 3552{; 3553 if (fLogy && y < 50) return Double_t(TMath::Exp(2.302585092994*y));; 3554 return y;; 3555}; 3556 ; 3557////////////////////////////////////////////////////////////////////////////////; 3558/// Convert x from X to pad.; 3559 ; 3560Double_t TPad::XtoPad(Double_t x) const; 3561{; 3562 if (fLogx) {; 3563 if (x > 0) x = TMath::Log10(x)",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:269469,Performance,load,load,269469,"n low edge of bin.Definition TAxis.cxx:518; TAxis::FindFixBinvirtual Int_t FindFixBin(Double_t x) constFind bin number corresponding to abscissa x.Definition TAxis.cxx:419; TAxis::GetLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::SetLimitsvirtual void SetLimits(Double_t xmin, Double_t xmax)Definition TAxis.h:164; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::GetParentvirtual TObject * GetParent() constDefinition TAxis.h:128; TAxis::SetRangevirtual void SetRange(Int_t first=0, Int_t last=0)Set the viewing range for the axis using bin numbers.Definition TAxis.cxx:1052; TAxis::GetBinUpEdgevirtual Double_t GetBinUpEdge(Int_t bin) constReturn up edge of bin.Definition TAxis.cxx:528; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBoxCreate a Box.Definition TBox.h:22; TBox::SetY2virtual void SetY2(Double_t y2)Definition TBox.h:65; TBox::Classstatic TClass * Class(); TBox::SetX1virtual void SetX1(Double_t x1)Definition TBox.h:62; TBox::SetX2virtual void SetX2(Double_t x2)Definition TBox.h:63; TBox::SetY1virtual void SetY1(Double_t y1)Definition TBox.h:64; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TButtonA TButton object is a user interface object.Definition TButton.h:18; TButton::Classstatic TClass * Class(); TCanvasImpABC describing GUI independent main window (with menubar, scrollbars and a drawing area).Definition TCanvasImp.h:30; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::GetWindowHeightUInt_t GetWindowHeight() constDefinition TCanvas.h:162; TCanvas::GetClickSelectedTObject * GetClickSelecte",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:274259,Performance,load,load,274259,"Emit pad Cleared signal.Definition TCanvas.cxx:770; TCanvas::GetWwUInt_t GetWw() const overrideDefinition TCanvas.h:163; TCanvas::OpaqueMovingBool_t OpaqueMoving() const overrideDefinition TCanvas.h:180; TCanvas::GetWhUInt_t GetWh() const overrideDefinition TCanvas.h:164; TCanvas::Classstatic TClass * Class(); TCanvas::SetSelectedvoid SetSelected(TObject *obj) overrideSet selected canvas.Definition TCanvas.cxx:2146; TCanvas::GetEventInt_t GetEvent() const overrideDefinition TCanvas.h:135; TCanvas::IsWebBool_t IsWeb() const overrideIs web canvas.Definition TCanvas.cxx:1496; TCanvas::SetBatchvoid SetBatch(Bool_t batch=kTRUE) overrideToggle batch mode.Definition TCanvas.cxx:1957; TCanvas::UseGLBool_t UseGL() constDefinition TCanvas.h:228; TCanvas::OpaqueResizingBool_t OpaqueResizing() const overrideDefinition TCanvas.h:181; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3879; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4640; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4621; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TCollection::GetSizevirtual Int_t GetSi",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:274742,Performance,load,load,274742,"TCanvas.h:135; TCanvas::IsWebBool_t IsWeb() const overrideIs web canvas.Definition TCanvas.cxx:1496; TCanvas::SetBatchvoid SetBatch(Bool_t batch=kTRUE) overrideToggle batch mode.Definition TCanvas.cxx:1957; TCanvas::UseGLBool_t UseGL() constDefinition TCanvas.h:228; TCanvas::OpaqueResizingBool_t OpaqueResizing() const overrideDefinition TCanvas.h:181; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3879; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4640; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4621; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TColorThe color creation and management class.Definition TColor.h:21; TColor::SaveColorstatic Bool_t SaveColor(std::ostream &out, Int_t ci)Save a color with index > 228 as a C++ statement(s) on output stream out.Definition TColor.cxx:2543; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",.",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:2287,Safety,detect,detectors,2287,"h""; 40#include ""TPaveStats.h""; 41#include ""TGroupButton.h""; 42#include ""TBrowser.h""; 43#include ""TVirtualGL.h""; 44#include ""TString.h""; 45#include ""TDataMember.h""; 46#include ""TMethod.h""; 47#include ""TDataType.h""; 48#include ""TFrame.h""; 49#include ""TExec.h""; 50#include ""TDatime.h""; 51#include ""TColor.h""; 52#include ""TCanvas.h""; 53#include ""TPluginManager.h""; 54#include ""TEnv.h""; 55#include ""TImage.h""; 56#include ""TViewer3DPad.h""; 57#include ""TCreatePrimitives.h""; 58#include ""TLegend.h""; 59#include ""TAtt3D.h""; 60#include ""TVirtualPadPainter.h""; 61#include ""strlcpy.h""; 62#include ""snprintf.h""; 63 ; 64#include ""TVirtualMutex.h""; 65 ; 66static Int_t gReadLevel = 0;; 67 ; 68Int_t TPad::fgMaxPickDistance = 5;; 69 ; 70ClassImpQ(TPad); 71 ; 72/** \class TPad; 73\ingroup gpad; 74 ; 75The most important graphics class in the ROOT system.; 76 ; 77A Pad is contained in a Canvas.; 78 ; 79A Pad may contain other pads (unlimited pad hierarchy).; 80 ; 81A pad is a linked list of primitives of any type (graphics objects,; 82histograms, detectors, tracks, etc.).; 83 ; 84Adding a new element into a pad is in general performed by the Draw; 85member function of the object classes.; 86 ; 87It is important to realize that the pad is a linked list of references; 88to the original object.; 89For example, in case of a histogram, the histogram.Draw() operation; 90only stores a reference to the histogram object and not a graphical; 91representation of this histogram.; 92When the mouse is used to change (say the bin content), the bin content; 93of the original histogram is changed.; 94 ; 95The convention used in ROOT is that a Draw operation only adds; 96a reference to the object. The effective drawing is performed; 97when the canvas receives a signal to be painted.; 98 ; 99\image html gpad_pad1.png; 100 ; 101This signal is generally sent when typing carriage return in the; 102command input or when a graphical operation has been performed on one; 103of the pads of this canvas.; 104When a Canvas/",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:11473,Safety,avoid,avoid,11473,") {; 351 Error(""TPad"", ""illegal height: %f"", yup-ylow);; 352 zombie = kTRUE;; 353 }; 354 ; 355 if (zombie) {; 356 // error in creating pad occurred, make this pad a zombie; 357 MakeZombie();; 358 return;; 359 }; 360 ; 361 ; 362 fLogx = gStyle->GetOptLogx();; 363 fLogy = gStyle->GetOptLogy();; 364 fLogz = gStyle->GetOptLogz();; 365 ; 366 fUxmin = fUymin = fUxmax = fUymax = 0;; 367 ; 368 // Set pad parameters and Compute conversion coefficients; 369 SetPad(name, title, xlow, ylow, xup, yup, color, bordersize, bordermode);; 370 Range(0, 0, 1, 1);; 371 SetBit(kMustCleanup);; 372 SetBit(kCanDelete);; 373}; 374 ; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Pad destructor.; 378 ; 379TPad::~TPad(); 380{; 381 if (ROOT::Detail::HasBeenDeleted(this)) return;; 382 Close();; 383 CloseToolTip(fTip);; 384 DeleteToolTip(fTip);; 385 auto primitives = fPrimitives;; 386 // In some cases, fPrimitives has the kMustCleanup bit set which will lead; 387 // its destructor to call RecursiveRemove and since this pad is still; 388 // likely to be (indirectly) in the list of cleanups, we must set; 389 // fPrimitives to nullptr to avoid TPad::RecursiveRemove from calling; 390 // a member function of a partially destructed object.; 391 fPrimitives = nullptr;; 392 delete primitives;; 393 SafeDelete(fExecs);; 394 delete fViewer3D;; 395 ; 396 // Required since we overload TObject::Hash.; 397 ROOT::CallRecursiveRemoveIfNeeded(*this);; 398 if (this == gPad); 399 gPad = nullptr;; 400}; 401 ; 402////////////////////////////////////////////////////////////////////////////////; 403/// Add an object to list of primitives with speicified draw option; 404/// When \par modified set to kTRUE (default) pad will be marked as modified; 405/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 406///; 407/// ~~~{.cpp}; 408/// auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; 409/// c1->Divide(2,2);; 410///; 411/// for (Int_t n ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:12083,Safety,avoid,avoid,12083,"/////////////////////////////////////////////////////////////////; 377/// Pad destructor.; 378 ; 379TPad::~TPad(); 380{; 381 if (ROOT::Detail::HasBeenDeleted(this)) return;; 382 Close();; 383 CloseToolTip(fTip);; 384 DeleteToolTip(fTip);; 385 auto primitives = fPrimitives;; 386 // In some cases, fPrimitives has the kMustCleanup bit set which will lead; 387 // its destructor to call RecursiveRemove and since this pad is still; 388 // likely to be (indirectly) in the list of cleanups, we must set; 389 // fPrimitives to nullptr to avoid TPad::RecursiveRemove from calling; 390 // a member function of a partially destructed object.; 391 fPrimitives = nullptr;; 392 delete primitives;; 393 SafeDelete(fExecs);; 394 delete fViewer3D;; 395 ; 396 // Required since we overload TObject::Hash.; 397 ROOT::CallRecursiveRemoveIfNeeded(*this);; 398 if (this == gPad); 399 gPad = nullptr;; 400}; 401 ; 402////////////////////////////////////////////////////////////////////////////////; 403/// Add an object to list of primitives with speicified draw option; 404/// When \par modified set to kTRUE (default) pad will be marked as modified; 405/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 406///; 407/// ~~~{.cpp}; 408/// auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; 409/// c1->Divide(2,2);; 410///; 411/// for (Int_t n = 1; n <= 4; ++n) {; 412/// auto h1 = new TH1I(TString::Format(""hist_%d"",n), ""Random hist"", 100, -5, 5);; 413/// h1->FillRandom(""gaus"", 2000 + n*1000);; 414/// c1->GetPad(n)->Add(h1);; 415/// }; 416/// ~~~; 417 ; 418void TPad::Add(TObject *obj, Option_t *opt, Bool_t modified); 419{; 420 if (!obj); 421 return;; 422 ; 423 if (!fPrimitives); 424 fPrimitives = new TList;; 425 ; 426 obj->SetBit(kMustCleanup);; 427 ; 428 fPrimitives->Add(obj, opt);; 429 ; 430 if (modified); 431 Modified();; 432}; 433 ; 434////////////////////////////////////////////////////////////////////////////////; 435/// Add an object as first in list of primitives ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:13061,Safety,avoid,avoid,13061,"; 394 delete fViewer3D;; 395 ; 396 // Required since we overload TObject::Hash.; 397 ROOT::CallRecursiveRemoveIfNeeded(*this);; 398 if (this == gPad); 399 gPad = nullptr;; 400}; 401 ; 402////////////////////////////////////////////////////////////////////////////////; 403/// Add an object to list of primitives with speicified draw option; 404/// When \par modified set to kTRUE (default) pad will be marked as modified; 405/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 406///; 407/// ~~~{.cpp}; 408/// auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; 409/// c1->Divide(2,2);; 410///; 411/// for (Int_t n = 1; n <= 4; ++n) {; 412/// auto h1 = new TH1I(TString::Format(""hist_%d"",n), ""Random hist"", 100, -5, 5);; 413/// h1->FillRandom(""gaus"", 2000 + n*1000);; 414/// c1->GetPad(n)->Add(h1);; 415/// }; 416/// ~~~; 417 ; 418void TPad::Add(TObject *obj, Option_t *opt, Bool_t modified); 419{; 420 if (!obj); 421 return;; 422 ; 423 if (!fPrimitives); 424 fPrimitives = new TList;; 425 ; 426 obj->SetBit(kMustCleanup);; 427 ; 428 fPrimitives->Add(obj, opt);; 429 ; 430 if (modified); 431 Modified();; 432}; 433 ; 434////////////////////////////////////////////////////////////////////////////////; 435/// Add an object as first in list of primitives with speicified draw option; 436/// When \par modified set to kTRUE (default) pad will be marked as modified; 437/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 438 ; 439void TPad::AddFirst(TObject *obj, Option_t *opt, Bool_t modified); 440{; 441 if (!obj); 442 return;; 443 ; 444 if (!fPrimitives); 445 fPrimitives = new TList;; 446 ; 447 obj->SetBit(kMustCleanup);; 448 ; 449 fPrimitives->AddFirst(obj, opt);; 450 ; 451 if (modified); 452 Modified();; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Add a new TExec object to the list of Execs.; 457///; 458/// When an event occurs in the pad (mouse click, etc) the list of",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:16928,Safety,avoid,avoid,16928,"wser *b); 524{; 525 cd();; 526 if (fPrimitives) fPrimitives->Browse(b);; 527}; 528 ; 529////////////////////////////////////////////////////////////////////////////////; 530/// Build a legend from the graphical objects in the pad.; 531///; 532/// A simple method to build automatically a TLegend from the primitives in a TPad.; 533///; 534/// Only those deriving from TAttLine, TAttMarker and TAttFill are added, excluding; 535/// TPave and TFrame derived classes.; 536///; 537/// \return The built TLegend; 538///; 539/// \param[in] x1, y1, x2, y2 The TLegend coordinates; 540/// \param[in] title The legend title. By default it is "" ""; 541/// \param[in] option The TLegend option; 542///; 543/// The caller program owns the returned TLegend.; 544///; 545/// If the pad contains some TMultiGraph or THStack the individual; 546/// graphs or histograms in them are added to the TLegend.; 547///; 548/// ### Automatic placement of the legend; 549/// If `x1` is equal to `x2` and `y1` is equal to `y2` the legend will be automatically; 550/// placed to avoid overlapping with the existing primitives already displayed.; 551/// `x1` is considered as the width of the legend and `y1` the height. By default; 552/// the legend is automatically placed with width = `x1`= `x2` = 0.3 and; 553/// height = `y1`= `y2` = 0.21.; 554 ; 555TLegend *TPad::BuildLegend(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; 556 const char* title, Option_t *option); 557{; 558 TList *lop = GetListOfPrimitives();; 559 if (!lop) return nullptr;; 560 TList *lof = nullptr;; 561 TLegend *leg = nullptr;; 562 TObject *obj = nullptr;; 563 TIter next(lop);; 564 TString mes;; 565 TString opt;; 566 ; 567 auto AddEntryFromListOfFunctions = [&]() {; 568 TIter nextobj(lof);; 569 while ((obj = nextobj())) {; 570 if (obj->InheritsFrom(TNamed::Class())) {; 571 if (strlen(obj->GetTitle())); 572 mes = obj->GetTitle();; 573 else; 574 mes = obj->GetName();; 575 } else {; 576 mes = obj->ClassName();; 577 }; 578 leg->AddEntry(obj, m",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:93002,Safety,avoid,avoid,93002,"//////////////////////////////////////////////////////////////////; 2917/// Set double buffer mode ON or OFF.; 2918 ; 2919void TPad::SetDoubleBuffer(Int_t mode); 2920{; 2921 if (fCanvas) fCanvas->SetDoubleBuffer(mode);; 2922}; 2923 ; 2924////////////////////////////////////////////////////////////////////////////////; 2925/// Set selected.; 2926 ; 2927void TPad::SetSelected(TObject *obj); 2928{; 2929 if (fCanvas) fCanvas->SetSelected(obj);; 2930}; 2931 ; 2932////////////////////////////////////////////////////////////////////////////////; 2933/// Update pad.; 2934 ; 2935void TPad::Update(); 2936{; 2937 if (fCanvas) fCanvas->Update();; 2938}; 2939 ; 2940////////////////////////////////////////////////////////////////////////////////; 2941/// Asynchronous pad update.; 2942/// In case of web-based canvas triggers update of the canvas on the client side,; 2943/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2944/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2945/// In case of normal canvas just canvas->Update() is performed.; 2946 ; 2947void TPad::UpdateAsync(); 2948{; 2949 if (fCanvas) fCanvas->UpdateAsync();; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Get frame.; 2954 ; 2955TFrame *TPad::GetFrame(); 2956{; 2957 if (!fPrimitives) fPrimitives = new TList;; 2958 TFrame *frame = (TFrame*)GetListOfPrimitives()->FindObject(fFrame);; 2959 if (!frame) frame = (TFrame*)GetListOfPrimitives()->FindObject(""TFrame"");; 2960 fFrame = frame;; 2961 if (!fFrame) {; 2962 if (!frame) fFrame = new TFrame(0,0,1,1);; 2963 Int_t framecolor = GetFrameFillColor();; 2964 if (!framecolor) framecolor = GetFillColor();; 2965 fFrame->SetFillColor(framecolor);; 2966 fFrame->SetFillStyle(GetFrameFillStyle());; 2967 fFrame->SetLineColor(GetFrameLineColor());; 2968 fFrame->SetLineStyle(GetFrameLineStyle());; 2969 fFrame->SetLineWidth(GetFrameLineWidth());; 297",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:158757,Safety,detect,detect,158757,"th ""("", the file is closed.; 4919///; 4920/// Example:; 4921/// ~~~ {.cpp}; 4922/// {; 4923/// TCanvas c1(""c1"");; 4924/// h1.Draw();; 4925/// c1.Print(""c1.ps(""); //write canvas and keep the ps file open; 4926/// h2.Draw();; 4927/// c1.Print(""c1.ps""); canvas is added to ""c1.ps""; 4928/// h3.Draw();; 4929/// c1.Print(""c1.ps)""); canvas is added to ""c1.ps"" and ps file is closed; 4930/// }; 4931/// ~~~; 4932/// In the previous example replacing ""ps"" by ""pdf"" will create a multi-pages PDF file.; 4933///; 4934/// Note that the following sequence writes the canvas to ""c1.ps"" and closes the ps file.:; 4935/// ~~~ {.cpp}; 4936/// TCanvas c1(""c1"");; 4937/// h1.Draw();; 4938/// c1.Print(""c1.ps"");; 4939/// ~~~; 4940/// The `TCanvas::Print(""file.ps("")` mechanism is very useful, but it can be; 4941/// a little inconvenient to have the action of opening/closing a file; 4942/// being atomic with printing a page. Particularly if pages are being; 4943/// generated in some loop one needs to detect the special cases of first; 4944/// and last page and then munge the argument to Print() accordingly.; 4945///; 4946/// The ""["" and ""]"" can be used instead of ""("" and "")"".; 4947///; 4948/// Example:; 4949/// ~~~ {.cpp}; 4950/// c1.Print(""file.ps[""); // No actual print, just open file.ps; 4951/// for (int i=0; i<10; ++i) {; 4952/// // fill canvas for context i; 4953/// // ...; 4954///; 4955/// c1.Print(""file.ps""); // actually print canvas to file; 4956/// }// end loop; 4957/// c1.Print(""file.ps]""); // No actual print, just close.; 4958/// ~~~; 4959/// As before, the same macro is valid for PDF files.; 4960///; 4961/// It is possible to print a canvas into an animated GIF file by specifying the; 4962/// file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay; 4963/// between the subimages' display. If NN is omitted the delay between; 4964/// subimages is zero. Each picture is added in the animation thanks to a loop; 4965/// similar to the following one:; 4966/// ~~~ {.cpp}; 4967///",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:160172,Safety,avoid,avoid,160172," canvas to file; 4956/// }// end loop; 4957/// c1.Print(""file.ps]""); // No actual print, just close.; 4958/// ~~~; 4959/// As before, the same macro is valid for PDF files.; 4960///; 4961/// It is possible to print a canvas into an animated GIF file by specifying the; 4962/// file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay; 4963/// between the subimages' display. If NN is omitted the delay between; 4964/// subimages is zero. Each picture is added in the animation thanks to a loop; 4965/// similar to the following one:; 4966/// ~~~ {.cpp}; 4967/// for (int i=0; i<10; ++i) {; 4968/// // fill canvas for context i; 4969/// // ...; 4970///; 4971/// c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; 4972/// }// end loop; 4973/// ~~~; 4974/// The delay between each frame must be specified in each Print() statement.; 4975/// If the file ""myfile.gif"" already exists, the new frame are appended at; 4976/// the end of the file. To avoid this, delete it first with `gSystem->Unlink(myfile.gif);`; 4977/// If you want the gif file to repeat or loop forever, check TASImage::WriteImage documentation; 4978 ; 4979void TPad::Print(const char *filename, Option_t *option); 4980{; 4981 if (!GetCanvas()); 4982 return;; 4983 ; 4984 TString psname, fs1 = filename;; 4985 ; 4986 // ""["" and ""]"" are special characters for ExpandPathName. When they are at the end; 4987 // of the file name (see help) they must be removed before doing ExpandPathName.; 4988 if (fs1.EndsWith(""["")) {; 4989 fs1.Replace((fs1.Length()-1),1,"" "");; 4990 gSystem->ExpandPathName(fs1);; 4991 fs1.Replace((fs1.Length()-1),1,""["");; 4992 } else if (fs1.EndsWith(""]"")) {; 4993 fs1.Replace((fs1.Length()-1),1,"" "");; 4994 gSystem->ExpandPathName(fs1);; 4995 fs1.Replace((fs1.Length()-1),1,""]"");; 4996 } else {; 4997 gSystem->ExpandPathName(fs1);; 4998 }; 4999 ; 5000 // Set the default option as ""Postscript"" (Should be a data member of TPad); 5001 const char *opt_default = ""ps"";; 5002 ; 5003 TString",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:329156,Security,access,access,329156,"; TStyle::GetOptLogxInt_t GetOptLogx() constDefinition TStyle.h:247; TStyle::GetDateYFloat_t GetDateY() constDefinition TStyle.h:198; TStyle::GetPadBorderModeInt_t GetPadBorderMode() constDefinition TStyle.h:210; TStyle::GetNumberOfColorsInt_t GetNumberOfColors() constReturn number of colors in the color palette.Definition TStyle.cxx:1175; TStyle::GetOptLogzInt_t GetOptLogz() constDefinition TStyle.h:249; TStyle::SetPadBorderSizevoid SetPadBorderSize(Width_t size=1)Definition TStyle.h:356; TStyle::GetHatchesLineWidthInt_t GetHatchesLineWidth() constDefinition TStyle.h:200; TStyle::GetPadTopMarginFloat_t GetPadTopMargin() constDefinition TStyle.h:212; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TTextBase class for several text objects.Definition TText.h:22; TText::Paintvoid Paint(Option_t *option="""") overridePaint this text with its current attributes.Definition TText.cxx:687; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TViewSee TView3D.Definition TView.h:25; TView::WCtoNDCvirtual void WCtoNDC(const Float_t *pw, Float_t *pn)=0; TView::GetDistancetoAxisvirtual Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t &ratio)=0; TView::Re",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:329190,Security,access,access,329190,"; TStyle::GetOptLogxInt_t GetOptLogx() constDefinition TStyle.h:247; TStyle::GetDateYFloat_t GetDateY() constDefinition TStyle.h:198; TStyle::GetPadBorderModeInt_t GetPadBorderMode() constDefinition TStyle.h:210; TStyle::GetNumberOfColorsInt_t GetNumberOfColors() constReturn number of colors in the color palette.Definition TStyle.cxx:1175; TStyle::GetOptLogzInt_t GetOptLogz() constDefinition TStyle.h:249; TStyle::SetPadBorderSizevoid SetPadBorderSize(Width_t size=1)Definition TStyle.h:356; TStyle::GetHatchesLineWidthInt_t GetHatchesLineWidth() constDefinition TStyle.h:200; TStyle::GetPadTopMarginFloat_t GetPadTopMargin() constDefinition TStyle.h:212; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TTextBase class for several text objects.Definition TText.h:22; TText::Paintvoid Paint(Option_t *option="""") overridePaint this text with its current attributes.Definition TText.cxx:687; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TViewSee TView3D.Definition TView.h:25; TView::WCtoNDCvirtual void WCtoNDC(const Float_t *pw, Float_t *pn)=0; TView::GetDistancetoAxisvirtual Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t &ratio)=0; TView::Re",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:4082,Testability,log,log,4082,"ignal to be painted.; 98 ; 99\image html gpad_pad1.png; 100 ; 101This signal is generally sent when typing carriage return in the; 102command input or when a graphical operation has been performed on one; 103of the pads of this canvas.; 104When a Canvas/Pad is repainted, the member function Paint for all; 105objects in the Pad linked list is invoked.; 106 ; 107\image html gpad_pad2.png; 108 ; 109When the mouse is moved on the Pad, The member function DistancetoPrimitive; 110is called for all the elements in the pad. DistancetoPrimitive returns; 111the distance in pixels to this object.; 112 ; 113When the object is within the distance window, the member function; 114ExecuteEvent is called for this object.; 115 ; 116In ExecuteEvent, move, changes can be performed on the object.; 117 ; 118For examples of DistancetoPrimitive and ExecuteEvent functions,; 119see classes; 120~~~ {.cpp}; 121 TLine::DistancetoPrimitive, TLine::ExecuteEvent; 122 TBox::DistancetoPrimitive, TBox::ExecuteEvent; 123 TH1::DistancetoPrimitive, TH1::ExecuteEvent; 124~~~; 125A Pad supports linear and log scales coordinate systems.; 126The transformation coefficients are explained in TPad::ResizePad.; 127*/; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// Pad default constructor.; 131 ; 132TPad::TPad(); 133{; 134 fModified = kTRUE;; 135 fTip = nullptr;; 136 fPadPointer = nullptr;; 137 fPrimitives = nullptr;; 138 fExecs = nullptr;; 139 fCanvas = nullptr;; 140 fPadPaint = 0;; 141 fPixmapID = -1;; 142 fGLDevice = -1;; 143 fCopyGLDevice = kFALSE;; 144 fEmbeddedGL = kFALSE;; 145 fTheta = 30;; 146 fPhi = 30;; 147 fNumber = 0;; 148 fAbsCoord = kFALSE;; 149 fEditable = kTRUE;; 150 fCrosshair = 0;; 151 fCrosshairPos = 0;; 152 fPadView3D = nullptr;; 153 fMother = (TPad*)gPad;; 154 ; 155 fAbsHNDC = 0.;; 156 fAbsPixeltoXk = 0.;; 157 fAbsPixeltoYk = 0.;; 158 fAbsWNDC = 0.;; 159 fAbsXlowNDC = 0.;; 160 fAbsYlowNDC = 0.;; 161 fBorderMode = 0;; 162 fBorderSize = 0;; 16",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:53238,Testability,log,log,53238,"the form ""stringt;stringx;stringy""; 1658/// the pad title is set to stringt, the x axis title to; 1659/// stringx, the y axis title to stringy.; 1660///; 1661/// #### Example:; 1662///; 1663/// Begin_Macro(source); 1664/// {; 1665/// auto c = new TCanvas(""c"",""c"",200,10,500,300);; 1666///; 1667/// const Int_t n = 50;; 1668/// auto g = new TGraph();; 1669/// for (Int_t i=0;i<n;i++) g->SetPoint(i,i*0.1,100*sin(i*0.1+0.2));; 1670///; 1671/// auto frame = c->DrawFrame(0, -110, 2, 110);; 1672/// frame->GetXaxis()->SetTitle(""X axis"");; 1673///; 1674/// g->Draw(""L*"");; 1675/// }; 1676/// End_Macro; 1677 ; 1678TH1F *TPad::DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char *title); 1679{; 1680 if (!IsEditable()); 1681 return nullptr;; 1682 ; 1683 if (this != gPad) {; 1684 Warning(""DrawFrame"", ""Must be called for the current pad only"");; 1685 if (gPad) return gPad->DrawFrame(xmin,ymin,xmax,ymax,title);; 1686 }; 1687 ; 1688 cd();; 1689 ; 1690 TH1F *hframe = (TH1F*)FindObject(""hframe"");; 1691 if (hframe) delete hframe;; 1692 Int_t nbins = 1000;; 1693 //if log scale in X, use variable bin size linear with log(x); 1694 //this gives a better precision when zooming on the axis; 1695 if (fLogx && xmin > 0 && xmax > xmin) {; 1696 Double_t xminl = TMath::Log(xmin);; 1697 Double_t xmaxl = TMath::Log(xmax);; 1698 Double_t dx = (xmaxl-xminl)/nbins;; 1699 std::vector<Double_t> xbins(nbins+1);; 1700 xbins[0] = xmin;; 1701 for (Int_t i=1;i<=nbins;i++) {; 1702 xbins[i] = TMath::Exp(xminl+i*dx);; 1703 }; 1704 hframe = new TH1F(""hframe"",title,nbins,xbins.data());; 1705 } else {; 1706 hframe = new TH1F(""hframe"",title,nbins,xmin,xmax);; 1707 }; 1708 hframe->SetBit(TH1::kNoStats);; 1709 hframe->SetBit(kCanDelete);; 1710 hframe->SetMinimum(ymin);; 1711 hframe->SetMaximum(ymax);; 1712 hframe->GetYaxis()->SetLimits(ymin,ymax);; 1713 hframe->SetDirectory(nullptr);; 1714 hframe->Draw("" "");; 1715 Update();; 1716 cd();; 1717 return hframe;; 1718}; 1719 ; 1720/////////////////",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:53288,Testability,log,log,53288,"the form ""stringt;stringx;stringy""; 1658/// the pad title is set to stringt, the x axis title to; 1659/// stringx, the y axis title to stringy.; 1660///; 1661/// #### Example:; 1662///; 1663/// Begin_Macro(source); 1664/// {; 1665/// auto c = new TCanvas(""c"",""c"",200,10,500,300);; 1666///; 1667/// const Int_t n = 50;; 1668/// auto g = new TGraph();; 1669/// for (Int_t i=0;i<n;i++) g->SetPoint(i,i*0.1,100*sin(i*0.1+0.2));; 1670///; 1671/// auto frame = c->DrawFrame(0, -110, 2, 110);; 1672/// frame->GetXaxis()->SetTitle(""X axis"");; 1673///; 1674/// g->Draw(""L*"");; 1675/// }; 1676/// End_Macro; 1677 ; 1678TH1F *TPad::DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char *title); 1679{; 1680 if (!IsEditable()); 1681 return nullptr;; 1682 ; 1683 if (this != gPad) {; 1684 Warning(""DrawFrame"", ""Must be called for the current pad only"");; 1685 if (gPad) return gPad->DrawFrame(xmin,ymin,xmax,ymax,title);; 1686 }; 1687 ; 1688 cd();; 1689 ; 1690 TH1F *hframe = (TH1F*)FindObject(""hframe"");; 1691 if (hframe) delete hframe;; 1692 Int_t nbins = 1000;; 1693 //if log scale in X, use variable bin size linear with log(x); 1694 //this gives a better precision when zooming on the axis; 1695 if (fLogx && xmin > 0 && xmax > xmin) {; 1696 Double_t xminl = TMath::Log(xmin);; 1697 Double_t xmaxl = TMath::Log(xmax);; 1698 Double_t dx = (xmaxl-xminl)/nbins;; 1699 std::vector<Double_t> xbins(nbins+1);; 1700 xbins[0] = xmin;; 1701 for (Int_t i=1;i<=nbins;i++) {; 1702 xbins[i] = TMath::Exp(xminl+i*dx);; 1703 }; 1704 hframe = new TH1F(""hframe"",title,nbins,xbins.data());; 1705 } else {; 1706 hframe = new TH1F(""hframe"",title,nbins,xmin,xmax);; 1707 }; 1708 hframe->SetBit(TH1::kNoStats);; 1709 hframe->SetBit(kCanDelete);; 1710 hframe->SetMinimum(ymin);; 1711 hframe->SetMaximum(ymax);; 1712 hframe->GetYaxis()->SetLimits(ymin,ymax);; 1713 hframe->SetDirectory(nullptr);; 1714 hframe->Draw("" "");; 1715 Update();; 1716 cd();; 1717 return hframe;; 1718}; 1719 ; 1720/////////////////",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:93008,Testability,log,logical,93008,"//////////////////////////////////////////////////////////////////; 2917/// Set double buffer mode ON or OFF.; 2918 ; 2919void TPad::SetDoubleBuffer(Int_t mode); 2920{; 2921 if (fCanvas) fCanvas->SetDoubleBuffer(mode);; 2922}; 2923 ; 2924////////////////////////////////////////////////////////////////////////////////; 2925/// Set selected.; 2926 ; 2927void TPad::SetSelected(TObject *obj); 2928{; 2929 if (fCanvas) fCanvas->SetSelected(obj);; 2930}; 2931 ; 2932////////////////////////////////////////////////////////////////////////////////; 2933/// Update pad.; 2934 ; 2935void TPad::Update(); 2936{; 2937 if (fCanvas) fCanvas->Update();; 2938}; 2939 ; 2940////////////////////////////////////////////////////////////////////////////////; 2941/// Asynchronous pad update.; 2942/// In case of web-based canvas triggers update of the canvas on the client side,; 2943/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2944/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2945/// In case of normal canvas just canvas->Update() is performed.; 2946 ; 2947void TPad::UpdateAsync(); 2948{; 2949 if (fCanvas) fCanvas->UpdateAsync();; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Get frame.; 2954 ; 2955TFrame *TPad::GetFrame(); 2956{; 2957 if (!fPrimitives) fPrimitives = new TList;; 2958 TFrame *frame = (TFrame*)GetListOfPrimitives()->FindObject(fFrame);; 2959 if (!frame) frame = (TFrame*)GetListOfPrimitives()->FindObject(""TFrame"");; 2960 fFrame = frame;; 2961 if (!fFrame) {; 2962 if (!frame) fFrame = new TFrame(0,0,1,1);; 2963 Int_t framecolor = GetFrameFillColor();; 2964 if (!framecolor) framecolor = GetFillColor();; 2965 fFrame->SetFillColor(framecolor);; 2966 fFrame->SetFillStyle(GetFrameFillStyle());; 2967 fFrame->SetLineColor(GetFrameLineColor());; 2968 fFrame->SetLineStyle(GetFrameLineStyle());; 2969 fFrame->SetLineWidth(GetFrameLineWidth());; 297",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:199820,Testability,log,logarithmic,199820,"bj;; 6065 pad->SetEditable(mode);; 6066 }; 6067 }; 6068}; 6069 ; 6070////////////////////////////////////////////////////////////////////////////////; 6071/// Override TAttFill::FillStyle for TPad because we want to handle style=0; 6072/// as style 4000.; 6073 ; 6074void TPad::SetFillStyle(Style_t fstyle); 6075{; 6076 if (fstyle == 0) fstyle = 4000;; 6077 TAttFill::SetFillStyle(fstyle);; 6078}; 6079 ; 6080////////////////////////////////////////////////////////////////////////////////; 6081/// Set Lin/Log scale for X; 6082/// - value = 0 X scale will be linear; 6083/// - value = 1 X scale will be logarithmic (base 10); 6084/// - value > 1 reserved for possible support of base e or other; 6085 ; 6086void TPad::SetLogx(Int_t value); 6087{; 6088 fLogx = value;; 6089 delete fView; fView = nullptr;; 6090 Modified();; 6091 RangeAxisChanged();; 6092}; 6093 ; 6094////////////////////////////////////////////////////////////////////////////////; 6095/// Set Lin/Log scale for Y; 6096/// - value = 0 Y scale will be linear; 6097/// - value = 1 Y scale will be logarithmic (base 10); 6098/// - value > 1 reserved for possible support of base e or other; 6099 ; 6100void TPad::SetLogy(Int_t value); 6101{; 6102 fLogy = value;; 6103 delete fView; fView = nullptr;; 6104 Modified();; 6105 RangeAxisChanged();; 6106}; 6107 ; 6108////////////////////////////////////////////////////////////////////////////////; 6109/// Set Lin/Log scale for Z; 6110 ; 6111void TPad::SetLogz(Int_t value); 6112{; 6113 fLogz = value;; 6114 delete fView; fView = nullptr;; 6115 Modified();; 6116 RangeAxisChanged();; 6117}; 6118 ; 6119////////////////////////////////////////////////////////////////////////////////; 6120/// Set canvas range for pad and resize the pad. If the aspect ratio; 6121/// was fixed before the call it will be un-fixed.; 6122 ; 6123void TPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); 6124{; 6125 // Reorder points to make sure xlow,ylow is bottom left point and; 6126 // x",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:200279,Testability,log,logarithmic,200279,"bj;; 6065 pad->SetEditable(mode);; 6066 }; 6067 }; 6068}; 6069 ; 6070////////////////////////////////////////////////////////////////////////////////; 6071/// Override TAttFill::FillStyle for TPad because we want to handle style=0; 6072/// as style 4000.; 6073 ; 6074void TPad::SetFillStyle(Style_t fstyle); 6075{; 6076 if (fstyle == 0) fstyle = 4000;; 6077 TAttFill::SetFillStyle(fstyle);; 6078}; 6079 ; 6080////////////////////////////////////////////////////////////////////////////////; 6081/// Set Lin/Log scale for X; 6082/// - value = 0 X scale will be linear; 6083/// - value = 1 X scale will be logarithmic (base 10); 6084/// - value > 1 reserved for possible support of base e or other; 6085 ; 6086void TPad::SetLogx(Int_t value); 6087{; 6088 fLogx = value;; 6089 delete fView; fView = nullptr;; 6090 Modified();; 6091 RangeAxisChanged();; 6092}; 6093 ; 6094////////////////////////////////////////////////////////////////////////////////; 6095/// Set Lin/Log scale for Y; 6096/// - value = 0 Y scale will be linear; 6097/// - value = 1 Y scale will be logarithmic (base 10); 6098/// - value > 1 reserved for possible support of base e or other; 6099 ; 6100void TPad::SetLogy(Int_t value); 6101{; 6102 fLogy = value;; 6103 delete fView; fView = nullptr;; 6104 Modified();; 6105 RangeAxisChanged();; 6106}; 6107 ; 6108////////////////////////////////////////////////////////////////////////////////; 6109/// Set Lin/Log scale for Z; 6110 ; 6111void TPad::SetLogz(Int_t value); 6112{; 6113 fLogz = value;; 6114 delete fView; fView = nullptr;; 6115 Modified();; 6116 RangeAxisChanged();; 6117}; 6118 ; 6119////////////////////////////////////////////////////////////////////////////////; 6120/// Set canvas range for pad and resize the pad. If the aspect ratio; 6121/// was fixed before the call it will be un-fixed.; 6122 ; 6123void TPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); 6124{; 6125 // Reorder points to make sure xlow,ylow is bottom left point and; 6126 // x",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:209885,Testability,log,log,209885,"the function gets the point on the element that is clicked to; 6347/// move (i) or resize (all others). The expected values are:; 6348/// \image html gpad_pad5.png; 6349 ; 6350void TPad::ShowGuidelines(TObject *object, const Int_t event, const char mode, const bool cling ); 6351{; 6352 // When the object is moved with arrow or when the ShowGuideLines flag; 6353 // is off we do show guide lines.; 6354 if ((event == kArrowKeyRelease) || (event == kArrowKeyPress) ||; 6355 !gEnv->GetValue(""Canvas.ShowGuideLines"", 0)) return;; 6356 ; 6357 std::vector<dField> curDist;; 6358 std::vector<dField> otherDist;; 6359 Int_t pMX, pMY;; 6360 Double_t MX, MY;; 6361 Int_t threshold;; 6362 TList *prims;; 6363 UInt_t n;; 6364 Rectangle_t aBBox, bBBox;; 6365 aBBox = bBBox = Rectangle_t();; 6366 TLine *L;; 6367 TArrow *A;; 6368 Int_t dSizeArrow = 12; // distance of arrows indicating same size from BBox in px; 6369 Bool_t movedX, movedY; // make sure the current object is moved just once; 6370 movedX = movedY = false;; 6371 Bool_t resize = false; // indicates resize mode; 6372 Bool_t log = gPad->GetLogx() || gPad->GetLogy();; 6373 if (mode != 'i') resize = true;; 6374 ; 6375 TPad *is_pad = dynamic_cast<TPad *>( object );; 6376 ; 6377 TContext ctxt(kTRUE);; 6378 ; 6379 if (is_pad && is_pad->GetMother()); 6380 is_pad->GetMother()->cd();; 6381 ; 6382 static TPad *tmpGuideLinePad = nullptr;; 6383 ; 6384 //delete all existing Guidelines and create new invisible pad; 6385 if (tmpGuideLinePad) {; 6386 ctxt.PadDeleted(tmpGuideLinePad);; 6387 auto guidePadClicked = (object == tmpGuideLinePad); // in case of funny button click combination.; 6388 tmpGuideLinePad->Delete();; 6389 tmpGuideLinePad = nullptr;; 6390 if (guidePadClicked) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:211284,Testability,log,log,211284,"= 'i') resize = true;; 6374 ; 6375 TPad *is_pad = dynamic_cast<TPad *>( object );; 6376 ; 6377 TContext ctxt(kTRUE);; 6378 ; 6379 if (is_pad && is_pad->GetMother()); 6380 is_pad->GetMother()->cd();; 6381 ; 6382 static TPad *tmpGuideLinePad = nullptr;; 6383 ; 6384 //delete all existing Guidelines and create new invisible pad; 6385 if (tmpGuideLinePad) {; 6386 ctxt.PadDeleted(tmpGuideLinePad);; 6387 auto guidePadClicked = (object == tmpGuideLinePad); // in case of funny button click combination.; 6388 tmpGuideLinePad->Delete();; 6389 tmpGuideLinePad = nullptr;; 6390 if (guidePadClicked) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox();; 6416 TPoint center = cur->GetBBoxCenter();; 6417 ; 6418 otherDist.clear();; 6419 curDist.clear();; 6420 ; 6421 switch (event) {; 6422 ; 6423 case kButton1Down:; 6424 case kButton1Motion:; 6425 MX = gPad->GetX1() + 0.5 * (gPad->GetX2()-gPad->GetX1());; 6426 MY = gPad->GetY1() + 0.5 * (gPad->GetY2()-gPad->GetY1());; 6427 pMX = gPad->XtoPixel(MX);; 6428 pMY = gPad->YtoPixel(MY);; 6429 // Middlelines; 6430 if (TMath::Abs(pMX-center.GetX())<threshold) {; 6431 if (cling && (!resize)) {; 6432 cur->SetBBoxCenterX(pMX);; 6433 center = cur->GetBBoxCenter();; 6434 BBox",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:235648,Testability,test,testlast,235648,"9/// printf(""Loop i=%d, found objIsA=%s, name=%s\n"",; 7040/// i,obj->ClassName(),obj->GetName());; 7041/// }; 7042///}; 7043/// ~~~; 7044///; 7045/// If ROOT runs in batch mode a call to this method does nothing.; 7046 ; 7047TObject *TPad::WaitPrimitive(const char *pname, const char *emode); 7048{; 7049 if (!gPad || IsWeb()); 7050 return nullptr;; 7051 ; 7052 if (emode && strlen(emode)) gROOT->SetEditorMode(emode);; 7053 if (gROOT->GetEditorMode() == 0 && pname && strlen(pname) > 2) gROOT->SetEditorMode(&pname[1]);; 7054 ; 7055 if (!fPrimitives) fPrimitives = new TList;; 7056 gSystem->ProcessEvents();; 7057 TObject *oldlast = gPad->GetListOfPrimitives() ? gPad->GetListOfPrimitives()->Last() : nullptr;; 7058 TObject *obj = nullptr;; 7059 Bool_t testlast = kFALSE;; 7060 Bool_t hasname = pname && (strlen(pname) > 0);; 7061 if (!pname[0] && !emode[0]) testlast = kTRUE;; 7062 if (testlast) gROOT->SetEditorMode();; 7063 while (!gSystem->ProcessEvents() && gROOT->GetSelectedPad() && gPad) {; 7064 if (gROOT->GetEditorMode() == 0) {; 7065 if (hasname) {; 7066 obj = FindObject(pname);; 7067 if (obj) return obj;; 7068 }; 7069 if (testlast) {; 7070 if (!gPad->GetListOfPrimitives()) return nullptr;; 7071 obj = gPad->GetListOfPrimitives()->Last();; 7072 if (obj != oldlast) return obj;; 7073 Int_t event = GetEvent();; 7074 if (event == kButton1Double || event == kKeyPress) {; 7075 //the following statement is required against other loop executions; 7076 //before returning; 7077 fCanvas->HandleInput((EEventType)-1,0,0);; 7078 return nullptr;; 7079 }; 7080 }; 7081 }; 7082 gSystem->Sleep(10);; 7083 }; 7084 ; 7085 return nullptr;; 7086}; 7087 ; 7088////////////////////////////////////////////////////////////////////////////////; 7089/// Create a tool tip and return its pointer.; 7090 ; 7091TObject *TPad::CreateToolTip(const TBox *box, const char *text, Long_t delayms); 7092{; 7093 if (gPad->IsBatch()) return nullptr;; 7094 return (TObject*)gROOT->ProcessLineFast(TString::Format(""new TG",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:235754,Testability,test,testlast,235754,"9/// printf(""Loop i=%d, found objIsA=%s, name=%s\n"",; 7040/// i,obj->ClassName(),obj->GetName());; 7041/// }; 7042///}; 7043/// ~~~; 7044///; 7045/// If ROOT runs in batch mode a call to this method does nothing.; 7046 ; 7047TObject *TPad::WaitPrimitive(const char *pname, const char *emode); 7048{; 7049 if (!gPad || IsWeb()); 7050 return nullptr;; 7051 ; 7052 if (emode && strlen(emode)) gROOT->SetEditorMode(emode);; 7053 if (gROOT->GetEditorMode() == 0 && pname && strlen(pname) > 2) gROOT->SetEditorMode(&pname[1]);; 7054 ; 7055 if (!fPrimitives) fPrimitives = new TList;; 7056 gSystem->ProcessEvents();; 7057 TObject *oldlast = gPad->GetListOfPrimitives() ? gPad->GetListOfPrimitives()->Last() : nullptr;; 7058 TObject *obj = nullptr;; 7059 Bool_t testlast = kFALSE;; 7060 Bool_t hasname = pname && (strlen(pname) > 0);; 7061 if (!pname[0] && !emode[0]) testlast = kTRUE;; 7062 if (testlast) gROOT->SetEditorMode();; 7063 while (!gSystem->ProcessEvents() && gROOT->GetSelectedPad() && gPad) {; 7064 if (gROOT->GetEditorMode() == 0) {; 7065 if (hasname) {; 7066 obj = FindObject(pname);; 7067 if (obj) return obj;; 7068 }; 7069 if (testlast) {; 7070 if (!gPad->GetListOfPrimitives()) return nullptr;; 7071 obj = gPad->GetListOfPrimitives()->Last();; 7072 if (obj != oldlast) return obj;; 7073 Int_t event = GetEvent();; 7074 if (event == kButton1Double || event == kKeyPress) {; 7075 //the following statement is required against other loop executions; 7076 //before returning; 7077 fCanvas->HandleInput((EEventType)-1,0,0);; 7078 return nullptr;; 7079 }; 7080 }; 7081 }; 7082 gSystem->Sleep(10);; 7083 }; 7084 ; 7085 return nullptr;; 7086}; 7087 ; 7088////////////////////////////////////////////////////////////////////////////////; 7089/// Create a tool tip and return its pointer.; 7090 ; 7091TObject *TPad::CreateToolTip(const TBox *box, const char *text, Long_t delayms); 7092{; 7093 if (gPad->IsBatch()) return nullptr;; 7094 return (TObject*)gROOT->ProcessLineFast(TString::Format(""new TG",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:235782,Testability,test,testlast,235782,"9/// printf(""Loop i=%d, found objIsA=%s, name=%s\n"",; 7040/// i,obj->ClassName(),obj->GetName());; 7041/// }; 7042///}; 7043/// ~~~; 7044///; 7045/// If ROOT runs in batch mode a call to this method does nothing.; 7046 ; 7047TObject *TPad::WaitPrimitive(const char *pname, const char *emode); 7048{; 7049 if (!gPad || IsWeb()); 7050 return nullptr;; 7051 ; 7052 if (emode && strlen(emode)) gROOT->SetEditorMode(emode);; 7053 if (gROOT->GetEditorMode() == 0 && pname && strlen(pname) > 2) gROOT->SetEditorMode(&pname[1]);; 7054 ; 7055 if (!fPrimitives) fPrimitives = new TList;; 7056 gSystem->ProcessEvents();; 7057 TObject *oldlast = gPad->GetListOfPrimitives() ? gPad->GetListOfPrimitives()->Last() : nullptr;; 7058 TObject *obj = nullptr;; 7059 Bool_t testlast = kFALSE;; 7060 Bool_t hasname = pname && (strlen(pname) > 0);; 7061 if (!pname[0] && !emode[0]) testlast = kTRUE;; 7062 if (testlast) gROOT->SetEditorMode();; 7063 while (!gSystem->ProcessEvents() && gROOT->GetSelectedPad() && gPad) {; 7064 if (gROOT->GetEditorMode() == 0) {; 7065 if (hasname) {; 7066 obj = FindObject(pname);; 7067 if (obj) return obj;; 7068 }; 7069 if (testlast) {; 7070 if (!gPad->GetListOfPrimitives()) return nullptr;; 7071 obj = gPad->GetListOfPrimitives()->Last();; 7072 if (obj != oldlast) return obj;; 7073 Int_t event = GetEvent();; 7074 if (event == kButton1Double || event == kKeyPress) {; 7075 //the following statement is required against other loop executions; 7076 //before returning; 7077 fCanvas->HandleInput((EEventType)-1,0,0);; 7078 return nullptr;; 7079 }; 7080 }; 7081 }; 7082 gSystem->Sleep(10);; 7083 }; 7084 ; 7085 return nullptr;; 7086}; 7087 ; 7088////////////////////////////////////////////////////////////////////////////////; 7089/// Create a tool tip and return its pointer.; 7090 ; 7091TObject *TPad::CreateToolTip(const TBox *box, const char *text, Long_t delayms); 7092{; 7093 if (gPad->IsBatch()) return nullptr;; 7094 return (TObject*)gROOT->ProcessLineFast(TString::Format(""new TG",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:236031,Testability,test,testlast,236031,"9/// printf(""Loop i=%d, found objIsA=%s, name=%s\n"",; 7040/// i,obj->ClassName(),obj->GetName());; 7041/// }; 7042///}; 7043/// ~~~; 7044///; 7045/// If ROOT runs in batch mode a call to this method does nothing.; 7046 ; 7047TObject *TPad::WaitPrimitive(const char *pname, const char *emode); 7048{; 7049 if (!gPad || IsWeb()); 7050 return nullptr;; 7051 ; 7052 if (emode && strlen(emode)) gROOT->SetEditorMode(emode);; 7053 if (gROOT->GetEditorMode() == 0 && pname && strlen(pname) > 2) gROOT->SetEditorMode(&pname[1]);; 7054 ; 7055 if (!fPrimitives) fPrimitives = new TList;; 7056 gSystem->ProcessEvents();; 7057 TObject *oldlast = gPad->GetListOfPrimitives() ? gPad->GetListOfPrimitives()->Last() : nullptr;; 7058 TObject *obj = nullptr;; 7059 Bool_t testlast = kFALSE;; 7060 Bool_t hasname = pname && (strlen(pname) > 0);; 7061 if (!pname[0] && !emode[0]) testlast = kTRUE;; 7062 if (testlast) gROOT->SetEditorMode();; 7063 while (!gSystem->ProcessEvents() && gROOT->GetSelectedPad() && gPad) {; 7064 if (gROOT->GetEditorMode() == 0) {; 7065 if (hasname) {; 7066 obj = FindObject(pname);; 7067 if (obj) return obj;; 7068 }; 7069 if (testlast) {; 7070 if (!gPad->GetListOfPrimitives()) return nullptr;; 7071 obj = gPad->GetListOfPrimitives()->Last();; 7072 if (obj != oldlast) return obj;; 7073 Int_t event = GetEvent();; 7074 if (event == kButton1Double || event == kKeyPress) {; 7075 //the following statement is required against other loop executions; 7076 //before returning; 7077 fCanvas->HandleInput((EEventType)-1,0,0);; 7078 return nullptr;; 7079 }; 7080 }; 7081 }; 7082 gSystem->Sleep(10);; 7083 }; 7084 ; 7085 return nullptr;; 7086}; 7087 ; 7088////////////////////////////////////////////////////////////////////////////////; 7089/// Create a tool tip and return its pointer.; 7090 ; 7091TObject *TPad::CreateToolTip(const TBox *box, const char *text, Long_t delayms); 7092{; 7093 if (gPad->IsBatch()) return nullptr;; 7094 return (TObject*)gROOT->ProcessLineFast(TString::Format(""new TG",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:289241,Testability,log,log,289241,"vent type.Definition TPad.cxx:2847; TPad::fAbsYlowNDCDouble_t fAbsYlowNDCAbsolute Y top left corner of pad in NDC [0,1].Definition TPad.h:70; TPad::fXtoAbsPixelkDouble_t fXtoAbsPixelkConversion coefficient for X World to absolute pixel.Definition TPad.h:41; TPad::SetAttMarkerPSvoid SetAttMarkerPS(Color_t color, Style_t style, Size_t msize) overrideSet postscript marker attributes.Definition TPad.cxx:6227; TPad::DivideSquarevirtual void DivideSquare(Int_t n, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)""n"" is the total number of sub-pads.Definition TPad.cxx:1341; TPad::AbsCoordinatesvoid AbsCoordinates(Bool_t set) overrideDefinition TPad.h:167; TPad::AbsPixeltoYDouble_t AbsPixeltoY(Int_t py) overrideDefinition TPad.h:169; TPad::Classstatic TClass * Class(); TPad::IsBatchBool_t IsBatch() const overrideIs pad in batch mode ?Definition TPad.cxx:2856; TPad::GetUymaxDouble_t GetUymax() const overrideReturns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decad...Definition TPad.h:234; TPad::AddExecvoid AddExec(const char *name, const char *command) overrideAdd a new TExec object to the list of Execs.Definition TPad.cxx:498; TPad::fWNDCDouble_t fWNDCWidth of pad along X in Normalized Coordinates (NDC)Definition TPad.h:66; TPad::NextPaletteColorInt_t NextPaletteColor() overrideGet the next autocolor in the pad.Definition TPad.cxx:3118; TPad::VtoPixelInt_t VtoPixel(Double_t v) const overrideConvert Y NDC to pixel.Definition TPad.cxx:7446; TPad::PaintBordervoid PaintBorder(Color_t color, Bool_t tops)Paint the pad border.Definition TPad.cxx:3644; TPad::GetPhiDouble_t GetPhi() const overrideDefinition TPad.h:225; TPad::IsEditableBool_t IsEditable() const overrideDefinition TPad.h:272; TPad::FillCollideGridvoid FillCollideGrid(TObject *o)Initialise the grid used to find empty space when adding a box (Legend) in a pad.Definition TPad.cxx:3134; TPad::SetViewvoid SetView(TView *view=nullptr) overrideSet the current TView. Delete ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:292241,Testability,log,log,292241,"orld coordinates.Definition TPad.cxx:4525; TPad::fPhiDouble_t fPhiphi angle to view as lego/surfaceDefinition TPad.h:80; TPad::fPixeltoYDouble_t fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixelDefinition TPad.h:60; TPad::RecordLatexvirtual void RecordLatex(const TObject *obj)Emit RecordLatex() signal.Definition TPad.cxx:7254; TPad::fAbsXlowNDCDouble_t fAbsXlowNDCAbsolute X top left corner of pad in NDC [0,1].Definition TPad.h:69; TPad::fVtoPixelkDouble_t fVtoPixelkConversion coefficient for V NDC to pixel.Definition TPad.h:52; TPad::fGridxBool_t fGridxSet to true if grid along X.Definition TPad.h:100; TPad::fPadView3DTObject * fPadView3D! 3D View of this TPadDefinition TPad.h:114; TPad::CopyBackgroundPixmapsvoid CopyBackgroundPixmaps(TPad *start, TPad *stop, Int_t x, Int_t y)Copy pixmaps of pads laying below pad ""stop"" into pad ""stop"".Definition TPad.cxx:3990; TPad::GetUxmaxDouble_t GetUxmax() const overrideReturns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decad...Definition TPad.h:232; TPad::Dividevoid Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0) overrideAutomatic pad generation by division.Definition TPad.cxx:1249; TPad::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitives in this pad on the C++ source file out.Definition TPad.cxx:5847; TPad::fXtoPixelDouble_t fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworldDefinition TPad.h:43; TPad::fExecsTList * fExecsList of commands to be executed when a pad event occurs.Definition TPad.h:108; TPad::PadtoYDouble_t PadtoY(Double_t y) const overrideConvert y from pad to Y.Definition TPad.cxx:3551; TPad::fTickxInt_t fTickxSet to 1 if tick marks along X.Definition TPad.h:89; TPad::SetBBoxY1void SetBBoxY1(const Int_t y) overrideSet top of BoundingBox to a value (resize in y direction on top)Definition TPad.cxx:7348; TPad::fTickyInt_t fTickySet to 1 if tick marks along Y.Definition TPad.h:90; TPad::Get",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:296968,Testability,log,log,296968,"261; TPad::PaintDatevoid PaintDate()Paint the current date and time if the option Date is set on via gStyle->SetOptDate() Paint the curre...Definition TPad.cxx:3750; TPad::SetMaxPickDistancestatic void SetMaxPickDistance(Int_t maxPick=5)static function to set the maximum Pick Distance fgMaxPickDistance This parameter is used in TPad::Pi...Definition TPad.cxx:6680; TPad::SetBBoxX2void SetBBoxX2(const Int_t x) overrideSet right hand side of BoundingBox to a value (resize in x direction on right)Definition TPad.cxx:7339; TPad::SetBBoxX1void SetBBoxX1(const Int_t x) overrideSet lefthandside of BoundingBox to a value (resize in x direction on left)Definition TPad.cxx:7328; TPad::ClippingCodevirtual Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2)Compute the endpoint codes for TPad::Clip.Definition TPad.cxx:901; TPad::GetUyminDouble_t GetUymin() const overrideReturns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decad...Definition TPad.h:230; TPad::fX1Double_t fX1X of lower X coordinate.Definition TPad.h:36; TPad::GetListOfPrimitivesTList * GetListOfPrimitives() const overrideDefinition TPad.h:245; TPad::SetFillStylevoid SetFillStyle(Style_t fstyle) overrideOverride TAttFill::FillStyle for TPad because we want to handle style=0 as style 4000.Definition TPad.cxx:6074; TPad::DrawFrameTH1F * DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char *title="""") overrideDraw an empty pad frame with X and Y axis.Definition TPad.cxx:1678; TPad::fVtoPixelDouble_t fVtoPixelypixel = fVtoPixelk + fVtoPixel*vndcDefinition TPad.h:53; TPad::GetCanvasImpTCanvasImp * GetCanvasImp() const overrideGet canvas implementation pointer if any.Definition TPad.cxx:2746; TPad::GetEventInt_t GetEvent() const overrideGet Event.Definition TPad.cxx:2754; TPad::PadtoXDouble_t PadtoX(Double_t x) const overrideConvert x from pad to X.Definition TPad.cxx:3542; TPad::PixeltoXYvirtual void P",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:298964,Testability,log,log,298964,".cxx:3542; TPad::PixeltoXYvirtual void PixeltoXY(Int_t xpixel, Int_t ypixel, Double_t &x, Double_t &y)Convert pixel to X/Y coordinates.Definition TPad.cxx:7406; TPad::DrawCrosshairvirtual void DrawCrosshair()Function called to draw a crosshair in the canvas.Definition TPad.cxx:1605; TPad::YtoPadDouble_t YtoPad(Double_t y) const overrideConvert y from Y to pad.Definition TPad.cxx:3572; TPad::RangeChangedvirtual void RangeChanged()Definition TPad.h:316; TPad::fUyminDouble_t fUyminMinimum value on the Y axis.Definition TPad.h:75; TPad::SetPadvoid SetPad(const char *name, const char *title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color=35, Short_t bordersize=5, Short_t bordermode=-1) overrideSet all pad parameters.Definition TPad.cxx:6171; TPad::SetCursorvoid SetCursor(ECursor cursor) overrideSet cursor type.Definition TPad.cxx:2911; TPad::GetCanvasIDInt_t GetCanvasID() const overrideGet canvas identifier.Definition TPad.cxx:2738; TPad::fLogzInt_t fLogz(=0 if Z linear scale, =1 if log scale)Definition TPad.h:93; TPad::fYtoPixelkDouble_t fYtoPixelkConversion coefficient for Y World to pixel.Definition TPad.h:45; TPad::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TPad.cxx:2947; TPad::TPadTPad()Pad default constructor.Definition TPad.cxx:132; TPad::AbsPixeltoXDouble_t AbsPixeltoX(Int_t px) overrideDefinition TPad.h:168; TPad::UseCurrentStylevoid UseCurrentStyle() overrideForce a copy of current style for all objects in pad.Definition TPad.cxx:6927; TPad::GetMaxPickDistancestatic Int_t GetMaxPickDistance()Static function (see also TPad::SetMaxPickDistance)Definition TPad.cxx:2794; TPad::VtoAbsPixelInt_t VtoAbsPixel(Double_t v) const overrideConvert Y NDC to absolute pixel.Definition TPad.cxx:7467; TPad::Rangevoid Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2) overrideSet world coordinate system for the pad.Definition TPad.cxx:5331; TPad::fUtoPixelkDouble_t fUtoPixelkConversion coefficient for U NDC to pixel.Def",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:305480,Testability,log,log,305480,"79; TPad::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a box.Definition TPad.cxx:1174; TPad::fFixedAspectRatioBool_t fFixedAspectRatioTrue if fixed aspect ratio.Definition TPad.h:104; TPad::PaintFillAreavoid PaintFillArea(Int_t n, Float_t *x, Float_t *y, Option_t *option="""") overrideDefinition TPad.cxx:4017; TPad::Modifiedvoid Modified(Bool_t flag=true) overrideMark pad modified Will be repainted when TCanvas::Update() will be called next time.Definition TPad.cxx:7369; TPad::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from a pad and its sub-pads.Definition TPad.cxx:5389; TPad::HasFixedAspectRatioBool_t HasFixedAspectRatio() const overrideDefinition TPad.h:270; TPad::CloseToolTipvoid CloseToolTip(TObject *tip) overrideHide tool tip.Definition TPad.cxx:7123; TPad::GetUxminDouble_t GetUxmin() const overrideReturns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decad...Definition TPad.h:228; TPad::SetToolTipTextvoid SetToolTipText(const char *text, Long_t delayms=1000) overrideSet tool tip text associated with this pad.Definition TPad.cxx:6690; TPad::PaintPolyLinevoid PaintPolyLine(Int_t n, Float_t *x, Float_t *y, Option_t *option="""") overridePaint polyline in CurrentPad World coordinates.Definition TPad.cxx:4392; TPad::lsvoid ls(Option_t *option="""") const overrideList all primitives in pad.Definition TPad.cxx:3090; TPad::GetViewTView * GetView() const overrideDefinition TPad.h:254; TPad::ModifiedUpdatevoid ModifiedUpdate() overrideShort cut to call Modified() and Update() in a single call.Definition TPad.cxx:3530; TPad::fVtoAbsPixelkDouble_t fVtoAbsPixelkConversion coefficient for V NDC to absolute pixel.Definition TPad.h:51; TPad::GetPadSaveTVirtualPad * GetPadSave() const overrideGet save pad.Definition TPad.cxx:2820; TPad::SetAttLinePSvoid SetAttLinePS(Color_t color, Style_t style, Width_t lwidth) overrideSet postscript li",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:309721,Testability,log,log,309721," AutoExec()Execute the list of Execs when a pad event occurs.Definition TPad.cxx:508; TPad::fAbsCoordBool_t fAbsCoordUse absolute coordinates.Definition TPad.h:102; TPad::fNumPaletteColorInt_t fNumPaletteColorNumber of objects with an automatic color.Definition TPad.h:116; TPad::fCrosshairPosInt_t fCrosshairPosPosition of crosshair.Definition TPad.h:96; TPad::FillCollideGridTGraphvoid FillCollideGridTGraph(TObject *o)Definition TPad.cxx:3360; TPad::SetFixedAspectRatiovoid SetFixedAspectRatio(Bool_t fixed=kTRUE) overrideFix pad aspect ratio to current value if fixed is true.Definition TPad.cxx:6031; TPad::GetBorderSizeShort_t GetBorderSize() const overrideDefinition TPad.h:200; TPad::RedrawAxisvoid RedrawAxis(Option_t *option="""") overrideRedraw the frame axis.Definition TPad.cxx:5450; TPad::DrawDistvoid DrawDist(Rectangle_t aBBox, Rectangle_t bBBox, char mode)Draw Arrows to indicated equal distances of Objects with given BBoxes.Definition TPad.cxx:6266; TPad::fLogxInt_t fLogx(=0 if X linear scale, =1 if log scale)Definition TPad.h:91; TPad::GetAbsWNDCDouble_t GetAbsWNDC() const overrideDefinition TPad.h:222; TPad::YtoAbsPixelInt_t YtoAbsPixel(Double_t y) const overrideConvert Y coordinate to absolute pixel.Definition TPad.cxx:7499; TPad::fUtoPixelDouble_t fUtoPixelxpixel = fUtoPixelk + fUtoPixel*undcDefinition TPad.h:50; TPad::fCrosshairInt_t fCrosshairCrosshair type (0 if no crosshair requested)Definition TPad.h:95; TPad::PaintFillAreaHatchesvoid PaintFillAreaHatches(Int_t n, Double_t *x, Double_t *y, Int_t FillStyle)This function paints hatched fill area according to the FillStyle value The convention for the Hatch ...Definition TPad.cxx:4108; TPad::RangeAxisvoid RangeAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax) overrideSet axis coordinate system for the pad.Definition TPad.cxx:5369; TPad::fUtoAbsPixelkDouble_t fUtoAbsPixelkConversion coefficient for U NDC to absolute pixel.Definition TPad.h:48; TPad::ResetToolTipvoid ResetToolTip(TObject *tip) o",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:314837,Testability,log,log,314837," Current pad.Definition TPad.cxx:693; TPad::GetLogyInt_t GetLogy() const overrideDefinition TPad.h:257; TPad::PaintLineNDCvoid PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2) overridePaint line in normalized coordinates.Definition TPad.cxx:4336; TPad::PixeltoYDouble_t PixeltoY(Int_t py) overrideConvert pixel to Y coordinate.Definition TPad.cxx:7397; TPad::Printvoid Print(const char *filename="""") const overrideThis method is equivalent to SaveAs(""filename""). See TPad::SaveAs for details.Definition TPad.cxx:4798; TPad::GetEventXInt_t GetEventX() const overrideGet X event.Definition TPad.cxx:2762; TPad::GetFrameTFrame * GetFrame() overrideGet frame.Definition TPad.cxx:2955; TPad::fYUpNDCDouble_t fYUpNDCDefinition TPad.h:65; TPad::fYtoAbsPixelkDouble_t fYtoAbsPixelkConversion coefficient for Y World to absolute pixel.Definition TPad.h:44; TPad::fXtoPixelkDouble_t fXtoPixelkConversion coefficient for X World to pixel.Definition TPad.h:42; TPad::fLogyInt_t fLogy(=0 if Y linear scale, =1 if log scale)Definition TPad.h:92; TPad::fFrameTFrame * fFrame! Pointer to 2-D frame (if one exists)Definition TPad.h:111; TPad::GetPainterTVirtualPadPainter * GetPainter() overrideGet pad painter from TCanvas.Definition TPad.cxx:7262; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TPad::Closedvirtual void Closed()Definition TPad.h:184; TPad::fHNDCDouble_t fHNDCHeight of pad along Y in Normalized Coordinates (NDC)Definition TPad.h:67; TPad::ShowGuidelinesvoid ShowGuidelines(TObject *object, const Int_t event, const char mode='i', const bool cling=true) overrideShows lines to indicate if a TAttBBox2D object is aligned to the center or to another object,...Definition TPad.cxx:6350; TPad::GetCrosshairInt_t GetCrosshair() constReturn the crosshair type (from the mother canvas) crosshair type = 0 means no crosshair.Definition TPad.cxx:6651; TPad::GetRangeAxisvoid GetRangeAxis(Double_t &xmin, Double_",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:325266,Testability,log,logx,325266,"cs)Definition TString.h:673; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::GetOptLogyInt_t GetOptLogy() constDefinition TStyle.h:248; TStyle::SetPadBorderModevoid SetPadBorderMode(Int_t mode=1)Definition TStyle.h:357; TStyle::SetPadTopMarginvoid SetPadTopMargin(Float_t margin=0.1)Definition TStyle.h:359; TStyle::SetOptLogxvoid SetOptLogx(Int_t logx=1)Definition TStyle.h:329; TStyle::SetPadBottomMarginvoid SetPadBottomMargin(Float_t margin=0.1)Definition TStyle.h:358; TStyle::GetOptTitleInt_t GetOptTitle() constDefinition TStyle.h:246; TStyle::GetPadTickXInt_t GetPadTickX() constDefinition TStyle.h:217; TStyle::IsReadingBool_t IsReading() constDefinition TStyle.h:296; TStyle::GetPadColorColor_t GetPadColor() constDefinition TStyle.h:208; TStyle::SetPadRightMarginvoid SetPadRightMargin(Float_t margin=0.1)Definition TStyle.h:361; TStyle::SetTitleFontvoid SetTitleFont(Style_t font=62, Option_t *axis=""X"")Definition TStyle.cxx:1775; TStyle::GetPadRightMarginFloat_t GetPadRightMargin() constDefinition TStyle.h:214; TStyle::SetTitleBorderSizevoid SetTitleBorderSize(Width_t size=2)Definition TStyle.h:408; TStyle::GetDateXFloat_t GetDateX() constDefinition TStyle.h:197; TStyle::GetTitleFontStyle_t GetTitleFont(Option_t *axis=""X"") constReturn title font.Definition TStyle.cxx:1216; TStyle::SetPadTickYvoid SetPadTickY(Int_t ti",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:327179,Testability,log,logy,327179,urn title font.Definition TStyle.cxx:1216; TStyle::SetPadTickYvoid SetPadTickY(Int_t ticky)Definition TStyle.h:365; TStyle::GetTitleFillColorColor_t GetTitleFillColor() constDefinition TStyle.h:271; TStyle::SetPadTickXvoid SetPadTickX(Int_t tickx)Definition TStyle.h:364; TStyle::GetOptDateInt_t GetOptDate() constDefinition TStyle.h:242; TStyle::GetPadGridYBool_t GetPadGridY() constDefinition TStyle.h:216; TStyle::SetPadGridXvoid SetPadGridX(Bool_t gridx)Definition TStyle.h:362; TStyle::SetTitleTextColorvoid SetTitleTextColor(Color_t color=1)Definition TStyle.h:405; TStyle::GetPadLeftMarginFloat_t GetPadLeftMargin() constDefinition TStyle.h:213; TStyle::GetHatchesSpacingDouble_t GetHatchesSpacing() constDefinition TStyle.h:201; TStyle::GetPadGridXBool_t GetPadGridX() constDefinition TStyle.h:215; TStyle::SetPadLeftMarginvoid SetPadLeftMargin(Float_t margin=0.1)Definition TStyle.h:360; TStyle::SetPadGridYvoid SetPadGridY(Bool_t gridy)Definition TStyle.h:363; TStyle::SetOptLogyvoid SetOptLogy(Int_t logy=1)Definition TStyle.h:330; TStyle::GetOptFileInt_t GetOptFile() constDefinition TStyle.h:243; TStyle::GetAttDateTAttText * GetAttDate()Definition TStyle.h:168; TStyle::GetPadTickYInt_t GetPadTickY() constDefinition TStyle.h:218; TStyle::GetPadBorderSizeWidth_t GetPadBorderSize() constDefinition TStyle.h:209; TStyle::GetTitleBorderSizeWidth_t GetTitleBorderSize() constDefinition TStyle.h:275; TStyle::GetColorPaletteInt_t GetColorPalette(Int_t i) constReturn color number i in current palette.Definition TStyle.cxx:1101; TStyle::SetTitleFillColorvoid SetTitleFillColor(Color_t color=1)Definition TStyle.h:404; TStyle::GetPadBottomMarginFloat_t GetPadBottomMargin() constDefinition TStyle.h:211; TStyle::SetOptLogzvoid SetOptLogz(Int_t logz=1)Definition TStyle.h:331; TStyle::SetPadColorvoid SetPadColor(Color_t color=19)Definition TStyle.h:355; TStyle::GetTitleTextColorColor_t GetTitleTextColor() constDefinition TStyle.h:272; TStyle::GetOptLogxInt_t GetOptLogx() constDefinition T,MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:327921,Testability,log,logz,327921,e::GetPadGridXBool_t GetPadGridX() constDefinition TStyle.h:215; TStyle::SetPadLeftMarginvoid SetPadLeftMargin(Float_t margin=0.1)Definition TStyle.h:360; TStyle::SetPadGridYvoid SetPadGridY(Bool_t gridy)Definition TStyle.h:363; TStyle::SetOptLogyvoid SetOptLogy(Int_t logy=1)Definition TStyle.h:330; TStyle::GetOptFileInt_t GetOptFile() constDefinition TStyle.h:243; TStyle::GetAttDateTAttText * GetAttDate()Definition TStyle.h:168; TStyle::GetPadTickYInt_t GetPadTickY() constDefinition TStyle.h:218; TStyle::GetPadBorderSizeWidth_t GetPadBorderSize() constDefinition TStyle.h:209; TStyle::GetTitleBorderSizeWidth_t GetTitleBorderSize() constDefinition TStyle.h:275; TStyle::GetColorPaletteInt_t GetColorPalette(Int_t i) constReturn color number i in current palette.Definition TStyle.cxx:1101; TStyle::SetTitleFillColorvoid SetTitleFillColor(Color_t color=1)Definition TStyle.h:404; TStyle::GetPadBottomMarginFloat_t GetPadBottomMargin() constDefinition TStyle.h:211; TStyle::SetOptLogzvoid SetOptLogz(Int_t logz=1)Definition TStyle.h:331; TStyle::SetPadColorvoid SetPadColor(Color_t color=19)Definition TStyle.h:355; TStyle::GetTitleTextColorColor_t GetTitleTextColor() constDefinition TStyle.h:272; TStyle::GetOptLogxInt_t GetOptLogx() constDefinition TStyle.h:247; TStyle::GetDateYFloat_t GetDateY() constDefinition TStyle.h:198; TStyle::GetPadBorderModeInt_t GetPadBorderMode() constDefinition TStyle.h:210; TStyle::GetNumberOfColorsInt_t GetNumberOfColors() constReturn number of colors in the color palette.Definition TStyle.cxx:1175; TStyle::GetOptLogzInt_t GetOptLogz() constDefinition TStyle.h:249; TStyle::SetPadBorderSizevoid SetPadBorderSize(Width_t size=1)Definition TStyle.h:356; TStyle::GetHatchesLineWidthInt_t GetHatchesLineWidth() constDefinition TStyle.h:200; TStyle::GetPadTopMarginFloat_t GetPadTopMargin() constDefinition TStyle.h:212; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definit,MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:338183,Testability,log,logarithm,338183," &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v1@ v1Definition rootcling_impl.cxx:3701; invvoid inv(rsa_NUMBER *, rsa_NUMBE",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:338852,Testability,log,logarithm,338852,"finition TMath.h:680; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v1@ v1Definition rootcling_impl.cxx:3701; invvoid inv(rsa_NUMBER *, rsa_NUMBER *, rsa_NUMBER *)Definition rsaaux.cxx:949; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361; Rectangle_t::fXShort_t fXDefinition GuiTypes.h:362; Rectangle_t::fHeightUShort_t fHeightDefinition GuiTypes.h:363; Rectangle_t::fYShort_t fYDefinition GuiTypes.h:362; Rectangle_t::fWidthUShort_t fWidthDefinition GuiTypes.h:363; dFieldstruct used by ShowGuidelines to store the distance Field between objects in the canvas.Definition TPad.cxx:6319; dField::fbTAttBBox2D * fbDefinition TPad.cxx:6321; dField::dFielddField()Definition TPad.cxx:6326; dField::fdirchar fdirDefinition TPad.cxx:6323; dField::dFielddField(TAttBBo",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:16127,Usability,simpl,simple,16127,"terpreter as a development engine.; 497 ; 498void TPad::AddExec(const char *name, const char *command); 499{; 500 if (!fExecs) fExecs = new TList;; 501 TExec *ex = new TExec(name,command);; 502 fExecs->Add(ex);; 503}; 504 ; 505////////////////////////////////////////////////////////////////////////////////; 506/// Execute the list of Execs when a pad event occurs.; 507 ; 508void TPad::AutoExec(); 509{; 510 if (GetCrosshair()); 511 DrawCrosshair();; 512 ; 513 if (!fExecs); 514 return;; 515 TIter next(fExecs);; 516 while (auto exec = (TExec*)next()); 517 exec->Exec();; 518}; 519 ; 520////////////////////////////////////////////////////////////////////////////////; 521/// Browse pad.; 522 ; 523void TPad::Browse(TBrowser *b); 524{; 525 cd();; 526 if (fPrimitives) fPrimitives->Browse(b);; 527}; 528 ; 529////////////////////////////////////////////////////////////////////////////////; 530/// Build a legend from the graphical objects in the pad.; 531///; 532/// A simple method to build automatically a TLegend from the primitives in a TPad.; 533///; 534/// Only those deriving from TAttLine, TAttMarker and TAttFill are added, excluding; 535/// TPave and TFrame derived classes.; 536///; 537/// \return The built TLegend; 538///; 539/// \param[in] x1, y1, x2, y2 The TLegend coordinates; 540/// \param[in] title The legend title. By default it is "" ""; 541/// \param[in] option The TLegend option; 542///; 543/// The caller program owns the returned TLegend.; 544///; 545/// If the pad contains some TMultiGraph or THStack the individual; 546/// graphs or histograms in them are added to the TLegend.; 547///; 548/// ### Automatic placement of the legend; 549/// If `x1` is equal to `x2` and `y1` is equal to `y2` the legend will be automatically; 550/// placed to avoid overlapping with the existing primitives already displayed.; 551/// `x1` is considered as the width of the legend and `y1` the height. By default; 552/// the legend is automatically placed with width = `x1`= `x2` = 0.3 and",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:23231,Usability,clear,clear,23231," bit with `mypad->SetBit(TPad::kClearAfterCR)`; 721 ; 722void TPad::Clear(Option_t *option); 723{; 724 if (!IsEditable()) return;; 725 ; 726 R__LOCKGUARD(gROOTMutex);; 727 ; 728 if (!fPadPaint) {; 729 SafeDelete(fView);; 730 if (fPrimitives) fPrimitives->Clear(option);; 731 if (fFrame) {; 732 if (! ROOT::Detail::HasBeenDeleted(fFrame)) delete fFrame;; 733 fFrame = nullptr;; 734 }; 735 }; 736 if (fCanvas) fCanvas->Cleared(this);; 737 ; 738 cd();; 739 ; 740 if (TestBit(kClearAfterCR)) {; 741 // Intentional do not use the return value of getchar,; 742 // we just want to get it and forget it; 743 getchar();; 744 }; 745 ; 746 if (!gPad->IsBatch() && GetPainter()) GetPainter()->ClearDrawable();; 747 if (gVirtualPS && gPad == gPad->GetCanvas()) gVirtualPS->NewPage();; 748 ; 749 PaintBorder(GetFillColor(), kTRUE);; 750 fCrosshairPos = 0;; 751 fNumPaletteColor = 0;; 752 fCollideGrid.clear();; 753 fCGnx = 0;; 754 fCGny = 0;; 755 ResetBit(TGraph::kClipFrame);; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Clipping routine: Cohen Sutherland algorithm.; 760///; 761/// - If Clip ==2 the segment is outside the boundary.; 762/// - If Clip ==1 the segment has one point outside the boundary.; 763/// - If Clip ==0 the segment is inside the boundary.; 764///; 765/// \param[inout] x[],y[] Segment coordinates (2 points); 766/// \param[in] xclipl,yclipb,xclipr,yclipt Clipping boundary; 767 ; 768Int_t TPad::Clip(Float_t *x, Float_t *y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); 769{; 770 const Float_t kP=10000;; 771 Int_t clip = 0;; 772 ; 773 for (Int_t i=0;i<2;i++) {; 774 if (TMath::Abs(xclipl-x[i]) <= TMath::Abs(xclipr-xclipl)/kP) x[i] = xclipl;; 775 if (TMath::Abs(xclipr-x[i]) <= TMath::Abs(xclipr-xclipl)/kP) x[i] = xclipr;; 776 if (TMath::Abs(yclipb-y[i]) <= TMath::Abs(yclipt-yclipb)/kP) y[i] = yclipb;; 777 if (TMath::Abs(yclipt-y[i]) <= TMath::Abs(yclipt-yclipb)/kP) y[i] = yclipt;; 778 }; 779 ; 780 // Comp",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:29064,Usability,simpl,simple,29064,"; 903 Int_t code = 0;; 904 if (x < xcl1) code = code | 0x1;; 905 if (x > xcl2) code = code | 0x2;; 906 if (y < ycl1) code = code | 0x4;; 907 if (y > ycl2) code = code | 0x8;; 908 return code;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Clip polygon using the Sutherland-Hodgman algorithm.; 913///; 914/// \param[in] n Number of points in the polygon to; 915/// be clipped; 916/// \param[in] x,y Polygon x[n], y[n] do be clipped vertices; 917/// \param[in] xclipl,yclipb,xclipr,yclipt Clipping boundary; 918/// \param[out] nn Number of points in xc and yc; 919/// \param[out] xc,yc Clipped polygon vertices. The Int_t; 920/// returned by this function is; 921/// the number of points in the clipped; 922/// polygon. These vectors must; 923/// be allocated by the calling function.; 924/// A size of 2*n for each is; 925/// enough.; 926///; 927/// Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; 928/// strategy: It solves a series of simple and identical problems that, when; 929/// combined, solve the overall problem. The simple problem is to clip a polygon; 930/// against a single infinite clip edge. Four clip edges, each defining one boundary; 931/// of the clip rectangle, successively clip a polygon against a clip rectangle.; 932///; 933/// Steps of Sutherland-Hodgman's polygon-clipping algorithm:; 934///; 935/// * Polygons can be clipped against each edge of the window one at a time.; 936/// Windows/edge intersections, if any, are easy to find since the X or Y coordinates; 937/// are already known.; 938/// * Vertices which are kept after clipping against one window edge are saved for; 939/// clipping against the remaining edges.; 940/// * Note that the number of vertices usually changes and will often increases.; 941///; 942/// The clip boundary determines a visible and invisible region. The edges from; 943/// vertex i to vertex i+1 can be one of four types:; 944///; 945/// * Case 1 : W",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:29154,Usability,simpl,simple,29154,"2) code = code | 0x8;; 908 return code;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Clip polygon using the Sutherland-Hodgman algorithm.; 913///; 914/// \param[in] n Number of points in the polygon to; 915/// be clipped; 916/// \param[in] x,y Polygon x[n], y[n] do be clipped vertices; 917/// \param[in] xclipl,yclipb,xclipr,yclipt Clipping boundary; 918/// \param[out] nn Number of points in xc and yc; 919/// \param[out] xc,yc Clipped polygon vertices. The Int_t; 920/// returned by this function is; 921/// the number of points in the clipped; 922/// polygon. These vectors must; 923/// be allocated by the calling function.; 924/// A size of 2*n for each is; 925/// enough.; 926///; 927/// Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; 928/// strategy: It solves a series of simple and identical problems that, when; 929/// combined, solve the overall problem. The simple problem is to clip a polygon; 930/// against a single infinite clip edge. Four clip edges, each defining one boundary; 931/// of the clip rectangle, successively clip a polygon against a clip rectangle.; 932///; 933/// Steps of Sutherland-Hodgman's polygon-clipping algorithm:; 934///; 935/// * Polygons can be clipped against each edge of the window one at a time.; 936/// Windows/edge intersections, if any, are easy to find since the X or Y coordinates; 937/// are already known.; 938/// * Vertices which are kept after clipping against one window edge are saved for; 939/// clipping against the remaining edges.; 940/// * Note that the number of vertices usually changes and will often increases.; 941///; 942/// The clip boundary determines a visible and invisible region. The edges from; 943/// vertex i to vertex i+1 can be one of four types:; 944///; 945/// * Case 1 : Wholly inside visible region - save endpoint; 946/// * Case 2 : Exit visible region - save the intersection; 947/// * Case 3 : Wholly outside visible regi",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:114259,Usability,clear,cleared,114259,"; 3599 ; 3600 Bool_t began3DScene = kFALSE;; 3601 fPadPaint = 1;; 3602 ; 3603 {; 3604 TContext ctxt(this, kTRUE);; 3605 ; 3606 PaintBorder(GetFillColor(), kTRUE);; 3607 PaintDate();; 3608 ; 3609 auto lnk = GetListOfPrimitives()->FirstLink();; 3610 ; 3611 while (lnk) {; 3612 TObject *obj = lnk->GetObject();; 3613 ; 3614 // Create a pad 3D viewer if none exists and we encounter a 3D shape; 3615 if (!fViewer3D && obj->InheritsFrom(TAtt3D::Class())) {; 3616 GetViewer3D(""pad"");; 3617 }; 3618 ; 3619 // Open a 3D scene if required; 3620 if (fViewer3D && !fViewer3D->BuildingScene()) {; 3621 fViewer3D->BeginScene();; 3622 began3DScene = kTRUE;; 3623 }; 3624 ; 3625 obj->Paint(lnk->GetOption());; 3626 lnk = lnk->Next();; 3627 }; 3628 }; 3629 ; 3630 fPadPaint = 0;; 3631 Modified(kFALSE);; 3632 ; 3633 // Close the 3D scene if we opened it. This must be done after modified; 3634 // flag is cleared, as some viewers will invoke another paint by marking pad modified again; 3635 if (began3DScene) {; 3636 fViewer3D->EndScene();; 3637 }; 3638}; 3639 ; 3640////////////////////////////////////////////////////////////////////////////////; 3641/// Paint the pad border.; 3642/// Draw first a box as a normal filled box; 3643 ; 3644void TPad::PaintBorder(Color_t color, Bool_t tops); 3645{; 3646 if (color >= 0) {; 3647 TAttLine::Modify(); //Change line attributes only if necessary; 3648 TAttFill::Modify(); //Change fill area attributes only if necessary; 3649 ; 3650 //With Cocoa we have a transparency. But we also have; 3651 //pixmaps, and if you just paint a new content over the old one; 3652 //with alpha < 1., you'll be able to see the old content.; 3653 if (!gROOT->IsBatch() && gVirtualX->InheritsFrom(""TGCocoa"") && GetPainter()); 3654 GetPainter()->ClearDrawable();; 3655 ; 3656 PaintBox(fX1,fY1,fX2,fY2);; 3657 }; 3658 if (color < 0) color = -color;; 3659 // then paint 3d frame (depending on bordermode); 3660 if (IsTransparent()) return;; 3661 // Paint a 3D frame around the pad.; 3662 ; 3663 ",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:123016,Usability,clear,cleared,123016,"nullptr;; 3821 while (lnk) {; 3822 auto obj = lnk->GetObject();; 3823 if (obj->InheritsFrom(TPad::Class())); 3824 ((TPad*)obj)->PaintModified();; 3825 lnk = lnk->Next();; 3826 }; 3827 return;; 3828 }; 3829 ; 3830 if (fCanvas) TColor::SetGrayscale(fCanvas->IsGrayscale());; 3831 ; 3832 TVirtualPS *saveps = gVirtualPS;; 3833 if (gVirtualPS) {; 3834 if (gVirtualPS->TestBit(kPrintingPS)); 3835 gVirtualPS = nullptr;; 3836 }; 3837 ; 3838 Bool_t began3DScene = kFALSE;; 3839 fPadPaint = 1;; 3840 {; 3841 TContext ctxt(this, kTRUE);; 3842 if (IsModified() || IsTransparent()) {; 3843 if ((fFillStyle < 3026) && (fFillStyle > 3000)) {; 3844 if (!gPad->IsBatch() && GetPainter()) GetPainter()->ClearDrawable();; 3845 }; 3846 PaintBorder(GetFillColor(), kTRUE);; 3847 }; 3848 ; 3849 PaintDate();; 3850 ; 3851 TList *pList = GetListOfPrimitives();; 3852 auto lnk = pList ? pList->FirstLink() : nullptr;; 3853 ; 3854 while (lnk) {; 3855 TObject *obj = lnk->GetObject();; 3856 if (obj->InheritsFrom(TPad::Class())) {; 3857 ((TPad*)obj)->PaintModified();; 3858 } else if (IsModified() || IsTransparent()) {; 3859 ; 3860 // Create a pad 3D viewer if none exists and we encounter a; 3861 // 3D shape; 3862 if (!fViewer3D && obj->InheritsFrom(TAtt3D::Class())) {; 3863 GetViewer3D(""pad"");; 3864 }; 3865 ; 3866 // Open a 3D scene if required; 3867 if (fViewer3D && !fViewer3D->BuildingScene()) {; 3868 fViewer3D->BeginScene();; 3869 began3DScene = kTRUE;; 3870 }; 3871 ; 3872 obj->Paint(lnk->GetOption());; 3873 }; 3874 lnk = lnk->Next();; 3875 }; 3876 }; 3877 ; 3878 fPadPaint = 0;; 3879 Modified(kFALSE);; 3880 ; 3881 // This must be done after modified flag is cleared, as some; 3882 // viewers will invoke another paint by marking pad modified again; 3883 if (began3DScene) {; 3884 if (fViewer3D) fViewer3D->EndScene();; 3885 }; 3886 ; 3887 gVirtualPS = saveps;; 3888}; 3889 ; 3890////////////////////////////////////////////////////////////////////////////////; 3891/// Paint box in CurrentPad World coordinates.",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:124847,Usability,clear,clear,124847,,MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:209192,Usability,guid,guide,209192," direction); 6331 : fa(a), fb(b), fdist(dist), fdir(direction); 6332 {}; 6333};; 6334 ; 6335////////////////////////////////////////////////////////////////////////////////; 6336/// Shows lines to indicate if a TAttBBox2D object is aligned to; 6337/// the center or to another object, shows distance arrows if two; 6338/// objects on screen have the same distance to another object; 6339/// Call from primitive in Execute Event, in ButtonMotion after; 6340/// the new coordinates have been set, to 'stick'; 6341/// once when button is up to delete lines; 6342///; 6343/// modes: t (Top), b (bottom), l (left), r (right), i (inside); 6344/// in resize modes (t,b,l,r) only size arrows are sticky; 6345///; 6346/// in mode, the function gets the point on the element that is clicked to; 6347/// move (i) or resize (all others). The expected values are:; 6348/// \image html gpad_pad5.png; 6349 ; 6350void TPad::ShowGuidelines(TObject *object, const Int_t event, const char mode, const bool cling ); 6351{; 6352 // When the object is moved with arrow or when the ShowGuideLines flag; 6353 // is off we do show guide lines.; 6354 if ((event == kArrowKeyRelease) || (event == kArrowKeyPress) ||; 6355 !gEnv->GetValue(""Canvas.ShowGuideLines"", 0)) return;; 6356 ; 6357 std::vector<dField> curDist;; 6358 std::vector<dField> otherDist;; 6359 Int_t pMX, pMY;; 6360 Double_t MX, MY;; 6361 Int_t threshold;; 6362 TList *prims;; 6363 UInt_t n;; 6364 Rectangle_t aBBox, bBBox;; 6365 aBBox = bBBox = Rectangle_t();; 6366 TLine *L;; 6367 TArrow *A;; 6368 Int_t dSizeArrow = 12; // distance of arrows indicating same size from BBox in px; 6369 Bool_t movedX, movedY; // make sure the current object is moved just once; 6370 movedX = movedY = false;; 6371 Bool_t resize = false; // indicates resize mode; 6372 Bool_t log = gPad->GetLogx() || gPad->GetLogy();; 6373 if (mode != 'i') resize = true;; 6374 ; 6375 TPad *is_pad = dynamic_cast<TPad *>( object );; 6376 ; 6377 TContext ctxt(kTRUE);; 6378 ; 6379 if (is_pad &&",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:210349,Usability,guid,guidePadClicked,210349,"; 6358 std::vector<dField> otherDist;; 6359 Int_t pMX, pMY;; 6360 Double_t MX, MY;; 6361 Int_t threshold;; 6362 TList *prims;; 6363 UInt_t n;; 6364 Rectangle_t aBBox, bBBox;; 6365 aBBox = bBBox = Rectangle_t();; 6366 TLine *L;; 6367 TArrow *A;; 6368 Int_t dSizeArrow = 12; // distance of arrows indicating same size from BBox in px; 6369 Bool_t movedX, movedY; // make sure the current object is moved just once; 6370 movedX = movedY = false;; 6371 Bool_t resize = false; // indicates resize mode; 6372 Bool_t log = gPad->GetLogx() || gPad->GetLogy();; 6373 if (mode != 'i') resize = true;; 6374 ; 6375 TPad *is_pad = dynamic_cast<TPad *>( object );; 6376 ; 6377 TContext ctxt(kTRUE);; 6378 ; 6379 if (is_pad && is_pad->GetMother()); 6380 is_pad->GetMother()->cd();; 6381 ; 6382 static TPad *tmpGuideLinePad = nullptr;; 6383 ; 6384 //delete all existing Guidelines and create new invisible pad; 6385 if (tmpGuideLinePad) {; 6386 ctxt.PadDeleted(tmpGuideLinePad);; 6387 auto guidePadClicked = (object == tmpGuideLinePad); // in case of funny button click combination.; 6388 tmpGuideLinePad->Delete();; 6389 tmpGuideLinePad = nullptr;; 6390 if (guidePadClicked) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox(",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:210518,Usability,guid,guidePadClicked,210518,"= 'i') resize = true;; 6374 ; 6375 TPad *is_pad = dynamic_cast<TPad *>( object );; 6376 ; 6377 TContext ctxt(kTRUE);; 6378 ; 6379 if (is_pad && is_pad->GetMother()); 6380 is_pad->GetMother()->cd();; 6381 ; 6382 static TPad *tmpGuideLinePad = nullptr;; 6383 ; 6384 //delete all existing Guidelines and create new invisible pad; 6385 if (tmpGuideLinePad) {; 6386 ctxt.PadDeleted(tmpGuideLinePad);; 6387 auto guidePadClicked = (object == tmpGuideLinePad); // in case of funny button click combination.; 6388 tmpGuideLinePad->Delete();; 6389 tmpGuideLinePad = nullptr;; 6390 if (guidePadClicked) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox();; 6416 TPoint center = cur->GetBBoxCenter();; 6417 ; 6418 otherDist.clear();; 6419 curDist.clear();; 6420 ; 6421 switch (event) {; 6422 ; 6423 case kButton1Down:; 6424 case kButton1Motion:; 6425 MX = gPad->GetX1() + 0.5 * (gPad->GetX2()-gPad->GetX1());; 6426 MY = gPad->GetY1() + 0.5 * (gPad->GetY2()-gPad->GetY1());; 6427 pMX = gPad->XtoPixel(MX);; 6428 pMY = gPad->YtoPixel(MY);; 6429 // Middlelines; 6430 if (TMath::Abs(pMX-center.GetX())<threshold) {; 6431 if (cling && (!resize)) {; 6432 cur->SetBBoxCenterX(pMX);; 6433 center = cur->GetBBoxCenter();; 6434 BBox",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:211445,Usability,clear,clear,211445,"LinePad->Delete();; 6389 tmpGuideLinePad = nullptr;; 6390 if (guidePadClicked) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox();; 6416 TPoint center = cur->GetBBoxCenter();; 6417 ; 6418 otherDist.clear();; 6419 curDist.clear();; 6420 ; 6421 switch (event) {; 6422 ; 6423 case kButton1Down:; 6424 case kButton1Motion:; 6425 MX = gPad->GetX1() + 0.5 * (gPad->GetX2()-gPad->GetX1());; 6426 MY = gPad->GetY1() + 0.5 * (gPad->GetY2()-gPad->GetY1());; 6427 pMX = gPad->XtoPixel(MX);; 6428 pMY = gPad->YtoPixel(MY);; 6429 // Middlelines; 6430 if (TMath::Abs(pMX-center.GetX())<threshold) {; 6431 if (cling && (!resize)) {; 6432 cur->SetBBoxCenterX(pMX);; 6433 center = cur->GetBBoxCenter();; 6434 BBox = cur->GetBBox();; 6435 center = cur->GetBBoxCenter();; 6436 }; 6437 L = new TLine(MX, gPad->GetY1(), MX, gPad->GetY2());; 6438 L->SetBit(kCanDelete);; 6439 L->SetLineColor(lineColor);; 6440 L->Draw();; 6441 }; 6442 if (TMath::Abs(pMY-center.GetY())<threshold) {; 6443 if (cling && (!resize)) {; 6444 cur->SetBBoxCenterY(pMY);; 6445 center = cur->GetBBoxCenter();; 6446 BBox = cur->GetBBox();; 6447 center = cur->GetBBoxCenter();; 6448 }; 6449 L = new TLine(gPad->GetX1(), MY, gPad->GetX2(), MY);; 6450 L->SetBit(",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:211468,Usability,clear,clear,211468,"ed) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox();; 6416 TPoint center = cur->GetBBoxCenter();; 6417 ; 6418 otherDist.clear();; 6419 curDist.clear();; 6420 ; 6421 switch (event) {; 6422 ; 6423 case kButton1Down:; 6424 case kButton1Motion:; 6425 MX = gPad->GetX1() + 0.5 * (gPad->GetX2()-gPad->GetX1());; 6426 MY = gPad->GetY1() + 0.5 * (gPad->GetY2()-gPad->GetY1());; 6427 pMX = gPad->XtoPixel(MX);; 6428 pMY = gPad->YtoPixel(MY);; 6429 // Middlelines; 6430 if (TMath::Abs(pMX-center.GetX())<threshold) {; 6431 if (cling && (!resize)) {; 6432 cur->SetBBoxCenterX(pMX);; 6433 center = cur->GetBBoxCenter();; 6434 BBox = cur->GetBBox();; 6435 center = cur->GetBBoxCenter();; 6436 }; 6437 L = new TLine(MX, gPad->GetY1(), MX, gPad->GetY2());; 6438 L->SetBit(kCanDelete);; 6439 L->SetLineColor(lineColor);; 6440 L->Draw();; 6441 }; 6442 if (TMath::Abs(pMY-center.GetY())<threshold) {; 6443 if (cling && (!resize)) {; 6444 cur->SetBBoxCenterY(pMY);; 6445 center = cur->GetBBoxCenter();; 6446 BBox = cur->GetBBox();; 6447 center = cur->GetBBoxCenter();; 6448 }; 6449 L = new TLine(gPad->GetX1(), MY, gPad->GetX2(), MY);; 6450 L->SetBit(kCanDelete);; 6451 L->SetLineColor(lineColor);; 6452 L->Draw();; 6453 }; 64",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:272886,Usability,feedback,feedback,272886,"n this canvas as a C++ macro file.Definition TCanvas.cxx:1822; TCanvas::HandleInputvirtual void HandleInput(EEventType button, Int_t x, Int_t y)Handle Input Events.Definition TCanvas.cxx:1234; TCanvas::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TCanvas.cxx:2545; TCanvas::GetSelectedTObject * GetSelected() const overrideDefinition TCanvas.h:141; TCanvas::GetEventXInt_t GetEventX() const overrideDefinition TCanvas.h:136; TCanvas::SetCanvasSizevoid SetCanvasSize(UInt_t ww, UInt_t wh) overrideSet Width and Height of canvas to ww and wh respectively.Definition TCanvas.cxx:1975; TCanvas::GetSelectedPadTVirtualPad * GetSelectedPad() const overrideDefinition TCanvas.h:146; TCanvas::SetCursorvoid SetCursor(ECursor cursor) overrideSet cursor.Definition TCanvas.cxx:1989; TCanvas::GetCanvasIDInt_t GetCanvasID() const overrideDefinition TCanvas.h:157; TCanvas::GetWindowWidthUInt_t GetWindowWidth() constDefinition TCanvas.h:161; TCanvas::FeedbackModevoid FeedbackMode(Bool_t set)Turn rubberband feedback mode on or off.Definition TCanvas.cxx:1128; TCanvas::SetClickSelectedvoid SetClickSelected(TObject *obj)Definition TCanvas.h:209; TCanvas::GetPadSaveTVirtualPad * GetPadSave() const overrideDefinition TCanvas.h:139; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TCanvas::Clearedvirtual void Cleared(TVirtualPad *pad)Emit pad Cleared signal.Definition TCanvas.cxx:770; TCanvas::GetWwUInt_t GetWw() const overrideDefinition TCanvas.h:163; TCanvas::OpaqueMovingBool_t OpaqueMoving() const overrideDefinition TCanvas.h:180; TCanvas::GetWhUInt_t GetWh() const overrideDefinition TCanvas.h:164; TCanvas::Classstatic TClass * Class(); TCanvas::SetSelectedvoid SetSelected(TObject *obj) overrideSet selected canvas.Definition TCanvas.cxx:2146; TCanvas::GetEventInt_t GetEvent() const overrideDefinition TCanvas.h:135; TCanvas::IsWebBool_t IsWeb() const overrideIs web canvas.Definition TCanvas.cxx:1496; TCanvas::SetBatchvoid Set",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:281858,Usability,simpl,simple,281858," TH2::Classstatic TClass * Class(); TH3::Classstatic TClass * Class(); THStackThe Histogram stack class.Definition THStack.h:40; THStack::GetHistogramTH1 * GetHistogram() constReturns a pointer to the histogram used to draw the axis.Definition THStack.cxx:484; THStack::Classstatic TClass * Class(); TImage::EImageFileTypesEImageFileTypesDefinition TImage.h:36; TImage::kBmp@ kBmpDefinition TImage.h:45; TImage::kPng@ kPngDefinition TImage.h:40; TImage::kJpeg@ kJpegDefinition TImage.h:41; TImage::kXpm@ kXpmDefinition TImage.h:37; TImage::kAnimGif@ kAnimGifDefinition TImage.h:55; TImage::kUnknown@ kUnknownDefinition TImage.h:54; TImage::kTiff@ kTiffDefinition TImage.h:49; TImage::kGif@ kGifDefinition TImage.h:48; TImage::Classstatic TClass * Class(); TIterDefinition TCollection.h:235; TIter::GetOptionOption_t * GetOption() constDefinition TCollection.h:253; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TListIterIterator of linked list.Definition TList.h:193; TListIter::GetOptionOption_t * GetOption() const overrideReturns the object option stored in the list.Definition TList.cxx:1140; TListA doubly linked list.Definition TList.h:38; TList::AfterTObject * After(const TObject *obj) const overrideReturns the object after object obj.Definition TList.cxx:328; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::LastLinkvirtual TObjLink * LastLink() constDefinition TList.h:107; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TList.cxx:762; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8cxx_source.html:334095,Usability,clear,cleared,334095,"ter::DrawTextNDCvirtual void DrawTextNDC(Double_t u, Double_t v, const char *text, ETextMode mode)=0; TVirtualPadPainter::GetLineWidthvirtual Width_t GetLineWidth() const =0; TVirtualPadPainter::SelectDrawablevirtual void SelectDrawable(Int_t device)=0; TVirtualPadPainter::DrawPolyMarkervirtual void DrawPolyMarker(Int_t n, const Double_t *x, const Double_t *y)=0; TVirtualPadPainter::DrawTextvirtual void DrawText(Double_t x, Double_t y, const char *text, ETextMode mode)=0; TVirtualPadPainter::GetFillStylevirtual Style_t GetFillStyle() const =0; TVirtualPadPainter::InvalidateCSvirtual void InvalidateCS()Empty definition.Definition TVirtualPadPainter.cxx:44; TVirtualPadPainter::kFilled@ kFilledDefinition TVirtualPadPainter.h:21; TVirtualPadPainter::kHollow@ kHollowDefinition TVirtualPadPainter.h:21; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::PadDeletedvoid PadDeleted(TVirtualPad *pad)Inform context that pad deleted or will be deleted soon Reference on that pad should be cleared.Definition TVirtualPad.cxx:73; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::YtoAbsPixelvirtual Int_t YtoAbsPixel(Double_t y) const =0; TVirtualPad::GetX2virtual Double_t GetX2() const =0; TVirtualPad::cdvirtual TVirtualPad * cd(Int_t subpadnumber=0)=0; TVirtualPad::XtoAbsPixelvirtual Int_t XtoAbsPixel(Double_t x) const =0; TVirtualPad::GetY1virtual Double_t GetY1() const =0; TVirtualPad::GetNumbervirtual Int_t GetNumber() const =0; TVirtualPad::Streamervoid Streamer(TBuffer &) overrideStream an object of class TVirtualPad.Definition TVirtualPad.cxx:124; TVirtualPad::VtoPixelvirtual Int_t VtoPixel(Double_t v) const =0; TVirtualPad::Classstatic TClass * Class(); TVirtualPad::VtoAbsPixelvirtual Int_t VtoAbsPixel(Double_t v) const =0; TVirtualPad::RangeAxisChangedvirtual void RangeAxisChanged()Definition TVirtualPad.h:203; TVirtual",MatchSource.WIKI,doc/master/TPad_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html
https://root.cern/doc/master/TPad_8h_source.html:4513,Availability,down,down,4513," Double_t fTheta; ///< theta angle to view as lego/surface; 80 Double_t fPhi; ///< phi angle to view as lego/surface; 81 ; 82 Double_t fAspectRatio; ///< ratio of w/h in case of fixed ratio; 83 ; 84 Int_t fPixmapID; ///<! Off-screen pixmap identifier; 85 Int_t fGLDevice; ///<! OpenGL off-screen pixmap identifier; 86 Bool_t fCopyGLDevice; ///<!; 87 Bool_t fEmbeddedGL; ///<!; 88 Int_t fNumber; ///< pad number identifier; 89 Int_t fTickx; ///< Set to 1 if tick marks along X; 90 Int_t fTicky; ///< Set to 1 if tick marks along Y; 91 Int_t fLogx; ///< (=0 if X linear scale, =1 if log scale); 92 Int_t fLogy; ///< (=0 if Y linear scale, =1 if log scale); 93 Int_t fLogz; ///< (=0 if Z linear scale, =1 if log scale); 94 Int_t fPadPaint; ///< Set to 1 while painting the pad; 95 Int_t fCrosshair; ///< Crosshair type (0 if no crosshair requested); 96 Int_t fCrosshairPos; ///< Position of crosshair; 97 Short_t fBorderSize; ///< pad bordersize in pixels; 98 Short_t fBorderMode; ///< Bordermode (-1=down, 0 = no border, 1=up); 99 Bool_t fModified; ///< Set to true when pad is modified; 100 Bool_t fGridx; ///< Set to true if grid along X; 101 Bool_t fGridy; ///< Set to true if grid along Y; 102 Bool_t fAbsCoord; ///< Use absolute coordinates; 103 Bool_t fEditable; ///< True if canvas is editable; 104 Bool_t fFixedAspectRatio; ///< True if fixed aspect ratio; 105 TPad *fMother{nullptr}; ///<! pointer to mother of the list; 106 TCanvas *fCanvas{nullptr}; ///<! Pointer to mother canvas; 107 TList *fPrimitives{nullptr};///<->List of primitives (subpads); 108 TList *fExecs{nullptr}; ///< List of commands to be executed when a pad event occurs; 109 TString fName; ///< Pad name; 110 TString fTitle; ///< Pad title; 111 TFrame *fFrame{nullptr}; ///<! Pointer to 2-D frame (if one exists); 112 TView *fView{nullptr}; ///<! Pointer to 3-D view (if one exists); 113 TObject *fPadPointer{nullptr};///<! free pointer; 114 TObject *fPadView3D{nullptr};///<! 3D View of this TPad; 115 static Int_t fgMaxPi",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:62448,Availability,down,down,62448,"GetAbsYlowNDC() const overrideDefinition TPad.h:221; TPad::fUxmaxDouble_t fUxmaxMaximum value on the X axis.Definition TPad.h:76; TPad::AddFirstvoid AddFirst(TObject *obj, Option_t *opt="""", Bool_t modified=kTRUE) overrideAdd an object as first in list of primitives with speicified draw option When.Definition TPad.cxx:439; TPad::SetTickyvoid SetTicky(Int_t value=1) overrideDefinition TPad.h:357; TPad::fY2Double_t fY2Y of upper Y coordinate.Definition TPad.h:39; TPad::fAbsPixeltoYkDouble_t fAbsPixeltoYkConversion coefficient for absolute pixel to Y World.Definition TPad.h:58; TPad::GetSelectedPadTVirtualPad * GetSelectedPad() const overrideGet selected pad.Definition TPad.cxx:2811; TPad::PaintPolyLine3Dvoid PaintPolyLine3D(Int_t n, Double_t *p) overridePaint 3-D polyline in the CurrentPad.Definition TPad.cxx:4511; TPad::GetPadTVirtualPad * GetPad(Int_t subpadnumber) const overrideGet a pointer to subpadnumber of this pad.Definition TPad.cxx:3000; TPad::fBorderModeShort_t fBorderModeBordermode (-1=down, 0 = no border, 1=up)Definition TPad.h:98; TPad::SetLogxvoid SetLogx(Int_t value=1) overrideSet Lin/Log scale for X.Definition TPad.cxx:6086; TPad::ReleaseViewer3Dvoid ReleaseViewer3D(Option_t *type="""") overrideRelease current (external) viewer.Definition TPad.cxx:7222; TPad::SetCrosshairvoid SetCrosshair(Int_t crhair=1) overrideSet crosshair active/inactive.Definition TPad.cxx:6664; TPad::fNextPaletteColorInt_t fNextPaletteColorNext automatic color.Definition TPad.h:117; TPad::SetBBoxCenterXvoid SetBBoxCenterX(const Int_t x) overrideSet X coordinate of the center of the Pad.Definition TPad.cxx:7309; TPad::GetLogxInt_t GetLogx() const overrideDefinition TPad.h:256; TPad::SetCopyGLDevicevoid SetCopyGLDevice(Bool_t copy) overrideDefinition TPad.h:367; TPad::fPadPointerTObject * fPadPointer! free pointerDefinition TPad.h:113; TPad::GetX2Double_t GetX2() const overrideDefinition TPad.h:241; TPad::CreateToolTipTObject * CreateToolTip(const TBox *b, const char *text, Long_t del",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:41899,Deployability,update,update,41899,"&x, Double_t &y)Convert pixel to X/Y coordinates.Definition TPad.cxx:7406; TPad::DrawCrosshairvirtual void DrawCrosshair()Function called to draw a crosshair in the canvas.Definition TPad.cxx:1605; TPad::YtoPadDouble_t YtoPad(Double_t y) const overrideConvert y from Y to pad.Definition TPad.cxx:3572; TPad::RangeChangedvirtual void RangeChanged()Definition TPad.h:316; TPad::fUyminDouble_t fUyminMinimum value on the Y axis.Definition TPad.h:75; TPad::SetPadvoid SetPad(const char *name, const char *title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color=35, Short_t bordersize=5, Short_t bordermode=-1) overrideSet all pad parameters.Definition TPad.cxx:6171; TPad::GetCanvasIDInt_t GetCanvasID() const overrideGet canvas identifier.Definition TPad.cxx:2738; TPad::fLogzInt_t fLogz(=0 if Z linear scale, =1 if log scale)Definition TPad.h:93; TPad::fYtoPixelkDouble_t fYtoPixelkConversion coefficient for Y World to pixel.Definition TPad.h:45; TPad::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TPad.cxx:2947; TPad::TPadTPad()Pad default constructor.Definition TPad.cxx:132; TPad::AbsPixeltoXDouble_t AbsPixeltoX(Int_t px) overrideDefinition TPad.h:168; TPad::UseCurrentStylevoid UseCurrentStyle() overrideForce a copy of current style for all objects in pad.Definition TPad.cxx:6927; TPad::GetMaxPickDistancestatic Int_t GetMaxPickDistance()Static function (see also TPad::SetMaxPickDistance)Definition TPad.cxx:2794; TPad::VtoAbsPixelInt_t VtoAbsPixel(Double_t v) const overrideConvert Y NDC to absolute pixel.Definition TPad.cxx:7467; TPad::Rangevoid Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2) overrideSet world coordinate system for the pad.Definition TPad.cxx:5331; TPad::EventPavevirtual void EventPave()Definition TPad.h:416; TPad::fUtoPixelkDouble_t fUtoPixelkConversion coefficient for U NDC to pixel.Definition TPad.h:49; TPad::fPixeltoXkDouble_t fPixeltoXkConversion coefficient for pixel to X World.Definition TPad.h:56;",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:30120,Integrability,rout,routine,30120,"inked list.Definition TList.h:38; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::SetGridxvoid SetGridx(Int_t value=1) overrideDefinition TPad.h:336; TPad::GetBorderModeShort_t GetBorderMode() const overrideDefinition TPad.h:199; TPad::OpaqueMovingBool_t OpaqueMoving() const overrideIs pad moving in opaque mode ?Definition TPad.cxx:2879; TPad::SetBorderSizevoid SetBorderSize(Short_t bordersize) overrideDefinition TPad.h:326; TPad::PaintTextNDCvoid PaintTextNDC(Double_t u, Double_t v, const char *text) overridePaint text in CurrentPad NDC coordinates.Definition TPad.cxx:4613; TPad::GetTickyInt_t GetTicky() const overrideDefinition TPad.h:239; TPad::Clipvirtual Int_t Clip(Float_t *x, Float_t *y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt)Clipping routine: Cohen Sutherland algorithm.Definition TPad.cxx:768; TPad::HideToolTipvirtual void HideToolTip(Int_t event)Hide tool tip depending on the event type.Definition TPad.cxx:2847; TPad::fAbsYlowNDCDouble_t fAbsYlowNDCAbsolute Y top left corner of pad in NDC [0,1].Definition TPad.h:70; TPad::fXtoAbsPixelkDouble_t fXtoAbsPixelkConversion coefficient for X World to absolute pixel.Definition TPad.h:41; TPad::SetAttMarkerPSvoid SetAttMarkerPS(Color_t color, Style_t style, Size_t msize) overrideSet postscript marker attributes.Definition TPad.cxx:6227; TPad::DivideSquarevirtual void DivideSquare(Int_t n, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)""n"" is the total number of sub-pads.Definition TPad.cxx:1341; TPad::AbsCoordinatesvoid AbsCoordinates(Bool_t set) overrideDefinition TPad.h:167; TPad::AbsPixeltoYDouble_t AbsPixeltoY(Int_t py) overrideDefinition TPad.h:169; TPad::IsBatchBool_t IsBatch() const overrideIs pad in batch m",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:30249,Integrability,depend,depending,30249,"cts.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::SetGridxvoid SetGridx(Int_t value=1) overrideDefinition TPad.h:336; TPad::GetBorderModeShort_t GetBorderMode() const overrideDefinition TPad.h:199; TPad::OpaqueMovingBool_t OpaqueMoving() const overrideIs pad moving in opaque mode ?Definition TPad.cxx:2879; TPad::SetBorderSizevoid SetBorderSize(Short_t bordersize) overrideDefinition TPad.h:326; TPad::PaintTextNDCvoid PaintTextNDC(Double_t u, Double_t v, const char *text) overridePaint text in CurrentPad NDC coordinates.Definition TPad.cxx:4613; TPad::GetTickyInt_t GetTicky() const overrideDefinition TPad.h:239; TPad::Clipvirtual Int_t Clip(Float_t *x, Float_t *y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt)Clipping routine: Cohen Sutherland algorithm.Definition TPad.cxx:768; TPad::HideToolTipvirtual void HideToolTip(Int_t event)Hide tool tip depending on the event type.Definition TPad.cxx:2847; TPad::fAbsYlowNDCDouble_t fAbsYlowNDCAbsolute Y top left corner of pad in NDC [0,1].Definition TPad.h:70; TPad::fXtoAbsPixelkDouble_t fXtoAbsPixelkConversion coefficient for X World to absolute pixel.Definition TPad.h:41; TPad::SetAttMarkerPSvoid SetAttMarkerPS(Color_t color, Style_t style, Size_t msize) overrideSet postscript marker attributes.Definition TPad.cxx:6227; TPad::DivideSquarevirtual void DivideSquare(Int_t n, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)""n"" is the total number of sub-pads.Definition TPad.cxx:1341; TPad::AbsCoordinatesvoid AbsCoordinates(Bool_t set) overrideDefinition TPad.h:167; TPad::AbsPixeltoYDouble_t AbsPixeltoY(Int_t py) overrideDefinition TPad.h:169; TPad::IsBatchBool_t IsBatch() const overrideIs pad in batch mode ?Definition TPad.cxx:2856; TPad::GetUymaxDouble_t GetUymax() const overrideReturns the maximum y-coordinate value visible on the pad. If log axis the",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:32792,Integrability,rout,routine,32792,"on TPad.cxx:3118; TPad::VtoPixelInt_t VtoPixel(Double_t v) const overrideConvert Y NDC to pixel.Definition TPad.cxx:7446; TPad::PaintBordervoid PaintBorder(Color_t color, Bool_t tops)Paint the pad border.Definition TPad.cxx:3644; TPad::GetPhiDouble_t GetPhi() const overrideDefinition TPad.h:225; TPad::IsEditableBool_t IsEditable() const overrideDefinition TPad.h:272; TPad::FillCollideGridvoid FillCollideGrid(TObject *o)Initialise the grid used to find empty space when adding a box (Legend) in a pad.Definition TPad.cxx:3134; TPad::SetViewvoid SetView(TView *view=nullptr) overrideSet the current TView. Delete previous view if view=0.Definition TPad.cxx:6195; TPad::GetViewer3DTVirtualViewer3D * GetViewer3D(Option_t *type="""") overrideCreate/obtain handle to 3D viewer.Definition TPad.cxx:7151; TPad::fPixeltoYkDouble_t fPixeltoYkConversion coefficient for pixel to Y World.Definition TPad.h:59; TPad::PaintHatchesvoid PaintHatches(Double_t dy, Double_t angle, Int_t nn, Double_t *xx, Double_t *yy)This routine draw hatches inclined with the angle ""angle"" and spaced of ""dy"" in normalized device coo...Definition TPad.cxx:4161; TPad::PaintLine3Dvoid PaintLine3D(Float_t *p1, Float_t *p2) overridePaint 3-D line in the CurrentPad.Definition TPad.cxx:4356; TPad::fgMaxPickDistancestatic Int_t fgMaxPickDistanceMaximum Pick Distance.Definition TPad.h:115; TPad::ResizePadvoid ResizePad(Option_t *option="""") overrideCompute pad conversion coefficients.Definition TPad.cxx:5624; TPad::PaintPolyMarkervoid PaintPolyMarker(Int_t n, Float_t *x, Float_t *y, Option_t *option="""") overridePaint polymarker in CurrentPad World coordinates.Definition TPad.cxx:4525; TPad::SetGridvoid SetGrid(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:335; TPad::fPhiDouble_t fPhiphi angle to view as lego/surfaceDefinition TPad.h:80; TPad::GetAspectRatioDouble_t GetAspectRatio() const overrideDefinition TPad.h:224; TPad::DestroyExternalViewer3Dvoid DestroyExternalViewer3D(); TPad::fPixeltoYDouble_t fPixelt",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:59689,Modifiability,inherit,inheritance,59689,"ble_t fHNDCHeight of pad along Y in Normalized Coordinates (NDC)Definition TPad.h:67; TPad::ShowGuidelinesvoid ShowGuidelines(TObject *object, const Int_t event, const char mode='i', const bool cling=true) overrideShows lines to indicate if a TAttBBox2D object is aligned to the center or to another object,...Definition TPad.cxx:6350; TPad::GetCrosshairInt_t GetCrosshair() constReturn the crosshair type (from the mother canvas) crosshair type = 0 means no crosshair.Definition TPad.cxx:6651; TPad::GetRangeAxisvoid GetRangeAxis(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) overrideReturn pad axis coordinates range.Definition TPad.cxx:3043; TPad::SetBorderModevoid SetBorderMode(Short_t bordermode) overrideDefinition TPad.h:325; TPad::PaintBoxvoid PaintBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Option_t *option="""") overridePaint box in CurrentPad World coordinates.Definition TPad.cxx:3896; TPad::DrawClassObjectvoid DrawClassObject(const TObject *obj, Option_t *option="""") overrideDraw class inheritance tree of the class to which obj belongs.Definition TPad.cxx:1403; TPad::fCGnyInt_t fCGny! Size of the collide grid along yDefinition TPad.h:120; TPad::fXlowNDCDouble_t fXlowNDCX bottom left corner of pad in NDC [0,1].Definition TPad.h:62; TPad::GetPrimitiveTObject * GetPrimitive(const char *name) const overrideGet primitive.Definition TPad.cxx:2983; TPad::fUxminDouble_t fUxminMinimum value on the X axis.Definition TPad.h:74; TPad::GetAbsHNDCDouble_t GetAbsHNDC() const overrideDefinition TPad.h:223; TPad::SetTicksvoid SetTicks(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:355; TPad::SetBBoxCentervoid SetBBoxCenter(const TPoint &p) overrideSet center of the Pad.Definition TPad.cxx:7299; TPad::IsWebBool_t IsWeb() const overrideIs web ?Definition TPad.cxx:2871; TPad::SetSelectedvoid SetSelected(TObject *obj) overrideSet selected.Definition TPad.cxx:2927; TPad::GetSelectedTObject * GetSelected() const overrideGet selected.Definition TPad.",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:64253,Security,hash,hash,64253,"fPadPointer! free pointerDefinition TPad.h:113; TPad::GetX2Double_t GetX2() const overrideDefinition TPad.h:241; TPad::CreateToolTipTObject * CreateToolTip(const TBox *b, const char *text, Long_t delayms) overrideCreate a tool tip and return its pointer.Definition TPad.cxx:7091; TPad::kCannotMove@ kCannotMoveFixed position.Definition TPad.h:158; TPad::kClearAfterCR@ kClearAfterCRClear after CR.Definition TPad.h:159; TPad::kHori@ kHoriPad is horizontal.Definition TPad.h:155; TPad::kClipFrame@ kClipFrameClip on frame.Definition TPad.h:156; TPad::kPrintingPS@ kPrintingPSPS Printing.Definition TPad.h:157; TPad::kFraming@ kFramingFrame is requested.Definition TPad.h:154; TPad::GetWNDCDouble_t GetWNDC() const overrideGet width of pad along X in Normalized Coordinates (NDC)Definition TPad.h:215; TPad::Popvoid Pop() overridePop pad to the top of the stack.Definition TPad.cxx:4776; TPad::GetAbsXlowNDCDouble_t GetAbsXlowNDC() const overrideDefinition TPad.h:220; TPad::HashULong_t Hash() const overrideReturn hash value for this object.Definition TPad.h:267; TPad::GetX1Double_t GetX1() const overrideDefinition TPad.h:240; TPad::GetHNDCDouble_t GetHNDC() const overrideGet height of pad along Y in Normalized Coordinates (NDC)Definition TPad.h:217; TPad::fMotherTPad * fMother! pointer to mother of the listDefinition TPad.h:105; TPad::SetThetavoid SetTheta(Double_t theta=30) overrideDefinition TPad.h:359; TPad::GetNameconst char * GetName() const overrideReturns name of object.Definition TPad.h:260; TPad::XtoAbsPixelInt_t XtoAbsPixel(Double_t x) const overrideConvert X coordinate to absolute pixel.Definition TPad.cxx:7475; TPad::fGridyBool_t fGridySet to true if grid along Y.Definition TPad.h:101; TPad::SetBBoxY2void SetBBoxY2(const Int_t y) overrideSet bottom of BoundingBox to a value (resize in y direction on bottom)Definition TPad.cxx:7358; TPad::XtoPadDouble_t XtoPad(Double_t x) const overrideConvert x from X to pad.Definition TPad.cxx:3560; TPointDefinition TPoint.h:31; TQObje",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:65534,Security,hash,hash,65534,"erTPad * fMother! pointer to mother of the listDefinition TPad.h:105; TPad::SetThetavoid SetTheta(Double_t theta=30) overrideDefinition TPad.h:359; TPad::GetNameconst char * GetName() const overrideReturns name of object.Definition TPad.h:260; TPad::XtoAbsPixelInt_t XtoAbsPixel(Double_t x) const overrideConvert X coordinate to absolute pixel.Definition TPad.cxx:7475; TPad::fGridyBool_t fGridySet to true if grid along Y.Definition TPad.h:101; TPad::SetBBoxY2void SetBBoxY2(const Int_t y) overrideSet bottom of BoundingBox to a value (resize in y direction on bottom)Definition TPad.cxx:7358; TPad::XtoPadDouble_t XtoPad(Double_t x) const overrideConvert x from X to pad.Definition TPad.cxx:3560; TPointDefinition TPoint.h:31; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TViewSee TView3D.Definition TView.h:25; TVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas.Definition TVirtualPadPainter.h:19; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualViewer3DAbstract 3D shapes viewer.Definition TVirtualViewer3D.h:34; TWebCanvasBasic TCanvasImp ABI implementation for Web-based Graphics Provides painting of main ROOT classes in ...Definition TWebCanvas.h:35; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v1@ v1Definition rootcling_impl.cxx:3701; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361; Drawth1 Draw(). graf2dgpadincTPad.h. ROOT master - Reference Guide Generated on Tue Nov 5 20",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:4096,Testability,log,log,4096,"NDC; ///< Absolute Y top left corner of pad in NDC [0,1]; 71 Double_t fAbsWNDC; ///< Absolute Width of pad along X in NDC; 72 Double_t fAbsHNDC; ///< Absolute Height of pad along Y in NDC; 73 ; 74 Double_t fUxmin; ///< Minimum value on the X axis; 75 Double_t fUymin; ///< Minimum value on the Y axis; 76 Double_t fUxmax; ///< Maximum value on the X axis; 77 Double_t fUymax; ///< Maximum value on the Y axis; 78 ; 79 Double_t fTheta; ///< theta angle to view as lego/surface; 80 Double_t fPhi; ///< phi angle to view as lego/surface; 81 ; 82 Double_t fAspectRatio; ///< ratio of w/h in case of fixed ratio; 83 ; 84 Int_t fPixmapID; ///<! Off-screen pixmap identifier; 85 Int_t fGLDevice; ///<! OpenGL off-screen pixmap identifier; 86 Bool_t fCopyGLDevice; ///<!; 87 Bool_t fEmbeddedGL; ///<!; 88 Int_t fNumber; ///< pad number identifier; 89 Int_t fTickx; ///< Set to 1 if tick marks along X; 90 Int_t fTicky; ///< Set to 1 if tick marks along Y; 91 Int_t fLogx; ///< (=0 if X linear scale, =1 if log scale); 92 Int_t fLogy; ///< (=0 if Y linear scale, =1 if log scale); 93 Int_t fLogz; ///< (=0 if Z linear scale, =1 if log scale); 94 Int_t fPadPaint; ///< Set to 1 while painting the pad; 95 Int_t fCrosshair; ///< Crosshair type (0 if no crosshair requested); 96 Int_t fCrosshairPos; ///< Position of crosshair; 97 Short_t fBorderSize; ///< pad bordersize in pixels; 98 Short_t fBorderMode; ///< Bordermode (-1=down, 0 = no border, 1=up); 99 Bool_t fModified; ///< Set to true when pad is modified; 100 Bool_t fGridx; ///< Set to true if grid along X; 101 Bool_t fGridy; ///< Set to true if grid along Y; 102 Bool_t fAbsCoord; ///< Use absolute coordinates; 103 Bool_t fEditable; ///< True if canvas is editable; 104 Bool_t fFixedAspectRatio; ///< True if fixed aspect ratio; 105 TPad *fMother{nullptr}; ///<! pointer to mother of the list; 106 TCanvas *fCanvas{nullptr}; ///<! Pointer to mother canvas; 107 TList *fPrimitives{nullptr};///<->List of primitives (subpads); 108 TList *fExecs{nullpt",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:4158,Testability,log,log,4158,"ouble_t fAbsWNDC; ///< Absolute Width of pad along X in NDC; 72 Double_t fAbsHNDC; ///< Absolute Height of pad along Y in NDC; 73 ; 74 Double_t fUxmin; ///< Minimum value on the X axis; 75 Double_t fUymin; ///< Minimum value on the Y axis; 76 Double_t fUxmax; ///< Maximum value on the X axis; 77 Double_t fUymax; ///< Maximum value on the Y axis; 78 ; 79 Double_t fTheta; ///< theta angle to view as lego/surface; 80 Double_t fPhi; ///< phi angle to view as lego/surface; 81 ; 82 Double_t fAspectRatio; ///< ratio of w/h in case of fixed ratio; 83 ; 84 Int_t fPixmapID; ///<! Off-screen pixmap identifier; 85 Int_t fGLDevice; ///<! OpenGL off-screen pixmap identifier; 86 Bool_t fCopyGLDevice; ///<!; 87 Bool_t fEmbeddedGL; ///<!; 88 Int_t fNumber; ///< pad number identifier; 89 Int_t fTickx; ///< Set to 1 if tick marks along X; 90 Int_t fTicky; ///< Set to 1 if tick marks along Y; 91 Int_t fLogx; ///< (=0 if X linear scale, =1 if log scale); 92 Int_t fLogy; ///< (=0 if Y linear scale, =1 if log scale); 93 Int_t fLogz; ///< (=0 if Z linear scale, =1 if log scale); 94 Int_t fPadPaint; ///< Set to 1 while painting the pad; 95 Int_t fCrosshair; ///< Crosshair type (0 if no crosshair requested); 96 Int_t fCrosshairPos; ///< Position of crosshair; 97 Short_t fBorderSize; ///< pad bordersize in pixels; 98 Short_t fBorderMode; ///< Bordermode (-1=down, 0 = no border, 1=up); 99 Bool_t fModified; ///< Set to true when pad is modified; 100 Bool_t fGridx; ///< Set to true if grid along X; 101 Bool_t fGridy; ///< Set to true if grid along Y; 102 Bool_t fAbsCoord; ///< Use absolute coordinates; 103 Bool_t fEditable; ///< True if canvas is editable; 104 Bool_t fFixedAspectRatio; ///< True if fixed aspect ratio; 105 TPad *fMother{nullptr}; ///<! pointer to mother of the list; 106 TCanvas *fCanvas{nullptr}; ///<! Pointer to mother canvas; 107 TList *fPrimitives{nullptr};///<->List of primitives (subpads); 108 TList *fExecs{nullptr}; ///< List of commands to be executed when a pad event occu",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:4220,Testability,log,log,4220,"2 Double_t fAbsHNDC; ///< Absolute Height of pad along Y in NDC; 73 ; 74 Double_t fUxmin; ///< Minimum value on the X axis; 75 Double_t fUymin; ///< Minimum value on the Y axis; 76 Double_t fUxmax; ///< Maximum value on the X axis; 77 Double_t fUymax; ///< Maximum value on the Y axis; 78 ; 79 Double_t fTheta; ///< theta angle to view as lego/surface; 80 Double_t fPhi; ///< phi angle to view as lego/surface; 81 ; 82 Double_t fAspectRatio; ///< ratio of w/h in case of fixed ratio; 83 ; 84 Int_t fPixmapID; ///<! Off-screen pixmap identifier; 85 Int_t fGLDevice; ///<! OpenGL off-screen pixmap identifier; 86 Bool_t fCopyGLDevice; ///<!; 87 Bool_t fEmbeddedGL; ///<!; 88 Int_t fNumber; ///< pad number identifier; 89 Int_t fTickx; ///< Set to 1 if tick marks along X; 90 Int_t fTicky; ///< Set to 1 if tick marks along Y; 91 Int_t fLogx; ///< (=0 if X linear scale, =1 if log scale); 92 Int_t fLogy; ///< (=0 if Y linear scale, =1 if log scale); 93 Int_t fLogz; ///< (=0 if Z linear scale, =1 if log scale); 94 Int_t fPadPaint; ///< Set to 1 while painting the pad; 95 Int_t fCrosshair; ///< Crosshair type (0 if no crosshair requested); 96 Int_t fCrosshairPos; ///< Position of crosshair; 97 Short_t fBorderSize; ///< pad bordersize in pixels; 98 Short_t fBorderMode; ///< Bordermode (-1=down, 0 = no border, 1=up); 99 Bool_t fModified; ///< Set to true when pad is modified; 100 Bool_t fGridx; ///< Set to true if grid along X; 101 Bool_t fGridy; ///< Set to true if grid along Y; 102 Bool_t fAbsCoord; ///< Use absolute coordinates; 103 Bool_t fEditable; ///< True if canvas is editable; 104 Bool_t fFixedAspectRatio; ///< True if fixed aspect ratio; 105 TPad *fMother{nullptr}; ///<! pointer to mother of the list; 106 TCanvas *fCanvas{nullptr}; ///<! Pointer to mother canvas; 107 TList *fPrimitives{nullptr};///<->List of primitives (subpads); 108 TList *fExecs{nullptr}; ///< List of commands to be executed when a pad event occurs; 109 TString fName; ///< Pad name; 110 TString fTitle; ///<",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:11883,Testability,log,log,11883, &yup) override;; 212 Double_t GetXlowNDC() const override { return fXlowNDC; }; 213 Double_t GetYlowNDC() const override { return fYlowNDC; }; 214 /// Get width of pad along X in Normalized Coordinates (NDC); 215 Double_t GetWNDC() const override { return fWNDC; }; 216 /// Get height of pad along Y in Normalized Coordinates (NDC); 217 Double_t GetHNDC() const override { return fHNDC; }; 218 UInt_t GetWw() const override;; 219 UInt_t GetWh() const override;; 220 Double_t GetAbsXlowNDC() const override { return fAbsXlowNDC; }; 221 Double_t GetAbsYlowNDC() const override { return fAbsYlowNDC; }; 222 Double_t GetAbsWNDC() const override { return fAbsWNDC; }; 223 Double_t GetAbsHNDC() const override { return fAbsHNDC; }; 224 Double_t GetAspectRatio() const override { return fAspectRatio; }; 225 Double_t GetPhi() const override { return fPhi; }; 226 Double_t GetTheta() const override { return fTheta; }; 227 ///Returns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 228 Double_t GetUxmin() const override { return fUxmin; }; 229 ///Returns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 230 Double_t GetUymin() const override { return fUymin; }; 231 ///Returns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 232 Double_t GetUxmax() const override { return fUxmax; }; 233 ///Returns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 234 Double_t GetUymax() const override { return fUymax; }; 235 Bool_t GetGridx() const override { return fGridx; }; 236 Bool_t GetGridy() const override { return fGridy; }; 237 Int_t GetNumber() const override { return fNumber; }; 238 Int_t GetTickx() const override { return fTickx; }; 239 Int_t GetTicky() const override { return fTicky; }; 240 Double_t GetX1() const override { return fX1; }; 241 Double_t GetX2() const override { return fX2; }; 242 Double,MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:12055,Testability,log,log,12055,ng X in Normalized Coordinates (NDC); 215 Double_t GetWNDC() const override { return fWNDC; }; 216 /// Get height of pad along Y in Normalized Coordinates (NDC); 217 Double_t GetHNDC() const override { return fHNDC; }; 218 UInt_t GetWw() const override;; 219 UInt_t GetWh() const override;; 220 Double_t GetAbsXlowNDC() const override { return fAbsXlowNDC; }; 221 Double_t GetAbsYlowNDC() const override { return fAbsYlowNDC; }; 222 Double_t GetAbsWNDC() const override { return fAbsWNDC; }; 223 Double_t GetAbsHNDC() const override { return fAbsHNDC; }; 224 Double_t GetAspectRatio() const override { return fAspectRatio; }; 225 Double_t GetPhi() const override { return fPhi; }; 226 Double_t GetTheta() const override { return fTheta; }; 227 ///Returns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 228 Double_t GetUxmin() const override { return fUxmin; }; 229 ///Returns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 230 Double_t GetUymin() const override { return fUymin; }; 231 ///Returns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 232 Double_t GetUxmax() const override { return fUxmax; }; 233 ///Returns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 234 Double_t GetUymax() const override { return fUymax; }; 235 Bool_t GetGridx() const override { return fGridx; }; 236 Bool_t GetGridy() const override { return fGridy; }; 237 Int_t GetNumber() const override { return fNumber; }; 238 Int_t GetTickx() const override { return fTickx; }; 239 Int_t GetTicky() const override { return fTicky; }; 240 Double_t GetX1() const override { return fX1; }; 241 Double_t GetX2() const override { return fX2; }; 242 Double_t GetY1() const override { return fY1; }; 243 Double_t GetY2() const override { return fY2; }; 244 static Int_t GetMaxPickDistance();; 245 TList *GetListOfPrimitives() con,MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:12227,Testability,log,log,12227,"_t GetHNDC() const override { return fHNDC; }; 218 UInt_t GetWw() const override;; 219 UInt_t GetWh() const override;; 220 Double_t GetAbsXlowNDC() const override { return fAbsXlowNDC; }; 221 Double_t GetAbsYlowNDC() const override { return fAbsYlowNDC; }; 222 Double_t GetAbsWNDC() const override { return fAbsWNDC; }; 223 Double_t GetAbsHNDC() const override { return fAbsHNDC; }; 224 Double_t GetAspectRatio() const override { return fAspectRatio; }; 225 Double_t GetPhi() const override { return fPhi; }; 226 Double_t GetTheta() const override { return fTheta; }; 227 ///Returns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 228 Double_t GetUxmin() const override { return fUxmin; }; 229 ///Returns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 230 Double_t GetUymin() const override { return fUymin; }; 231 ///Returns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 232 Double_t GetUxmax() const override { return fUxmax; }; 233 ///Returns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 234 Double_t GetUymax() const override { return fUymax; }; 235 Bool_t GetGridx() const override { return fGridx; }; 236 Bool_t GetGridy() const override { return fGridy; }; 237 Int_t GetNumber() const override { return fNumber; }; 238 Int_t GetTickx() const override { return fTickx; }; 239 Int_t GetTicky() const override { return fTicky; }; 240 Double_t GetX1() const override { return fX1; }; 241 Double_t GetX2() const override { return fX2; }; 242 Double_t GetY1() const override { return fY1; }; 243 Double_t GetY2() const override { return fY2; }; 244 static Int_t GetMaxPickDistance();; 245 TList *GetListOfPrimitives() const override { return fPrimitives; }; 246 TList *GetListOfExecs() const override { return fExecs; }; 247 TObject *GetPrimitive(const char *name) const override; //obsolete, ",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:12399,Testability,log,log,12399,"fAbsXlowNDC; }; 221 Double_t GetAbsYlowNDC() const override { return fAbsYlowNDC; }; 222 Double_t GetAbsWNDC() const override { return fAbsWNDC; }; 223 Double_t GetAbsHNDC() const override { return fAbsHNDC; }; 224 Double_t GetAspectRatio() const override { return fAspectRatio; }; 225 Double_t GetPhi() const override { return fPhi; }; 226 Double_t GetTheta() const override { return fTheta; }; 227 ///Returns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 228 Double_t GetUxmin() const override { return fUxmin; }; 229 ///Returns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 230 Double_t GetUymin() const override { return fUymin; }; 231 ///Returns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 232 Double_t GetUxmax() const override { return fUxmax; }; 233 ///Returns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 234 Double_t GetUymax() const override { return fUymax; }; 235 Bool_t GetGridx() const override { return fGridx; }; 236 Bool_t GetGridy() const override { return fGridy; }; 237 Int_t GetNumber() const override { return fNumber; }; 238 Int_t GetTickx() const override { return fTickx; }; 239 Int_t GetTicky() const override { return fTicky; }; 240 Double_t GetX1() const override { return fX1; }; 241 Double_t GetX2() const override { return fX2; }; 242 Double_t GetY1() const override { return fY1; }; 243 Double_t GetY2() const override { return fY2; }; 244 static Int_t GetMaxPickDistance();; 245 TList *GetListOfPrimitives() const override { return fPrimitives; }; 246 TList *GetListOfExecs() const override { return fExecs; }; 247 TObject *GetPrimitive(const char *name) const override; //obsolete, use FindObject instead; 248 TObject *GetSelected() const override;; 249 TVirtualPad *GetPad(Int_t subpadnumber) const override;; 250 TObject *GetPadPointer() const override",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:31213,Testability,log,log,31213,"ent)Hide tool tip depending on the event type.Definition TPad.cxx:2847; TPad::fAbsYlowNDCDouble_t fAbsYlowNDCAbsolute Y top left corner of pad in NDC [0,1].Definition TPad.h:70; TPad::fXtoAbsPixelkDouble_t fXtoAbsPixelkConversion coefficient for X World to absolute pixel.Definition TPad.h:41; TPad::SetAttMarkerPSvoid SetAttMarkerPS(Color_t color, Style_t style, Size_t msize) overrideSet postscript marker attributes.Definition TPad.cxx:6227; TPad::DivideSquarevirtual void DivideSquare(Int_t n, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)""n"" is the total number of sub-pads.Definition TPad.cxx:1341; TPad::AbsCoordinatesvoid AbsCoordinates(Bool_t set) overrideDefinition TPad.h:167; TPad::AbsPixeltoYDouble_t AbsPixeltoY(Int_t py) overrideDefinition TPad.h:169; TPad::IsBatchBool_t IsBatch() const overrideIs pad in batch mode ?Definition TPad.cxx:2856; TPad::GetUymaxDouble_t GetUymax() const overrideReturns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decad...Definition TPad.h:234; TPad::AddExecvoid AddExec(const char *name, const char *command) overrideAdd a new TExec object to the list of Execs.Definition TPad.cxx:498; TPad::SetViewer3Dvoid SetViewer3D(TVirtualViewer3D *viewer3d) overrideDefinition TPad.h:364; TPad::fWNDCDouble_t fWNDCWidth of pad along X in Normalized Coordinates (NDC)Definition TPad.h:66; TPad::SetNamevoid SetName(const char *name) overrideDefinition TPad.h:353; TPad::NextPaletteColorInt_t NextPaletteColor() overrideGet the next autocolor in the pad.Definition TPad.cxx:3118; TPad::VtoPixelInt_t VtoPixel(Double_t v) const overrideConvert Y NDC to pixel.Definition TPad.cxx:7446; TPad::PaintBordervoid PaintBorder(Color_t color, Bool_t tops)Paint the pad border.Definition TPad.cxx:3644; TPad::GetPhiDouble_t GetPhi() const overrideDefinition TPad.h:225; TPad::IsEditableBool_t IsEditable() const overrideDefinition TPad.h:272; TPad::FillCollideGridvoid FillCollideGrid(TObject *o)Initialise the grid used",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:34851,Testability,log,log,34851,"l void RecordLatex(const TObject *obj)Emit RecordLatex() signal.Definition TPad.cxx:7254; TPad::fAbsXlowNDCDouble_t fAbsXlowNDCAbsolute X top left corner of pad in NDC [0,1].Definition TPad.h:69; TPad::GetListOfExecsTList * GetListOfExecs() const overrideDefinition TPad.h:246; TPad::SetTickxvoid SetTickx(Int_t value=1) overrideDefinition TPad.h:356; TPad::fVtoPixelkDouble_t fVtoPixelkConversion coefficient for V NDC to pixel.Definition TPad.h:52; TPad::fGridxBool_t fGridxSet to true if grid along X.Definition TPad.h:100; TPad::fPadView3DTObject * fPadView3D! 3D View of this TPadDefinition TPad.h:114; TPad::SetTitlevoid SetTitle(const char *title="""") overrideDefinition TPad.h:358; TPad::CopyBackgroundPixmapsvoid CopyBackgroundPixmaps(TPad *start, TPad *stop, Int_t x, Int_t y)Copy pixmaps of pads laying below pad ""stop"" into pad ""stop"".Definition TPad.cxx:3990; TPad::GetUxmaxDouble_t GetUxmax() const overrideReturns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decad...Definition TPad.h:232; TPad::Dividevoid Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0) overrideAutomatic pad generation by division.Definition TPad.cxx:1249; TPad::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitives in this pad on the C++ source file out.Definition TPad.cxx:5847; TPad::StartEditingvirtual void StartEditing()Definition TPad.h:417; TPad::fXtoPixelDouble_t fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworldDefinition TPad.h:43; TPad::fExecsTList * fExecsList of commands to be executed when a pad event occurs.Definition TPad.h:108; TPad::PadtoYDouble_t PadtoY(Double_t y) const overrideConvert y from pad to Y.Definition TPad.cxx:3551; TPad::fTickxInt_t fTickxSet to 1 if tick marks along X.Definition TPad.h:89; TPad::SetBBoxY1void SetBBoxY1(const Int_t y) overrideSet top of BoundingBox to a value (resize in y direction on top)Definition TPad.cxx:7348; TPad::fTickyInt_t ",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:39821,Testability,log,log,39821,"261; TPad::PaintDatevoid PaintDate()Paint the current date and time if the option Date is set on via gStyle->SetOptDate() Paint the curre...Definition TPad.cxx:3750; TPad::SetMaxPickDistancestatic void SetMaxPickDistance(Int_t maxPick=5)static function to set the maximum Pick Distance fgMaxPickDistance This parameter is used in TPad::Pi...Definition TPad.cxx:6680; TPad::SetBBoxX2void SetBBoxX2(const Int_t x) overrideSet right hand side of BoundingBox to a value (resize in x direction on right)Definition TPad.cxx:7339; TPad::SetBBoxX1void SetBBoxX1(const Int_t x) overrideSet lefthandside of BoundingBox to a value (resize in x direction on left)Definition TPad.cxx:7328; TPad::ClippingCodevirtual Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2)Compute the endpoint codes for TPad::Clip.Definition TPad.cxx:901; TPad::GetUyminDouble_t GetUymin() const overrideReturns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decad...Definition TPad.h:230; TPad::fX1Double_t fX1X of lower X coordinate.Definition TPad.h:36; TPad::GetListOfPrimitivesTList * GetListOfPrimitives() const overrideDefinition TPad.h:245; TPad::GetPadPointerTObject * GetPadPointer() const overrideDefinition TPad.h:250; TPad::DrawFrameTH1F * DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char *title="""") overrideDraw an empty pad frame with X and Y axis.Definition TPad.cxx:1678; TPad::fVtoPixelDouble_t fVtoPixelypixel = fVtoPixelk + fVtoPixel*vndcDefinition TPad.h:53; TPad::GetCanvasImpTCanvasImp * GetCanvasImp() const overrideGet canvas implementation pointer if any.Definition TPad.cxx:2746; TPad::GetEventInt_t GetEvent() const overrideGet Event.Definition TPad.cxx:2754; TPad::GetView3DTObject * GetView3D() const overrideDefinition TPad.h:255; TPad::PadtoXDouble_t PadtoX(Double_t x) const overrideConvert x from pad to X.Definition TPad.cxx:3542; TPad::PixeltoXYvirtual void PixeltoXY(Int_t x",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:41705,Testability,log,log,41705,"5; TPad::PadtoXDouble_t PadtoX(Double_t x) const overrideConvert x from pad to X.Definition TPad.cxx:3542; TPad::PixeltoXYvirtual void PixeltoXY(Int_t xpixel, Int_t ypixel, Double_t &x, Double_t &y)Convert pixel to X/Y coordinates.Definition TPad.cxx:7406; TPad::DrawCrosshairvirtual void DrawCrosshair()Function called to draw a crosshair in the canvas.Definition TPad.cxx:1605; TPad::YtoPadDouble_t YtoPad(Double_t y) const overrideConvert y from Y to pad.Definition TPad.cxx:3572; TPad::RangeChangedvirtual void RangeChanged()Definition TPad.h:316; TPad::fUyminDouble_t fUyminMinimum value on the Y axis.Definition TPad.h:75; TPad::SetPadvoid SetPad(const char *name, const char *title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color=35, Short_t bordersize=5, Short_t bordermode=-1) overrideSet all pad parameters.Definition TPad.cxx:6171; TPad::GetCanvasIDInt_t GetCanvasID() const overrideGet canvas identifier.Definition TPad.cxx:2738; TPad::fLogzInt_t fLogz(=0 if Z linear scale, =1 if log scale)Definition TPad.h:93; TPad::fYtoPixelkDouble_t fYtoPixelkConversion coefficient for Y World to pixel.Definition TPad.h:45; TPad::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TPad.cxx:2947; TPad::TPadTPad()Pad default constructor.Definition TPad.cxx:132; TPad::AbsPixeltoXDouble_t AbsPixeltoX(Int_t px) overrideDefinition TPad.h:168; TPad::UseCurrentStylevoid UseCurrentStyle() overrideForce a copy of current style for all objects in pad.Definition TPad.cxx:6927; TPad::GetMaxPickDistancestatic Int_t GetMaxPickDistance()Static function (see also TPad::SetMaxPickDistance)Definition TPad.cxx:2794; TPad::VtoAbsPixelInt_t VtoAbsPixel(Double_t v) const overrideConvert Y NDC to absolute pixel.Definition TPad.cxx:7467; TPad::Rangevoid Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2) overrideSet world coordinate system for the pad.Definition TPad.cxx:5331; TPad::EventPavevirtual void EventPave()Definition TPad.h:416; TPad::fUtoPixelkDo",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:48486,Testability,log,log,48486,"65; TPad::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a box.Definition TPad.cxx:1174; TPad::fFixedAspectRatioBool_t fFixedAspectRatioTrue if fixed aspect ratio.Definition TPad.h:104; TPad::PaintFillAreavoid PaintFillArea(Int_t n, Float_t *x, Float_t *y, Option_t *option="""") overrideDefinition TPad.cxx:4017; TPad::Modifiedvoid Modified(Bool_t flag=true) overrideMark pad modified Will be repainted when TCanvas::Update() will be called next time.Definition TPad.cxx:7369; TPad::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from a pad and its sub-pads.Definition TPad.cxx:5389; TPad::HasFixedAspectRatioBool_t HasFixedAspectRatio() const overrideDefinition TPad.h:270; TPad::CloseToolTipvoid CloseToolTip(TObject *tip) overrideHide tool tip.Definition TPad.cxx:7123; TPad::GetUxminDouble_t GetUxmin() const overrideReturns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decad...Definition TPad.h:228; TPad::SetToolTipTextvoid SetToolTipText(const char *text, Long_t delayms=1000) overrideSet tool tip text associated with this pad.Definition TPad.cxx:6690; TPad::PaintPolyLinevoid PaintPolyLine(Int_t n, Float_t *x, Float_t *y, Option_t *option="""") overridePaint polyline in CurrentPad World coordinates.Definition TPad.cxx:4392; TPad::lsvoid ls(Option_t *option="""") const overrideList all primitives in pad.Definition TPad.cxx:3090; TPad::GetViewTView * GetView() const overrideDefinition TPad.h:254; TPad::ModifiedUpdatevoid ModifiedUpdate() overrideShort cut to call Modified() and Update() in a single call.Definition TPad.cxx:3530; TPad::fVtoAbsPixelkDouble_t fVtoAbsPixelkConversion coefficient for V NDC to absolute pixel.Definition TPad.h:51; TPad::GetPadSaveTVirtualPad * GetPadSave() const overrideGet save pad.Definition TPad.cxx:2820; TPad::SetAttLinePSvoid SetAttLinePS(Color_t color, Style_t style, Width_t lwidth) overrideSet postscript li",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:53002,Testability,log,log,53002," AutoExec()Execute the list of Execs when a pad event occurs.Definition TPad.cxx:508; TPad::fAbsCoordBool_t fAbsCoordUse absolute coordinates.Definition TPad.h:102; TPad::fNumPaletteColorInt_t fNumPaletteColorNumber of objects with an automatic color.Definition TPad.h:116; TPad::fCrosshairPosInt_t fCrosshairPosPosition of crosshair.Definition TPad.h:96; TPad::FillCollideGridTGraphvoid FillCollideGridTGraph(TObject *o)Definition TPad.cxx:3360; TPad::SetFixedAspectRatiovoid SetFixedAspectRatio(Bool_t fixed=kTRUE) overrideFix pad aspect ratio to current value if fixed is true.Definition TPad.cxx:6031; TPad::GetBorderSizeShort_t GetBorderSize() const overrideDefinition TPad.h:200; TPad::RedrawAxisvoid RedrawAxis(Option_t *option="""") overrideRedraw the frame axis.Definition TPad.cxx:5450; TPad::DrawDistvoid DrawDist(Rectangle_t aBBox, Rectangle_t bBBox, char mode)Draw Arrows to indicated equal distances of Objects with given BBoxes.Definition TPad.cxx:6266; TPad::fLogxInt_t fLogx(=0 if X linear scale, =1 if log scale)Definition TPad.h:91; TPad::GetAbsWNDCDouble_t GetAbsWNDC() const overrideDefinition TPad.h:222; TPad::YtoAbsPixelInt_t YtoAbsPixel(Double_t y) const overrideConvert Y coordinate to absolute pixel.Definition TPad.cxx:7499; TPad::fUtoPixelDouble_t fUtoPixelxpixel = fUtoPixelk + fUtoPixel*undcDefinition TPad.h:50; TPad::fCrosshairInt_t fCrosshairCrosshair type (0 if no crosshair requested)Definition TPad.h:95; TPad::PaintFillAreaHatchesvoid PaintFillAreaHatches(Int_t n, Double_t *x, Double_t *y, Int_t FillStyle)This function paints hatched fill area according to the FillStyle value The convention for the Hatch ...Definition TPad.cxx:4108; TPad::RangeAxisvoid RangeAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax) overrideSet axis coordinate system for the pad.Definition TPad.cxx:5369; TPad::fUtoAbsPixelkDouble_t fUtoAbsPixelkConversion coefficient for U NDC to absolute pixel.Definition TPad.h:48; TPad::ResetToolTipvoid ResetToolTip(TObject *tip) o",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPad_8h_source.html:58355,Testability,log,log,58355," Current pad.Definition TPad.cxx:693; TPad::GetLogyInt_t GetLogy() const overrideDefinition TPad.h:257; TPad::PaintLineNDCvoid PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2) overridePaint line in normalized coordinates.Definition TPad.cxx:4336; TPad::PixeltoYDouble_t PixeltoY(Int_t py) overrideConvert pixel to Y coordinate.Definition TPad.cxx:7397; TPad::Printvoid Print(const char *filename="""") const overrideThis method is equivalent to SaveAs(""filename""). See TPad::SaveAs for details.Definition TPad.cxx:4798; TPad::GetEventXInt_t GetEventX() const overrideGet X event.Definition TPad.cxx:2762; TPad::GetFrameTFrame * GetFrame() overrideGet frame.Definition TPad.cxx:2955; TPad::fYUpNDCDouble_t fYUpNDCDefinition TPad.h:65; TPad::fYtoAbsPixelkDouble_t fYtoAbsPixelkConversion coefficient for Y World to absolute pixel.Definition TPad.h:44; TPad::fXtoPixelkDouble_t fXtoPixelkConversion coefficient for X World to pixel.Definition TPad.h:42; TPad::fLogyInt_t fLogy(=0 if Y linear scale, =1 if log scale)Definition TPad.h:92; TPad::fFrameTFrame * fFrame! Pointer to 2-D frame (if one exists)Definition TPad.h:111; TPad::GetPainterTVirtualPadPainter * GetPainter() overrideGet pad painter from TCanvas.Definition TPad.cxx:7262; TPad::Closedvirtual void Closed()Definition TPad.h:184; TPad::fHNDCDouble_t fHNDCHeight of pad along Y in Normalized Coordinates (NDC)Definition TPad.h:67; TPad::ShowGuidelinesvoid ShowGuidelines(TObject *object, const Int_t event, const char mode='i', const bool cling=true) overrideShows lines to indicate if a TAttBBox2D object is aligned to the center or to another object,...Definition TPad.cxx:6350; TPad::GetCrosshairInt_t GetCrosshair() constReturn the crosshair type (from the mother canvas) crosshair type = 0 means no crosshair.Definition TPad.cxx:6651; TPad::GetRangeAxisvoid GetRangeAxis(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) overrideReturn pad axis coordinates range.Definition TPad.cxx:3043; TPad::SetBorderMode",MatchSource.WIKI,doc/master/TPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html
https://root.cern/doc/master/TPaveStats_8h_source.html:4239,Usability,simpl,simple,4239,"ion_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TPaveText.h; TVirtualPaveStats.h; TBoxCreate a Box.Definition TBox.h:22; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObjectMother of all ROOT objects.Definition TObject.h:41; TPaveStatsThe histogram statistics painter class.Definition TPaveStats.h:18; TPaveStats::TPaveStatsTPaveStats()TPaveStats default constructor.Definition TPaveStats.cxx:231; TPaveStats::GetOptStatInt_t GetOptStat() constReturn the stat option.Definition TPaveStats.cxx:271; TPaveStats::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TPaveStats.cxx:504; TPaveStats::EditTextvoid EditText() overrideEdit text at the mouse position.Definition TPaveStats.h:34; TPaveStats::UseCurrentStylevoid UseCurrentStyle() overrideReplace current attributes by current style.Definition TPaveStats.cxx:570; TPaveStats::InsertTextvoid InsertText(const char *) overrideAdd a new Text line at the mouse position.Definition TPaveStats.h:41; TPaveStats::InsertLinevoid InsertLine() overrideAdd a new line at t",MatchSource.WIKI,doc/master/TPaveStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPaveStats_8h_source.html
https://root.cern/doc/master/TPaveText_8cxx_source.html:37921,Availability,error,error,37921,"e list.Definition TList.cxx:194; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Paintvoid Paint(Option_t *option="""") overridePaint this pavelabel with its current attributes.Definition TPaveLabel.cxx:111; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Classstatic TClass * Class(); TPaveText::fLongestInt_t fLongestLength of the longest line.Definition TPaveText.h:25; TPaveText::GetSizevirtual Int_t GetSize() constreturn number of text lines (ignoring TLine, etc)Definition TPaveText.cxx:373; TPaveText::~TPaveText~TPaveText() overridepavetext default destructor.Definition TPaveText.cxx:118; TPaveT",MatchSource.WIKI,doc/master/TPaveText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPaveText_8cxx_source.html
https://root.cern/doc/master/TPaveText_8cxx_source.html:37927,Integrability,message,message,37927,"e list.Definition TList.cxx:194; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Paintvoid Paint(Option_t *option="""") overridePaint this pavelabel with its current attributes.Definition TPaveLabel.cxx:111; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Classstatic TClass * Class(); TPaveText::fLongestInt_t fLongestLength of the longest line.Definition TPaveText.h:25; TPaveText::GetSizevirtual Int_t GetSize() constreturn number of text lines (ignoring TLine, etc)Definition TPaveText.cxx:373; TPaveText::~TPaveText~TPaveText() overridepavetext default destructor.Definition TPaveText.cxx:118; TPaveT",MatchSource.WIKI,doc/master/TPaveText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPaveText_8cxx_source.html
https://root.cern/doc/master/TPaveText_8cxx_source.html:3657,Modifiability,inherit,inherits,3657,"is a Pave with several lines of text; 84///; 85/// - option = ""TR"" Top and Right shadows are drawn.; 86/// - option = ""TL"" Top and Left shadows are drawn.; 87/// - option = ""BR"" Bottom and Right shadows are drawn.; 88/// - option = ""BL"" Bottom and Left shadows are drawn.; 89///; 90/// If none of these four above options is specified the default the; 91/// option ""BR"" will be used to draw the border. To produces a pave; 92/// without any border it is enough to specify the option ""NB"" (no border).; 93/// If you want to remove the border or shadow of an already existing TPaveText,; 94/// then use the function TPave::SetBorderSize.; 95///; 96/// - option = ""NDC"" x1,y1,x2,y2 are given in NDC; 97/// - option = ""ARC"" corners are rounded; 98///; 99/// In case of option ""ARC"", the corner radius is specified; 100/// via TPave::SetCornerRadius(rad) where rad is given in percent; 101/// of the pave height (default value is 0.2).; 102///; 103/// The individual text items are entered via AddText; 104/// By default, text items inherits from the default pavetext AttText.; 105/// A title can be added later to this pavetext via TPaveText::SetLabel.; 106 ; 107TPaveText::TPaveText(Double_t x1, Double_t y1,Double_t x2, Double_t y2, Option_t *option); 108 :TPave(x1,y1,x2,y2,4,option), TAttText(22,0,gStyle->GetTextColor(),gStyle->GetTextFont(),0); 109{; 110 fLines = new TList;; 111 fMargin = 0.05;; 112 fLongest = 0;; 113}; 114 ; 115////////////////////////////////////////////////////////////////////////////////; 116/// pavetext default destructor.; 117 ; 118TPaveText::~TPaveText(); 119{; 120 if (ROOT::Detail::HasBeenDeleted(this)) return;; 121 if (fLines) fLines->Delete();; 122 delete fLines;; 123 fLines = nullptr;; 124}; 125 ; 126////////////////////////////////////////////////////////////////////////////////; 127/// pavetext copy constructor.; 128 ; 129TPaveText::TPaveText(const TPaveText &pavetext) : TPave(pavetext), TAttText(pavetext); 130{; 131 fLabel = pavetext.fLabel;; 132 fLongest ",MatchSource.WIKI,doc/master/TPaveText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPaveText_8cxx_source.html
https://root.cern/doc/master/TPaveText_8cxx_source.html:37773,Modifiability,inherit,inherits,37773,"ct in the list. Returns 0 when list is empty.Definition TList.cxx:691; TList::AddBeforevoid AddBefore(const TObject *before, TObject *obj) overrideInsert object before object before in the list.Definition TList.cxx:194; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Paintvoid Paint(Option_t *option="""") overridePaint this pavelabel with its current attributes.Definition TPaveLabel.cxx:111; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Classstatic TClass * Class(); TPaveText::fLongestInt_t fLongestLength of the longest line.Definition TPaveText.h:25; TPaveText::GetSizevirtual Int_t GetSize() co",MatchSource.WIKI,doc/master/TPaveText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPaveText_8cxx_source.html
https://root.cern/doc/master/TPaveText_8cxx_source.html:35795,Usability,simpl,simple,35795,"uffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TCollection::Printvoid Print(Option_t *option="""") const overrideDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::GetXsizeDouble_t GetXsize()Return size of the formula along X in pad coordinates when the text precision is smaller than 3.Definition TLatex.cxx:2569; TLatex::Classstatic TClass * Class(); TLatex::PaintLatexvirtual void PaintLatex(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Main drawing function.Definition TLatex.cxx:2114; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::Classstatic TClass * Class(); TLine::PaintLinevirtual void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:399; TLine::GetY1Double_t GetY1() constDefinition TLine.h:52; TLine::GetX2Double_t GetX2() constDefinition TLine.h:51; TLine::IsATClass * IsA() const overrideDefinition TLine.h:79; TLine::GetX1Double_t GetX1() constDefinition TLine.h:50; TLine::GetY2Double_t GetY2() constDefinition TLine.h:53; TListA doubly linked list.Definition TList.h:38; TList::AddAftervoid AddAfter(const TObject *after, TObject *obj) overrideInsert object after object after in the list.Definition TList.cxx:248; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::LastTObject * Last() const overrideReturn the last object in the list. Returns 0 when list is em",MatchSource.WIKI,doc/master/TPaveText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPaveText_8cxx_source.html
https://root.cern/doc/master/TPaveText_8h_source.html:5061,Usability,simpl,simple,5061,"r ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TPave.h; TText.h; TAttTextText Attributes class.Definition TAttText.h:18; TBoxCreate a Box.Definition TBox.h:22; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TListA doubly linked list.Definition TList.h:38; TObjectMother of all ROOT objects.Definition TObject.h:41; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::fLongestInt_t fLongestLength of the longest line.Definition TPaveText.h:25; TPaveText::GetSizevirtual Int_t GetSize() constreturn number of text lines (ignoring TLine, etc)Definition TPaveText.cxx:373; TPaveText::~TPaveText~TPaveText() overridepavetext default destructor.Definition TPaveText.cxx:118; TPaveText::GetListOfLinesvirtual TList * GetListOfLines() constDefinition TPaveText.h:48; TPaveText::GetLabelconst char * GetLabel() constDefinition TPaveText.h:45; TPaveText::fLinesTList * fLinesList of labels.Definition TPaveText.h:27; TPaveText::PaintPrimit",MatchSource.WIKI,doc/master/TPaveText_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPaveText_8h_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:28596,Availability,error,error,28596,"254; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPolyLineDefined by an array on N points in a 2-D space.Definition TPolyLine.h:23; TPolyLine::fOptionTString fOptionoptionsDefinition TPolyLine.h:30; TPolyLine::Sizevirtual Int_t Size() constDefinition TPolyLine.h:71; TPolyLine::fLastPointInt_t fLastPointThe index of the last filled point.Definition TPolyLine.h:27; TPolyLine::Mergevirtual Int_t Merge(TCollection *list)Merge polylines in the collection in this polyline.Definition TPolyLine.cxx:479; TPolyLine::PaintPolyLineNDCvirtual void PaintPolyLineNDC(Int_t n, Double_t *x, Double_t *y, Option_t *option="""")Draw this polyline with new coordinates in NDC.Definition TPolyLine.cxx:560; TPolyLine::Copyvoid Copy(TObject &polyline) const overrideCopy this polyline to polyline.Definition TPolyLine.cxx:140; TPolyLine::DistancetoPrimitiveInt_t Distanc",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:7777,Deployability,release,released,7777," 210}; 211 ; 212////////////////////////////////////////////////////////////////////////////////; 213/// Draw this polyline with its current attributes.; 214 ; 215void TPolyLine::Draw(Option_t *option); 216{; 217 AppendPad(option);; 218}; 219 ; 220////////////////////////////////////////////////////////////////////////////////; 221/// Draw this polyline with new coordinates.; 222 ; 223TPolyLine *TPolyLine::DrawPolyLine(Int_t n, Double_t *x, Double_t *y, Option_t *option); 224{; 225 TPolyLine *newpolyline = new TPolyLine(n,x,y);; 226 TAttLine::Copy(*newpolyline);; 227 TAttFill::Copy(*newpolyline);; 228 newpolyline->fOption = fOption;; 229 newpolyline->SetBit(kCanDelete);; 230 newpolyline->AppendPad(option);; 231 return newpolyline;; 232}; 233 ; 234////////////////////////////////////////////////////////////////////////////////; 235/// Execute action corresponding to one event.; 236///; 237/// This member function is called when a polyline is clicked with the locator; 238///; 239/// If Left button clicked on one of the line end points, this point; 240/// follows the cursor until button is released.; 241///; 242/// if Middle button clicked, the line is moved parallel to itself; 243/// until the button is released.; 244 ; 245void TPolyLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); 246{; 247 if (!gPad) return;; 248 ; 249 Int_t i, d;; 250 Double_t xmin, xmax, ymin, ymax, dx, dy, dxr, dyr;; 251 const Int_t kMaxDiff = 10;; 252 static Bool_t middle;; 253 static Int_t ipoint, pxp, pyp;; 254 static Int_t px1,px2,py1,py2;; 255 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 256 static Int_t dpx, dpy;; 257 static std::vector<Int_t> x, y;; 258 Bool_t opaque = gPad->OpaqueMoving();; 259 ; 260 if (!gPad->IsEditable()) return;; 261 ; 262 Int_t np = Size();; 263 ; 264 switch (event) {; 265 ; 266 case kButton1Down:; 267 gVirtualX->SetLineColor(-1);; 268 TAttLine::Modify(); //Change line attributes only if necessary; 269 px1 = gPad->XtoAbsPixel(gPad->GetX1());; 270 py1",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:7894,Deployability,release,released,7894,"lyLine::Draw(Option_t *option); 216{; 217 AppendPad(option);; 218}; 219 ; 220////////////////////////////////////////////////////////////////////////////////; 221/// Draw this polyline with new coordinates.; 222 ; 223TPolyLine *TPolyLine::DrawPolyLine(Int_t n, Double_t *x, Double_t *y, Option_t *option); 224{; 225 TPolyLine *newpolyline = new TPolyLine(n,x,y);; 226 TAttLine::Copy(*newpolyline);; 227 TAttFill::Copy(*newpolyline);; 228 newpolyline->fOption = fOption;; 229 newpolyline->SetBit(kCanDelete);; 230 newpolyline->AppendPad(option);; 231 return newpolyline;; 232}; 233 ; 234////////////////////////////////////////////////////////////////////////////////; 235/// Execute action corresponding to one event.; 236///; 237/// This member function is called when a polyline is clicked with the locator; 238///; 239/// If Left button clicked on one of the line end points, this point; 240/// follows the cursor until button is released.; 241///; 242/// if Middle button clicked, the line is moved parallel to itself; 243/// until the button is released.; 244 ; 245void TPolyLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); 246{; 247 if (!gPad) return;; 248 ; 249 Int_t i, d;; 250 Double_t xmin, xmax, ymin, ymax, dx, dy, dxr, dyr;; 251 const Int_t kMaxDiff = 10;; 252 static Bool_t middle;; 253 static Int_t ipoint, pxp, pyp;; 254 static Int_t px1,px2,py1,py2;; 255 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 256 static Int_t dpx, dpy;; 257 static std::vector<Int_t> x, y;; 258 Bool_t opaque = gPad->OpaqueMoving();; 259 ; 260 if (!gPad->IsEditable()) return;; 261 ; 262 Int_t np = Size();; 263 ; 264 switch (event) {; 265 ; 266 case kButton1Down:; 267 gVirtualX->SetLineColor(-1);; 268 TAttLine::Modify(); //Change line attributes only if necessary; 269 px1 = gPad->XtoAbsPixel(gPad->GetX1());; 270 py1 = gPad->YtoAbsPixel(gPad->GetY1());; 271 px2 = gPad->XtoAbsPixel(gPad->GetX2());; 272 py2 = gPad->YtoAbsPixel(gPad->GetY2());; 273 ipoint = -1;; 274 ; 275 ; 276 if (!x.em",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:20485,Energy Efficiency,allocate,allocate,20485,"NDC);; 607}; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// Set point following LastPoint to x, y.; 611/// Returns index of the point (new last point).; 612 ; 613Int_t TPolyLine::SetNextPoint(Double_t x, Double_t y); 614{; 615 fLastPoint++;; 616 SetPoint(fLastPoint, x, y);; 617 return fLastPoint;; 618}; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// Set point number n to (x, y); 622/// If n is greater than the current size, the arrays are automatically; 623/// extended.; 624 ; 625void TPolyLine::SetPoint(Int_t n, Double_t x, Double_t y); 626{; 627 if (n < 0) return;; 628 if (!fX || !fY || n >= fN) {; 629 // re-allocate the object; 630 Int_t newN = TMath::Max(2*fN,n+1);; 631 Double_t *savex = new Double_t [newN];; 632 Double_t *savey = new Double_t [newN];; 633 if (fX && fN){; 634 memcpy(savex,fX,fN*sizeof(Double_t));; 635 memset(&savex[fN],0,(newN-fN)*sizeof(Double_t));; 636 delete [] fX;; 637 }; 638 if (fY && fN){; 639 memcpy(savey,fY,fN*sizeof(Double_t));; 640 memset(&savey[fN],0,(newN-fN)*sizeof(Double_t));; 641 delete [] fY;; 642 }; 643 fX = savex;; 644 fY = savey;; 645 fN = newN;; 646 }; 647 fX[n] = x;; 648 fY[n] = y;; 649 fLastPoint = TMath::Max(fLastPoint, n);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Resize this polyline to size n.; 654/// If n <= 0 the current arrays of points are deleted.; 655/// If n is greater than the current size, the new points are set to (0, 0); 656 ; 657void TPolyLine::SetPolyLine(Int_t n); 658{; 659 if (n <= 0) {; 660 fN = 0;; 661 fLastPoint = -1;; 662 delete [] fX;; 663 delete [] fY;; 664 fX = fY = nullptr;; 665 return;; 666 }; 667 if (n < fN) {; 668 fN = n;; 669 fLastPoint = n - 1;; 670 } else {; 671 SetPoint(n-1,0,0);; 672 }; 673}; 674 ; 675////////////////////////////////////////////////////////////////////////////////; 676/// Set new values for this polyline (singl",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:5055,Integrability,depend,depend,5055,"143 TAttLine::Copy(((TPolyLine&)obj));; 144 TAttFill::Copy(((TPolyLine&)obj));; 145 ((TPolyLine&)obj).fN = fN;; 146 delete [] ((TPolyLine&)obj).fX;; 147 delete [] ((TPolyLine&)obj).fY;; 148 if (fN > 0) {; 149 ((TPolyLine&)obj).fX = new Double_t[fN];; 150 ((TPolyLine&)obj).fY = new Double_t[fN];; 151 for (Int_t i = 0; i < fN; i++) {; 152 ((TPolyLine &)obj).fX[i] = fX[i];; 153 ((TPolyLine &)obj).fY[i] = fY[i];; 154 }; 155 } else {; 156 ((TPolyLine&)obj).fX = nullptr;; 157 ((TPolyLine&)obj).fY = nullptr;; 158 }; 159 ((TPolyLine&)obj).fOption = fOption;; 160 ((TPolyLine&)obj).fLastPoint = fLastPoint;; 161}; 162 ; 163////////////////////////////////////////////////////////////////////////////////; 164/// Returns closest distance in pixels from point (px, py) to a polyline.; 165///; 166/// First looks for distances to the points of the polyline. Stops search; 167/// and returns if a vertex of the polyline is found to be closer than 10; 168/// pixels. Thus the return value may depend on the ordering of points; 169/// in the polyline.; 170///; 171/// Then looks for distances to the lines of the polyline. There is no; 172/// arbitrary cutoff; any distance may be found.; 173///; 174/// Finally checks whether (px, py) is inside a closed and filled polyline.; 175/// (Must be EXACTLY closed. ""Filled"" means fill color and fill style are; 176/// both non-zero.) If so, returns zero.; 177///; 178/// Returns 9999 if the polyline has no points.; 179 ; 180Int_t TPolyLine::DistancetoPrimitive(Int_t px, Int_t py); 181{; 182 const Int_t big = 9999;; 183 if (!gPad) return big;; 184 const Int_t kMaxDiff = 10;; 185 ; 186 // check if point is near one of the points; 187 Int_t i, pxp, pyp, d;; 188 Int_t distance = big;; 189 if (Size() <= 0) return distance;; 190 ; 191 for (i=0;i<Size();i++) {; 192 pxp = gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 193 pyp = gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 194 d = TMath::Abs(pxp-px) + TMath::Abs(pyp-py);; 195 if (d < distance) distance = d;; 196 }; 197 if ",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:14348,Integrability,rout,routines,14348,"; 394 if (middle) {; 395 for(i=0;i<np-1;i++) {; 396 pxp = x[i]+dpx;; 397 pyp = y[i]+dpy;; 398 }; 399 pxp = x[np-1]+dpx;; 400 pyp = y[np-1]+dpy;; 401 dpx += px - pxold;; 402 dpy += py - pyold;; 403 pxold = px;; 404 pyold = py;; 405 } else {; 406 pxold = px;; 407 pxold = TMath::Max(pxold, px1);; 408 pxold = TMath::Min(pxold, px2);; 409 pyold = py;; 410 pyold = TMath::Max(pyold, py2);; 411 pyold = TMath::Min(pyold, py1);; 412 }; 413 if (!x.empty() && !y.empty()) {; 414 if (middle) {; 415 for(i=0;i<np;i++) {; 416 fX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 417 fY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 418 }; 419 } else {; 420 fX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 421 fY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 422 }; 423 }; 424 gPad->Modified(kTRUE);; 425 }; 426 break;; 427 ; 428 case kButton1Up:; 429 ; 430 // Compute x,y range; 431 xmin = gPad->GetUxmin();; 432 xmax = gPad->GetUxmax();; 433 ymin = gPad->GetUymin();; 434 ymax = gPad->GetUymax();; 435 dx = xmax-xmin;; 436 dy = ymax-ymin;; 437 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 438 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 439 ; 440 // Range() could change the size of the pad pixmap and therefore should; 441 // be called before the other paint routines; 442 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 443 ymin - dyr*gPad->GetBottomMargin(),; 444 xmax + dxr*gPad->GetRightMargin(),; 445 ymax + dyr*gPad->GetTopMargin());; 446 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 447 ; 448 if (!x.empty() && !y.empty()) {; 449 if (middle) {; 450 for(i=0;i<np;i++) {; 451 fX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 452 fY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 453 }; 454 } else {; 455 fX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 456 fY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 457 }; 458 x.clear();; 459 y.clear();; 460 }; 461 gPad->Modified(kTRUE);; 462 gVirtualX->SetLineColor(-1);; 463 }; 464}; 465 ; 466//////",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:28602,Integrability,message,message,28602,"254; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPolyLineDefined by an array on N points in a 2-D space.Definition TPolyLine.h:23; TPolyLine::fOptionTString fOptionoptionsDefinition TPolyLine.h:30; TPolyLine::Sizevirtual Int_t Size() constDefinition TPolyLine.h:71; TPolyLine::fLastPointInt_t fLastPointThe index of the last filled point.Definition TPolyLine.h:27; TPolyLine::Mergevirtual Int_t Merge(TCollection *list)Merge polylines in the collection in this polyline.Definition TPolyLine.cxx:479; TPolyLine::PaintPolyLineNDCvirtual void PaintPolyLineNDC(Int_t n, Double_t *x, Double_t *y, Option_t *option="""")Draw this polyline with new coordinates in NDC.Definition TPolyLine.cxx:560; TPolyLine::Copyvoid Copy(TObject &polyline) const overrideCopy this polyline to polyline.Definition TPolyLine.cxx:140; TPolyLine::DistancetoPrimitiveInt_t Distanc",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:15940,Modifiability,extend,extend,15940,"450 for(i=0;i<np;i++) {; 451 fX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 452 fY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 453 }; 454 } else {; 455 fX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 456 fY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 457 }; 458 x.clear();; 459 y.clear();; 460 }; 461 gPad->Modified(kTRUE);; 462 gVirtualX->SetLineColor(-1);; 463 }; 464}; 465 ; 466////////////////////////////////////////////////////////////////////////////////; 467/// List this polyline with its attributes.; 468/// The option string is ignored.; 469 ; 470void TPolyLine::ls(Option_t *) const; 471{; 472 TROOT::IndentLevel();; 473 printf(""TPolyLine N=%d\n"",fN);; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// Merge polylines in the collection in this polyline; 478 ; 479Int_t TPolyLine::Merge(TCollection *li); 480{; 481 if (!li) return 0;; 482 TIter next(li);; 483 ; 484 //first loop to count the number of entries; 485 TPolyLine *pl;; 486 Int_t npoints = 0;; 487 while ((pl = (TPolyLine*)next())) {; 488 if (!pl->InheritsFrom(TPolyLine::Class())) {; 489 Error(""Add"",""Attempt to add object of class: %s to a %s"",pl->ClassName(),this->ClassName());; 490 return -1;; 491 }; 492 npoints += pl->Size();; 493 }; 494 ; 495 //extend this polyline to hold npoints; 496 if (npoints > 1) SetPoint(npoints-1,0,0);; 497 ; 498 //merge all polylines; 499 next.Reset();; 500 while ((pl = (TPolyLine*)next())) {; 501 Int_t np = pl->Size();; 502 Double_t *x = pl->GetX();; 503 Double_t *y = pl->GetY();; 504 for (Int_t i=0;i<np;i++) {; 505 SetPoint(i,x[i],y[i]);; 506 }; 507 }; 508 ; 509 return npoints;; 510}; 511 ; 512////////////////////////////////////////////////////////////////////////////////; 513/// Paint this polyline with its current attributes.; 514 ; 515void TPolyLine::Paint(Option_t *option); 516{; 517 if (TestBit(kPolyLineNDC)) {; 518 if (option && strlen(option)) PaintPolyLineNDC(fLastPoint+1, fX, fY, option);; 5",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:20332,Modifiability,extend,extended,20332,"ne(""<<fN<<"",""<<quote<<fOption<<quote<<"");""<<std::endl;; 590 ; 591 SaveFillAttributes(out, ""pline"", 0, 1001);; 592 SaveLineAttributes(out, ""pline"", 1, 1, 1);; 593 ; 594 for (Int_t i=0;i<Size();i++); 595 out<<"" pline->SetPoint(""<<i<<"",""<<fX[i]<<"",""<<fY[i]<<"");""<<std::endl;; 596 ; 597 out<<"" pline->Draw(""<<quote<<option<<quote<<"");""<<std::endl;; 598}; 599 ; 600////////////////////////////////////////////////////////////////////////////////; 601/// Set NDC mode on if isNDC = kTRUE, off otherwise; 602 ; 603void TPolyLine::SetNDC(Bool_t isNDC); 604{; 605 ResetBit(kPolyLineNDC);; 606 if (isNDC) SetBit(kPolyLineNDC);; 607}; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// Set point following LastPoint to x, y.; 611/// Returns index of the point (new last point).; 612 ; 613Int_t TPolyLine::SetNextPoint(Double_t x, Double_t y); 614{; 615 fLastPoint++;; 616 SetPoint(fLastPoint, x, y);; 617 return fLastPoint;; 618}; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// Set point number n to (x, y); 622/// If n is greater than the current size, the arrays are automatically; 623/// extended.; 624 ; 625void TPolyLine::SetPoint(Int_t n, Double_t x, Double_t y); 626{; 627 if (n < 0) return;; 628 if (!fX || !fY || n >= fN) {; 629 // re-allocate the object; 630 Int_t newN = TMath::Max(2*fN,n+1);; 631 Double_t *savex = new Double_t [newN];; 632 Double_t *savey = new Double_t [newN];; 633 if (fX && fN){; 634 memcpy(savex,fX,fN*sizeof(Double_t));; 635 memset(&savex[fN],0,(newN-fN)*sizeof(Double_t));; 636 delete [] fX;; 637 }; 638 if (fY && fN){; 639 memcpy(savey,fY,fN*sizeof(Double_t));; 640 memset(&savey[fN],0,(newN-fN)*sizeof(Double_t));; 641 delete [] fY;; 642 }; 643 fX = savex;; 644 fY = savey;; 645 fN = newN;; 646 }; 647 fX[n] = x;; 648 fY[n] = y;; 649 fLastPoint = TMath::Max(fLastPoint, n);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:28350,Modifiability,inherit,inherits,28350," on output stream out.Definition TAttLine.cxx:275; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollectionCollection abstract base class.Definition TCollection.h:65; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPolyLineDefined by an array on N points in a 2-D space.Definition TPolyLine.h:23; TPolyLine::fOptionTString fOptionoptionsDefinition TPolyLine.h:30; TPolyLine::Sizevirtual Int_t Size() constDefinition TPolyLine.h:71; TPolyLine::fLastPointInt_t fLastPointThe index of the last filled point.Definition TPolyLine.h:27; TPolyLine::Mergevirtual Int_t Merge(TCollection *list)Merge polylines in the collection in this polyline.Definition TPolyLine.cxx:479; TPolyLine::PaintPolyLineNDCvirtual void PaintPolyLineNDC(Int_t n,",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:14924,Usability,clear,clear,14924,"min = gPad->GetUxmin();; 432 xmax = gPad->GetUxmax();; 433 ymin = gPad->GetUymin();; 434 ymax = gPad->GetUymax();; 435 dx = xmax-xmin;; 436 dy = ymax-ymin;; 437 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 438 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 439 ; 440 // Range() could change the size of the pad pixmap and therefore should; 441 // be called before the other paint routines; 442 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 443 ymin - dyr*gPad->GetBottomMargin(),; 444 xmax + dxr*gPad->GetRightMargin(),; 445 ymax + dyr*gPad->GetTopMargin());; 446 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 447 ; 448 if (!x.empty() && !y.empty()) {; 449 if (middle) {; 450 for(i=0;i<np;i++) {; 451 fX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 452 fY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 453 }; 454 } else {; 455 fX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 456 fY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 457 }; 458 x.clear();; 459 y.clear();; 460 }; 461 gPad->Modified(kTRUE);; 462 gVirtualX->SetLineColor(-1);; 463 }; 464}; 465 ; 466////////////////////////////////////////////////////////////////////////////////; 467/// List this polyline with its attributes.; 468/// The option string is ignored.; 469 ; 470void TPolyLine::ls(Option_t *) const; 471{; 472 TROOT::IndentLevel();; 473 printf(""TPolyLine N=%d\n"",fN);; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// Merge polylines in the collection in this polyline; 478 ; 479Int_t TPolyLine::Merge(TCollection *li); 480{; 481 if (!li) return 0;; 482 TIter next(li);; 483 ; 484 //first loop to count the number of entries; 485 TPolyLine *pl;; 486 Int_t npoints = 0;; 487 while ((pl = (TPolyLine*)next())) {; 488 if (!pl->InheritsFrom(TPolyLine::Class())) {; 489 Error(""Add"",""Attempt to add object of class: %s to a %s"",pl->ClassName(),this->ClassName());; 490 return -1;; 491 }; 492 npoints += pl->Size();; 493 }; 494 ",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPolyLine_8cxx_source.html:14940,Usability,clear,clear,14940,"= xmax-xmin;; 436 dy = ymax-ymin;; 437 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 438 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 439 ; 440 // Range() could change the size of the pad pixmap and therefore should; 441 // be called before the other paint routines; 442 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 443 ymin - dyr*gPad->GetBottomMargin(),; 444 xmax + dxr*gPad->GetRightMargin(),; 445 ymax + dyr*gPad->GetTopMargin());; 446 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 447 ; 448 if (!x.empty() && !y.empty()) {; 449 if (middle) {; 450 for(i=0;i<np;i++) {; 451 fX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 452 fY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 453 }; 454 } else {; 455 fX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 456 fY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 457 }; 458 x.clear();; 459 y.clear();; 460 }; 461 gPad->Modified(kTRUE);; 462 gVirtualX->SetLineColor(-1);; 463 }; 464}; 465 ; 466////////////////////////////////////////////////////////////////////////////////; 467/// List this polyline with its attributes.; 468/// The option string is ignored.; 469 ; 470void TPolyLine::ls(Option_t *) const; 471{; 472 TROOT::IndentLevel();; 473 printf(""TPolyLine N=%d\n"",fN);; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// Merge polylines in the collection in this polyline; 478 ; 479Int_t TPolyLine::Merge(TCollection *li); 480{; 481 if (!li) return 0;; 482 TIter next(li);; 483 ; 484 //first loop to count the number of entries; 485 TPolyLine *pl;; 486 Int_t npoints = 0;; 487 while ((pl = (TPolyLine*)next())) {; 488 if (!pl->InheritsFrom(TPolyLine::Class())) {; 489 Error(""Add"",""Attempt to add object of class: %s to a %s"",pl->ClassName(),this->ClassName());; 490 return -1;; 491 }; 492 npoints += pl->Size();; 493 }; 494 ; 495 //extend this polyline to hold npoints; 496 if (npoints > 1) SetPoint(npoints-1,0,0);; 497 ; 498 //merge all polyline",MatchSource.WIKI,doc/master/TPolyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html
https://root.cern/doc/master/TPrincipal_8h_source.html:5325,Deployability,update,update,5325,"imarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; namechar name[80]Definition TGX11.cxx:110; TMatrixD.h; TNamed.h; TVectorD.h; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TListA doubly linked list.Definition TList.h:38; TMatrixT< Double_t >; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TPrincipal::MakeMethodsvirtual void MakeMethods(const char *classname=""PCA"", Option_t *option="""")Generate the file <classname>PCA.cxx which contains the implementation of two methods:Definition TPrincipal.cxx:871; TPrincipal::AddRowvirtual void AddRow(const Double_t *x)Add a data point and update the covariance matrix.Definition TPrincipal.cxx:414; TPrincipal::X2Pvirtual void X2P(const Double_t *x, Double_t *p)Calculate the principal components from the original data vector x, and return it in p.Definition TPrincipal.cxx:1229; TPrincipal::fTraceDouble_t fTraceTrace of covarience matrix.Definition TPrincipal.h:38; TPrincipal::TPrincipalTPrincipal()Empty constructor. Do not use.Definition TPrincipal.cxx:229; TPrincipal::GetCovarianceMatrixconst TMatrixD * GetCovarianceMatrix() constReturn the covariance matrix.Definition TPrincipal.h:60; TPrincipal::Clearvoid Clear(Option_t *option="""") overrideClear the data in Object.Definition TPrincipal.cxx:494; TPrincipal::MakeHistogramsvirtual void MakeHistograms(const char *name=""pca"", Option_t *option=""epsdx"")Make histograms of the result of the analysis.Definition TPrincipal.cxx:587; TPrincipal::Printvoid Print(Option_t *opt=""MSE"") const overridePrint the statistics Options are.Definition TPrincipal.cxx:",MatchSource.WIKI,doc/master/TPrincipal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPrincipal_8h_source.html
https://root.cern/doc/master/TPrincipal_8h_source.html:952,Modifiability,variab,variables,952,"; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TPrincipal; 13#define ROOT_TPrincipal; 14 ; 15#include ""TNamed.h""; 16#include ""TVectorD.h""; 17#include ""TMatrixD.h""; 18 ; 19class TList;; 20 ; 21class TPrincipal : public TNamed {; 22 ; 23protected:; 24 Int_t fNumberOfDataPoints; ///< Number of data points; 25 Int_t fNumberOfVariables; ///< Number of variables; 26 ; 27 TVectorD fMeanValues; ///< Mean value over all data points; 28 TVectorD fSigmas; ///< vector of sigmas; 29 TMatrixD fCovarianceMatrix; ///< Covariance matrix; 30 ; 31 TMatrixD fEigenVectors; ///< Eigenvector matrix of trans; 32 TVectorD fEigenValues; ///< Eigenvalue vector of trans; 33 ; 34 TVectorD fOffDiagonal; ///< Elements of the tridiagonal; 35 ; 36 TVectorD fUserData; ///< Vector of original data points; 37 ; 38 Double_t fTrace; ///< Trace of covarience matrix; 39 ; 40 TList *fHistograms; ///< List of histograms; 41 ; 42 Bool_t fIsNormalised; ///< Normalize matrix?; 43 Bool_t fStoreData; ///< Should we store input data?; 44 ; 45 TPrincipal(const TPrincipal&);; 46 TPrincipal& operator=(const TPrincipal&);; 47 ; 48 void MakeNormalised();; 49 void MakeRealCode(const char *filename, const char *prefix, Option_t *option="""");; 50 ; 51public:; 52 TPrincipal();; 53 ~TPrincipal() override;; 54 TPrincipal(Long64_t nVariables, Option_t *opt=""ND"");; 55 ; 56 virtual void AddRow(const Double_t *x);; 57 void Browse(TBrowser *b) override;; 58 void Clear(Option_t *option="""") override;; 59 /// Return the covariance matrix. \note Only the lower diagonal of the covariance matrix is computed by the class; 60 const TMatrixD *GetCovarianceMatrix() const {return &fCovarianceMatrix;}; 61 const TVectorD *GetEigenValues() const {return &fEigenValues;}; 62 const TMatrixD *GetEigenVectors() const {return &fEigenVectors;}; 63 TList *GetHistograms() const {retu",MatchSource.WIKI,doc/master/TPrincipal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPrincipal_8h_source.html
https://root.cern/doc/master/TPrincipal_8h_source.html:6774,Modifiability,variab,variables,6774,":229; TPrincipal::GetCovarianceMatrixconst TMatrixD * GetCovarianceMatrix() constReturn the covariance matrix.Definition TPrincipal.h:60; TPrincipal::Clearvoid Clear(Option_t *option="""") overrideClear the data in Object.Definition TPrincipal.cxx:494; TPrincipal::MakeHistogramsvirtual void MakeHistograms(const char *name=""pca"", Option_t *option=""epsdx"")Make histograms of the result of the analysis.Definition TPrincipal.cxx:587; TPrincipal::Printvoid Print(Option_t *opt=""MSE"") const overridePrint the statistics Options are.Definition TPrincipal.cxx:1094; TPrincipal::fUserDataTVectorD fUserDataVector of original data points.Definition TPrincipal.h:36; TPrincipal::MakeCodevirtual void MakeCode(const char *filename=""pca"", Option_t *option="""")Generates the file <filename>, with .C appended if it does argument doesn't end in ....Definition TPrincipal.cxx:562; TPrincipal::fCovarianceMatrixTMatrixD fCovarianceMatrixCovariance matrix.Definition TPrincipal.h:29; TPrincipal::fNumberOfVariablesInt_t fNumberOfVariablesNumber of variables.Definition TPrincipal.h:25; TPrincipal::fSigmasTVectorD fSigmasvector of sigmasDefinition TPrincipal.h:28; TPrincipal::fOffDiagonalTVectorD fOffDiagonalElements of the tridiagonal.Definition TPrincipal.h:34; TPrincipal::fEigenValuesTVectorD fEigenValuesEigenvalue vector of trans.Definition TPrincipal.h:32; TPrincipal::GetMeanValuesconst TVectorD * GetMeanValues() constDefinition TPrincipal.h:64; TPrincipal::fMeanValuesTVectorD fMeanValuesMean value over all data points.Definition TPrincipal.h:27; TPrincipal::fHistogramsTList * fHistogramsList of histograms.Definition TPrincipal.h:40; TPrincipal::GetEigenVectorsconst TMatrixD * GetEigenVectors() constDefinition TPrincipal.h:62; TPrincipal::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TPrincipal.h:68; TPrincipal::MakeRealCodevoid MakeRealCode(const char *filename, const char *prefix, Option_t *",MatchSource.WIKI,doc/master/TPrincipal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPrincipal_8h_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:1039,Availability,error,error,1039,". ROOT: hist/hist/src/TProfile2D.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TProfile2D.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 16/04/2000; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TProfile2D.h""; 13#include ""TBuffer.h""; 14#include ""TMath.h""; 15#include ""THLimitsFinder.h""; 16#include ""TError.h""; 17#include ""TClass.h""; 18#include ""TProfileHelper.h""; 19#include <iostream>; 20 ; 21Bool_t TProfile2D::fgApproximate = kFALSE;; 22 ; 23ClassImp(TProfile2D);; 24 ; 25/** \class TProfile2D; 26 \ingroup Histograms; 27 Profile2D histograms are used to display the mean; 28 value of Z and its error for each cell in X,Y.; 29 Profile2D histograms are in many cases an; 30 elegant replacement of three-dimensional histograms : the inter-relation of three; 31 measured quantities X, Y and Z can always be visualized by a three-dimensional; 32 histogram or scatter-plot; its representation on the line-printer is not particularly; 33 satisfactory, except for sparse data. If Z is an unknown (but single-valued); 34 approximate function of X,Y this function is displayed by a profile2D histogram with; 35 much better precision than by a scatter-plot.; 36 ; 37 The following formulae show the cumulated contents (capital letters) and the values; 38 displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; 39 \f[; 40 \begin{align}; 41 H(i,j) &= \sum w \cdot Z \\; 42 E(i,j) &= \sum w \cdot Z^2 \\; 43 W(i,j) &= \sum w \\; 44 h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; 45 s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; 46 e(i,j) &= \",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:2113,Availability,error,errors,2113,"for each cell in X,Y.; 29 Profile2D histograms are in many cases an; 30 elegant replacement of three-dimensional histograms : the inter-relation of three; 31 measured quantities X, Y and Z can always be visualized by a three-dimensional; 32 histogram or scatter-plot; its representation on the line-printer is not particularly; 33 satisfactory, except for sparse data. If Z is an unknown (but single-valued); 34 approximate function of X,Y this function is displayed by a profile2D histogram with; 35 much better precision than by a scatter-plot.; 36 ; 37 The following formulae show the cumulated contents (capital letters) and the values; 38 displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; 39 \f[; 40 \begin{align}; 41 H(i,j) &= \sum w \cdot Z \\; 42 E(i,j) &= \sum w \cdot Z^2 \\; 43 W(i,j) &= \sum w \\; 44 h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; 45 s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; 46 e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; 47 \end{align}; 48 \f]; 49 The bin content is always the mean of the Z values, but errors change depending on options:; 50 \f[; 51 \begin{align}; 52 \text{GetBinContent}(i,j) &= h(i,j) \\; 53 \text{GetBinError}(i,j) &=; 54 \begin{cases}; 55 e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; 56 s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; 57 \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 58 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; 59 \end{cases}; 60 \end{align}; 61 \f]; 62 ; 63 In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); 64 the bin error e(I,J) is computed from the average of the s(I,J) for all cells; 65 if the static function TProfile2D::Approximate has been called.; 66 This simple/crude approximation was suggeste",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:2859,Availability,error,error,2859,"\sum w \cdot Z^2 \\; 43 W(i,j) &= \sum w \\; 44 h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; 45 s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; 46 e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; 47 \end{align}; 48 \f]; 49 The bin content is always the mean of the Z values, but errors change depending on options:; 50 \f[; 51 \begin{align}; 52 \text{GetBinContent}(i,j) &= h(i,j) \\; 53 \text{GetBinError}(i,j) &=; 54 \begin{cases}; 55 e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; 56 s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; 57 \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 58 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; 59 \end{cases}; 60 \end{align}; 61 \f]; 62 ; 63 In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); 64 the bin error e(I,J) is computed from the average of the s(I,J) for all cells; 65 if the static function TProfile2D::Approximate has been called.; 66 This simple/crude approximation was suggested in order to keep the cell; 67 during a fit operation. But note that this approximation is not the default behaviour.; 68 ; 69 ### Creating and drawing a 2D profile; 70 ~~~~{.cpp}; 71 {; 72 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 73 auto hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; 74 Float_t px, py, pz;; 75 for ( Int_t i=0; i<25000; i++) {; 76 gRandom->Rannor(px,py);; 77 pz = px*px + py*py;; 78 hprof2d->Fill(px,py,pz,1);; 79 }; 80 hprof2d->Draw();; 81 }; 82 ~~~~; 83*/; 84 ; 85////////////////////////////////////////////////////////////////////////////////; 86/// Default constructor for Profile2D histograms.; 87 ; 88TProfile2D::TProfile2D(); 89{; 90 fTsumwz = fTsumwz2 = 0;; 91 fScaling = kFALSE;; 92 BuildOptions(0,0,"""")",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:4937,Availability,error,errors,4937,"le2D histograms.; 97 ; 98TProfile2D::~TProfile2D(); 99{; 100}; 101 ; 102////////////////////////////////////////////////////////////////////////////////; 103/// Normal Constructor for Profile histograms.; 104///; 105/// The first eight parameters are similar to TH2D::TH2D.; 106/// All values of z are accepted at filling time.; 107/// To fill a profile2D histogram, one must use TProfile2D::Fill function.; 108///; 109/// Note that when filling the profile histogram the function Fill; 110/// checks if the variable z is between fZmin and fZmax.; 111/// If a minimum or maximum value is set for the Z scale before filling,; 112/// then all values below zmin or above zmax will be discarded.; 113/// Setting the minimum or maximum value for the Z scale before filling; 114/// has the same effect as calling the special TProfile2D constructor below; 115/// where zmin and zmax are specified.; 116///; 117/// H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; 118/// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; 119///; 120/// See TProfile2D::BuildOptions for explanation of parameters; 121///; 122/// see other constructors below with all possible combinations of; 123/// fix and variable bin size like in TH2D.; 124 ; 125TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 126: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 127{; 128 BuildOptions(0,0,option);; 129 if (xlow >= xup || ylow >= yup) SetBuffer(fgBufferSize);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Create a 2-D Profile with variable bins in X and fix bins in Y.; 134 ; 135TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 136: TH2D(name,title,nx,xbins,ny,ylow,yup); 137{; 138 BuildOptions(0,0,option);; 139}; 140 ; 141////////////////////",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:5026,Availability,error,error,5026,"le2D histograms.; 97 ; 98TProfile2D::~TProfile2D(); 99{; 100}; 101 ; 102////////////////////////////////////////////////////////////////////////////////; 103/// Normal Constructor for Profile histograms.; 104///; 105/// The first eight parameters are similar to TH2D::TH2D.; 106/// All values of z are accepted at filling time.; 107/// To fill a profile2D histogram, one must use TProfile2D::Fill function.; 108///; 109/// Note that when filling the profile histogram the function Fill; 110/// checks if the variable z is between fZmin and fZmax.; 111/// If a minimum or maximum value is set for the Z scale before filling,; 112/// then all values below zmin or above zmax will be discarded.; 113/// Setting the minimum or maximum value for the Z scale before filling; 114/// has the same effect as calling the special TProfile2D constructor below; 115/// where zmin and zmax are specified.; 116///; 117/// H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; 118/// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; 119///; 120/// See TProfile2D::BuildOptions for explanation of parameters; 121///; 122/// see other constructors below with all possible combinations of; 123/// fix and variable bin size like in TH2D.; 124 ; 125TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 126: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 127{; 128 BuildOptions(0,0,option);; 129 if (xlow >= xup || ylow >= yup) SetBuffer(fgBufferSize);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Create a 2-D Profile with variable bins in X and fix bins in Y.; 134 ; 135TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 136: TH2D(name,title,nx,xbins,ny,ylow,yup); 137{; 138 BuildOptions(0,0,option);; 139}; 140 ; 141////////////////////",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:7257,Availability,error,errors,7257,"Profile with variable bins in X and variable bins in Y.; 152 ; 153TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Option_t *option); 154: TH2D(name,title,nx,xbins,ny,ybins); 155{; 156 BuildOptions(0,0,option);; 157}; 158 ; 159////////////////////////////////////////////////////////////////////////////////; 160/// Constructor for Profile2D histograms with range in z.; 161///; 162/// The first eight parameters are similar to TH2D::TH2D.; 163/// Only the values of Z between ZMIN and ZMAX will be considered at filling time.; 164/// zmin and zmax will also be the maximum and minimum values; 165/// on the z scale when drawing the profile2D.; 166///; 167/// See TProfile2D::BuildOptions for more explanations on errors; 168 ; 169TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny, Double_t ylow,Double_t yup,Double_t zlow,Double_t zup,Option_t *option); 170: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 171{; 172 BuildOptions(zlow,zup,option);; 173 if (xlow >= xup || ylow >= yup) SetBuffer(fgBufferSize);; 174}; 175 ; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Set Profile2D histogram structure and options.; 179///; 180/// - zmin: minimum value allowed for z; 181/// - zmax: maximum value allowed for z; 182/// if (zmin = zmax = 0) there are no limits on the allowed z values (zmin = -inf, zmax = +inf); 183///; 184/// - option: this is the option for the computation of the t error of the profile ( TProfile2D::GetBinError ); 185/// possible values for the options are documented in TProfile2D::SetErrorOption; 186///; 187/// See TProfile::BuildOptions for a detailed description; 188 ; 189void TProfile2D::BuildOptions(Double_t zmin, Double_t zmax, Option_t *option); 190{; 191 ; 192 SetErrorOption(option);; 193 ; 194 // create extra profile data structure (bin entries/ y^2 and sum of weight square); 195 TProfileHel",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:8029,Availability,error,error,8029,"more explanations on errors; 168 ; 169TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny, Double_t ylow,Double_t yup,Double_t zlow,Double_t zup,Option_t *option); 170: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 171{; 172 BuildOptions(zlow,zup,option);; 173 if (xlow >= xup || ylow >= yup) SetBuffer(fgBufferSize);; 174}; 175 ; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Set Profile2D histogram structure and options.; 179///; 180/// - zmin: minimum value allowed for z; 181/// - zmax: maximum value allowed for z; 182/// if (zmin = zmax = 0) there are no limits on the allowed z values (zmin = -inf, zmax = +inf); 183///; 184/// - option: this is the option for the computation of the t error of the profile ( TProfile2D::GetBinError ); 185/// possible values for the options are documented in TProfile2D::SetErrorOption; 186///; 187/// See TProfile::BuildOptions for a detailed description; 188 ; 189void TProfile2D::BuildOptions(Double_t zmin, Double_t zmax, Option_t *option); 190{; 191 ; 192 SetErrorOption(option);; 193 ; 194 // create extra profile data structure (bin entries/ y^2 and sum of weight square); 195 TProfileHelper::BuildArray(this);; 196 ; 197 fZmin = zmin;; 198 fZmax = zmax;; 199 fScaling = kFALSE;; 200 fTsumwz = fTsumwz2 = 0;; 201}; 202 ; 203////////////////////////////////////////////////////////////////////////////////; 204/// Copy constructor.; 205 ; 206TProfile2D::TProfile2D(const TProfile2D &profile2d) : TH2D(); 207{; 208 profile2d.TProfile2D::Copy(*this);; 209}; 210 ; 211TProfile2D &TProfile2D::operator=(const TProfile2D &profile2d); 212{; 213 if (this != &profile2d); 214 profile2d.TProfile2D::Copy(*this);; 215 return *this;; 216}; 217 ; 218////////////////////////////////////////////////////////////////////////////////; 219/// Performs the operation: `this = this + c1*f1` .; 220 ; 221Bool_t TProfile2D::Add(TF1 *, Double_t , Option_t*); 222{; 223 Error",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:10817,Availability,error,error,10817,"rofile2D::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 250{; 251 if (!h1 || !h2) {; 252 Error(""Add"",""Attempt to add a non-existing profile"");; 253 return kFALSE;; 254 }; 255 if (!h1->InheritsFrom(TProfile2D::Class())) {; 256 Error(""Add"",""Attempt to add a non-profile2D object"");; 257 return kFALSE;; 258 }; 259 if (!h2->InheritsFrom(TProfile2D::Class())) {; 260 Error(""Add"",""Attempt to add a non-profile2D object"");; 261 return kFALSE;; 262 }; 263 return TProfileHelper::Add(this, h1, h2, c1, c2);; 264}; 265 ; 266////////////////////////////////////////////////////////////////////////////////; 267/// Static function, set the fgApproximate flag.; 268///; 269/// When the flag is true, the function GetBinError; 270/// will approximate the bin error with the average profile error on all bins; 271/// in the following situation only; 272/// - the number of bins in the profile2D is less than 10404 (eg 100x100); 273/// - the bin number of entries is small ( <5); 274/// - the estimated bin error is extremely small compared to the bin content; 275/// (see TProfile2D::GetBinError); 276 ; 277void TProfile2D::Approximate(Bool_t approx); 278{; 279 fgApproximate = approx;; 280}; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Fill histogram with all entries in the buffer.; 284///; 285/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 286/// - action = 0 histogram is filled from the buffer; 287/// - action = 1 histogram is filled and buffer is deleted; 288/// The buffer is automatically deleted when the number of entries; 289/// in the buffer is greater than the number of entries in the histogram; 290 ; 291Int_t TProfile2D::BufferEmpty(Int_t action); 292{; 293 // do we need to compute the bin size?; 294 if (!fBuffer) return 0;; 295 Int_t nbentries = (Int_t)fBuffer[0];; 296 if (!nbentries) return 0;; 297 Double_t *buffer = fBuffer;; 298 if (nbentries < 0) {; 299 if (action == ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:10848,Availability,error,error,10848,"rofile2D::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 250{; 251 if (!h1 || !h2) {; 252 Error(""Add"",""Attempt to add a non-existing profile"");; 253 return kFALSE;; 254 }; 255 if (!h1->InheritsFrom(TProfile2D::Class())) {; 256 Error(""Add"",""Attempt to add a non-profile2D object"");; 257 return kFALSE;; 258 }; 259 if (!h2->InheritsFrom(TProfile2D::Class())) {; 260 Error(""Add"",""Attempt to add a non-profile2D object"");; 261 return kFALSE;; 262 }; 263 return TProfileHelper::Add(this, h1, h2, c1, c2);; 264}; 265 ; 266////////////////////////////////////////////////////////////////////////////////; 267/// Static function, set the fgApproximate flag.; 268///; 269/// When the flag is true, the function GetBinError; 270/// will approximate the bin error with the average profile error on all bins; 271/// in the following situation only; 272/// - the number of bins in the profile2D is less than 10404 (eg 100x100); 273/// - the bin number of entries is small ( <5); 274/// - the estimated bin error is extremely small compared to the bin content; 275/// (see TProfile2D::GetBinError); 276 ; 277void TProfile2D::Approximate(Bool_t approx); 278{; 279 fgApproximate = approx;; 280}; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Fill histogram with all entries in the buffer.; 284///; 285/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 286/// - action = 0 histogram is filled from the buffer; 287/// - action = 1 histogram is filled and buffer is deleted; 288/// The buffer is automatically deleted when the number of entries; 289/// in the buffer is greater than the number of entries in the histogram; 290 ; 291Int_t TProfile2D::BufferEmpty(Int_t action); 292{; 293 // do we need to compute the bin size?; 294 if (!fBuffer) return 0;; 295 Int_t nbentries = (Int_t)fBuffer[0];; 296 if (!nbentries) return 0;; 297 Double_t *buffer = fBuffer;; 298 if (nbentries < 0) {; 299 if (action == ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:11063,Availability,error,error,11063,"rofile2D::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 250{; 251 if (!h1 || !h2) {; 252 Error(""Add"",""Attempt to add a non-existing profile"");; 253 return kFALSE;; 254 }; 255 if (!h1->InheritsFrom(TProfile2D::Class())) {; 256 Error(""Add"",""Attempt to add a non-profile2D object"");; 257 return kFALSE;; 258 }; 259 if (!h2->InheritsFrom(TProfile2D::Class())) {; 260 Error(""Add"",""Attempt to add a non-profile2D object"");; 261 return kFALSE;; 262 }; 263 return TProfileHelper::Add(this, h1, h2, c1, c2);; 264}; 265 ; 266////////////////////////////////////////////////////////////////////////////////; 267/// Static function, set the fgApproximate flag.; 268///; 269/// When the flag is true, the function GetBinError; 270/// will approximate the bin error with the average profile error on all bins; 271/// in the following situation only; 272/// - the number of bins in the profile2D is less than 10404 (eg 100x100); 273/// - the bin number of entries is small ( <5); 274/// - the estimated bin error is extremely small compared to the bin content; 275/// (see TProfile2D::GetBinError); 276 ; 277void TProfile2D::Approximate(Bool_t approx); 278{; 279 fgApproximate = approx;; 280}; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Fill histogram with all entries in the buffer.; 284///; 285/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 286/// - action = 0 histogram is filled from the buffer; 287/// - action = 1 histogram is filled and buffer is deleted; 288/// The buffer is automatically deleted when the number of entries; 289/// in the buffer is greater than the number of entries in the histogram; 290 ; 291Int_t TProfile2D::BufferEmpty(Int_t action); 292{; 293 // do we need to compute the bin size?; 294 if (!fBuffer) return 0;; 295 Int_t nbentries = (Int_t)fBuffer[0];; 296 if (!nbentries) return 0;; 297 Double_t *buffer = fBuffer;; 298 if (nbentries < 0) {; 299 if (action == ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:18248,Availability,error,error,18248,"ble_t *er1 = p1->GetW2();; 463 Double_t *en1 = p1->GetB();; 464 Double_t c0,c1,w,z,x,y;; 465 for (binx =0;binx<=nx+1;binx++) {; 466 for (biny =0;biny<=ny+1;biny++) {; 467 bin = biny*(fXaxis.GetNbins()+2) + binx;; 468 c0 = fArray[bin];; 469 c1 = cu1[bin];; 470 if (c1) w = c0/c1;; 471 else w = 0;; 472 fArray[bin] = w;; 473 z = TMath::Abs(w);; 474 x = fXaxis.GetBinCenter(binx);; 475 y = fYaxis.GetBinCenter(biny);; 476 fEntries++;; 477 fTsumw += z;; 478 fTsumw2 += z*z;; 479 fTsumwx += z*x;; 480 fTsumwx2 += z*x*x;; 481 fTsumwy += z*y;; 482 fTsumwy2 += z*y*y;; 483 fTsumwxy += z*x*y;; 484 fTsumwz += z;; 485 fTsumwz2 += z*z;; 486 Double_t e0 = fSumw2.fArray[bin];; 487 Double_t e1 = er1[bin];; 488 Double_t c12= c1*c1;; 489 if (!c1) fSumw2.fArray[bin] = 0;; 490 else fSumw2.fArray[bin] = (e0*c1*c1 + e1*c0*c0)/(c12*c12);; 491 if (!en1[bin]) fBinEntries.fArray[bin] = 0;; 492 else fBinEntries.fArray[bin] /= en1[bin];; 493 }; 494 }; 495 // maintaining the correct sum of weights square is not supported when dividing; 496 // bin error resulting from division of profile needs to be checked; 497 if (fBinSumw2.fN) {; 498 Warning(""Divide"",""Cannot preserve during the division of profiles the sum of bin weight square"");; 499 fBinSumw2 = TArrayD();; 500 }; 501 return kTRUE;; 502}; 503 ; 504////////////////////////////////////////////////////////////////////////////////; 505/// Replace contents of this profile2D by the division of h1 by h2.; 506///; 507/// `this = c1*h1/(c2*h2)`; 508///; 509/// This function return kFALSE if the divide operation failed; 510 ; 511Bool_t TProfile2D::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 512{; 513 TString opt = option;; 514 opt.ToLower();; 515 Bool_t binomial = kFALSE;; 516 if (opt.Contains(""b"")) binomial = kTRUE;; 517 if (!h1 || !h2) {; 518 Error(""Divide"",""Attempt to divide a non-existing profile2D"");; 519 return kFALSE;; 520 }; 521 if (!h1->InheritsFrom(TProfile2D::Class())) {; 522 Error(""Divide"",""Attempt to divide",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:30030,Availability,error,error,30030,"///////////////////////; 840/// Return bin entries of a Profile2D histogram.; 841 ; 842Double_t TProfile2D::GetBinEntries(Int_t bin) const; 843{; 844 if (fBuffer) ((TProfile2D*)this)->BufferEmpty();; 845 ; 846 if (bin < 0 || bin >= fNcells) return 0;; 847 return fBinEntries.fArray[bin];; 848}; 849 ; 850////////////////////////////////////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:30092,Availability,error,errors,30092,"0 || bin >= fNcells) return 0;; 847 return fBinEntries.fArray[bin];; 848}; 849 ; 850////////////////////////////////////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886/////////////////////////////////",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:30150,Availability,error,errors,30150,"0 || bin >= fNcells) return 0;; 847 return fBinEntries.fArray[bin];; 848}; 849 ; 850////////////////////////////////////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886/////////////////////////////////",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:30252,Availability,error,errors,30252,"//////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886////////////////////////////////////////////////////////////////////////////////; 887/// Return option to compute profile2D errors.; 888 ; 889Opti",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:30414,Availability,error,errors,30414,"se of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886////////////////////////////////////////////////////////////////////////////////; 887/// Return option to compute profile2D errors.; 888 ; 889Option_t *TProfile2D::GetErrorOption() const; 890{; 891 if (fErrorMode == kERRORSPREAD) return ""s"";; 892 if (fErrorMode == kERRORSPREADI) return ""i",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:31232,Availability,error,errors,31232,"6/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886////////////////////////////////////////////////////////////////////////////////; 887/// Return option to compute profile2D errors.; 888 ; 889Option_t *TProfile2D::GetErrorOption() const; 890{; 891 if (fErrorMode == kERRORSPREAD) return ""s"";; 892 if (fErrorMode == kERRORSPREADI) return ""i"";; 893 if (fErrorMode == kERRORSPREADG) return ""g"";; 894 return """";; 895}; 896 ; 897////////////////////////////////////////////////////////////////////////////////; 898/// Fill the array stats from the contents of this profile.; 899/// The array stats must be correctly dimensioned in the calling program.; 900///; 901/// - stats[0] = sumw; 902/// - stats[1] = sumw2; 903/// - stats[2] = sumwx; 904/// - stats[3] = sumwx2; 905/// - stats[4] = sumwy; 906/// - stats[5] = sumwy2; 907/// - stats[6] = sumwxy; 908/// - stats[7] = sumwz; 909/// - stats[8] = sumwz2; 910///; 911/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 912/// is simply a copy o",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:35551,Availability,down,down,35551," the number of bins for this axis to the number of bins having a label.; 979 ; 980void TProfile2D::LabelsDeflate(Option_t *ax); 981{; 982 TProfileHelper::LabelsDeflate(this, ax);; 983}; 984 ; 985////////////////////////////////////////////////////////////////////////////////; 986/// Double the number of bins for axis.; 987/// Refill histogram; 988/// This function is called by TAxis::FindBin(const char *label); 989 ; 990void TProfile2D::LabelsInflate(Option_t *ax); 991{; 992 TProfileHelper::LabelsInflate(this, ax);; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set option(s) to draw axis with labels.; 997///; 998/// option might have the following values:; 999///; 1000/// - ""a"" sort by alphabetic order; 1001/// - "">"" sort by decreasing values; 1002/// - ""<"" sort by increasing values; 1003/// - ""h"" draw labels horizontal; 1004/// - ""v"" draw labels vertical; 1005/// - ""u"" draw labels up (end of label right adjusted); 1006/// - ""d"" draw labels down (start of label left adjusted); 1007 ; 1008void TProfile2D::LabelsOption(Option_t *option, Option_t *ax); 1009{; 1010 ; 1011 TAxis *axis = GetXaxis();; 1012 if (ax[0] == 'y' || ax[0] == 'Y') axis = GetYaxis();; 1013 THashList *labels = axis->GetLabels();; 1014 if (!labels) {; 1015 Warning(""LabelsOption"",""Cannot sort. No labels"");; 1016 return;; 1017 }; 1018 TString opt = option;; 1019 opt.ToLower();; 1020 if (opt.Contains(""h"")) {; 1021 axis->SetBit(TAxis::kLabelsHori);; 1022 axis->ResetBit(TAxis::kLabelsVert);; 1023 axis->ResetBit(TAxis::kLabelsDown);; 1024 axis->ResetBit(TAxis::kLabelsUp);; 1025 }; 1026 if (opt.Contains(""v"")) {; 1027 axis->SetBit(TAxis::kLabelsVert);; 1028 axis->ResetBit(TAxis::kLabelsHori);; 1029 axis->ResetBit(TAxis::kLabelsDown);; 1030 axis->ResetBit(TAxis::kLabelsUp);; 1031 }; 1032 if (opt.Contains(""u"")) {; 1033 axis->SetBit(TAxis::kLabelsUp);; 1034 axis->ResetBit(TAxis::kLabelsVert);; 1035 axis->ResetBit(TAxis::kLabelsDown);; 1036 axis->ResetBit(",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:38207,Availability,error,errors,38207,"utive and starts from the first bin; 1054 // in that case the current code will work fine; 1055 Int_t firstLabelBin = axis->GetNbins() + 1;; 1056 Int_t lastLabelBin = -1;; 1057 for (Int_t i = 0; i < n; ++i) {; 1058 Int_t bin = labels->At(i)->GetUniqueID();; 1059 if (bin < firstLabelBin); 1060 firstLabelBin = bin;; 1061 if (bin > lastLabelBin); 1062 lastLabelBin = bin;; 1063 }; 1064 if (firstLabelBin != 1 || lastLabelBin - firstLabelBin + 1 != n) {; 1065 Error(""LabelsOption"",; 1066 ""%s of TProfile2D %s contains bins without labels. Sorting will not work correctly - return"",; 1067 axis->GetName(), GetName());; 1068 return;; 1069 }; 1070 // case where label bins are consecutive starting from first bin will work; 1071 Warning(; 1072 ""LabelsOption"",; 1073 ""axis %s of TProfile2D %s has extra following bins without labels. Sorting will work only for first label bins"",; 1074 axis->GetName(), GetName());; 1075 }; 1076 ; 1077 std::vector<Int_t> a(n);; 1078 Int_t i, j, k, ibin, bin;; 1079 std::vector<Double_t> sumw(fNcells);; 1080 std::vector<Double_t> errors(fNcells);; 1081 std::vector<Double_t> ent(fNcells);; 1082 std::vector<Double_t> binsw2;; 1083 if (fBinSumw2.fN); 1084 binsw2.resize(fNcells);; 1085 ; 1086 // delete buffer if it is there since bins will be reordered.; 1087 if (fBuffer); 1088 BufferEmpty(1);; 1089 ; 1090 // number of bins to loop; 1091 Int_t nx = (axis == GetXaxis()) ? n + 1 : fXaxis.GetNbins() + 2;; 1092 Int_t ny = (axis == GetYaxis()) ? n + 1 : fYaxis.GetNbins() + 2;; 1093 ; 1094 // make a labelold list but ordered with bins; 1095 // (re-ordered original label list); 1096 std::vector<TObject *> labold(n);; 1097 for (i = 0; i < n; i++); 1098 labold[i] = nullptr;; 1099 TIter nextold(labels);; 1100 TObject *obj;; 1101 while ((obj = nextold())) {; 1102 bin = obj->GetUniqueID();; 1103 if (bin>=1 && bin<=n); 1104 labold[bin-1] = obj;; 1105 }; 1106 // order now labold according to bin content; 1107 ; 1108 labels->Clear();; 1109 ; 1110 std::vector<Double_t> pcon",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:39399,Availability,error,errors,39399,"binsw2.resize(fNcells);; 1085 ; 1086 // delete buffer if it is there since bins will be reordered.; 1087 if (fBuffer); 1088 BufferEmpty(1);; 1089 ; 1090 // number of bins to loop; 1091 Int_t nx = (axis == GetXaxis()) ? n + 1 : fXaxis.GetNbins() + 2;; 1092 Int_t ny = (axis == GetYaxis()) ? n + 1 : fYaxis.GetNbins() + 2;; 1093 ; 1094 // make a labelold list but ordered with bins; 1095 // (re-ordered original label list); 1096 std::vector<TObject *> labold(n);; 1097 for (i = 0; i < n; i++); 1098 labold[i] = nullptr;; 1099 TIter nextold(labels);; 1100 TObject *obj;; 1101 while ((obj = nextold())) {; 1102 bin = obj->GetUniqueID();; 1103 if (bin>=1 && bin<=n); 1104 labold[bin-1] = obj;; 1105 }; 1106 // order now labold according to bin content; 1107 ; 1108 labels->Clear();; 1109 ; 1110 std::vector<Double_t> pcont;; 1111 std::vector<Double_t> econt;; 1112 if (sort > 0) {; 1113 pcont.resize(n);; 1114 econt.resize(n);; 1115 }; 1116 ; 1117 for (i = 0; i < nx; i++) {; 1118 for (j = 0; j < ny; j++) {; 1119 bin = GetBin(i, j);; 1120 sumw[bin] = fArray[bin];; 1121 errors[bin] = fSumw2.fArray[bin];; 1122 ent[bin] = fBinEntries.fArray[bin];; 1123 if (fBinSumw2.fN); 1124 binsw2[bin] = fBinSumw2.fArray[bin];; 1125 if (axis == GetXaxis()); 1126 k = i - 1;; 1127 else; 1128 k = j - 1;; 1129 //---when sorting by values of bins; 1130 if (sort > 0 && fBinEntries.fArray[bin] != 0 && k > 0 && k < n) {; 1131 pcont[k] += fArray[bin];; 1132 econt[k] += fBinEntries.fArray[bin];; 1133 }; 1134 }; 1135 }; 1136 // compute average of slize for ordering; 1137 if (sort > 0) {; 1138 for (k = 0; k < n; ++k) {; 1139 a[k] = k;; 1140 if (econt[k] > 0); 1141 pcont[k] /= econt[k];; 1142 }; 1143 if (sort == 1); 1144 TMath::Sort(n, pcont.data(), a.data(), kTRUE); // sort by decreasing values; 1145 else; 1146 TMath::Sort(n, pcont.data(), a.data(), kFALSE); // sort by increasing values; 1147 } else {; 1148 //---alphabetic sort; 1149 // sort labels using vector of strings and TMath::Sort; 1150 // I need to array b",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:41428,Availability,error,errors,41428,";; 1152 for (i = 0; i < n; i++) {; 1153 vecLabels[i] = labold[i]->GetName();; 1154 a[i] = i;; 1155 }; 1156 // sort in ascending order for strings; 1157 TMath::Sort(n, vecLabels.data(), a.data(), kFALSE);; 1158 }; 1159 ; 1160 // set the new labels; 1161 for (i = 0; i < n; i++) {; 1162 obj = labold[a[i]];; 1163 labels->Add(obj);; 1164 // set the corresponding bin. NB bin starts from 1; 1165 obj->SetUniqueID(i + 1);; 1166 if (gDebug); 1167 std::cout << ""bin "" << i + 1 << "" setting new labels for axis "" << labold.at(a[i])->GetName() << "" from ""; 1168 << a[i] << std::endl;; 1169 }; 1170 // set the new content; 1171 for (i = 0; i < nx; i++) {; 1172 for (j = 0; j < ny; j++) {; 1173 bin = GetBin(i, j);; 1174 if (axis == GetXaxis()) {; 1175 if (i == 0) break; // skip underflow in x; 1176 ibin = GetBin(a[i - 1] + 1, j);; 1177 } else {; 1178 if (j == 0) continue; // skip underflow in y; 1179 ibin = GetBin(i, a[j-1] + 1);; 1180 }; 1181 fArray[bin] = sumw[ibin];; 1182 fSumw2.fArray[bin] = errors[ibin];; 1183 fBinEntries.fArray[bin] = ent[ibin];; 1184 if (fBinSumw2.fN); 1185 fBinSumw2.fArray[bin] = binsw2[ibin];; 1186 }; 1187 }; 1188 // need to set to zero the statistics if axis has been sorted; 1189 // see for example TH3::PutStats for definition of s vector; 1190 bool labelsAreSorted = kFALSE;; 1191 for (i = 0; i < n; ++i) {; 1192 if (a[i] != i) {; 1193 labelsAreSorted = kTRUE;; 1194 break;; 1195 }; 1196 }; 1197 if (labelsAreSorted) {; 1198 double s[TH1::kNstat];; 1199 GetStats(s);; 1200 if (axis == GetXaxis()) {; 1201 s[2] = 0; // fTsumwx; 1202 s[3] = 0; // fTsumwx2; 1203 s[6] = 0; // fTsumwxy; 1204 } else {; 1205 s[4] = 0; // fTsumwy; 1206 s[5] = 0; // fTsumwy2; 1207 s[6] = 0; // fTsumwxy; 1208 }; 1209 PutStats(s);; 1210 }; 1211}; 1212 ; 1213////////////////////////////////////////////////////////////////////////////////; 1214/// Merge all histograms in the collection in this histogram.; 1215/// This function computes the min/max for the axes,; 1216/// compute a new number of",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:42485,Availability,error,errors,42485,"= errors[ibin];; 1183 fBinEntries.fArray[bin] = ent[ibin];; 1184 if (fBinSumw2.fN); 1185 fBinSumw2.fArray[bin] = binsw2[ibin];; 1186 }; 1187 }; 1188 // need to set to zero the statistics if axis has been sorted; 1189 // see for example TH3::PutStats for definition of s vector; 1190 bool labelsAreSorted = kFALSE;; 1191 for (i = 0; i < n; ++i) {; 1192 if (a[i] != i) {; 1193 labelsAreSorted = kTRUE;; 1194 break;; 1195 }; 1196 }; 1197 if (labelsAreSorted) {; 1198 double s[TH1::kNstat];; 1199 GetStats(s);; 1200 if (axis == GetXaxis()) {; 1201 s[2] = 0; // fTsumwx; 1202 s[3] = 0; // fTsumwx2; 1203 s[6] = 0; // fTsumwxy; 1204 } else {; 1205 s[4] = 0; // fTsumwy; 1206 s[5] = 0; // fTsumwy2; 1207 s[6] = 0; // fTsumwxy; 1208 }; 1209 PutStats(s);; 1210 }; 1211}; 1212 ; 1213////////////////////////////////////////////////////////////////////////////////; 1214/// Merge all histograms in the collection in this histogram.; 1215/// This function computes the min/max for the axes,; 1216/// compute a new number of bins, if necessary,; 1217/// add bin contents, errors and statistics.; 1218/// If overflows are present and limits are different the function will fail.; 1219/// The function returns the total number of entries in the result histogram; 1220/// if the merge is successful, -1 otherwise.; 1221///; 1222/// IMPORTANT remark. The 2 axis x and y may have different number; 1223/// of bins and different limits, BUT the largest bin width must be; 1224/// a multiple of the smallest bin width and the upper limit must also; 1225/// be a multiple of the bin width.; 1226 ; 1227Long64_t TProfile2D::Merge(TCollection *li); 1228{; 1229 return TProfileHelper::Merge(this, li);; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Performs the operation: this = this*c1*f1; 1234 ; 1235Bool_t TProfile2D::Multiply(TF1 *, Double_t ); 1236{; 1237 Error(""Multiply"",""Function not implemented for TProfile2D"");; 1238 return kFALSE;; 1239}; 1240 ; 1241",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:44448,Availability,error,errors,44448,"/////////////////////////////////; 1242/// Multiply this profile2D by h1.; 1243///; 1244/// `this = this*h1`; 1245 ; 1246Bool_t TProfile2D::Multiply(const TH1 *); 1247{; 1248 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1249 return kFALSE;; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Replace contents of this profile2D by multiplication of h1 by h2.; 1254///; 1255/// `this = (c1*h1)*(c2*h2)`; 1256 ; 1257Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1258{; 1259 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1260 return kFALSE;; 1261}; 1262 ; 1263////////////////////////////////////////////////////////////////////////////////; 1264/// Project this profile2D into a 2-D histogram along X,Y.; 1265///; 1266/// The projection is always of the type TH2D.; 1267///; 1268/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1269/// to be equal to the errors of the profile.; 1270/// Option ""E"" is defined as the default one in the header file.; 1271/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1272/// - if option ""B"" is specified, the content of bin of the returned histogram; 1273/// will be equal to the GetBinEntries(bin) of the profile,; 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH2D using the 3-rd value as a weight.; 1280/// This option makes sense only for profile filled with all weights =1.; 1281/// When the profile is weighted (filled with weights different than 1) the; 1282/// bin erro",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:44531,Availability,error,errors,44531,"/////////////////////////////////; 1242/// Multiply this profile2D by h1.; 1243///; 1244/// `this = this*h1`; 1245 ; 1246Bool_t TProfile2D::Multiply(const TH1 *); 1247{; 1248 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1249 return kFALSE;; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Replace contents of this profile2D by multiplication of h1 by h2.; 1254///; 1255/// `this = (c1*h1)*(c2*h2)`; 1256 ; 1257Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1258{; 1259 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1260 return kFALSE;; 1261}; 1262 ; 1263////////////////////////////////////////////////////////////////////////////////; 1264/// Project this profile2D into a 2-D histogram along X,Y.; 1265///; 1266/// The projection is always of the type TH2D.; 1267///; 1268/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1269/// to be equal to the errors of the profile.; 1270/// Option ""E"" is defined as the default one in the header file.; 1271/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1272/// - if option ""B"" is specified, the content of bin of the returned histogram; 1273/// will be equal to the GetBinEntries(bin) of the profile,; 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH2D using the 3-rd value as a weight.; 1280/// This option makes sense only for profile filled with all weights =1.; 1281/// When the profile is weighted (filled with weights different than 1) the; 1282/// bin erro",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:44675,Availability,error,errors,44675,"rofile2D by multiplication of h1 by h2.; 1254///; 1255/// `this = (c1*h1)*(c2*h2)`; 1256 ; 1257Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1258{; 1259 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1260 return kFALSE;; 1261}; 1262 ; 1263////////////////////////////////////////////////////////////////////////////////; 1264/// Project this profile2D into a 2-D histogram along X,Y.; 1265///; 1266/// The projection is always of the type TH2D.; 1267///; 1268/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1269/// to be equal to the errors of the profile.; 1270/// Option ""E"" is defined as the default one in the header file.; 1271/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1272/// - if option ""B"" is specified, the content of bin of the returned histogram; 1273/// will be equal to the GetBinEntries(bin) of the profile,; 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH2D using the 3-rd value as a weight.; 1280/// This option makes sense only for profile filled with all weights =1.; 1281/// When the profile is weighted (filled with weights different than 1) the; 1282/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 1283/// correctly computed from the information stored in the profile. In that case the; 1284/// obtained histogram contains as bin error square the weighted sum of the square of the; 1285/// profiled observable (TProfile2D::fSumw2[bin] ); 1286 ; 1287TH2D *TProfile2D::ProjectionXY(const char *name, Option_t *option) const; 1288{; 12",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:44956,Availability,error,errors,44956,"rofile2D by multiplication of h1 by h2.; 1254///; 1255/// `this = (c1*h1)*(c2*h2)`; 1256 ; 1257Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1258{; 1259 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1260 return kFALSE;; 1261}; 1262 ; 1263////////////////////////////////////////////////////////////////////////////////; 1264/// Project this profile2D into a 2-D histogram along X,Y.; 1265///; 1266/// The projection is always of the type TH2D.; 1267///; 1268/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1269/// to be equal to the errors of the profile.; 1270/// Option ""E"" is defined as the default one in the header file.; 1271/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1272/// - if option ""B"" is specified, the content of bin of the returned histogram; 1273/// will be equal to the GetBinEntries(bin) of the profile,; 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH2D using the 3-rd value as a weight.; 1280/// This option makes sense only for profile filled with all weights =1.; 1281/// When the profile is weighted (filled with weights different than 1) the; 1282/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 1283/// correctly computed from the information stored in the profile. In that case the; 1284/// obtained histogram contains as bin error square the weighted sum of the square of the; 1285/// profiled observable (TProfile2D::fSumw2[bin] ); 1286 ; 1287TH2D *TProfile2D::ProjectionXY(const char *name, Option_t *option) const; 1288{; 12",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:45471,Availability,error,error,45471,"d set; 1269/// to be equal to the errors of the profile.; 1270/// Option ""E"" is defined as the default one in the header file.; 1271/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1272/// - if option ""B"" is specified, the content of bin of the returned histogram; 1273/// will be equal to the GetBinEntries(bin) of the profile,; 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH2D using the 3-rd value as a weight.; 1280/// This option makes sense only for profile filled with all weights =1.; 1281/// When the profile is weighted (filled with weights different than 1) the; 1282/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 1283/// correctly computed from the information stored in the profile. In that case the; 1284/// obtained histogram contains as bin error square the weighted sum of the square of the; 1285/// profiled observable (TProfile2D::fSumw2[bin] ); 1286 ; 1287TH2D *TProfile2D::ProjectionXY(const char *name, Option_t *option) const; 1288{; 1289 ; 1290 TString opt = option;; 1291 opt.ToLower();; 1292 ; 1293 // Create the projection histogram; 1294 // name of projected histogram is by default name of original histogram + _pxy; 1295 TString pname(name);; 1296 if (pname.IsNull() || pname == ""_pxy""); 1297 pname = TString(GetName() ) + TString(""_pxy"");; 1298 ; 1299 ; 1300 Int_t nx = fXaxis.GetNbins();; 1301 Int_t ny = fYaxis.GetNbins();; 1302 const TArrayD *xbins = fXaxis.GetXbins();; 1303 const TArrayD *ybins = fYaxis.GetXbins();; 1304 TH2D * h1 = nullptr;; 1305 if (xbins->fN == 0 && ybins->fN == 0) {; 1306 h1 = new TH2D(pname,GetTitle(),nx,fXaxis.Ge",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:45680,Availability,error,error,45680,"bin of the returned histogram; 1273/// will be equal to the GetBinEntries(bin) of the profile,; 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH2D using the 3-rd value as a weight.; 1280/// This option makes sense only for profile filled with all weights =1.; 1281/// When the profile is weighted (filled with weights different than 1) the; 1282/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 1283/// correctly computed from the information stored in the profile. In that case the; 1284/// obtained histogram contains as bin error square the weighted sum of the square of the; 1285/// profiled observable (TProfile2D::fSumw2[bin] ); 1286 ; 1287TH2D *TProfile2D::ProjectionXY(const char *name, Option_t *option) const; 1288{; 1289 ; 1290 TString opt = option;; 1291 opt.ToLower();; 1292 ; 1293 // Create the projection histogram; 1294 // name of projected histogram is by default name of original histogram + _pxy; 1295 TString pname(name);; 1296 if (pname.IsNull() || pname == ""_pxy""); 1297 pname = TString(GetName() ) + TString(""_pxy"");; 1298 ; 1299 ; 1300 Int_t nx = fXaxis.GetNbins();; 1301 Int_t ny = fYaxis.GetNbins();; 1302 const TArrayD *xbins = fXaxis.GetXbins();; 1303 const TArrayD *ybins = fYaxis.GetXbins();; 1304 TH2D * h1 = nullptr;; 1305 if (xbins->fN == 0 && ybins->fN == 0) {; 1306 h1 = new TH2D(pname,GetTitle(),nx,fXaxis.GetXmin(),fXaxis.GetXmax(),ny,fYaxis.GetXmin(),fYaxis.GetXmax());; 1307 } else if (xbins->fN == 0) {; 1308 h1 = new TH2D(pname,GetTitle(),nx,fXaxis.GetXmin(),fXaxis.GetXmax(),ny, ybins->GetArray() );; 1309 } else if (ybins->fN == 0) {; 1310 h1 = new TH2D(pname,GetTitle(),nx,x",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:47988,Availability,error,errors,47988,"pname,GetTitle(),nx,xbins->GetArray(),ny,ybins->GetArray() );; 1313 }; 1314 fXaxis.Copy(*h1->GetXaxis());; 1315 fYaxis.Copy(*h1->GetYaxis());; 1316 Bool_t computeErrors = kFALSE;; 1317 Bool_t cequalErrors = kFALSE;; 1318 Bool_t binEntries = kFALSE;; 1319 Bool_t binWeight = kFALSE;; 1320 if (opt.Contains(""b"")) binEntries = kTRUE;; 1321 if (opt.Contains(""e"")) computeErrors = kTRUE;; 1322 if (opt.Contains(""w"")) binWeight = kTRUE;; 1323 if (opt.Contains(""c=e"")) {cequalErrors = kTRUE; computeErrors=kFALSE;}; 1324 if (computeErrors || binWeight || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 1325 ; 1326 // Fill the projected histogram; 1327 Int_t bin,binx, biny;; 1328 Double_t cont;; 1329 for (binx =0;binx<=nx+1;binx++) {; 1330 for (biny =0;biny<=ny+1;biny++) {; 1331 bin = GetBin(binx,biny);; 1332 ; 1333 if (binEntries) cont = GetBinEntries(bin);; 1334 else if (cequalErrors) cont = GetBinError(bin);; 1335 else if (binWeight) cont = GetBinContent(bin) * GetBinEntries(bin);; 1336 else cont = GetBinContent(bin); // default case; 1337 ; 1338 h1->SetBinContent(bin ,cont);; 1339 ; 1340 // if option E projected histogram errors are same as profile; 1341 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1342 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1343 // this is correct only if the profile is unweighted; 1344 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1345 // in case of bin entries and profile is weighted, we need to set also the bin error; 1346 if (binEntries && fBinSumw2.fN ) {; 1347 R__ASSERT( h1->GetSumw2() );; 1348 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1349 }; 1350 }; 1351 }; 1352 h1->SetEntries(fEntries);; 1353 return h1;; 1354}; 1355 ; 1356////////////////////////////////////////////////////////////////////////////////; 1357/// Project a 2-D histogram into a profile histogram along X.; 1358///; 1359/// The projection is made from the channels along the Y axis; 1360/// ranging f",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:48116,Availability,error,error,48116,"pname,GetTitle(),nx,xbins->GetArray(),ny,ybins->GetArray() );; 1313 }; 1314 fXaxis.Copy(*h1->GetXaxis());; 1315 fYaxis.Copy(*h1->GetYaxis());; 1316 Bool_t computeErrors = kFALSE;; 1317 Bool_t cequalErrors = kFALSE;; 1318 Bool_t binEntries = kFALSE;; 1319 Bool_t binWeight = kFALSE;; 1320 if (opt.Contains(""b"")) binEntries = kTRUE;; 1321 if (opt.Contains(""e"")) computeErrors = kTRUE;; 1322 if (opt.Contains(""w"")) binWeight = kTRUE;; 1323 if (opt.Contains(""c=e"")) {cequalErrors = kTRUE; computeErrors=kFALSE;}; 1324 if (computeErrors || binWeight || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 1325 ; 1326 // Fill the projected histogram; 1327 Int_t bin,binx, biny;; 1328 Double_t cont;; 1329 for (binx =0;binx<=nx+1;binx++) {; 1330 for (biny =0;biny<=ny+1;biny++) {; 1331 bin = GetBin(binx,biny);; 1332 ; 1333 if (binEntries) cont = GetBinEntries(bin);; 1334 else if (cequalErrors) cont = GetBinError(bin);; 1335 else if (binWeight) cont = GetBinContent(bin) * GetBinEntries(bin);; 1336 else cont = GetBinContent(bin); // default case; 1337 ; 1338 h1->SetBinContent(bin ,cont);; 1339 ; 1340 // if option E projected histogram errors are same as profile; 1341 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1342 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1343 // this is correct only if the profile is unweighted; 1344 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1345 // in case of bin entries and profile is weighted, we need to set also the bin error; 1346 if (binEntries && fBinSumw2.fN ) {; 1347 R__ASSERT( h1->GetSumw2() );; 1348 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1349 }; 1350 }; 1351 }; 1352 h1->SetEntries(fEntries);; 1353 return h1;; 1354}; 1355 ; 1356////////////////////////////////////////////////////////////////////////////////; 1357/// Project a 2-D histogram into a profile histogram along X.; 1358///; 1359/// The projection is made from the channels along the Y axis; 1360/// ranging f",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:48387,Availability,error,error,48387,"rs=kFALSE;}; 1324 if (computeErrors || binWeight || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 1325 ; 1326 // Fill the projected histogram; 1327 Int_t bin,binx, biny;; 1328 Double_t cont;; 1329 for (binx =0;binx<=nx+1;binx++) {; 1330 for (biny =0;biny<=ny+1;biny++) {; 1331 bin = GetBin(binx,biny);; 1332 ; 1333 if (binEntries) cont = GetBinEntries(bin);; 1334 else if (cequalErrors) cont = GetBinError(bin);; 1335 else if (binWeight) cont = GetBinContent(bin) * GetBinEntries(bin);; 1336 else cont = GetBinContent(bin); // default case; 1337 ; 1338 h1->SetBinContent(bin ,cont);; 1339 ; 1340 // if option E projected histogram errors are same as profile; 1341 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1342 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1343 // this is correct only if the profile is unweighted; 1344 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1345 // in case of bin entries and profile is weighted, we need to set also the bin error; 1346 if (binEntries && fBinSumw2.fN ) {; 1347 R__ASSERT( h1->GetSumw2() );; 1348 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1349 }; 1350 }; 1351 }; 1352 h1->SetEntries(fEntries);; 1353 return h1;; 1354}; 1355 ; 1356////////////////////////////////////////////////////////////////////////////////; 1357/// Project a 2-D histogram into a profile histogram along X.; 1358///; 1359/// The projection is made from the channels along the Y axis; 1360/// ranging from firstybin to lastybin included.; 1361/// The result is a 1D profile which contains the combination of all the considered bins along Y; 1362/// By default, bins 1 to ny are included; 1363/// When all bins are included, the number of entries in the projection; 1364/// is set to the number of entries of the 2-D histogram, otherwise; 1365/// the number of entries is incremented by 1 for all non empty cells.; 1366///; 1367/// The option can also be used to specify the projected profile error ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:49352,Availability,error,error,49352,"e of bin entries and profile is weighted, we need to set also the bin error; 1346 if (binEntries && fBinSumw2.fN ) {; 1347 R__ASSERT( h1->GetSumw2() );; 1348 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1349 }; 1350 }; 1351 }; 1352 h1->SetEntries(fEntries);; 1353 return h1;; 1354}; 1355 ; 1356////////////////////////////////////////////////////////////////////////////////; 1357/// Project a 2-D histogram into a profile histogram along X.; 1358///; 1359/// The projection is made from the channels along the Y axis; 1360/// ranging from firstybin to lastybin included.; 1361/// The result is a 1D profile which contains the combination of all the considered bins along Y; 1362/// By default, bins 1 to ny are included; 1363/// When all bins are included, the number of entries in the projection; 1364/// is set to the number of entries of the 2-D histogram, otherwise; 1365/// the number of entries is incremented by 1 for all non empty cells.; 1366///; 1367/// The option can also be used to specify the projected profile error type.; 1368/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 1369 ; 1370TProfile *TProfile2D::ProfileX(const char *name, Int_t firstybin, Int_t lastybin, Option_t *option) const; 1371{; 1372 return DoProfile(true, name, firstybin, lastybin, option);; 1373}; 1374 ; 1375////////////////////////////////////////////////////////////////////////////////; 1376/// Project a 2-D histogram into a profile histogram along X; 1377///; 1378/// The projection is made from the channels along the X axis; 1379/// ranging from firstybin to lastybin included.; 1380/// The result is a 1D profile which contains the combination of all the considered bins along X; 1381/// By default, bins 1 to ny are included; 1382/// When all bins are included, the number of entries in the projection; 1383/// is set to the number of entries of the 2-D histogram, otherwise; 1384/// the number of entries is incremented by 1 for all non empty cells",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:50399,Availability,error,error,50399," 1368/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 1369 ; 1370TProfile *TProfile2D::ProfileX(const char *name, Int_t firstybin, Int_t lastybin, Option_t *option) const; 1371{; 1372 return DoProfile(true, name, firstybin, lastybin, option);; 1373}; 1374 ; 1375////////////////////////////////////////////////////////////////////////////////; 1376/// Project a 2-D histogram into a profile histogram along X; 1377///; 1378/// The projection is made from the channels along the X axis; 1379/// ranging from firstybin to lastybin included.; 1380/// The result is a 1D profile which contains the combination of all the considered bins along X; 1381/// By default, bins 1 to ny are included; 1382/// When all bins are included, the number of entries in the projection; 1383/// is set to the number of entries of the 2-D histogram, otherwise; 1384/// the number of entries is incremented by 1 for all non empty cells.; 1385///; 1386/// The option can also be used to specify the projected profile error type.; 1387/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 1388 ; 1389TProfile *TProfile2D::ProfileY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 1390{; 1391 return DoProfile(false, name, firstxbin, lastxbin, option);; 1392}; 1393 ; 1394////////////////////////////////////////////////////////////////////////////////; 1395/// Implementation of ProfileX or ProfileY for a TProfile2D.; 1396///; 1397/// Do correctly the combination of the bin averages when doing the projection; 1398 ; 1399TProfile * TProfile2D::DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const {; 1400 TString opt = option;; 1401 opt.ToLower();; 1402 bool originalRange = opt.Contains(""o"");; 1403 ; 1404 TString expectedName = ( onX ? ""_pfx"" : ""_pfy"" );; 1405 ; 1406 TString pname(name);; 1407 if (pname.IsNull() || name == expectedName); 1408 pname = TString(GetName() ) + e",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:53575,Availability,error,errors,53575,"SSERT( h1W->GetSumw2()->fN != 0); // h1W should always be a weighted histogram since h2dW is; 1451 for (int i = 0; i < p1->fN ; ++i) {; 1452 p1->fArray[i] = h1W->GetBinContent(i); // array of profile is sum of all values; 1453 p1->GetSumw2()->fArray[i] = h1W->GetSumw2()->fArray[i]; // array of content square of profile is weight square of the W projected histogram; 1454 p1->SetBinEntries(i, h1N->GetBinContent(i) );; 1455 if (fBinSumw2.fN) p1->GetBinSumw2()->fArray[i] = h1N->GetSumw2()->fArray[i]; // sum of weight squares are stored to compute errors in h1N histogram; 1456 }; 1457 // delete the created histograms; 1458 delete h2dW;; 1459 delete h2dN;; 1460 delete h1W;; 1461 delete h1N;; 1462 ; 1463 // Also we need to set the entries since they have not been correctly calculated during the projection; 1464 // we can only set them to the effective entries; 1465 p1->SetEntries( p1->GetEffectiveEntries() );; 1466 ; 1467 return p1;; 1468}; 1469 ; 1470 ; 1471////////////////////////////////////////////////////////////////////////////////; 1472/// Replace current statistics with the values in array stats; 1473 ; 1474void TProfile2D::PutStats(Double_t *stats); 1475{; 1476 fTsumw = stats[0];; 1477 fTsumw2 = stats[1];; 1478 fTsumwx = stats[2];; 1479 fTsumwx2 = stats[3];; 1480 fTsumwy = stats[4];; 1481 fTsumwy2 = stats[5];; 1482 fTsumwxy = stats[6];; 1483 fTsumwz = stats[7];; 1484 fTsumwz2 = stats[8];; 1485}; 1486 ; 1487////////////////////////////////////////////////////////////////////////////////; 1488/// Reset contents of a Profile2D histogram.; 1489 ; 1490void TProfile2D::Reset(Option_t *option); 1491{; 1492 TH2D::Reset(option);; 1493 fBinEntries.Reset();; 1494 fBinSumw2.Reset();; 1495 TString opt = option;; 1496 opt.ToUpper();; 1497 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1498 fTsumwz = fTsumwz2 = 0;; 1499}; 1500 ; 1501 ; 1502////////////////////////////////////////////////////////////////////////////////; 1503/// Profile histogram is resized along axis suc",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:55384,Availability,error,errors,55384,"s[6];; 1483 fTsumwz = stats[7];; 1484 fTsumwz2 = stats[8];; 1485}; 1486 ; 1487////////////////////////////////////////////////////////////////////////////////; 1488/// Reset contents of a Profile2D histogram.; 1489 ; 1490void TProfile2D::Reset(Option_t *option); 1491{; 1492 TH2D::Reset(option);; 1493 fBinEntries.Reset();; 1494 fBinSumw2.Reset();; 1495 TString opt = option;; 1496 opt.ToUpper();; 1497 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1498 fTsumwz = fTsumwz2 = 0;; 1499}; 1500 ; 1501 ; 1502////////////////////////////////////////////////////////////////////////////////; 1503/// Profile histogram is resized along axis such that x is in the axis range.; 1504///; 1505/// The new axis limits are recomputed by doubling iteratively; 1506/// the current axis range until the specified value x is within the limits.; 1507/// The algorithm makes a copy of the histogram, then loops on all bins; 1508/// of the old histogram to fill the extended histogram.; 1509/// Takes into account errors (Sumw2) if any.; 1510/// The axis must be extendable before invoking this function.; 1511///; 1512/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1513 ; 1514void TProfile2D::ExtendAxis(Double_t x, TAxis *axis); 1515{; 1516 TProfile2D* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1517 if ( hold ) {; 1518 fTsumwz = hold->fTsumwz;; 1519 fTsumwz2 = hold->fTsumwz2;; 1520 delete hold;; 1521 }; 1522}; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1526///; 1527/// if newname is not blank a new profile hnew is created.; 1528/// else the current histogram is modified (default); 1529/// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; 1530/// have to be merged into one bin of hnew; 1531/// If the original profile has errors stored (via Sumw2), the resulting; 1532/// profile has new errors correctly calculated.; ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:56285,Availability,error,errors,56285,"s.; 1507/// The algorithm makes a copy of the histogram, then loops on all bins; 1508/// of the old histogram to fill the extended histogram.; 1509/// Takes into account errors (Sumw2) if any.; 1510/// The axis must be extendable before invoking this function.; 1511///; 1512/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1513 ; 1514void TProfile2D::ExtendAxis(Double_t x, TAxis *axis); 1515{; 1516 TProfile2D* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1517 if ( hold ) {; 1518 fTsumwz = hold->fTsumwz;; 1519 fTsumwz2 = hold->fTsumwz2;; 1520 delete hold;; 1521 }; 1522}; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1526///; 1527/// if newname is not blank a new profile hnew is created.; 1528/// else the current histogram is modified (default); 1529/// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; 1530/// have to be merged into one bin of hnew; 1531/// If the original profile has errors stored (via Sumw2), the resulting; 1532/// profile has new errors correctly calculated.; 1533///; 1534/// examples: if hpxpy is an existing TProfile2D profile with 40 x 40 bins; 1535/// ~~~ {.cpp}; 1536/// hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one; 1537/// // Carefull: previous contents of hpxpy are lost; 1538/// hpxpy->Rebin2D(3,5); // merges 3 bins along the xaxis and 5 bins along the yaxis in one; 1539/// // Carefull: previous contents of hpxpy are lost; 1540/// hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; 1541/// TProfile2D *hnew = hpxpy->RebinY(5,""hnew""); // creates a new profile hnew; 1542/// // merging 5 bins of hpxpy along the yaxis in one bin; 1543/// ~~~; 1544///; 1545/// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; 1546/// along the xaxis/yaxis the top limit(s) of the rebinned profile; 1547/// is changed to the upper ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:56351,Availability,error,errors,56351,"s.; 1507/// The algorithm makes a copy of the histogram, then loops on all bins; 1508/// of the old histogram to fill the extended histogram.; 1509/// Takes into account errors (Sumw2) if any.; 1510/// The axis must be extendable before invoking this function.; 1511///; 1512/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1513 ; 1514void TProfile2D::ExtendAxis(Double_t x, TAxis *axis); 1515{; 1516 TProfile2D* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1517 if ( hold ) {; 1518 fTsumwz = hold->fTsumwz;; 1519 fTsumwz2 = hold->fTsumwz2;; 1520 delete hold;; 1521 }; 1522}; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1526///; 1527/// if newname is not blank a new profile hnew is created.; 1528/// else the current histogram is modified (default); 1529/// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; 1530/// have to be merged into one bin of hnew; 1531/// If the original profile has errors stored (via Sumw2), the resulting; 1532/// profile has new errors correctly calculated.; 1533///; 1534/// examples: if hpxpy is an existing TProfile2D profile with 40 x 40 bins; 1535/// ~~~ {.cpp}; 1536/// hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one; 1537/// // Carefull: previous contents of hpxpy are lost; 1538/// hpxpy->Rebin2D(3,5); // merges 3 bins along the xaxis and 5 bins along the yaxis in one; 1539/// // Carefull: previous contents of hpxpy are lost; 1540/// hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; 1541/// TProfile2D *hnew = hpxpy->RebinY(5,""hnew""); // creates a new profile hnew; 1542/// // merging 5 bins of hpxpy along the yaxis in one bin; 1543/// ~~~; 1544///; 1545/// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; 1546/// along the xaxis/yaxis the top limit(s) of the rebinned profile; 1547/// is changed to the upper ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:68981,Availability,error,errors,68981,"////; 1842/// Rebin only the Y axis.; 1843/// see Rebin2D; 1844 ; 1845TProfile2D * TProfile2D::RebinY(Int_t ngroup,const char * newname ) {; 1846 return Rebin2D(1,ngroup,newname);; 1847}; 1848 ; 1849////////////////////////////////////////////////////////////////////////////////; 1850/// Save primitive as a C++ statement(s) on output stream out.; 1851///; 1852/// Note the following restrictions in the code generated:; 1853/// - variable bin size not implemented; 1854/// - SetErrorOption not implemented; 1855 ; 1856void TProfile2D::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1857{; 1858 char quote = '""';; 1859 out <<"" ""<<std::endl;; 1860 out <<"" ""<<ClassName()<<"" *"";; 1861 ; 1862 out << GetName() << "" = new "" << ClassName() << ""("" << quote; 1863 << GetName() << quote << "","" << quote<< GetTitle() << quote; 1864 << "","" << GetXaxis()->GetNbins();; 1865 out << "","" << GetXaxis()->GetXmin(); 1866 << "","" << GetXaxis()->GetXmax();; 1867 out << "","" << GetYaxis()->GetNbins();; 1868 out << "","" << GetYaxis()->GetXmin(); 1869 << "","" << GetYaxis()->GetXmax();; 1870 out << "","" << fZmin; 1871 << "","" << fZmax;; 1872 out << "");"" << std::endl;; 1873 ; 1874 ; 1875 // save bin entries; 1876 Int_t bin;; 1877 for (bin=0;bin<fNcells;bin++) {; 1878 Double_t bi = GetBinEntries(bin);; 1879 if (bi) {; 1880 out<<"" ""<<GetName()<<""->SetBinEntries(""<<bin<<"",""<<bi<<"");""<<std::endl;; 1881 }; 1882 }; 1883 //save bin contents; 1884 for (bin=0;bin<fNcells;bin++) {; 1885 Double_t bc = fArray[bin];; 1886 if (bc) {; 1887 out<<"" ""<<GetName()<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1888 }; 1889 }; 1890 // save bin errors; 1891 if (fSumw2.fN) {; 1892 for (bin=0;bin<fNcells;bin++) {; 1893 Double_t be = TMath::Sqrt(fSumw2.fArray[bin]);; 1894 if (be) {; 1895 out<<"" ""<<GetName()<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 1896 }; 1897 }; 1898 }; 1899 ; 1900 TH1::SavePrimitiveHelp(out, GetName(), option);; 1901}; 1902 ; 1903//////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:71771,Availability,error,errors,71771," ; 1936void TProfile2D::SetBins(Int_t nx, const Double_t *xbins, Int_t ny, const Double_t *ybins); 1937{; 1938 TH1::SetBins(nx,xbins,ny,ybins);; 1939 fBinEntries.Set(fNcells);; 1940 if (fBinSumw2.fN) fBinSumw2.Set(fNcells);; 1941}; 1942 ; 1943////////////////////////////////////////////////////////////////////////////////; 1944/// Set total number of bins including under/overflow.; 1945/// Reallocate bin contents array; 1946 ; 1947void TProfile2D::SetBinsLength(Int_t n); 1948{; 1949 TH2D::SetBinsLength(n);; 1950 TProfileHelper::BuildArray(this);; 1951}; 1952 ; 1953////////////////////////////////////////////////////////////////////////////////; 1954/// Set the buffer size in units of 8 bytes (double).; 1955 ; 1956void TProfile2D::SetBuffer(Int_t buffersize, Option_t *); 1957{; 1958 if (fBuffer) {; 1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin con",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:71824,Availability,error,errors,71824," Reallocate bin contents array; 1946 ; 1947void TProfile2D::SetBinsLength(Int_t n); 1948{; 1949 TH2D::SetBinsLength(n);; 1950 TProfileHelper::BuildArray(this);; 1951}; 1952 ; 1953////////////////////////////////////////////////////////////////////////////////; 1954/// Set the buffer size in units of 8 bytes (double).; 1955 ; 1956void TProfile2D::SetBuffer(Int_t buffersize, Option_t *); 1957{; 1958 if (fBuffer) {; 1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y an",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:71898,Availability,error,errors,71898," Reallocate bin contents array; 1946 ; 1947void TProfile2D::SetBinsLength(Int_t n); 1948{; 1949 TH2D::SetBinsLength(n);; 1950 TProfileHelper::BuildArray(this);; 1951}; 1952 ; 1953////////////////////////////////////////////////////////////////////////////////; 1954/// Set the buffer size in units of 8 bytes (double).; 1955 ; 1956void TProfile2D::SetBuffer(Int_t buffersize, Option_t *); 1957{; 1958 if (fBuffer) {; 1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y an",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:71922,Availability,error,error,71922," Reallocate bin contents array; 1946 ; 1947void TProfile2D::SetBinsLength(Int_t n); 1948{; 1949 TH2D::SetBinsLength(n);; 1950 TProfileHelper::BuildArray(this);; 1951}; 1952 ; 1953////////////////////////////////////////////////////////////////////////////////; 1954/// Set the buffer size in units of 8 bytes (double).; 1955 ; 1956void TProfile2D::SetBuffer(Int_t buffersize, Option_t *); 1957{; 1958 if (fBuffer) {; 1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y an",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:71999,Availability,error,error,71999," TProfileHelper::BuildArray(this);; 1951}; 1952 ; 1953////////////////////////////////////////////////////////////////////////////////; 1954/// Set the buffer size in units of 8 bytes (double).; 1955 ; 1956void TProfile2D::SetBuffer(Int_t buffersize, Option_t *); 1957{; 1958 if (fBuffer) {; 1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994voi",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:72203,Availability,error,errors,72203,"1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994void TProfile2D::SetErrorOption(Option_t *option); 1995{; 1996 TProfileHelper::SetErrorOption(this, option);; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Stream an object of class TProfile2D.; 2001 ; 2002void TProfile2D::Streamer(T",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:72467,Availability,error,errors,72467,"1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994void TProfile2D::SetErrorOption(Option_t *option); 1995{; 1996 TProfileHelper::SetErrorOption(this, option);; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Stream an object of class TProfile2D.; 2001 ; 2002void TProfile2D::Streamer(T",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:72606,Availability,error,error,72606,"fer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994void TProfile2D::SetErrorOption(Option_t *option); 1995{; 1996 TProfileHelper::SetErrorOption(this, option);; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Stream an object of class TProfile2D.; 2001 ; 2002void TProfile2D::Streamer(TBuffer &R__b); 2003{; 2004 if (R__b.IsReading()) {; 2005 UInt_t R__s, R__c;; 2006 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2007 if (R__v > 2) {; 2008 R__b.ReadClassBuffer(TProfile2D::Class(), this, R__v, R__s, R__c);; 2009 return;; 2010 }; 2011 //====process old versions before automati",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:73686,Availability,error,errorMode,73686," measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994void TProfile2D::SetErrorOption(Option_t *option); 1995{; 1996 TProfileHelper::SetErrorOption(this, option);; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Stream an object of class TProfile2D.; 2001 ; 2002void TProfile2D::Streamer(TBuffer &R__b); 2003{; 2004 if (R__b.IsReading()) {; 2005 UInt_t R__s, R__c;; 2006 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2007 if (R__v > 2) {; 2008 R__b.ReadClassBuffer(TProfile2D::Class(), this, R__v, R__s, R__c);; 2009 return;; 2010 }; 2011 //====process old versions before automatic schema evolution; 2012 TH2D::Streamer(R__b);; 2013 fBinEntries.Streamer(R__b);; 2014 Int_t errorMode;; 2015 R__b >> errorMode;; 2016 fErrorMode = (EErrorType)errorMode;; 2017 if (R__v < 2) {; 2018 Float_t zmin,zmax;; 2019 R__b >> zmin; fZmin = zmin;; 2020 R__b >> zmax; fZmax = zmax;; 2021 } else {; 2022 R__b >> fZmin;; 2023 R__b >> fZmax;; 2024 }; 2025 R__b.CheckByteCount(R__s, R__c, TProfile2D::IsA());; 2026 //====end of old versions; 2027 ; 2028 } else {; 2029 R__b.WriteClassBuffer(TProfile2D::Class(),this);; 2030 }; 2031}; 2032 ; 2033////////////////////////////////////////////////////////////////////////////////; 2034/// Create/Delete structure to store sum of squares of weights per bin.; 2035///; 2036/// This is needed to compute the correct statistical quantities; 2037/// of a profile filled with weights; 2038///; 2039/// This function is automatically called when the histogram is created; 2040/// if the static function TH1::SetDefaultSumw2 has been called before.; 2041/// If flag is false the structure is deleted; 2042 ; 2043void TProfile2D::Sumw2(Bool_t flag); 2044{; 2045 TProfileHelper::Sumw2(this, flag);; 2046}; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition Rtyp",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:73711,Availability,error,errorMode,73711," measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994void TProfile2D::SetErrorOption(Option_t *option); 1995{; 1996 TProfileHelper::SetErrorOption(this, option);; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Stream an object of class TProfile2D.; 2001 ; 2002void TProfile2D::Streamer(TBuffer &R__b); 2003{; 2004 if (R__b.IsReading()) {; 2005 UInt_t R__s, R__c;; 2006 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2007 if (R__v > 2) {; 2008 R__b.ReadClassBuffer(TProfile2D::Class(), this, R__v, R__s, R__c);; 2009 return;; 2010 }; 2011 //====process old versions before automatic schema evolution; 2012 TH2D::Streamer(R__b);; 2013 fBinEntries.Streamer(R__b);; 2014 Int_t errorMode;; 2015 R__b >> errorMode;; 2016 fErrorMode = (EErrorType)errorMode;; 2017 if (R__v < 2) {; 2018 Float_t zmin,zmax;; 2019 R__b >> zmin; fZmin = zmin;; 2020 R__b >> zmax; fZmax = zmax;; 2021 } else {; 2022 R__b >> fZmin;; 2023 R__b >> fZmax;; 2024 }; 2025 R__b.CheckByteCount(R__s, R__c, TProfile2D::IsA());; 2026 //====end of old versions; 2027 ; 2028 } else {; 2029 R__b.WriteClassBuffer(TProfile2D::Class(),this);; 2030 }; 2031}; 2032 ; 2033////////////////////////////////////////////////////////////////////////////////; 2034/// Create/Delete structure to store sum of squares of weights per bin.; 2035///; 2036/// This is needed to compute the correct statistical quantities; 2037/// of a profile filled with weights; 2038///; 2039/// This function is automatically called when the histogram is created; 2040/// if the static function TH1::SetDefaultSumw2 has been called before.; 2041/// If flag is false the structure is deleted; 2042 ; 2043void TProfile2D::Sumw2(Bool_t flag); 2044{; 2045 TProfileHelper::Sumw2(this, flag);; 2046}; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition Rtyp",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:73753,Availability,error,errorMode,73753," measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994void TProfile2D::SetErrorOption(Option_t *option); 1995{; 1996 TProfileHelper::SetErrorOption(this, option);; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Stream an object of class TProfile2D.; 2001 ; 2002void TProfile2D::Streamer(TBuffer &R__b); 2003{; 2004 if (R__b.IsReading()) {; 2005 UInt_t R__s, R__c;; 2006 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2007 if (R__v > 2) {; 2008 R__b.ReadClassBuffer(TProfile2D::Class(), this, R__v, R__s, R__c);; 2009 return;; 2010 }; 2011 //====process old versions before automatic schema evolution; 2012 TH2D::Streamer(R__b);; 2013 fBinEntries.Streamer(R__b);; 2014 Int_t errorMode;; 2015 R__b >> errorMode;; 2016 fErrorMode = (EErrorType)errorMode;; 2017 if (R__v < 2) {; 2018 Float_t zmin,zmax;; 2019 R__b >> zmin; fZmin = zmin;; 2020 R__b >> zmax; fZmax = zmax;; 2021 } else {; 2022 R__b >> fZmin;; 2023 R__b >> fZmax;; 2024 }; 2025 R__b.CheckByteCount(R__s, R__c, TProfile2D::IsA());; 2026 //====end of old versions; 2027 ; 2028 } else {; 2029 R__b.WriteClassBuffer(TProfile2D::Class(),this);; 2030 }; 2031}; 2032 ; 2033////////////////////////////////////////////////////////////////////////////////; 2034/// Create/Delete structure to store sum of squares of weights per bin.; 2035///; 2036/// This is needed to compute the correct statistical quantities; 2037/// of a profile filled with weights; 2038///; 2039/// This function is automatically called when the histogram is created; 2040/// if the static function TH1::SetDefaultSumw2 has been called before.; 2041/// If flag is false the structure is deleted; 2042 ; 2043void TProfile2D::Sumw2(Bool_t flag); 2044{; 2045 TProfileHelper::Sumw2(this, flag);; 2046}; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition Rtyp",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:75337,Availability,error,error,75337,"// This is needed to compute the correct statistical quantities; 2037/// of a profile filled with weights; 2038///; 2039/// This function is automatically called when the histogram is created; 2040/// if the static function TH1::SetDefaultSumw2 has been called before.; 2041/// If flag is false the structure is deleted; 2042 ; 2043void TProfile2D::Sumw2(Bool_t flag); 2044{; 2045 TProfileHelper::Sumw2(this, flag);; 2046}; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfileHelper.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:75472,Availability,error,error,75472,"y called when the histogram is created; 2040/// if the static function TH1::SetDefaultSumw2 has been called before.; 2041/// If flag is false the structure is deleted; 2042 ; 2043void TProfile2D::Sumw2(Bool_t flag); 2044{; 2045 TProfileHelper::Sumw2(this, flag);; 2046}; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfileHelper.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; gDebugInt_t gDebugDefinition TROOT.cxx:597; TArrayDArray o",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:75744,Availability,error,error,75744,"2046}; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfileHelper.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; gDebugInt_t gDebugDefinition TROOT.cxx:597; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Streamervoid Streamer(TBuffer &) overrideStream a TArrayD object.Definition TArrayD.cxx:149; TArrayD::Copyvoid Copy(TArrayD &array) constDef",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:80990,Availability,error,error,80990,"n TH1.cxx:4448; TH1::kXaxis@ kXaxisDefinition TH1.h:73; TH1::kYaxis@ kYaxisDefinition TH1.h:74; TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal function used in TH1::Fill to see which axis is full alphanumeric, i.e.Definition TH1.cxx:6675; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Defi",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:86425,Availability,error,error,86425,"ject.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile2D.cxx:1227; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile2D.h:44; TProfile2D::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TProfile2D.h:39; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::IsATClass * IsA() const overrideDefinition TProfile2D.h:153; TProfile2D::ProjectionXYTH2D * ProjectionXY(const char *name=""_pxy"", Option_t *option=""e"") constProject this profile2D into a 2-D histogram along X,Y.Definition TProfile2D.cxx:1287; TProfile2D::MultiplyBool_t Multiply(TF1 *h1, Double_t c1=1) overridePerforms t",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:87719,Availability,error,error,87719,"place current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile2D.h:44; TProfile2D::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TProfile2D.h:39; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::IsATClass * IsA() const overrideDefinition TProfile2D.h:153; TProfile2D::ProjectionXYTH2D * ProjectionXY(const char *name=""_pxy"", Option_t *option=""e"") constProject this profile2D into a 2-D histogram along X,Y.Definition TProfile2D.cxx:1287; TProfile2D::MultiplyBool_t Multiply(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this*c1*f1.Definition TProfile2D.cxx:1235; TProfile2D::LabelsDeflatevoid LabelsDeflate(Option_t *axis=""X"") overrideReduce the number of bins for this axis to the number of bins having a label.Definition TProfile2D.cxx:980; TProfile2D::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile2D histogram.Definition TProfile2D.cxx:881; TProfile2D::Approximatestatic void Approximate(Bool_t approx=kTRUE)Static function, set the fgApproximate flag.Definition TProfile2D.cxx:277; TProfile2D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile2D.h:35; TProfile2D::fZminDouble_t fZminLower limit in Z (if set)Definition TProfile2D.h:36; TProfile2D::RebinXTProfile2D * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis.Definition TProfile2D.cxx:1837; TProfile2D::GetW2Double_t * GetW2()Definition TProfile2D.h:66; TProfile2D::fScalingBool_t fScaling! True when TProfile2D::Scale is calledDefinition TProfile2D.h:38; TProfile2D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)Return bin effective entries for a weighted filled Profile histogram.Definition TProfile2D.cxx:858; TProfile2D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D erro",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:87984,Availability,error,errors,87984,"weight*Z.Definition TProfile2D.h:39; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::IsATClass * IsA() const overrideDefinition TProfile2D.h:153; TProfile2D::ProjectionXYTH2D * ProjectionXY(const char *name=""_pxy"", Option_t *option=""e"") constProject this profile2D into a 2-D histogram along X,Y.Definition TProfile2D.cxx:1287; TProfile2D::MultiplyBool_t Multiply(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this*c1*f1.Definition TProfile2D.cxx:1235; TProfile2D::LabelsDeflatevoid LabelsDeflate(Option_t *axis=""X"") overrideReduce the number of bins for this axis to the number of bins having a label.Definition TProfile2D.cxx:980; TProfile2D::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile2D histogram.Definition TProfile2D.cxx:881; TProfile2D::Approximatestatic void Approximate(Bool_t approx=kTRUE)Static function, set the fgApproximate flag.Definition TProfile2D.cxx:277; TProfile2D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile2D.h:35; TProfile2D::fZminDouble_t fZminLower limit in Z (if set)Definition TProfile2D.h:36; TProfile2D::RebinXTProfile2D * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis.Definition TProfile2D.cxx:1837; TProfile2D::GetW2Double_t * GetW2()Definition TProfile2D.h:66; TProfile2D::fScalingBool_t fScaling! True when TProfile2D::Scale is calledDefinition TProfile2D.h:38; TProfile2D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)Return bin effective entries for a weighted filled Profile histogram.Definition TProfile2D.cxx:858; TProfile2D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile2D.cxx:889; TProfile2D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile2D.cxx:1856; TProfile2D::fBinSumw2TArrayD fBinSumw2Array of ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:88686,Availability,error,errors,88686," TProfile2D::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile2D histogram.Definition TProfile2D.cxx:881; TProfile2D::Approximatestatic void Approximate(Bool_t approx=kTRUE)Static function, set the fgApproximate flag.Definition TProfile2D.cxx:277; TProfile2D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile2D.h:35; TProfile2D::fZminDouble_t fZminLower limit in Z (if set)Definition TProfile2D.h:36; TProfile2D::RebinXTProfile2D * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis.Definition TProfile2D.cxx:1837; TProfile2D::GetW2Double_t * GetW2()Definition TProfile2D.h:66; TProfile2D::fScalingBool_t fScaling! True when TProfile2D::Scale is calledDefinition TProfile2D.h:38; TProfile2D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)Return bin effective entries for a weighted filled Profile histogram.Definition TProfile2D.cxx:858; TProfile2D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile2D.cxx:889; TProfile2D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile2D.cxx:1856; TProfile2D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile2D.h:41; TProfile2D::GetB2Double_t * GetB2()Definition TProfile2D.h:64; TProfile2D::Classstatic TClass * Class(); TProfile2D::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along axis such that x is in the axis range.Definition TProfile2D.cxx:1514; TProfile2D::ProfileYTProfile * ProfileY(const char *name=""_pfy"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TProfile2D.cxx:1389; TProfile2D::RebinYTProfile2D * RebinY(Int_t ngroup=2, const char *newname="""") overrideRebin only the Y axis.Definition TProf",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:91501,Availability,error,error,91501,"="""") constProject a 2-D histogram into a profile histogram along X.Definition TProfile2D.cxx:1370; TProfile2D::LabelsOptionvoid LabelsOption(Option_t *option=""h"", Option_t *axis=""X"") overrideSet option(s) to draw axis with labels.Definition TProfile2D.cxx:1008; TProfile2D::TProfile2DTProfile2D()Default constructor for Profile2D histograms.Definition TProfile2D.cxx:88; TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::fBinEntriesTArrayD fBinEntriesNumber of entries per bin.Definition TProfile2D.h:34; TProfile2D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile2D.h:49; TProfile2D::~TProfile2D~TProfile2D() overrideDefault destructor for Profile2D histograms.Definition TProfile2D.cxx:98; TProfile2D::Streamervoid Streamer(TBuffer &) overrideStream an object of class TProfile2D.Definition TProfile2D.cxx:2002; TProfile2D::fgApproximatestatic Bool_t fgApproximateBin error approximation option.Definition TProfile2D.h:42; TProfile2D::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1) .Definition TProfile2D.cxx:415; TProfile2D::Rebin2DTProfile2D * Rebin2D(Int_t nxgroup=2, Int_t nygroup=2, const char *newname="""") overrideRebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.Definition TProfile2D.cxx:1552; TProfile2D::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TProfile2D.cxx:291; TProfile2D::LabelsInflatevoid LabelsInflate(Option_t *axis=""X"") overrideDouble the number of bins for axis.Definition TProfile2D.cxx:990; TProfile2D::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this profile.Definition TProfile2D.cxx:916; TProfile2D::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile2D histogram.Definition TProfile",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:93566,Availability,error,errors,93566,"uble_t fZmaxUpper limit in Z (if set)Definition TProfile2D.h:37; TProfile2D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile2D.cxx:1947; TProfile2D::BuildOptionsvoid BuildOptions(Double_t zmin, Double_t zmax, Option_t *option)Set Profile2D histogram structure and options.Definition TProfile2D.cxx:189; TProfile2D::AddBool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""") overridePerforms the operation: this = this + c1*f1 .Definition TProfile2D.cxx:221; TProfile2D::operator=TProfile2D & operator=(const TProfile2D &profile)Definition TProfile2D.cxx:211; TProfile2D::SetBuffervoid SetBuffer(Int_t buffersize, Option_t *option="""") overrideSet the buffer size in units of 8 bytes (double).Definition TProfile2D.cxx:1956; TProfile2D::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TProfile2D.h:40; TProfile2D::GetBDouble_t * GetB()Definition TProfile2D.h:63; TProfile2D::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile2D errors.Definition TProfile2D.cxx:1994; TProfile2D::GetBinContentDouble_t GetBinContent(Int_t bin) const overrideReturn bin content of a Profile2D histogram.Definition TProfile2D.cxx:829; TProfileHelper::LabelsInflatestatic void LabelsInflate(T *p, Option_t *)Definition TProfileHelper.h:626; TProfileHelper::GetBinErrorstatic Double_t GetBinError(T *p, Int_t bin)Definition TProfileHelper.h:704; TProfileHelper::ExtendAxisstatic T * ExtendAxis(T *p, Double_t x, TAxis *axis)Definition TProfileHelper.h:430; TProfileHelper::Sumw2static void Sumw2(T *p, Bool_t flag)Definition TProfileHelper.h:529; TProfileHelper::SetBinEntriesstatic void SetBinEntries(T *p, Int_t bin, Double_t w)Definition TProfileHelper.h:768; TProfileHelper::Scalestatic void Scale(T *p, Double_t c1, Option_t *option)Definition TProfileHelper.h:512; TProfileHelper::SetErrorOptionstatic void SetErrorOption(T *p, Option_t *opt)Definition TProfileHelper.h:693; TProfileHelper::M",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:96332,Availability,down,down,96332,"0; TProfileHelper::Addstatic Bool_t Add(T *p, const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2=1)Definition TProfileHelper.h:71; TProfileHelper::GetBinEffectiveEntriesstatic Double_t GetBinEffectiveEntries(T *p, Int_t bin)Definition TProfileHelper.h:143; TProfileHelper::LabelsDeflatestatic void LabelsDeflate(T *p, Option_t *)Definition TProfileHelper.h:560; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile.h:111; TProfile::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile.cxx:1700; TProfile::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/delete structure to store sum of squares of weights per bin.Definition TProfile.cxx:1825; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; c2return c2Definition legend2.C:14; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. histhistsrcTProfile2D.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:1727,Integrability,rout,routines,1727,"""TMath.h""; 15#include ""THLimitsFinder.h""; 16#include ""TError.h""; 17#include ""TClass.h""; 18#include ""TProfileHelper.h""; 19#include <iostream>; 20 ; 21Bool_t TProfile2D::fgApproximate = kFALSE;; 22 ; 23ClassImp(TProfile2D);; 24 ; 25/** \class TProfile2D; 26 \ingroup Histograms; 27 Profile2D histograms are used to display the mean; 28 value of Z and its error for each cell in X,Y.; 29 Profile2D histograms are in many cases an; 30 elegant replacement of three-dimensional histograms : the inter-relation of three; 31 measured quantities X, Y and Z can always be visualized by a three-dimensional; 32 histogram or scatter-plot; its representation on the line-printer is not particularly; 33 satisfactory, except for sparse data. If Z is an unknown (but single-valued); 34 approximate function of X,Y this function is displayed by a profile2D histogram with; 35 much better precision than by a scatter-plot.; 36 ; 37 The following formulae show the cumulated contents (capital letters) and the values; 38 displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; 39 \f[; 40 \begin{align}; 41 H(i,j) &= \sum w \cdot Z \\; 42 E(i,j) &= \sum w \cdot Z^2 \\; 43 W(i,j) &= \sum w \\; 44 h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; 45 s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; 46 e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; 47 \end{align}; 48 \f]; 49 The bin content is always the mean of the Z values, but errors change depending on options:; 50 \f[; 51 \begin{align}; 52 \text{GetBinContent}(i,j) &= h(i,j) \\; 53 \text{GetBinError}(i,j) &=; 54 \begin{cases}; 55 e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; 56 s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; 57 \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 58 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurem",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:2127,Integrability,depend,depending,2127,"for each cell in X,Y.; 29 Profile2D histograms are in many cases an; 30 elegant replacement of three-dimensional histograms : the inter-relation of three; 31 measured quantities X, Y and Z can always be visualized by a three-dimensional; 32 histogram or scatter-plot; its representation on the line-printer is not particularly; 33 satisfactory, except for sparse data. If Z is an unknown (but single-valued); 34 approximate function of X,Y this function is displayed by a profile2D histogram with; 35 much better precision than by a scatter-plot.; 36 ; 37 The following formulae show the cumulated contents (capital letters) and the values; 38 displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; 39 \f[; 40 \begin{align}; 41 H(i,j) &= \sum w \cdot Z \\; 42 E(i,j) &= \sum w \cdot Z^2 \\; 43 W(i,j) &= \sum w \\; 44 h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; 45 s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; 46 e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; 47 \end{align}; 48 \f]; 49 The bin content is always the mean of the Z values, but errors change depending on options:; 50 \f[; 51 \begin{align}; 52 \text{GetBinContent}(i,j) &= h(i,j) \\; 53 \text{GetBinError}(i,j) &=; 54 \begin{cases}; 55 e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; 56 s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; 57 \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 58 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; 59 \end{cases}; 60 \end{align}; 61 \f]; 62 ; 63 In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); 64 the bin error e(I,J) is computed from the average of the s(I,J) for all cells; 65 if the static function TProfile2D::Approximate has been called.; 66 This simple/crude approximation was suggeste",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:4494,Modifiability,variab,variable,4494,"i++) {; 76 gRandom->Rannor(px,py);; 77 pz = px*px + py*py;; 78 hprof2d->Fill(px,py,pz,1);; 79 }; 80 hprof2d->Draw();; 81 }; 82 ~~~~; 83*/; 84 ; 85////////////////////////////////////////////////////////////////////////////////; 86/// Default constructor for Profile2D histograms.; 87 ; 88TProfile2D::TProfile2D(); 89{; 90 fTsumwz = fTsumwz2 = 0;; 91 fScaling = kFALSE;; 92 BuildOptions(0,0,"""");; 93}; 94 ; 95////////////////////////////////////////////////////////////////////////////////; 96/// Default destructor for Profile2D histograms.; 97 ; 98TProfile2D::~TProfile2D(); 99{; 100}; 101 ; 102////////////////////////////////////////////////////////////////////////////////; 103/// Normal Constructor for Profile histograms.; 104///; 105/// The first eight parameters are similar to TH2D::TH2D.; 106/// All values of z are accepted at filling time.; 107/// To fill a profile2D histogram, one must use TProfile2D::Fill function.; 108///; 109/// Note that when filling the profile histogram the function Fill; 110/// checks if the variable z is between fZmin and fZmax.; 111/// If a minimum or maximum value is set for the Z scale before filling,; 112/// then all values below zmin or above zmax will be discarded.; 113/// Setting the minimum or maximum value for the Z scale before filling; 114/// has the same effect as calling the special TProfile2D constructor below; 115/// where zmin and zmax are specified.; 116///; 117/// H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; 118/// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; 119///; 120/// See TProfile2D::BuildOptions for explanation of parameters; 121///; 122/// see other constructors below with all possible combinations of; 123/// fix and variable bin size like in TH2D.; 124 ; 125TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 126: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 127{; 128 Bu",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:5212,Modifiability,variab,variable,5212,"3/// Normal Constructor for Profile histograms.; 104///; 105/// The first eight parameters are similar to TH2D::TH2D.; 106/// All values of z are accepted at filling time.; 107/// To fill a profile2D histogram, one must use TProfile2D::Fill function.; 108///; 109/// Note that when filling the profile histogram the function Fill; 110/// checks if the variable z is between fZmin and fZmax.; 111/// If a minimum or maximum value is set for the Z scale before filling,; 112/// then all values below zmin or above zmax will be discarded.; 113/// Setting the minimum or maximum value for the Z scale before filling; 114/// has the same effect as calling the special TProfile2D constructor below; 115/// where zmin and zmax are specified.; 116///; 117/// H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; 118/// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; 119///; 120/// See TProfile2D::BuildOptions for explanation of parameters; 121///; 122/// see other constructors below with all possible combinations of; 123/// fix and variable bin size like in TH2D.; 124 ; 125TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 126: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 127{; 128 BuildOptions(0,0,option);; 129 if (xlow >= xup || ylow >= yup) SetBuffer(fgBufferSize);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Create a 2-D Profile with variable bins in X and fix bins in Y.; 134 ; 135TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 136: TH2D(name,title,nx,xbins,ny,ylow,yup); 137{; 138 BuildOptions(0,0,option);; 139}; 140 ; 141////////////////////////////////////////////////////////////////////////////////; 142/// Create a 2-D Profile with fix bins in X and variable bins in Y.; 143 ; 144TProfile2D::",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:5679,Modifiability,variab,variable,5679," checks if the variable z is between fZmin and fZmax.; 111/// If a minimum or maximum value is set for the Z scale before filling,; 112/// then all values below zmin or above zmax will be discarded.; 113/// Setting the minimum or maximum value for the Z scale before filling; 114/// has the same effect as calling the special TProfile2D constructor below; 115/// where zmin and zmax are specified.; 116///; 117/// H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; 118/// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; 119///; 120/// See TProfile2D::BuildOptions for explanation of parameters; 121///; 122/// see other constructors below with all possible combinations of; 123/// fix and variable bin size like in TH2D.; 124 ; 125TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 126: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 127{; 128 BuildOptions(0,0,option);; 129 if (xlow >= xup || ylow >= yup) SetBuffer(fgBufferSize);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Create a 2-D Profile with variable bins in X and fix bins in Y.; 134 ; 135TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 136: TH2D(name,title,nx,xbins,ny,ylow,yup); 137{; 138 BuildOptions(0,0,option);; 139}; 140 ; 141////////////////////////////////////////////////////////////////////////////////; 142/// Create a 2-D Profile with fix bins in X and variable bins in Y.; 143 ; 144TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,const Double_t *ybins,Option_t *option); 145: TH2D(name,title,nx,xlow,xup,ny,ybins); 146{; 147 BuildOptions(0,0,option);; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Create a 2-D Profile ",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:6100,Modifiability,variab,variable,6100," cell contents. The errors computed are s(I,J) if CHOPT='S'; 118/// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; 119///; 120/// See TProfile2D::BuildOptions for explanation of parameters; 121///; 122/// see other constructors below with all possible combinations of; 123/// fix and variable bin size like in TH2D.; 124 ; 125TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 126: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 127{; 128 BuildOptions(0,0,option);; 129 if (xlow >= xup || ylow >= yup) SetBuffer(fgBufferSize);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Create a 2-D Profile with variable bins in X and fix bins in Y.; 134 ; 135TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 136: TH2D(name,title,nx,xbins,ny,ylow,yup); 137{; 138 BuildOptions(0,0,option);; 139}; 140 ; 141////////////////////////////////////////////////////////////////////////////////; 142/// Create a 2-D Profile with fix bins in X and variable bins in Y.; 143 ; 144TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,const Double_t *ybins,Option_t *option); 145: TH2D(name,title,nx,xlow,xup,ny,ybins); 146{; 147 BuildOptions(0,0,option);; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Create a 2-D Profile with variable bins in X and variable bins in Y.; 152 ; 153TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Option_t *option); 154: TH2D(name,title,nx,xbins,ny,ybins); 155{; 156 BuildOptions(0,0,option);; 157}; 158 ; 159////////////////////////////////////////////////////////////////////////////////; 160/// Constructor for Profile2D histograms with range in z.; 161/",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:6485,Modifiability,variab,variable,6485,"uble_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 126: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 127{; 128 BuildOptions(0,0,option);; 129 if (xlow >= xup || ylow >= yup) SetBuffer(fgBufferSize);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Create a 2-D Profile with variable bins in X and fix bins in Y.; 134 ; 135TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 136: TH2D(name,title,nx,xbins,ny,ylow,yup); 137{; 138 BuildOptions(0,0,option);; 139}; 140 ; 141////////////////////////////////////////////////////////////////////////////////; 142/// Create a 2-D Profile with fix bins in X and variable bins in Y.; 143 ; 144TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,const Double_t *ybins,Option_t *option); 145: TH2D(name,title,nx,xlow,xup,ny,ybins); 146{; 147 BuildOptions(0,0,option);; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Create a 2-D Profile with variable bins in X and variable bins in Y.; 152 ; 153TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Option_t *option); 154: TH2D(name,title,nx,xbins,ny,ybins); 155{; 156 BuildOptions(0,0,option);; 157}; 158 ; 159////////////////////////////////////////////////////////////////////////////////; 160/// Constructor for Profile2D histograms with range in z.; 161///; 162/// The first eight parameters are similar to TH2D::TH2D.; 163/// Only the values of Z between ZMIN and ZMAX will be considered at filling time.; 164/// zmin and zmax will also be the maximum and minimum values; 165/// on the z scale when drawing the profile2D.; 166///; 167/// See TProfile2D::BuildOptions for more explanations on errors; 168 ; 169TProfile2D::TProfile2D(const char *name,const cha",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:6508,Modifiability,variab,variable,6508,"uble_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 126: TH2D(name,title,nx,xlow,xup,ny,ylow,yup); 127{; 128 BuildOptions(0,0,option);; 129 if (xlow >= xup || ylow >= yup) SetBuffer(fgBufferSize);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Create a 2-D Profile with variable bins in X and fix bins in Y.; 134 ; 135TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,Double_t ylow,Double_t yup,Option_t *option); 136: TH2D(name,title,nx,xbins,ny,ylow,yup); 137{; 138 BuildOptions(0,0,option);; 139}; 140 ; 141////////////////////////////////////////////////////////////////////////////////; 142/// Create a 2-D Profile with fix bins in X and variable bins in Y.; 143 ; 144TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,const Double_t *ybins,Option_t *option); 145: TH2D(name,title,nx,xlow,xup,ny,ybins); 146{; 147 BuildOptions(0,0,option);; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Create a 2-D Profile with variable bins in X and variable bins in Y.; 152 ; 153TProfile2D::TProfile2D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Option_t *option); 154: TH2D(name,title,nx,xbins,ny,ybins); 155{; 156 BuildOptions(0,0,option);; 157}; 158 ; 159////////////////////////////////////////////////////////////////////////////////; 160/// Constructor for Profile2D histograms with range in z.; 161///; 162/// The first eight parameters are similar to TH2D::TH2D.; 163/// Only the values of Z between ZMIN and ZMAX will be considered at filling time.; 164/// zmin and zmax will also be the maximum and minimum values; 165/// on the z scale when drawing the profile2D.; 166///; 167/// See TProfile2D::BuildOptions for more explanations on errors; 168 ; 169TProfile2D::TProfile2D(const char *name,const cha",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:30178,Modifiability,evolve,evolved,30178,"0 || bin >= fNcells) return 0;; 847 return fBinEntries.fArray[bin];; 848}; 849 ; 850////////////////////////////////////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886/////////////////////////////////",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:51996,Modifiability,variab,variable,51996,"X, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const {; 1400 TString opt = option;; 1401 opt.ToLower();; 1402 bool originalRange = opt.Contains(""o"");; 1403 ; 1404 TString expectedName = ( onX ? ""_pfx"" : ""_pfy"" );; 1405 ; 1406 TString pname(name);; 1407 if (pname.IsNull() || name == expectedName); 1408 pname = TString(GetName() ) + expectedName;; 1409 ; 1410 const TAxis& outAxis = ( onX ? fXaxis : fYaxis );; 1411 const TArrayD *bins = outAxis.GetXbins();; 1412 Int_t firstOutBin = outAxis.GetFirst();; 1413 Int_t lastOutBin = outAxis.GetLast();; 1414 ; 1415 TProfile * p1 = nullptr;; 1416 // case of fixed bins; 1417 if (bins->fN == 0) {; 1418 if (originalRange); 1419 p1 = new TProfile(pname,GetTitle(), outAxis.GetNbins(), outAxis.GetXmin(), outAxis.GetXmax(), opt );; 1420 else; 1421 p1 = new TProfile(pname,GetTitle(), lastOutBin-firstOutBin+1,; 1422 outAxis.GetBinLowEdge(firstOutBin),outAxis.GetBinUpEdge(lastOutBin), opt);; 1423 } else {; 1424 // case of variable bins; 1425 if (originalRange ); 1426 p1 = new TProfile(pname,GetTitle(),outAxis.GetNbins(),bins->fArray,opt);; 1427 else; 1428 p1 = new TProfile(pname,GetTitle(),lastOutBin-firstOutBin+1,&bins->fArray[firstOutBin-1],opt);; 1429 ; 1430 }; 1431 ; 1432 if (fBinSumw2.fN) p1->Sumw2();; 1433 ; 1434 // make projection in a 2D first; 1435 TH2D * h2dW = ProjectionXY(""h2temp-W"",""W"");; 1436 TH2D * h2dN = ProjectionXY(""h2temp-N"",""B"");; 1437 ; 1438 h2dW->SetDirectory(nullptr); h2dN->SetDirectory(nullptr);; 1439 ; 1440 ; 1441 TString opt1 = (originalRange) ? ""o"" : """";; 1442 TH1D * h1W = (onX) ? h2dW->ProjectionX(""h1temp-W"",firstbin,lastbin,opt1) : h2dW->ProjectionY(""h1temp-W"",firstbin,lastbin,opt1);; 1443 TH1D * h1N = (onX) ? h2dN->ProjectionX(""h1temp-N"",firstbin,lastbin,opt1) : h2dN->ProjectionY(""h1temp-N"",firstbin,lastbin,opt1);; 1444 h1W->SetDirectory(nullptr); h1N->SetDirectory(nullptr);; 1445 ; 1446 ; 1447 // fill the bin content; 1448 R__ASSERT( h1W->fN == p1->fN );; 1449 R__ASSERT( h1N->fN == p1-",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:55336,Modifiability,extend,extended,55336,"fTsumwx2 = stats[3];; 1480 fTsumwy = stats[4];; 1481 fTsumwy2 = stats[5];; 1482 fTsumwxy = stats[6];; 1483 fTsumwz = stats[7];; 1484 fTsumwz2 = stats[8];; 1485}; 1486 ; 1487////////////////////////////////////////////////////////////////////////////////; 1488/// Reset contents of a Profile2D histogram.; 1489 ; 1490void TProfile2D::Reset(Option_t *option); 1491{; 1492 TH2D::Reset(option);; 1493 fBinEntries.Reset();; 1494 fBinSumw2.Reset();; 1495 TString opt = option;; 1496 opt.ToUpper();; 1497 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1498 fTsumwz = fTsumwz2 = 0;; 1499}; 1500 ; 1501 ; 1502////////////////////////////////////////////////////////////////////////////////; 1503/// Profile histogram is resized along axis such that x is in the axis range.; 1504///; 1505/// The new axis limits are recomputed by doubling iteratively; 1506/// the current axis range until the specified value x is within the limits.; 1507/// The algorithm makes a copy of the histogram, then loops on all bins; 1508/// of the old histogram to fill the extended histogram.; 1509/// Takes into account errors (Sumw2) if any.; 1510/// The axis must be extendable before invoking this function.; 1511///; 1512/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1513 ; 1514void TProfile2D::ExtendAxis(Double_t x, TAxis *axis); 1515{; 1516 TProfile2D* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1517 if ( hold ) {; 1518 fTsumwz = hold->fTsumwz;; 1519 fTsumwz2 = hold->fTsumwz2;; 1520 delete hold;; 1521 }; 1522}; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1526///; 1527/// if newname is not blank a new profile hnew is created.; 1528/// else the current histogram is modified (default); 1529/// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; 1530/// have to be merged into one bin of hnew; 1531/// If the original profile has e",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:55433,Modifiability,extend,extendable,55433,"1485}; 1486 ; 1487////////////////////////////////////////////////////////////////////////////////; 1488/// Reset contents of a Profile2D histogram.; 1489 ; 1490void TProfile2D::Reset(Option_t *option); 1491{; 1492 TH2D::Reset(option);; 1493 fBinEntries.Reset();; 1494 fBinSumw2.Reset();; 1495 TString opt = option;; 1496 opt.ToUpper();; 1497 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1498 fTsumwz = fTsumwz2 = 0;; 1499}; 1500 ; 1501 ; 1502////////////////////////////////////////////////////////////////////////////////; 1503/// Profile histogram is resized along axis such that x is in the axis range.; 1504///; 1505/// The new axis limits are recomputed by doubling iteratively; 1506/// the current axis range until the specified value x is within the limits.; 1507/// The algorithm makes a copy of the histogram, then loops on all bins; 1508/// of the old histogram to fill the extended histogram.; 1509/// Takes into account errors (Sumw2) if any.; 1510/// The axis must be extendable before invoking this function.; 1511///; 1512/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1513 ; 1514void TProfile2D::ExtendAxis(Double_t x, TAxis *axis); 1515{; 1516 TProfile2D* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1517 if ( hold ) {; 1518 fTsumwz = hold->fTsumwz;; 1519 fTsumwz2 = hold->fTsumwz2;; 1520 delete hold;; 1521 }; 1522}; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1526///; 1527/// if newname is not blank a new profile hnew is created.; 1528/// else the current histogram is modified (default); 1529/// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; 1530/// have to be merged into one bin of hnew; 1531/// If the original profile has errors stored (via Sumw2), the resulting; 1532/// profile has new errors correctly calculated.; 1533///; 1534/// examples: if hpxpy is an existing TProfile",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:67784,Modifiability,variab,variable,67784,"////; 1842/// Rebin only the Y axis.; 1843/// see Rebin2D; 1844 ; 1845TProfile2D * TProfile2D::RebinY(Int_t ngroup,const char * newname ) {; 1846 return Rebin2D(1,ngroup,newname);; 1847}; 1848 ; 1849////////////////////////////////////////////////////////////////////////////////; 1850/// Save primitive as a C++ statement(s) on output stream out.; 1851///; 1852/// Note the following restrictions in the code generated:; 1853/// - variable bin size not implemented; 1854/// - SetErrorOption not implemented; 1855 ; 1856void TProfile2D::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1857{; 1858 char quote = '""';; 1859 out <<"" ""<<std::endl;; 1860 out <<"" ""<<ClassName()<<"" *"";; 1861 ; 1862 out << GetName() << "" = new "" << ClassName() << ""("" << quote; 1863 << GetName() << quote << "","" << quote<< GetTitle() << quote; 1864 << "","" << GetXaxis()->GetNbins();; 1865 out << "","" << GetXaxis()->GetXmin(); 1866 << "","" << GetXaxis()->GetXmax();; 1867 out << "","" << GetYaxis()->GetNbins();; 1868 out << "","" << GetYaxis()->GetXmin(); 1869 << "","" << GetYaxis()->GetXmax();; 1870 out << "","" << fZmin; 1871 << "","" << fZmax;; 1872 out << "");"" << std::endl;; 1873 ; 1874 ; 1875 // save bin entries; 1876 Int_t bin;; 1877 for (bin=0;bin<fNcells;bin++) {; 1878 Double_t bi = GetBinEntries(bin);; 1879 if (bi) {; 1880 out<<"" ""<<GetName()<<""->SetBinEntries(""<<bin<<"",""<<bi<<"");""<<std::endl;; 1881 }; 1882 }; 1883 //save bin contents; 1884 for (bin=0;bin<fNcells;bin++) {; 1885 Double_t bc = fArray[bin];; 1886 if (bc) {; 1887 out<<"" ""<<GetName()<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1888 }; 1889 }; 1890 // save bin errors; 1891 if (fSumw2.fN) {; 1892 for (bin=0;bin<fNcells;bin++) {; 1893 Double_t be = TMath::Sqrt(fSumw2.fArray[bin]);; 1894 if (be) {; 1895 out<<"" ""<<GetName()<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 1896 }; 1897 }; 1898 }; 1899 ; 1900 TH1::SavePrimitiveHelp(out, GetName(), option);; 1901}; 1902 ; 1903//////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:70463,Modifiability,variab,variable,70463,"iply this profile2D by a constant c1.; 1905///; 1906/// `this = c1*this; 1907///; 1908/// This function uses the services of TProfile2D::Add; 1909 ; 1910void TProfile2D::Scale(Double_t c1, Option_t * option); 1911{; 1912 TProfileHelper::Scale(this, c1, option);; 1913}; 1914 ; 1915////////////////////////////////////////////////////////////////////////////////; 1916/// Set the number of entries in bin.; 1917 ; 1918void TProfile2D::SetBinEntries(Int_t bin, Double_t w); 1919{; 1920 TProfileHelper::SetBinEntries(this, bin, w);; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Redefine x and y axis parameters.; 1925 ; 1926void TProfile2D::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); 1927{; 1928 TH1::SetBins(nx,xmin, xmax,ny, ymin,ymax);; 1929 fBinEntries.Set(fNcells);; 1930 if (fBinSumw2.fN) fBinSumw2.Set(fNcells);; 1931}; 1932 ; 1933////////////////////////////////////////////////////////////////////////////////; 1934/// Redefine x and y axis parameters for variable bin sizes.; 1935 ; 1936void TProfile2D::SetBins(Int_t nx, const Double_t *xbins, Int_t ny, const Double_t *ybins); 1937{; 1938 TH1::SetBins(nx,xbins,ny,ybins);; 1939 fBinEntries.Set(fNcells);; 1940 if (fBinSumw2.fN) fBinSumw2.Set(fNcells);; 1941}; 1942 ; 1943////////////////////////////////////////////////////////////////////////////////; 1944/// Set total number of bins including under/overflow.; 1945/// Reallocate bin contents array; 1946 ; 1947void TProfile2D::SetBinsLength(Int_t n); 1948{; 1949 TH2D::SetBinsLength(n);; 1950 TProfileHelper::BuildArray(this);; 1951}; 1952 ; 1953////////////////////////////////////////////////////////////////////////////////; 1954/// Set the buffer size in units of 8 bytes (double).; 1955 ; 1956void TProfile2D::SetBuffer(Int_t buffersize, Option_t *); 1957{; 1958 if (fBuffer) {; 1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersi",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:80706,Modifiability,extend,extendable,80706,"y(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::kXaxis@ kXaxisDefinition TH1.h:73; TH1::kYaxis@ kYaxisDefinition TH1.h:74; TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal function used in TH1::Fill to see which axis is full alphanumeric, i.e.Definition TH1.c",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:86045,Modifiability,inherit,inherits,86045,"ion.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile2D.cxx:1227; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile2D.h:44; TProfile2D::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TProfile2D.h:39; TProfile2D::FillI",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:75759,Safety,abort,abort,75759,"256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfileHelper.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; gDebugInt_t gDebugDefinition TROOT.cxx:597; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Streamervoid Streamer(TBuffer &) overrideStream a TArrayD object.Definition TArrayD.cxx:149; TArrayD::Copyvoid Copy(TArrayD &array) constDefinition TArrayD.h:42; TArrayD::Setvo",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:84795,Security,hash,hash,84795,"am into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH2.h:36; TH2::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH2.h:35; TH2::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz=0) const overrideReturn Global bin number corresponding to binx,y,z.Definition TH2.cxx:1086; TH2::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along X.Definition TH2.cxx:2436; TH2::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH2.h:34; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition THashList.cxx:189; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the ob",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:3006,Usability,simpl,simple,3006," \f]; 49 The bin content is always the mean of the Z values, but errors change depending on options:; 50 \f[; 51 \begin{align}; 52 \text{GetBinContent}(i,j) &= h(i,j) \\; 53 \text{GetBinError}(i,j) &=; 54 \begin{cases}; 55 e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; 56 s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; 57 \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 58 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; 59 \end{cases}; 60 \end{align}; 61 \f]; 62 ; 63 In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); 64 the bin error e(I,J) is computed from the average of the s(I,J) for all cells; 65 if the static function TProfile2D::Approximate has been called.; 66 This simple/crude approximation was suggested in order to keep the cell; 67 during a fit operation. But note that this approximation is not the default behaviour.; 68 ; 69 ### Creating and drawing a 2D profile; 70 ~~~~{.cpp}; 71 {; 72 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 73 auto hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; 74 Float_t px, py, pz;; 75 for ( Int_t i=0; i<25000; i++) {; 76 gRandom->Rannor(px,py);; 77 pz = px*px + py*py;; 78 hprof2d->Fill(px,py,pz,1);; 79 }; 80 hprof2d->Draw();; 81 }; 82 ~~~~; 83*/; 84 ; 85////////////////////////////////////////////////////////////////////////////////; 86/// Default constructor for Profile2D histograms.; 87 ; 88TProfile2D::TProfile2D(); 89{; 90 fTsumwz = fTsumwz2 = 0;; 91 fScaling = kFALSE;; 92 BuildOptions(0,0,"""");; 93}; 94 ; 95////////////////////////////////////////////////////////////////////////////////; 96/// Default destructor for Profile2D histograms.; 97 ; 98TProfile2D::~TProfile2D(); 99{; 100};",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:32058,Usability,simpl,simply,32058," (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886////////////////////////////////////////////////////////////////////////////////; 887/// Return option to compute profile2D errors.; 888 ; 889Option_t *TProfile2D::GetErrorOption() const; 890{; 891 if (fErrorMode == kERRORSPREAD) return ""s"";; 892 if (fErrorMode == kERRORSPREADI) return ""i"";; 893 if (fErrorMode == kERRORSPREADG) return ""g"";; 894 return """";; 895}; 896 ; 897////////////////////////////////////////////////////////////////////////////////; 898/// Fill the array stats from the contents of this profile.; 899/// The array stats must be correctly dimensioned in the calling program.; 900///; 901/// - stats[0] = sumw; 902/// - stats[1] = sumw2; 903/// - stats[2] = sumwx; 904/// - stats[3] = sumwx2; 905/// - stats[4] = sumwy; 906/// - stats[5] = sumwy2; 907/// - stats[6] = sumwxy; 908/// - stats[7] = sumwz; 909/// - stats[8] = sumwz2; 910///; 911/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 912/// is simply a copy of the statistics quantities computed at filling time.; 913/// If a sub-range is specified, the function recomputes these quantities; 914/// from the bin contents in the current axis range.; 915 ; 916void TProfile2D::GetStats(Double_t *stats) const; 917{; 918 if (fBuffer) ((TProfile2D*)this)->BufferEmpty();; 919 ; 920 // check for labels axis . In that case corresponding statistics do not make sense and it is set to zero; 921 Bool_t labelXaxis = ((const_cast<TAxis&>(fXaxis)).GetLabels() && fXaxis.CanExtend() );; 922 Bool_t labelYaxis = ((const_cast<TAxis&>(fYaxis)).GetLabels() && fYaxis.CanExtend() );; 923 ; 924 // Loop on bins; 925 if ( (fTsumw == 0 /* && fEntries > 0 */) || fXaxis.TestBit(TAxis::kAxisRange) || fYaxis.TestBit(TAxis::kAxisRange)) {; 926 Int_t bin, binx, biny;; 927 Double_t w, w2;; 928 Double_t x,y;; 929 for (bin=0;",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8cxx_source.html:44686,Usability,simpl,simply,44686,"rofile2D by multiplication of h1 by h2.; 1254///; 1255/// `this = (c1*h1)*(c2*h2)`; 1256 ; 1257Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1258{; 1259 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1260 return kFALSE;; 1261}; 1262 ; 1263////////////////////////////////////////////////////////////////////////////////; 1264/// Project this profile2D into a 2-D histogram along X,Y.; 1265///; 1266/// The projection is always of the type TH2D.; 1267///; 1268/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1269/// to be equal to the errors of the profile.; 1270/// Option ""E"" is defined as the default one in the header file.; 1271/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1272/// - if option ""B"" is specified, the content of bin of the returned histogram; 1273/// will be equal to the GetBinEntries(bin) of the profile,; 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH2D using the 3-rd value as a weight.; 1280/// This option makes sense only for profile filled with all weights =1.; 1281/// When the profile is weighted (filled with weights different than 1) the; 1282/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 1283/// correctly computed from the information stored in the profile. In that case the; 1284/// obtained histogram contains as bin error square the weighted sum of the square of the; 1285/// profiled observable (TProfile2D::fSumw2[bin] ); 1286 ; 1287TH2D *TProfile2D::ProjectionXY(const char *name, Option_t *option) const; 1288{; 12",MatchSource.WIKI,doc/master/TProfile2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:1215,Availability,error,errors,1215,"//////////////////////////////////////; 17// //; 18// TProfile2D //; 19// //; 20// Profile2D histogram class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TH2.h""; 25#include ""TProfile.h""; 26 ; 27class TProfile2D : public TH2D {; 28 ; 29public:; 30 friend class TProfileHelper;; 31 friend class TH1Merger;; 32 ; 33protected:; 34 TArrayD fBinEntries; ///< Number of entries per bin; 35 EErrorType fErrorMode; ///< Option to compute errors; 36 Double_t fZmin; ///< Lower limit in Z (if set); 37 Double_t fZmax; ///< Upper limit in Z (if set); 38 Bool_t fScaling; ///<! True when TProfile2D::Scale is called; 39 Double_t fTsumwz; ///< Total Sum of weight*Z; 40 Double_t fTsumwz2; ///< Total Sum of weight*Z*Z; 41 TArrayD fBinSumw2; ///< Array of sum of squares of weights per bin; 42 static Bool_t fgApproximate; ///< Bin error approximation option; 43 ; 44 Int_t BufferFill(Double_t, Double_t) override {return -2;} //may not use; 45 Int_t BufferFill(Double_t, Double_t, Double_t) override {return -2;} //may not use; 46 virtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w);; 47 ; 48 // helper methods for the Merge unification in TProfileHelper; 49 void SetBins(const Int_t* nbins, const Double_t* range) { SetBins(nbins[0], range[0], range[1],; 50 nbins[1], range[2], range[3]); };; 51 Int_t Fill(const Double_t* v) { return Fill(v[0], v[1], v[2], v[3]); };; 52 ; 53 TProfile *DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const override;; 54 ; 55 using TH2::Fill;; 56 Int_t Fill(Double_t, Double_t) override {return TH2::Fill(0); } //MayNotUse; 57 ; 58 Double_t RetrieveBinContent(Int_t bin) const override { return (fBinEntries.fArray[bin] > 0) ? fArray[bin]/fBinEntries.fArray[bin] : 0; }; 59 //virtual void UpdateBinContent(Int_t bin, Double_t content);; 60 Double_t GetBinErrorSqUnchecked(Int_t bin) const override { Double_t err = GetBinError(bin); return err*err; }; 61 ",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:1603,Availability,error,error,1603,"//////////////////////////////////////; 17// //; 18// TProfile2D //; 19// //; 20// Profile2D histogram class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TH2.h""; 25#include ""TProfile.h""; 26 ; 27class TProfile2D : public TH2D {; 28 ; 29public:; 30 friend class TProfileHelper;; 31 friend class TH1Merger;; 32 ; 33protected:; 34 TArrayD fBinEntries; ///< Number of entries per bin; 35 EErrorType fErrorMode; ///< Option to compute errors; 36 Double_t fZmin; ///< Lower limit in Z (if set); 37 Double_t fZmax; ///< Upper limit in Z (if set); 38 Bool_t fScaling; ///<! True when TProfile2D::Scale is called; 39 Double_t fTsumwz; ///< Total Sum of weight*Z; 40 Double_t fTsumwz2; ///< Total Sum of weight*Z*Z; 41 TArrayD fBinSumw2; ///< Array of sum of squares of weights per bin; 42 static Bool_t fgApproximate; ///< Bin error approximation option; 43 ; 44 Int_t BufferFill(Double_t, Double_t) override {return -2;} //may not use; 45 Int_t BufferFill(Double_t, Double_t, Double_t) override {return -2;} //may not use; 46 virtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w);; 47 ; 48 // helper methods for the Merge unification in TProfileHelper; 49 void SetBins(const Int_t* nbins, const Double_t* range) { SetBins(nbins[0], range[0], range[1],; 50 nbins[1], range[2], range[3]); };; 51 Int_t Fill(const Double_t* v) { return Fill(v[0], v[1], v[2], v[3]); };; 52 ; 53 TProfile *DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const override;; 54 ; 55 using TH2::Fill;; 56 Int_t Fill(Double_t, Double_t) override {return TH2::Fill(0); } //MayNotUse; 57 ; 58 Double_t RetrieveBinContent(Int_t bin) const override { return (fBinEntries.fArray[bin] > 0) ? fArray[bin]/fBinEntries.fArray[bin] : 0; }; 59 //virtual void UpdateBinContent(Int_t bin, Double_t content);; 60 Double_t GetBinErrorSqUnchecked(Int_t bin) const override { Double_t err = GetBinError(bin); return err*err; }; 61 ",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:11092,Availability,error,error,11092,"ayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Resetvoid Reset()Definition TArrayD.h:47; TArray::fNInt_t fNDefinition TArray.h:38; TArray::GetSizeInt_t GetSize() constDefinition TArray.h:47; TAxisClass to manage histogram axis.Definition TAxis.h:31; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TH1MergerDefinition TH1Merger.h:20; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz=0) const overrideReturn Global bin number corresponding to binx,y,z.Definition TH2.cxx:1086; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TObjectMother of all ROOT objects.Definition TObject.h:41; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile2D.cxx:1227; TProfile2D::SetBinsvoid SetBins(Int_t, Double_t, Double_t) overrideRedefine x axis parameters.Definition TProfile2D.h:67; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile2D.h:44; TProfile2D::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TProfile2D.h:39; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::ProjectionXYTH2D * ProjectionXY(const char *name=""_pxy"", Option_t *option=""e"") constProject this profile2D into a 2-D histogram along X,Y.Definition TProfile2D.cxx:1287; TProfile2D::MultiplyBool_t Mul",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:12435,Availability,error,error,12435,"ile2D.h:67; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile2D.h:44; TProfile2D::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TProfile2D.h:39; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::ProjectionXYTH2D * ProjectionXY(const char *name=""_pxy"", Option_t *option=""e"") constProject this profile2D into a 2-D histogram along X,Y.Definition TProfile2D.cxx:1287; TProfile2D::MultiplyBool_t Multiply(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this*c1*f1.Definition TProfile2D.cxx:1235; TProfile2D::LabelsDeflatevoid LabelsDeflate(Option_t *axis=""X"") overrideReduce the number of bins for this axis to the number of bins having a label.Definition TProfile2D.cxx:980; TProfile2D::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile2D histogram.Definition TProfile2D.cxx:881; TProfile2D::GetBinContentDouble_t GetBinContent(Int_t binx, Int_t biny, Int_t) const overrideDefinition TProfile2D.h:115; TProfile2D::Approximatestatic void Approximate(Bool_t approx=kTRUE)Static function, set the fgApproximate flag.Definition TProfile2D.cxx:277; TProfile2D::GetBinSumw2virtual const TArrayD * GetBinSumw2() constDefinition TProfile2D.h:122; TProfile2D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile2D.h:35; TProfile2D::fZminDouble_t fZminLower limit in Z (if set)Definition TProfile2D.h:36; TProfile2D::RebinXTProfile2D * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis.Definition TProfile2D.cxx:1837; TProfile2D::FillInt_t Fill(const char *namex, const char *namey, Double_t z) overrideIncrement cell defined by namex,namey by a weight w.Definition TProfile2D.h:112; TProfile2D::GetW2Double_t * GetW2()Definition TProfile2D.h:66; T",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:12917,Availability,error,errors,12917,"ectionXY(const char *name=""_pxy"", Option_t *option=""e"") constProject this profile2D into a 2-D histogram along X,Y.Definition TProfile2D.cxx:1287; TProfile2D::MultiplyBool_t Multiply(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this*c1*f1.Definition TProfile2D.cxx:1235; TProfile2D::LabelsDeflatevoid LabelsDeflate(Option_t *axis=""X"") overrideReduce the number of bins for this axis to the number of bins having a label.Definition TProfile2D.cxx:980; TProfile2D::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile2D histogram.Definition TProfile2D.cxx:881; TProfile2D::GetBinContentDouble_t GetBinContent(Int_t binx, Int_t biny, Int_t) const overrideDefinition TProfile2D.h:115; TProfile2D::Approximatestatic void Approximate(Bool_t approx=kTRUE)Static function, set the fgApproximate flag.Definition TProfile2D.cxx:277; TProfile2D::GetBinSumw2virtual const TArrayD * GetBinSumw2() constDefinition TProfile2D.h:122; TProfile2D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile2D.h:35; TProfile2D::fZminDouble_t fZminLower limit in Z (if set)Definition TProfile2D.h:36; TProfile2D::RebinXTProfile2D * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis.Definition TProfile2D.cxx:1837; TProfile2D::FillInt_t Fill(const char *namex, const char *namey, Double_t z) overrideIncrement cell defined by namex,namey by a weight w.Definition TProfile2D.h:112; TProfile2D::GetW2Double_t * GetW2()Definition TProfile2D.h:66; TProfile2D::BufferFillInt_t BufferFill(Double_t, Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile2D.h:45; TProfile2D::GetBinErrorDouble_t GetBinError(Int_t binx, Int_t biny) const overrideDefinition TProfile2D.h:117; TProfile2D::SetBinsvoid SetBins(Int_t, const Double_t *) overrideRedefine x axis parameters with variable bin sizes.Definition TProfile2D.h:69; TProfile2D::FillInt_t Fill(const char *namex, Double_t y, Double_t z) overrideIncrement cel",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:14331,Availability,error,errors,14331," by namex,namey by a weight w.Definition TProfile2D.h:112; TProfile2D::GetW2Double_t * GetW2()Definition TProfile2D.h:66; TProfile2D::BufferFillInt_t BufferFill(Double_t, Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile2D.h:45; TProfile2D::GetBinErrorDouble_t GetBinError(Int_t binx, Int_t biny) const overrideDefinition TProfile2D.h:117; TProfile2D::SetBinsvoid SetBins(Int_t, const Double_t *) overrideRedefine x axis parameters with variable bin sizes.Definition TProfile2D.h:69; TProfile2D::FillInt_t Fill(const char *namex, Double_t y, Double_t z) overrideIncrement cell defined by namex,y by a weight w.Definition TProfile2D.h:111; TProfile2D::fScalingBool_t fScaling! True when TProfile2D::Scale is calledDefinition TProfile2D.h:38; TProfile2D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)Return bin effective entries for a weighted filled Profile histogram.Definition TProfile2D.cxx:858; TProfile2D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile2D.cxx:889; TProfile2D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile2D.cxx:1856; TProfile2D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile2D.h:41; TProfile2D::GetBinContentDouble_t GetBinContent(Int_t binx, Int_t biny) const overrideDefinition TProfile2D.h:114; TProfile2D::GetB2Double_t * GetB2()Definition TProfile2D.h:64; TProfile2D::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along axis such that x is in the axis range.Definition TProfile2D.cxx:1514; TProfile2D::ProfileYTProfile * ProfileY(const char *name=""_pfy"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TProfile2D.cxx:1389; TProfile2D::RebinYTProfile2D * RebinY(Int_t ngroup=",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:17489,Availability,error,error,17489,"D::TProfile2DTProfile2D()Default constructor for Profile2D histograms.Definition TProfile2D.cxx:88; TProfile2D::GetBinErrorDouble_t GetBinError(Int_t binx, Int_t biny, Int_t) const overrideDefinition TProfile2D.h:118; TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::FillInt_t Fill(Double_t x, const char *namey, Double_t z) overrideIncrement cell defined by x,namey by a weight w.Definition TProfile2D.h:110; TProfile2D::GetBinErrorSqUncheckedDouble_t GetBinErrorSqUnchecked(Int_t bin) const overrideDefinition TProfile2D.h:60; TProfile2D::fBinEntriesTArrayD fBinEntriesNumber of entries per bin.Definition TProfile2D.h:34; TProfile2D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile2D.h:49; TProfile2D::~TProfile2D~TProfile2D() overrideDefault destructor for Profile2D histograms.Definition TProfile2D.cxx:98; TProfile2D::fgApproximatestatic Bool_t fgApproximateBin error approximation option.Definition TProfile2D.h:42; TProfile2D::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1) .Definition TProfile2D.cxx:415; TProfile2D::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x, y and z axis parameters with variable bin sizes.Definition TProfile2D.h:73; TProfile2D::Rebin2DTProfile2D * Rebin2D(Int_t nxgroup=2, Int_t nygroup=2, const char *newname="""") overrideRebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.Definition TProfile2D.cxx:1552; TProfile2D::FillInt_t Fill(Double_t, Double_t) overrideIncrement cell defined by x,y by 1.Definition TProfile2D.h:56; TProfile2D::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TProfile2D.cxx:291; TProfile2D::LabelsInflatevoid LabelsInflate(Option_t *axis=""X"") overrideDouble the number of bins for ax",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:20440,Availability,error,errors,20440,"::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile2D.cxx:1947; TProfile2D::BuildOptionsvoid BuildOptions(Double_t zmin, Double_t zmax, Option_t *option)Set Profile2D histogram structure and options.Definition TProfile2D.cxx:189; TProfile2D::AddBool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""") overridePerforms the operation: this = this + c1*f1 .Definition TProfile2D.cxx:221; TProfile2D::operator=TProfile2D & operator=(const TProfile2D &profile)Definition TProfile2D.cxx:211; TProfile2D::SetBuffervoid SetBuffer(Int_t buffersize, Option_t *option="""") overrideSet the buffer size in units of 8 bytes (double).Definition TProfile2D.cxx:1956; TProfile2D::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TProfile2D.h:40; TProfile2D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile2D.h:121; TProfile2D::GetNumberOfBinsDouble_t GetNumberOfBins()Definition TProfile2D.h:151; TProfile2D::GetBDouble_t * GetB()Definition TProfile2D.h:63; TProfile2D::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile2D errors.Definition TProfile2D.cxx:1994; TProfile2D::GetZmaxvirtual Double_t GetZmax() constDefinition TProfile2D.h:126; TProfile2D::GetZminvirtual Double_t GetZmin() constDefinition TProfile2D.h:125; TProfile2D::GetBinContentDouble_t GetBinContent(Int_t bin) const overrideReturn bin content of a Profile2D histogram.Definition TProfile2D.cxx:829; TProfileHelperDefinition TProfileHelper.h:30; TProfileProfile Histogram.Definition TProfile.h:32; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; c2return c2Definition legend2.C:14; v@ vDefinition rootcling_impl.cxx:3699. histhistincTProfile2D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:9533,Modifiability,inherit,inherited,9533,"n, Double_t xmax, Int_t nbinsy, Double_t ymin, Double_t ymax) override;; 146 void SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins) override;; 147 void SetBinsLength(Int_t n=-1) override;; 148 void SetBuffer(Int_t buffersize, Option_t *option="""") override;; 149 virtual void SetErrorOption(Option_t *option=""""); // *MENU*; 150 void Sumw2(Bool_t flag = kTRUE) override;; 151 Double_t GetNumberOfBins() { return fBinEntries.GetSize(); }; 152 ; 153 ClassDefOverride(TProfile2D,8) //Profile2D histogram class; 154};; 155 ; 156#endif; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TH2.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TProfile.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Resetvoid Reset()Definition TArrayD.h:47; TArray::fNInt_t fNDefinition TArray.h:38; TArray::GetSizeInt_t GetSize() constDefinition TArray.h:47; TAxisClass to manage histogram axis.Definition TAxis.h:31; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TH1MergerDefinition TH1Merger.h:20; ",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:13749,Modifiability,variab,variable,13749," the fgApproximate flag.Definition TProfile2D.cxx:277; TProfile2D::GetBinSumw2virtual const TArrayD * GetBinSumw2() constDefinition TProfile2D.h:122; TProfile2D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile2D.h:35; TProfile2D::fZminDouble_t fZminLower limit in Z (if set)Definition TProfile2D.h:36; TProfile2D::RebinXTProfile2D * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis.Definition TProfile2D.cxx:1837; TProfile2D::FillInt_t Fill(const char *namex, const char *namey, Double_t z) overrideIncrement cell defined by namex,namey by a weight w.Definition TProfile2D.h:112; TProfile2D::GetW2Double_t * GetW2()Definition TProfile2D.h:66; TProfile2D::BufferFillInt_t BufferFill(Double_t, Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile2D.h:45; TProfile2D::GetBinErrorDouble_t GetBinError(Int_t binx, Int_t biny) const overrideDefinition TProfile2D.h:117; TProfile2D::SetBinsvoid SetBins(Int_t, const Double_t *) overrideRedefine x axis parameters with variable bin sizes.Definition TProfile2D.h:69; TProfile2D::FillInt_t Fill(const char *namex, Double_t y, Double_t z) overrideIncrement cell defined by namex,y by a weight w.Definition TProfile2D.h:111; TProfile2D::fScalingBool_t fScaling! True when TProfile2D::Scale is calledDefinition TProfile2D.h:38; TProfile2D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)Return bin effective entries for a weighted filled Profile histogram.Definition TProfile2D.cxx:858; TProfile2D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile2D.cxx:889; TProfile2D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile2D.cxx:1856; TProfile2D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile2D.h:41; TProfile2D::GetBinContentDouble_t GetBinContent",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/TProfile2D_8h_source.html:17840,Modifiability,variab,variable,17840,"to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::FillInt_t Fill(Double_t x, const char *namey, Double_t z) overrideIncrement cell defined by x,namey by a weight w.Definition TProfile2D.h:110; TProfile2D::GetBinErrorSqUncheckedDouble_t GetBinErrorSqUnchecked(Int_t bin) const overrideDefinition TProfile2D.h:60; TProfile2D::fBinEntriesTArrayD fBinEntriesNumber of entries per bin.Definition TProfile2D.h:34; TProfile2D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile2D.h:49; TProfile2D::~TProfile2D~TProfile2D() overrideDefault destructor for Profile2D histograms.Definition TProfile2D.cxx:98; TProfile2D::fgApproximatestatic Bool_t fgApproximateBin error approximation option.Definition TProfile2D.h:42; TProfile2D::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1) .Definition TProfile2D.cxx:415; TProfile2D::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x, y and z axis parameters with variable bin sizes.Definition TProfile2D.h:73; TProfile2D::Rebin2DTProfile2D * Rebin2D(Int_t nxgroup=2, Int_t nygroup=2, const char *newname="""") overrideRebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.Definition TProfile2D.cxx:1552; TProfile2D::FillInt_t Fill(Double_t, Double_t) overrideIncrement cell defined by x,y by 1.Definition TProfile2D.h:56; TProfile2D::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TProfile2D.cxx:291; TProfile2D::LabelsInflatevoid LabelsInflate(Option_t *axis=""X"") overrideDouble the number of bins for axis.Definition TProfile2D.cxx:990; TProfile2D::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this profile.Definition TProfile2D.cxx:916; TProfile2D::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile2D histo",MatchSource.WIKI,doc/master/TProfile2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html
https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:271,Availability,fault,faulty,271,". ROOT: tutorials/hist/tprofile2polyRealisticModuleError.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealisticModuleError.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Simulate faulty detector panel w.r.t. ; particle charge. ; #include <iostream>; #include <fstream>; #include <vector>; ; void tprofile2polyRealisticModuleError(Int_t numEvents = 1000000); {; TCanvas *c1 = new TCanvas(""c1"", ""4 Malfunctioning Panels"", 800, 400);; c1->Divide(3, 1);; ; // -------------------- Construct detector bins ------------------------; auto th2p = new TH2Poly();; auto avg = new TProfile2Poly();; auto err = new TProfile2Poly();; ; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; std::cout << ""[ERROR] Bad file"" << std::endl;; return;; }; ; Double_t x[3], y[3];; for (Int_t i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioni",MatchSource.WIKI,doc/master/tprofile2polyRealisticModuleError_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html
https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:972,Availability,error,error,972,"rence. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealisticModuleError.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Simulate faulty detector panel w.r.t. ; particle charge. ; #include <iostream>; #include <fstream>; #include <vector>; ; void tprofile2polyRealisticModuleError(Int_t numEvents = 1000000); {; TCanvas *c1 = new TCanvas(""c1"", ""4 Malfunctioning Panels"", 800, 400);; c1->Divide(3, 1);; ; // -------------------- Construct detector bins ------------------------; auto th2p = new TH2Poly();; auto avg = new TProfile2Poly();; auto err = new TProfile2Poly();; ; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; std::cout << ""[ERROR] Bad file"" << std::endl;; return;; }; ; Double_t x[3], y[3];; for (Int_t i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioning panels -------------------; if (th2p->IsInsideBin(4, r1, r2)) va",MatchSource.WIKI,doc/master/tprofile2polyRealisticModuleError_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html
https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:2714,Availability,error,error,2714," < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioning panels -------------------; if (th2p->IsInsideBin(4, r1, r2)) val = rok - rbad1;; if (th2p->IsInsideBin(20, r1, r2)) val = rok - rbad2;; if (th2p->IsInsideBin(13, r1, r2)) val = rok + rbad1;; if (th2p->IsInsideBin(37, r1, r2)) val = rok + rbad2;; ; // -------------------- Fill histograms ------------------------; th2p->Fill(r1, r2, val);; avg->Fill(r1, r2, val);; err->Fill(r1, r2, val);; }; ; // -------------------- Display end state ------------------------; c1->cd(1);; th2p->SetStats(0);; th2p->SetTitle(""total hits"");; th2p->Draw(""COLZ"");; ; c1->cd(2);; avg->SetStats(0);; avg->SetTitle(""average charge"");; avg->Draw(""COLZ"");; ; c1->cd(3);; err->SetStats(0);; err->SetContentToError();; err->SetTitle(""error"");; err->Draw(""COLZ"");; }; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gROOT#define gROOTDefinition TROOT.h:406; TCanvasThe Canvas class.Definition TCanvas.h:23; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TProfile2Poly2D Profile Histogram with Polygonal Bins.Definition TProfile2Poly.h:58; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from th",MatchSource.WIKI,doc/master/tprofile2polyRealisticModuleError_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html
https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:311,Energy Efficiency,charge,charge,311,". ROOT: tutorials/hist/tprofile2polyRealisticModuleError.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealisticModuleError.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Simulate faulty detector panel w.r.t. ; particle charge. ; #include <iostream>; #include <fstream>; #include <vector>; ; void tprofile2polyRealisticModuleError(Int_t numEvents = 1000000); {; TCanvas *c1 = new TCanvas(""c1"", ""4 Malfunctioning Panels"", 800, 400);; c1->Divide(3, 1);; ; // -------------------- Construct detector bins ------------------------; auto th2p = new TH2Poly();; auto avg = new TProfile2Poly();; auto err = new TProfile2Poly();; ; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; std::cout << ""[ERROR] Bad file"" << std::endl;; return;; }; ; Double_t x[3], y[3];; for (Int_t i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioni",MatchSource.WIKI,doc/master/tprofile2polyRealisticModuleError_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html
https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:2608,Energy Efficiency,charge,charge,2608," < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioning panels -------------------; if (th2p->IsInsideBin(4, r1, r2)) val = rok - rbad1;; if (th2p->IsInsideBin(20, r1, r2)) val = rok - rbad2;; if (th2p->IsInsideBin(13, r1, r2)) val = rok + rbad1;; if (th2p->IsInsideBin(37, r1, r2)) val = rok + rbad2;; ; // -------------------- Fill histograms ------------------------; th2p->Fill(r1, r2, val);; avg->Fill(r1, r2, val);; err->Fill(r1, r2, val);; }; ; // -------------------- Display end state ------------------------; c1->cd(1);; th2p->SetStats(0);; th2p->SetTitle(""total hits"");; th2p->Draw(""COLZ"");; ; c1->cd(2);; avg->SetStats(0);; avg->SetTitle(""average charge"");; avg->Draw(""COLZ"");; ; c1->cd(3);; err->SetStats(0);; err->SetContentToError();; err->SetTitle(""error"");; err->Draw(""COLZ"");; }; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gROOT#define gROOTDefinition TROOT.h:406; TCanvasThe Canvas class.Definition TCanvas.h:23; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TProfile2Poly2D Profile Histogram with Polygonal Bins.Definition TProfile2Poly.h:58; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from th",MatchSource.WIKI,doc/master/tprofile2polyRealisticModuleError_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html
https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:278,Safety,detect,detector,278,". ROOT: tutorials/hist/tprofile2polyRealisticModuleError.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealisticModuleError.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Simulate faulty detector panel w.r.t. ; particle charge. ; #include <iostream>; #include <fstream>; #include <vector>; ; void tprofile2polyRealisticModuleError(Int_t numEvents = 1000000); {; TCanvas *c1 = new TCanvas(""c1"", ""4 Malfunctioning Panels"", 800, 400);; c1->Divide(3, 1);; ; // -------------------- Construct detector bins ------------------------; auto th2p = new TH2Poly();; auto avg = new TProfile2Poly();; auto err = new TProfile2Poly();; ; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; std::cout << ""[ERROR] Bad file"" << std::endl;; return;; }; ; Double_t x[3], y[3];; for (Int_t i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioni",MatchSource.WIKI,doc/master/tprofile2polyRealisticModuleError_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html
https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:579,Safety,detect,detector,579,". ROOT: tutorials/hist/tprofile2polyRealisticModuleError.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealisticModuleError.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Simulate faulty detector panel w.r.t. ; particle charge. ; #include <iostream>; #include <fstream>; #include <vector>; ; void tprofile2polyRealisticModuleError(Int_t numEvents = 1000000); {; TCanvas *c1 = new TCanvas(""c1"", ""4 Malfunctioning Panels"", 800, 400);; c1->Divide(3, 1);; ; // -------------------- Construct detector bins ------------------------; auto th2p = new TH2Poly();; auto avg = new TProfile2Poly();; auto err = new TProfile2Poly();; ; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; std::cout << ""[ERROR] Bad file"" << std::endl;; return;; }; ; Double_t x[3], y[3];; for (Int_t i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioni",MatchSource.WIKI,doc/master/tprofile2polyRealisticModuleError_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html
https://root.cern/doc/master/tprofile2polyRealistic_8C.html:1816,Availability,error,error,1816,"rofile2Poly[NUM_LS];; auto tot_merge = new TProfile2Poly();; auto det_avg_merge = new TProfile2Poly();; auto det_err_merge = new TProfile2Poly();; ; float minx = -15;; float maxx = 15;; float miny = -15;; float maxy = 15;; float binsz = 0.5;; ; for (float i = minx; i < maxx; i += binsz) {; for (float j = miny; j < maxy; j += binsz) {; tot_merge->AddBin(i, j, i + binsz, j + binsz);; for (int l = 0; l < NUM_LS; ++l) {; tot_avg_ls[l].AddBin(i, j, i + binsz, j + binsz);; }; }; }; ; // -------------------- Construct detector bins ------------------------; auto h2p = new TH2Poly();; auto tp2p = new TProfile2Poly();; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; cout << ""[ERROR] Bad file"" << endl;; return;; }; ; Double_t x[3], y[3];; for (int i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; ; det_avg_merge->AddBin(3, x, y);; det_err_merge->AddBin(3, x, y);; ; for (int l = 0; l < NUM_LS; ++l) {; det_avg_ls[l].AddBin(3, x, y);; det_err_ls[l].AddBin(3, x, y);; }; }; ; std::cout << "" WE ARE AFTER ADDING BINS "" << std::endl;; ; // -------------------- Simulate particles ------------------------; TRandom ran;; ; // moving error; Double_t xoffset1 = 0;; Double_t yoffset1 = 0;; Double_t xoffset2 = 0;; Double_t yoffset2 = 0;; ; for (int i = 0; i <= NUM_LS-1; ++",MatchSource.WIKI,doc/master/tprofile2polyRealistic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html
https://root.cern/doc/master/tprofile2polyRealistic_8C.html:2803,Availability,error,error,2803,"::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; cout << ""[ERROR] Bad file"" << endl;; return;; }; ; Double_t x[3], y[3];; for (int i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; ; det_avg_merge->AddBin(3, x, y);; det_err_merge->AddBin(3, x, y);; ; for (int l = 0; l < NUM_LS; ++l) {; det_avg_ls[l].AddBin(3, x, y);; det_err_ls[l].AddBin(3, x, y);; }; }; ; std::cout << "" WE ARE AFTER ADDING BINS "" << std::endl;; ; // -------------------- Simulate particles ------------------------; TRandom ran;; ; // moving error; Double_t xoffset1 = 0;; Double_t yoffset1 = 0;; Double_t xoffset2 = 0;; Double_t yoffset2 = 0;; ; for (int i = 0; i <= NUM_LS-1; ++i) { // LumiSection; std::cout << ""[In Progress] LumiSection "" << i << std::endl;; for (int j = 0; j < numEvents; ++j) { // Events; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(10, 1);; Double_t rbad1 = ran.Gaus(8, 5);; Double_t rbad2 = ran.Gaus(-8, 5);; ; Double_t val = rok;; ; xoffset1 += 0.00002;; yoffset1 += 0.00002;; ; xoffset2 += 0.00003;; yoffset2 += 0.00004;; ; if (r2 > 3. - yoffset1 && r2 < 8. - yoffset1 &&; r1 > 1. + xoffset1 && r1 < 5. + xoffset1 ) {; val -= rbad1;; }; ; if (r2 > -10 + yoffset2 && r2 < -8 + yoffset2 &&; r1 > -6 + xoffset2 && r1 < 8 + xoffset2 ) {; val -= rbad2;; }; ; tot_avg_ls[i].Fill(r1, r2, val);; det_avg_ls[i].Fill(r1, r2, val);; det_err_ls[i].Fill(r1, r2, val);; }; ; std::string title;; ; c1->cd(i+1);; title = ""Global View: Avg in LS "" + std::to_string(i);; tot_avg_ls[i].SetTitle(title.c_str());; tot_avg_ls[i].SetStats(false);; t",MatchSource.WIKI,doc/master/tprofile2polyRealistic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html
https://root.cern/doc/master/tprofile2polyRealistic_8C.html:4971,Availability,error,error,4971,"SetTitle(title.c_str());; tot_avg_ls[i].SetStats(false);; tot_avg_ls[i].Draw(""COLZ"");; c1->Update();; ; c1->cd((i+1)+NUM_LS);; title = ""Detector View: Avg in LS "" + std::to_string(i);; det_avg_ls[i].SetTitle(title.c_str());; det_avg_ls[i].SetStats(false);; det_avg_ls[i].Draw(""COLZ"");; c1->Update();; ; c1->cd((i+1)+(NUM_LS*2));; title = ""Detector View: Error in LS "" + std::to_string(i);; det_err_ls[i].SetTitle(title.c_str());; det_err_ls[i].SetStats(false);; det_err_ls[i].SetContentToError();; det_err_ls[i].Draw(""COLZ"");; c1->Update();; }; ; std::vector<TProfile2Poly*> tot_avg_v;; std::vector<TProfile2Poly*> det_avg_v;; for (int t = 0; t < NUM_LS; t++){; tot_avg_v.push_back(&tot_avg_ls[t]);; det_avg_v.push_back(&det_avg_ls[t]);; }; ; std::cout << ""[In Progress] Merging"" << std::endl;; ; tot_merge->Merge(tot_avg_v);; c2->cd(1);; tot_merge->SetTitle(""Total average merge"");; tot_merge->Draw(""COLZ"");; ; det_avg_merge->Merge(det_avg_v);; c2->cd(2);; det_avg_merge->SetTitle(""Detector average merge"");; det_avg_merge->SetContentToAverage(); // implicit; det_avg_merge->Draw(""COLZ"");; ; det_err_merge->Merge(det_avg_v);; c2->cd(3);; det_err_merge->SetTitle(""Detector error merge"");; det_err_merge->SetContentToError();; det_err_merge->Draw(""COLZ"");; }; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TProfile2D.h; TProfile2Poly.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TProfile2Poly2D Profile Histogram with Polygonal Bins.Definition TProfile2Poly.h:58; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...",MatchSource.WIKI,doc/master/tprofile2polyRealistic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html
https://root.cern/doc/master/tprofile2polyRealistic_8C.html:250,Energy Efficiency,charge,charges,250,". ROOT: tutorials/hist/tprofile2polyRealistic.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealistic.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Different charges depending on region . ; #include <iostream>; #include <fstream>; #include <TProfile2Poly.h>; #include <TProfile2D.h>; #include <TCanvas.h>; #include <TRandom.h>; #include <TROOT.h>; ; void tprofile2polyRealistic(Int_t numEvents=100000); {; int NUM_LS = 8;; TCanvas *c1 = new TCanvas(""c1"", ""moving charge"", 900, 400);; TCanvas *c2 = new TCanvas(""c2"", ""Merge Individual moving charge plots"", 800, 400);; ; c1->Divide(NUM_LS, 3);; c2->Divide(3,1);; ; // -------------------- Construct Reference plot bins ------------------------; auto new_avg = new TProfile2Poly();; ; auto tot_avg_ls = new TProfile2Poly[NUM_LS];; auto det_avg_ls = new TProfile2Poly[NUM_LS];; auto det_err_ls = new TProfile2Poly[NUM_LS];; auto tot_merge = new TProfile2Poly();; auto det_avg_merge = new TProfile2Poly();; auto det_err_merge = new TProfile2Poly();; ; float minx = -15;; float maxx = 15;; float miny = -15;; float maxy = 15;; float binsz = 0.5;; ; for (float i = minx; i < maxx; i += binsz) {; for (float j = miny; j < maxy; j += binsz) {; tot_merge->AddBin(i, j, i + binsz, j + binsz);; for (int l = 0; l < NUM_LS; ++l) {; tot_avg_ls[l].AddBin(i, j, i + binsz, j + binsz);; }; }; }; ; // -------------------- Construct detector bins ------------------------; auto h2p = new TH2Poly();; auto tp2p = new TProfile2Poly();; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<",MatchSource.WIKI,doc/master/tprofile2polyRealistic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html
https://root.cern/doc/master/tprofile2polyRealistic_8C.html:555,Energy Efficiency,charge,charge,555,". ROOT: tutorials/hist/tprofile2polyRealistic.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealistic.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Different charges depending on region . ; #include <iostream>; #include <fstream>; #include <TProfile2Poly.h>; #include <TProfile2D.h>; #include <TCanvas.h>; #include <TRandom.h>; #include <TROOT.h>; ; void tprofile2polyRealistic(Int_t numEvents=100000); {; int NUM_LS = 8;; TCanvas *c1 = new TCanvas(""c1"", ""moving charge"", 900, 400);; TCanvas *c2 = new TCanvas(""c2"", ""Merge Individual moving charge plots"", 800, 400);; ; c1->Divide(NUM_LS, 3);; c2->Divide(3,1);; ; // -------------------- Construct Reference plot bins ------------------------; auto new_avg = new TProfile2Poly();; ; auto tot_avg_ls = new TProfile2Poly[NUM_LS];; auto det_avg_ls = new TProfile2Poly[NUM_LS];; auto det_err_ls = new TProfile2Poly[NUM_LS];; auto tot_merge = new TProfile2Poly();; auto det_avg_merge = new TProfile2Poly();; auto det_err_merge = new TProfile2Poly();; ; float minx = -15;; float maxx = 15;; float miny = -15;; float maxy = 15;; float binsz = 0.5;; ; for (float i = minx; i < maxx; i += binsz) {; for (float j = miny; j < maxy; j += binsz) {; tot_merge->AddBin(i, j, i + binsz, j + binsz);; for (int l = 0; l < NUM_LS; ++l) {; tot_avg_ls[l].AddBin(i, j, i + binsz, j + binsz);; }; }; }; ; // -------------------- Construct detector bins ------------------------; auto h2p = new TH2Poly();; auto tp2p = new TProfile2Poly();; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<",MatchSource.WIKI,doc/master/tprofile2polyRealistic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html
https://root.cern/doc/master/tprofile2polyRealistic_8C.html:633,Energy Efficiency,charge,charge,633,". ROOT: tutorials/hist/tprofile2polyRealistic.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealistic.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Different charges depending on region . ; #include <iostream>; #include <fstream>; #include <TProfile2Poly.h>; #include <TProfile2D.h>; #include <TCanvas.h>; #include <TRandom.h>; #include <TROOT.h>; ; void tprofile2polyRealistic(Int_t numEvents=100000); {; int NUM_LS = 8;; TCanvas *c1 = new TCanvas(""c1"", ""moving charge"", 900, 400);; TCanvas *c2 = new TCanvas(""c2"", ""Merge Individual moving charge plots"", 800, 400);; ; c1->Divide(NUM_LS, 3);; c2->Divide(3,1);; ; // -------------------- Construct Reference plot bins ------------------------; auto new_avg = new TProfile2Poly();; ; auto tot_avg_ls = new TProfile2Poly[NUM_LS];; auto det_avg_ls = new TProfile2Poly[NUM_LS];; auto det_err_ls = new TProfile2Poly[NUM_LS];; auto tot_merge = new TProfile2Poly();; auto det_avg_merge = new TProfile2Poly();; auto det_err_merge = new TProfile2Poly();; ; float minx = -15;; float maxx = 15;; float miny = -15;; float maxy = 15;; float binsz = 0.5;; ; for (float i = minx; i < maxx; i += binsz) {; for (float j = miny; j < maxy; j += binsz) {; tot_merge->AddBin(i, j, i + binsz, j + binsz);; for (int l = 0; l < NUM_LS; ++l) {; tot_avg_ls[l].AddBin(i, j, i + binsz, j + binsz);; }; }; }; ; // -------------------- Construct detector bins ------------------------; auto h2p = new TH2Poly();; auto tp2p = new TProfile2Poly();; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<",MatchSource.WIKI,doc/master/tprofile2polyRealistic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html
https://root.cern/doc/master/tprofile2polyRealistic_8C.html:258,Integrability,depend,depending,258,". ROOT: tutorials/hist/tprofile2polyRealistic.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealistic.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Different charges depending on region . ; #include <iostream>; #include <fstream>; #include <TProfile2Poly.h>; #include <TProfile2D.h>; #include <TCanvas.h>; #include <TRandom.h>; #include <TROOT.h>; ; void tprofile2polyRealistic(Int_t numEvents=100000); {; int NUM_LS = 8;; TCanvas *c1 = new TCanvas(""c1"", ""moving charge"", 900, 400);; TCanvas *c2 = new TCanvas(""c2"", ""Merge Individual moving charge plots"", 800, 400);; ; c1->Divide(NUM_LS, 3);; c2->Divide(3,1);; ; // -------------------- Construct Reference plot bins ------------------------; auto new_avg = new TProfile2Poly();; ; auto tot_avg_ls = new TProfile2Poly[NUM_LS];; auto det_avg_ls = new TProfile2Poly[NUM_LS];; auto det_err_ls = new TProfile2Poly[NUM_LS];; auto tot_merge = new TProfile2Poly();; auto det_avg_merge = new TProfile2Poly();; auto det_err_merge = new TProfile2Poly();; ; float minx = -15;; float maxx = 15;; float miny = -15;; float maxy = 15;; float binsz = 0.5;; ; for (float i = minx; i < maxx; i += binsz) {; for (float j = miny; j < maxy; j += binsz) {; tot_merge->AddBin(i, j, i + binsz, j + binsz);; for (int l = 0; l < NUM_LS; ++l) {; tot_avg_ls[l].AddBin(i, j, i + binsz, j + binsz);; }; }; }; ; // -------------------- Construct detector bins ------------------------; auto h2p = new TH2Poly();; auto tp2p = new TProfile2Poly();; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<",MatchSource.WIKI,doc/master/tprofile2polyRealistic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html
https://root.cern/doc/master/tprofile2polyRealistic_8C.html:1458,Safety,detect,detector,1458," NUM_LS = 8;; TCanvas *c1 = new TCanvas(""c1"", ""moving charge"", 900, 400);; TCanvas *c2 = new TCanvas(""c2"", ""Merge Individual moving charge plots"", 800, 400);; ; c1->Divide(NUM_LS, 3);; c2->Divide(3,1);; ; // -------------------- Construct Reference plot bins ------------------------; auto new_avg = new TProfile2Poly();; ; auto tot_avg_ls = new TProfile2Poly[NUM_LS];; auto det_avg_ls = new TProfile2Poly[NUM_LS];; auto det_err_ls = new TProfile2Poly[NUM_LS];; auto tot_merge = new TProfile2Poly();; auto det_avg_merge = new TProfile2Poly();; auto det_err_merge = new TProfile2Poly();; ; float minx = -15;; float maxx = 15;; float miny = -15;; float maxy = 15;; float binsz = 0.5;; ; for (float i = minx; i < maxx; i += binsz) {; for (float j = miny; j < maxy; j += binsz) {; tot_merge->AddBin(i, j, i + binsz, j + binsz);; for (int l = 0; l < NUM_LS; ++l) {; tot_avg_ls[l].AddBin(i, j, i + binsz, j + binsz);; }; }; }; ; // -------------------- Construct detector bins ------------------------; auto h2p = new TH2Poly();; auto tp2p = new TProfile2Poly();; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; cout << ""[ERROR] Bad file"" << endl;; return;; }; ; Double_t x[3], y[3];; for (int i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; ; det_avg_merge->AddBin(3, x, ",MatchSource.WIKI,doc/master/tprofile2polyRealistic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:4234,Availability,error,errors,4234,"r Profile3D histograms.; 85 ; 86TProfile3D::~TProfile3D(); 87{; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// Normal Constructor for Profile histograms.; 92///; 93/// The first eleven parameters are similar to TH3D::TH3D.; 94/// All values of t are accepted at filling time.; 95/// To fill a profile3D histogram, one must use TProfile3D::Fill function.; 96///; 97/// Note that when filling the profile histogram the function Fill; 98/// checks if the variable t is between fTmin and fTmax.; 99/// If a minimum or maximum value is set for the T scale before filling,; 100/// then all values below tmin or above tmax will be discarded.; 101/// Setting the minimum or maximum value for the T scale before filling; 102/// has the same effect as calling the special TProfile3D constructor below; 103/// where tmin and tmax are specified.; 104///; 105/// H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; 106/// (spread option), or e(I,J,K) if CHOPT=' ' (error on mean).; 107///; 108/// See TProfile3D::BuildOptions for explanation of parameters; 109///; 110/// see other constructors below with all possible combinations of; 111/// fix and variable bin size like in TH3D.; 112 ; 113TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Int_t nz, Double_t zlow,Double_t zup,Option_t *option); 114 : TH3D(name,title,nx,xlow,xup,ny,ylow,yup,nz,zlow,zup); 115{; 116 BuildOptions(0,0,option);; 117 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 118}; 119 ; 120////////////////////////////////////////////////////////////////////////////////; 121/// Create a 3-D Profile with variable bins in X , Y and Z.; 122 ; 123TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Int_t nz,const Double_t *zbins,Option_t *option); 124 : TH3D(name,title,nx,xbins,",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:4327,Availability,error,error,4327,"r Profile3D histograms.; 85 ; 86TProfile3D::~TProfile3D(); 87{; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// Normal Constructor for Profile histograms.; 92///; 93/// The first eleven parameters are similar to TH3D::TH3D.; 94/// All values of t are accepted at filling time.; 95/// To fill a profile3D histogram, one must use TProfile3D::Fill function.; 96///; 97/// Note that when filling the profile histogram the function Fill; 98/// checks if the variable t is between fTmin and fTmax.; 99/// If a minimum or maximum value is set for the T scale before filling,; 100/// then all values below tmin or above tmax will be discarded.; 101/// Setting the minimum or maximum value for the T scale before filling; 102/// has the same effect as calling the special TProfile3D constructor below; 103/// where tmin and tmax are specified.; 104///; 105/// H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; 106/// (spread option), or e(I,J,K) if CHOPT=' ' (error on mean).; 107///; 108/// See TProfile3D::BuildOptions for explanation of parameters; 109///; 110/// see other constructors below with all possible combinations of; 111/// fix and variable bin size like in TH3D.; 112 ; 113TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Int_t nz, Double_t zlow,Double_t zup,Option_t *option); 114 : TH3D(name,title,nx,xlow,xup,ny,ylow,yup,nz,zlow,zup); 115{; 116 BuildOptions(0,0,option);; 117 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 118}; 119 ; 120////////////////////////////////////////////////////////////////////////////////; 121/// Create a 3-D Profile with variable bins in X , Y and Z.; 122 ; 123TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Int_t nz,const Double_t *zbins,Option_t *option); 124 : TH3D(name,title,nx,xbins,",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:5764,Availability,error,error,5764,"////////////////////////////////////////; 121/// Create a 3-D Profile with variable bins in X , Y and Z.; 122 ; 123TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Int_t nz,const Double_t *zbins,Option_t *option); 124 : TH3D(name,title,nx,xbins,ny,ybins,nz,zbins); 125{; 126 BuildOptions(0,0,option);; 127}; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// Set Profile3D histogram structure and options.; 131///; 132/// - tmin: minimum value allowed for t; 133/// - tmax: maximum value allowed for t; 134/// if (tmin = tmax = 0) there are no limits on the allowed t values (tmin = -inf, tmax = +inf); 135///; 136/// - option: this is the option for the computation of the t error of the profile ( TProfile3D::GetBinError ); 137/// possible values for the options are documented in TProfile3D::SetErrorOption; 138///; 139/// see also TProfile::BuildOptions for a detailed description; 140 ; 141void TProfile3D::BuildOptions(Double_t tmin, Double_t tmax, Option_t *option); 142{; 143 SetErrorOption(option);; 144 ; 145 // create extra profile data structure (bin entries/ y^2 and sum of weight square); 146 TProfileHelper::BuildArray(this);; 147 ; 148 fTmin = tmin;; 149 fTmax = tmax;; 150 fScaling = kFALSE;; 151 fTsumwt = fTsumwt2 = 0;; 152}; 153 ; 154////////////////////////////////////////////////////////////////////////////////; 155/// Copy constructor.; 156 ; 157TProfile3D::TProfile3D(const TProfile3D &profile3d) : TH3D(); 158{; 159 profile3d.TProfile3D::Copy(*this);; 160}; 161 ; 162TProfile3D &TProfile3D::operator=(const TProfile3D &profile3d); 163{; 164 if (this != &profile3d); 165 profile3d.TProfile3D::Copy(*this);; 166 return *this;; 167}; 168 ; 169////////////////////////////////////////////////////////////////////////////////; 170/// Performs the operation: `this = this + c1*f1` .; 171 ; 172Bool_t TProfile3D::Add(TF1 *, Double_t , Option_t*); 173{; 174 Error(",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:8546,Availability,error,error,8546,"le3D::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 201{; 202 if (!h1 || !h2) {; 203 Error(""Add"",""Attempt to add a non-existing profile"");; 204 return kFALSE;; 205 }; 206 if (!h1->InheritsFrom(TProfile3D::Class())) {; 207 Error(""Add"",""Attempt to add a non-profile3D object"");; 208 return kFALSE;; 209 }; 210 if (!h2->InheritsFrom(TProfile3D::Class())) {; 211 Error(""Add"",""Attempt to add a non-profile3D object"");; 212 return kFALSE;; 213 }; 214 ; 215 return TProfileHelper::Add(this, h1, h2, c1, c2);; 216}; 217 ; 218 ; 219////////////////////////////////////////////////////////////////////////////////; 220/// Set the fgApproximate flag.; 221///; 222/// When the flag is true, the function GetBinError; 223/// will approximate the bin error with the average profile error on all bins; 224/// in the following situation only; 225///; 226/// - the number of bins in the profile3D is less than 10404 (eg 100x100x100); 227/// - the bin number of entries is small ( <5); 228/// - the estimated bin error is extremely small compared to the bin content; 229/// (see TProfile3D::GetBinError); 230 ; 231void TProfile3D::Approximate(Bool_t approx); 232{; 233 fgApproximate = approx;; 234}; 235 ; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Fill histogram with all entries in the buffer.; 239///; 240/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 241/// - action = 0 histogram is filled from the buffer; 242/// - action = 1 histogram is filled and buffer is deleted; 243/// The buffer is automatically deleted when the number of entries; 244/// in the buffer is greater than the number of entries in the histogram; 245 ; 246Int_t TProfile3D::BufferEmpty(Int_t action); 247{; 248 // do we need to compute the bin size?; 249 if (!fBuffer) return 0;; 250 Int_t nbentries = (Int_t)fBuffer[0];; 251 if (!nbentries) return 0;; 252 Double_t *buffer = fBuffer;; 253 if (nbentries < 0) {; 254 if (a",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:8577,Availability,error,error,8577,"le3D::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 201{; 202 if (!h1 || !h2) {; 203 Error(""Add"",""Attempt to add a non-existing profile"");; 204 return kFALSE;; 205 }; 206 if (!h1->InheritsFrom(TProfile3D::Class())) {; 207 Error(""Add"",""Attempt to add a non-profile3D object"");; 208 return kFALSE;; 209 }; 210 if (!h2->InheritsFrom(TProfile3D::Class())) {; 211 Error(""Add"",""Attempt to add a non-profile3D object"");; 212 return kFALSE;; 213 }; 214 ; 215 return TProfileHelper::Add(this, h1, h2, c1, c2);; 216}; 217 ; 218 ; 219////////////////////////////////////////////////////////////////////////////////; 220/// Set the fgApproximate flag.; 221///; 222/// When the flag is true, the function GetBinError; 223/// will approximate the bin error with the average profile error on all bins; 224/// in the following situation only; 225///; 226/// - the number of bins in the profile3D is less than 10404 (eg 100x100x100); 227/// - the bin number of entries is small ( <5); 228/// - the estimated bin error is extremely small compared to the bin content; 229/// (see TProfile3D::GetBinError); 230 ; 231void TProfile3D::Approximate(Bool_t approx); 232{; 233 fgApproximate = approx;; 234}; 235 ; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Fill histogram with all entries in the buffer.; 239///; 240/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 241/// - action = 0 histogram is filled from the buffer; 242/// - action = 1 histogram is filled and buffer is deleted; 243/// The buffer is automatically deleted when the number of entries; 244/// in the buffer is greater than the number of entries in the histogram; 245 ; 246Int_t TProfile3D::BufferEmpty(Int_t action); 247{; 248 // do we need to compute the bin size?; 249 if (!fBuffer) return 0;; 250 Int_t nbentries = (Int_t)fBuffer[0];; 251 if (!nbentries) return 0;; 252 Double_t *buffer = fBuffer;; 253 if (nbentries < 0) {; 254 if (a",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:8804,Availability,error,error,8804,"le3D::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 201{; 202 if (!h1 || !h2) {; 203 Error(""Add"",""Attempt to add a non-existing profile"");; 204 return kFALSE;; 205 }; 206 if (!h1->InheritsFrom(TProfile3D::Class())) {; 207 Error(""Add"",""Attempt to add a non-profile3D object"");; 208 return kFALSE;; 209 }; 210 if (!h2->InheritsFrom(TProfile3D::Class())) {; 211 Error(""Add"",""Attempt to add a non-profile3D object"");; 212 return kFALSE;; 213 }; 214 ; 215 return TProfileHelper::Add(this, h1, h2, c1, c2);; 216}; 217 ; 218 ; 219////////////////////////////////////////////////////////////////////////////////; 220/// Set the fgApproximate flag.; 221///; 222/// When the flag is true, the function GetBinError; 223/// will approximate the bin error with the average profile error on all bins; 224/// in the following situation only; 225///; 226/// - the number of bins in the profile3D is less than 10404 (eg 100x100x100); 227/// - the bin number of entries is small ( <5); 228/// - the estimated bin error is extremely small compared to the bin content; 229/// (see TProfile3D::GetBinError); 230 ; 231void TProfile3D::Approximate(Bool_t approx); 232{; 233 fgApproximate = approx;; 234}; 235 ; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Fill histogram with all entries in the buffer.; 239///; 240/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 241/// - action = 0 histogram is filled from the buffer; 242/// - action = 1 histogram is filled and buffer is deleted; 243/// The buffer is automatically deleted when the number of entries; 244/// in the buffer is greater than the number of entries in the histogram; 245 ; 246Int_t TProfile3D::BufferEmpty(Int_t action); 247{; 248 // do we need to compute the bin size?; 249 if (!fBuffer) return 0;; 250 Int_t nbentries = (Int_t)fBuffer[0];; 251 if (!nbentries) return 0;; 252 Double_t *buffer = fBuffer;; 253 if (nbentries < 0) {; 254 if (a",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:16750,Availability,error,error,16750,"biny++) {; 435 for (binz =0;binz<=nz+1;binz++) {; 436 bin = GetBin(binx,biny,binz);; 437 c0 = fArray[bin];; 438 c1 = cu1[bin];; 439 if (c1) w = c0/c1;; 440 else w = 0;; 441 fArray[bin] = w;; 442 u = TMath::Abs(w);; 443 x = fXaxis.GetBinCenter(binx);; 444 y = fYaxis.GetBinCenter(biny);; 445 z = fZaxis.GetBinCenter(binz);; 446 fEntries++;; 447 fTsumw += u;; 448 fTsumw2 += u*u;; 449 fTsumwx += u*x;; 450 fTsumwx2 += u*x*x;; 451 fTsumwy += u*y;; 452 fTsumwy2 += u*y*y;; 453 fTsumwxy += u*x*y;; 454 fTsumwz += u;; 455 fTsumwz2 += u*z;; 456 fTsumwxz += u*x*z;; 457 fTsumwyz += u*y*z;; 458 fTsumwt += u;; 459 fTsumwt2 += u*u;; 460 Double_t e0 = fSumw2.fArray[bin];; 461 Double_t e1 = er1[bin];; 462 Double_t c12= c1*c1;; 463 if (!c1) fSumw2.fArray[bin] = 0;; 464 else fSumw2.fArray[bin] = (e0*c1*c1 + e1*c0*c0)/(c12*c12);; 465 if (!en1[bin]) fBinEntries.fArray[bin] = 0;; 466 else fBinEntries.fArray[bin] /= en1[bin];; 467 }; 468 }; 469 }; 470 // maintaining the correct sum of weights square is not supported when dividing; 471 // bin error resulting from division of profile needs to be checked; 472 if (fBinSumw2.fN) {; 473 Warning(""Divide"",""Cannot preserve during the division of profiles the sum of bin weight square"");; 474 fBinSumw2 = TArrayD();; 475 }; 476 return kTRUE;; 477}; 478 ; 479////////////////////////////////////////////////////////////////////////////////; 480/// Replace contents of this profile2D by the division of h1 by h2.; 481///; 482/// `this = c1*h1/(c2*h2)`; 483///; 484/// This function return kFALSE if the divide operation failed; 485 ; 486Bool_t TProfile3D::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 487{; 488 TString opt = option;; 489 opt.ToLower();; 490 Bool_t binomial = kFALSE;; 491 if (opt.Contains(""b"")) binomial = kTRUE;; 492 if (!h1 || !h2) {; 493 Error(""Divide"",""Attempt to divide a non-existing profile2D"");; 494 return kFALSE;; 495 }; 496 if (!h1->InheritsFrom(TProfile3D::Class())) {; 497 Error(""Divide"",""Attempt to div",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:25112,Availability,error,error,25112,"/////////; 702/// Return bin entries of a Profile3D histogram.; 703 ; 704Double_t TProfile3D::GetBinEntries(Int_t bin) const; 705{; 706 if (fBuffer) ((TProfile3D*)this)->BufferEmpty();; 707 ; 708 if (bin < 0 || bin >= fNcells) return 0;; 709 return fBinEntries.fArray[bin];; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Return bin effective entries for a weighted filled Profile histogram.; 714///; 715/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:25174,Availability,error,errors,25174,"return 0;; 709 return fBinEntries.fArray[bin];; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Return bin effective entries for a weighted filled Profile histogram.; 714///; 715/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation.; 743/// (see also comments in TProfile::GetBinError); 744 ; 745Double_t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750/////////////////////////",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:25232,Availability,error,errors,25232,"return 0;; 709 return fBinEntries.fArray[bin];; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Return bin effective entries for a weighted filled Profile histogram.; 714///; 715/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation.; 743/// (see also comments in TProfile::GetBinError); 744 ; 745Double_t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750/////////////////////////",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:25334,Availability,error,errors,25334,"/////////////////////////////; 713/// Return bin effective entries for a weighted filled Profile histogram.; 714///; 715/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation.; 743/// (see also comments in TProfile::GetBinError); 744 ; 745Double_t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750////////////////////////////////////////////////////////////////////////////////; 751/// Return option to compute profile2D errors.; 752 ;",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:25504,Availability,error,errors,25504,"rofile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation.; 743/// (see also comments in TProfile::GetBinError); 744 ; 745Double_t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750////////////////////////////////////////////////////////////////////////////////; 751/// Return option to compute profile2D errors.; 752 ; 753Option_t *TProfile3D::GetErrorOption() const; 754{; 755 if (fErrorMode == kERRORSPREAD) return ""s"";; 756 if (fErrorMode == kERRORSPREADI) return ""i",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:26322,Availability,error,errors,26322," Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation.; 743/// (see also comments in TProfile::GetBinError); 744 ; 745Double_t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750////////////////////////////////////////////////////////////////////////////////; 751/// Return option to compute profile2D errors.; 752 ; 753Option_t *TProfile3D::GetErrorOption() const; 754{; 755 if (fErrorMode == kERRORSPREAD) return ""s"";; 756 if (fErrorMode == kERRORSPREADI) return ""i"";; 757 if (fErrorMode == kERRORSPREADG) return ""g"";; 758 return """";; 759}; 760 ; 761////////////////////////////////////////////////////////////////////////////////; 762/// fill the array stats from the contents of this profile.; 763///; 764/// The array stats must be correctly dimensioned in the calling program.; 765///; 766/// - stats[0] = sumw; 767/// - stats[1] = sumw2; 768/// - stats[2] = sumwx; 769/// - stats[3] = sumwx2; 770/// - stats[4] = sumwy; 771/// - stats[5] = sumwy2; 772/// - stats[6] = sumwxy; 773/// - stats[7] = sumwz; 774/// - stats[8] = sumwz2; 775/// - stats[9] = sumwxz; 776/// - stats[10]= sumwyz; 777/// - stats[11]= sumwt; 778/// - stats[12]= su",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:30605,Availability,down,down,30605,"r this axis to the number of bins having a label.; 846 ; 847void TProfile3D::LabelsDeflate(Option_t *ax); 848{; 849 TProfileHelper::LabelsDeflate(this, ax);; 850}; 851 ; 852////////////////////////////////////////////////////////////////////////////////; 853/// Double the number of bins for axis.; 854/// Refill histogram; 855/// This function is called by TAxis::FindBin(const char *label); 856 ; 857void TProfile3D::LabelsInflate(Option_t *ax); 858{; 859 TProfileHelper::LabelsInflate(this, ax);; 860}; 861 ; 862////////////////////////////////////////////////////////////////////////////////; 863/// Set option(s) to draw axis with labels.; 864///; 865/// option might have the following values:; 866///; 867/// - ""a"" sort by alphabetic order; 868/// - "">"" sort by decreasing values; 869/// - ""<"" sort by increasing values; 870/// - ""h"" draw labels horizontal; 871/// - ""v"" draw labels vertical; 872/// - ""u"" draw labels up (end of label right adjusted); 873/// - ""d"" draw labels down (start of label left adjusted); 874 ; 875void TProfile3D::LabelsOption(Option_t * /* option */, Option_t * /* ax */); 876{; 877 Error(""LabelsOption"",""Labels option function is not implemented for a TProfile3D"");; 878}; 879////////////////////////////////////////////////////////////////////////////////; 880/// Merge all histograms in the collection in this histogram.; 881///; 882/// This function computes the min/max for the axes,; 883/// compute a new number of bins, if necessary,; 884/// add bin contents, errors and statistics.; 885/// If overflows are present and limits are different the function will fail.; 886/// The function returns the total number of entries in the result histogram; 887/// if the merge is successful, -1 otherwise.; 888///; 889/// IMPORTANT remark. The 2 axis x and y may have different number; 890/// of bins and different limits, BUT the largest bin width must be; 891/// a multiple of the smallest bin width and the upper limit must also; 892/// be a multiple of the bin widt",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:31122,Availability,error,errors,31122,"t *ax); 858{; 859 TProfileHelper::LabelsInflate(this, ax);; 860}; 861 ; 862////////////////////////////////////////////////////////////////////////////////; 863/// Set option(s) to draw axis with labels.; 864///; 865/// option might have the following values:; 866///; 867/// - ""a"" sort by alphabetic order; 868/// - "">"" sort by decreasing values; 869/// - ""<"" sort by increasing values; 870/// - ""h"" draw labels horizontal; 871/// - ""v"" draw labels vertical; 872/// - ""u"" draw labels up (end of label right adjusted); 873/// - ""d"" draw labels down (start of label left adjusted); 874 ; 875void TProfile3D::LabelsOption(Option_t * /* option */, Option_t * /* ax */); 876{; 877 Error(""LabelsOption"",""Labels option function is not implemented for a TProfile3D"");; 878}; 879////////////////////////////////////////////////////////////////////////////////; 880/// Merge all histograms in the collection in this histogram.; 881///; 882/// This function computes the min/max for the axes,; 883/// compute a new number of bins, if necessary,; 884/// add bin contents, errors and statistics.; 885/// If overflows are present and limits are different the function will fail.; 886/// The function returns the total number of entries in the result histogram; 887/// if the merge is successful, -1 otherwise.; 888///; 889/// IMPORTANT remark. The 2 axis x and y may have different number; 890/// of bins and different limits, BUT the largest bin width must be; 891/// a multiple of the smallest bin width and the upper limit must also; 892/// be a multiple of the bin width.; 893 ; 894Long64_t TProfile3D::Merge(TCollection *li); 895{; 896 return TProfileHelper::Merge(this, li);; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Performs the operation: `this = this*c1*f1` .; 901 ; 902Bool_t TProfile3D::Multiply(TF1 *, Double_t ); 903{; 904 Error(""Multiply"",""Function not implemented for TProfile3D"");; 905 return kFALSE;; 906}; 907 ; 908/////////////////",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:33041,Availability,error,errors,33041,"E;; 906}; 907 ; 908////////////////////////////////////////////////////////////////////////////////; 909/// Multiply this profile2D by h1.; 910///; 911/// `this = this*h1`; 912 ; 913Bool_t TProfile3D::Multiply(const TH1 *); 914{; 915 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 916 return kFALSE;; 917}; 918 ; 919////////////////////////////////////////////////////////////////////////////////; 920/// Replace contents of this profile2D by multiplication of h1 by h2.; 921///; 922/// `this = (c1*h1)*(c2*h2)`; 923 ; 924Bool_t TProfile3D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 925{; 926 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 927 return kFALSE;; 928}; 929 ; 930////////////////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of t",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:33307,Availability,error,errors,33307,"ultiply"",""Multiplication of profile2D histograms not implemented"");; 916 return kFALSE;; 917}; 918 ; 919////////////////////////////////////////////////////////////////////////////////; 920/// Replace contents of this profile2D by multiplication of h1 by h2.; 921///; 922/// `this = (c1*h1)*(c2*h2)`; 923 ; 924Bool_t TProfile3D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 925{; 926 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 927 return kFALSE;; 928}; 929 ; 930////////////////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled wi",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:33370,Availability,error,errors,33370,"ultiply"",""Multiplication of profile2D histograms not implemented"");; 916 return kFALSE;; 917}; 918 ; 919////////////////////////////////////////////////////////////////////////////////; 920/// Replace contents of this profile2D by multiplication of h1 by h2.; 921///; 922/// `this = (c1*h1)*(c2*h2)`; 923 ; 924Bool_t TProfile3D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 925{; 926 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 927 return kFALSE;; 928}; 929 ; 930////////////////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled wi",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:33452,Availability,error,errors,33452,"ultiply"",""Multiplication of profile2D histograms not implemented"");; 916 return kFALSE;; 917}; 918 ; 919////////////////////////////////////////////////////////////////////////////////; 920/// Replace contents of this profile2D by multiplication of h1 by h2.; 921///; 922/// `this = (c1*h1)*(c2*h2)`; 923 ; 924Bool_t TProfile3D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 925{; 926 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 927 return kFALSE;; 928}; 929 ; 930////////////////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled wi",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:33594,Availability,error,errors,33594,"////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled with all weights =1.; 953/// When the profile is weighted (filled with weights different than 1) the; 954/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 955/// correctly computed from the information stored in the profile. In that case the; 956/// obtained histogram contains as bin error square the weighted sum of the square of the; 957/// profiled observable (TProfile2D::fSumw2[bin] ); 958///; 959/// Note that the axis range is not considered when doing the projection; 960 ; 961TH3D *TProf",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:33871,Availability,error,errors,33871,"////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled with all weights =1.; 953/// When the profile is weighted (filled with weights different than 1) the; 954/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 955/// correctly computed from the information stored in the profile. In that case the; 956/// obtained histogram contains as bin error square the weighted sum of the square of the; 957/// profiled observable (TProfile2D::fSumw2[bin] ); 958///; 959/// Note that the axis range is not considered when doing the projection; 960 ; 961TH3D *TProf",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:34379,Availability,error,error,34379,"re computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled with all weights =1.; 953/// When the profile is weighted (filled with weights different than 1) the; 954/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 955/// correctly computed from the information stored in the profile. In that case the; 956/// obtained histogram contains as bin error square the weighted sum of the square of the; 957/// profiled observable (TProfile2D::fSumw2[bin] ); 958///; 959/// Note that the axis range is not considered when doing the projection; 960 ; 961TH3D *TProfile3D::ProjectionXYZ(const char *name, Option_t *option) const; 962{; 963 ; 964 TString opt = option;; 965 opt.ToLower();; 966 Int_t nx = fXaxis.GetNbins();; 967 Int_t ny = fYaxis.GetNbins();; 968 Int_t nz = fZaxis.GetNbins();; 969 const TArrayD *xbins = fXaxis.GetXbins();; 970 const TArrayD *ybins = fYaxis.GetXbins();; 971 const TArrayD *zbins = fZaxis.GetXbins();; 972 ; 973 // Create the projection histogram; 974 TString pname = name;; 975 if (pname == ""_px"") {; 976 pname = GetName(); pname.Append(""_pxyz"");; 977 }; 978 TH3D *h1 = nullptr ;; 979 if (xbins->fN == 0 && ybins->fN == 0 && zbins->fN == 0)",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:34586,Availability,error,error,34586,"m; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled with all weights =1.; 953/// When the profile is weighted (filled with weights different than 1) the; 954/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 955/// correctly computed from the information stored in the profile. In that case the; 956/// obtained histogram contains as bin error square the weighted sum of the square of the; 957/// profiled observable (TProfile2D::fSumw2[bin] ); 958///; 959/// Note that the axis range is not considered when doing the projection; 960 ; 961TH3D *TProfile3D::ProjectionXYZ(const char *name, Option_t *option) const; 962{; 963 ; 964 TString opt = option;; 965 opt.ToLower();; 966 Int_t nx = fXaxis.GetNbins();; 967 Int_t ny = fYaxis.GetNbins();; 968 Int_t nz = fZaxis.GetNbins();; 969 const TArrayD *xbins = fXaxis.GetXbins();; 970 const TArrayD *ybins = fYaxis.GetXbins();; 971 const TArrayD *zbins = fZaxis.GetXbins();; 972 ; 973 // Create the projection histogram; 974 TString pname = name;; 975 if (pname == ""_px"") {; 976 pname = GetName(); pname.Append(""_pxyz"");; 977 }; 978 TH3D *h1 = nullptr ;; 979 if (xbins->fN == 0 && ybins->fN == 0 && zbins->fN == 0); 980 h1 = new TH3D(pname,GetTitle(),nx,fXaxis.GetXmin(),fXaxis.GetXmax(),ny,fYaxis.GetXmin(),fYaxis.GetXmax(),nz,fZaxis.GetXmin(),fZaxis.GetXmax());; 981 else if ( xbins->fN != 0 && ybins->fN != 0 && zbins->fN != 0); 982 h1 = new TH3D(pname,GetTitle(),nx,xbins->GetArray(),ny,ybins->GetArray(), nz,zbins->GetAr",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:36959,Availability,error,errors,36959,"d an axis with fixed bins. This case is not supported - return a null pointer"");; 985 return nullptr;; 986 }; 987 ; 988 ; 989 Bool_t computeErrors = kFALSE;; 990 Bool_t cequalErrors = kFALSE;; 991 Bool_t binEntries = kFALSE;; 992 Bool_t binWeight = kFALSE;; 993 ; 994 if (opt.Contains(""b"")) binEntries = kTRUE;; 995 if (opt.Contains(""e"")) computeErrors = kTRUE;; 996 if (opt.Contains(""w"")) binWeight = kTRUE;; 997 if (opt.Contains(""c=e"")) {cequalErrors = kTRUE; computeErrors=kFALSE;}; 998 if (computeErrors || binWeight || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 999 ; 1000 // Fill the projected histogram; 1001 Int_t bin,binx,biny,binz;; 1002 Double_t cont;; 1003 for (binx =0;binx<=nx+1;binx++) {; 1004 for (biny =0;biny<=ny+1;biny++) {; 1005 for (binz =0;binz<=nz+1;binz++) {; 1006 bin = GetBin(binx,biny,binz);; 1007 ; 1008 if (binEntries) cont = GetBinEntries(bin);; 1009 else if (cequalErrors) cont = GetBinError(bin);; 1010 else if (binWeight) cont = GetBinContent(bin) * GetBinEntries(bin);; 1011 else cont = GetBinContent(bin); // default case; 1012 ; 1013 h1->SetBinContent(bin ,cont);; 1014 ; 1015 // if option E projected histogram errors are same as profile; 1016 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1017 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1018 // this is correct only if the profile is unweighted; 1019 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1020 // in case of bin entries and profile is weighted, we need to set also the bin error; 1021 if (binEntries && fBinSumw2.fN ) {; 1022 R__ASSERT( h1->GetSumw2() );; 1023 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1024 }; 1025 }; 1026 }; 1027 }; 1028 h1->SetEntries(fEntries);; 1029 return h1;; 1030}; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Project a 3-D profile into a 2D-profile histogram depending on the option parameter.; 1033///; 1034/// option may contain a com",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:37087,Availability,error,error,37087,"d an axis with fixed bins. This case is not supported - return a null pointer"");; 985 return nullptr;; 986 }; 987 ; 988 ; 989 Bool_t computeErrors = kFALSE;; 990 Bool_t cequalErrors = kFALSE;; 991 Bool_t binEntries = kFALSE;; 992 Bool_t binWeight = kFALSE;; 993 ; 994 if (opt.Contains(""b"")) binEntries = kTRUE;; 995 if (opt.Contains(""e"")) computeErrors = kTRUE;; 996 if (opt.Contains(""w"")) binWeight = kTRUE;; 997 if (opt.Contains(""c=e"")) {cequalErrors = kTRUE; computeErrors=kFALSE;}; 998 if (computeErrors || binWeight || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 999 ; 1000 // Fill the projected histogram; 1001 Int_t bin,binx,biny,binz;; 1002 Double_t cont;; 1003 for (binx =0;binx<=nx+1;binx++) {; 1004 for (biny =0;biny<=ny+1;biny++) {; 1005 for (binz =0;binz<=nz+1;binz++) {; 1006 bin = GetBin(binx,biny,binz);; 1007 ; 1008 if (binEntries) cont = GetBinEntries(bin);; 1009 else if (cequalErrors) cont = GetBinError(bin);; 1010 else if (binWeight) cont = GetBinContent(bin) * GetBinEntries(bin);; 1011 else cont = GetBinContent(bin); // default case; 1012 ; 1013 h1->SetBinContent(bin ,cont);; 1014 ; 1015 // if option E projected histogram errors are same as profile; 1016 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1017 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1018 // this is correct only if the profile is unweighted; 1019 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1020 // in case of bin entries and profile is weighted, we need to set also the bin error; 1021 if (binEntries && fBinSumw2.fN ) {; 1022 R__ASSERT( h1->GetSumw2() );; 1023 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1024 }; 1025 }; 1026 }; 1027 }; 1028 h1->SetEntries(fEntries);; 1029 return h1;; 1030}; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Project a 3-D profile into a 2D-profile histogram depending on the option parameter.; 1033///; 1034/// option may contain a com",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:37358,Availability,error,error,37358," || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 999 ; 1000 // Fill the projected histogram; 1001 Int_t bin,binx,biny,binz;; 1002 Double_t cont;; 1003 for (binx =0;binx<=nx+1;binx++) {; 1004 for (biny =0;biny<=ny+1;biny++) {; 1005 for (binz =0;binz<=nz+1;binz++) {; 1006 bin = GetBin(binx,biny,binz);; 1007 ; 1008 if (binEntries) cont = GetBinEntries(bin);; 1009 else if (cequalErrors) cont = GetBinError(bin);; 1010 else if (binWeight) cont = GetBinContent(bin) * GetBinEntries(bin);; 1011 else cont = GetBinContent(bin); // default case; 1012 ; 1013 h1->SetBinContent(bin ,cont);; 1014 ; 1015 // if option E projected histogram errors are same as profile; 1016 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1017 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1018 // this is correct only if the profile is unweighted; 1019 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1020 // in case of bin entries and profile is weighted, we need to set also the bin error; 1021 if (binEntries && fBinSumw2.fN ) {; 1022 R__ASSERT( h1->GetSumw2() );; 1023 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1024 }; 1025 }; 1026 }; 1027 }; 1028 h1->SetEntries(fEntries);; 1029 return h1;; 1030}; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Project a 3-D profile into a 2D-profile histogram depending on the option parameter.; 1033///; 1034/// option may contain a combination of the characters x,y,z:; 1035///; 1036/// - option = ""xy"" return the x versus y projection into a TProfile2D histogram; 1037/// - option = ""yx"" return the y versus x projection into a TProfile2D histogram; 1038/// - option = ""xz"" return the x versus z projection into a TProfile2D histogram; 1039/// - option = ""zx"" return the z versus x projection into a TProfile2D histogram; 1040/// - option = ""yz"" return the y versus z projection into a TProfile2D histogram; 1041/// - option = ""zy"" return the z versus y ",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:38717,Availability,error,error,38717,"in] = fSumw2.fArray[bin];; 1020 // in case of bin entries and profile is weighted, we need to set also the bin error; 1021 if (binEntries && fBinSumw2.fN ) {; 1022 R__ASSERT( h1->GetSumw2() );; 1023 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1024 }; 1025 }; 1026 }; 1027 }; 1028 h1->SetEntries(fEntries);; 1029 return h1;; 1030}; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Project a 3-D profile into a 2D-profile histogram depending on the option parameter.; 1033///; 1034/// option may contain a combination of the characters x,y,z:; 1035///; 1036/// - option = ""xy"" return the x versus y projection into a TProfile2D histogram; 1037/// - option = ""yx"" return the y versus x projection into a TProfile2D histogram; 1038/// - option = ""xz"" return the x versus z projection into a TProfile2D histogram; 1039/// - option = ""zx"" return the z versus x projection into a TProfile2D histogram; 1040/// - option = ""yz"" return the y versus z projection into a TProfile2D histogram; 1041/// - option = ""zy"" return the z versus y projection into a TProfile2D histogram; 1042///; 1043/// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal along X; 1044///; 1045/// The resulting profile contains the combination of all the considered bins along X; 1046/// By default, all bins are included considering also underflow/overflows; 1047///; 1048/// The option can also be used to specify the projected profile error type.; 1049/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 1050///; 1051/// To select a bin range along an axis, use TAxis::SetRange, eg; 1052/// `h3.GetYaxis()->SetRange(23,56);`; 1053 ; 1054TProfile2D *TProfile3D::Project3DProfile(Option_t *option) const; 1055{; 1056 // can call TH3 method which will call the virtual method :DoProjectProfile2D re-implemented below; 1057 // but need to add underflow/overflow; 1058 TString opt(option);; 1059 opt.Append("" UF OF"");; 1060 return ",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:42525,Availability,error,error,42525,,MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:44169,Availability,error,errors,44169,"6 if (projX == GetZaxis() ) { projX_hW = h3dW->GetZaxis(); projX_hN = h3dN->GetZaxis(); }; 1137 TAxis * projY_hW = h3dW->GetYaxis();; 1138 TAxis * projY_hN = h3dN->GetYaxis();; 1139 if (projY == GetXaxis() ) { projY_hW = h3dW->GetXaxis(); projY_hN = h3dN->GetXaxis(); }; 1140 if (projY == GetZaxis() ) { projY_hW = h3dW->GetZaxis(); projY_hN = h3dN->GetZaxis(); }; 1141 ; 1142 TH2D * h2W = TH3::DoProject2D(*h3dW,""htemp-W"","""",projX_hW, projY_hW, true, originalRange, useUF, useOF);; 1143 TH2D * h2N = TH3::DoProject2D(*h3dN,""htemp-N"","""",projX_hN, projY_hN, useWeights, originalRange, useUF, useOF);; 1144 h2W->SetDirectory(nullptr); h2N->SetDirectory(nullptr);; 1145 ; 1146 ; 1147 // fill the bin content; 1148 R__ASSERT( h2W->fN == p2->fN );; 1149 R__ASSERT( h2N->fN == p2->fN );; 1150 R__ASSERT( h2W->GetSumw2()->fN != 0); // h2W should always be a weighted histogram since h3dW is weighted; 1151 for (int i = 0; i < p2->fN ; ++i) {; 1152 //std::cout << "" proj bin "" << i << "" "" << h2W->fArray[i] << "" "" << h2N->fArray[i] << std::endl;; 1153 p2->fArray[i] = h2W->fArray[i]; // array of profile is sum of all values; 1154 p2->GetSumw2()->fArray[i] = h2W->GetSumw2()->fArray[i]; // array of content square of profile is weight square of the W projected histogram; 1155 p2->SetBinEntries(i, h2N->fArray[i] );; 1156 if (useWeights) p2->GetBinSumw2()->fArray[i] = h2N->GetSumw2()->fArray[i]; // sum of weight squares are stored to compute errors in h1N histogram; 1157 }; 1158 // delete the created histograms; 1159 delete h3dW;; 1160 delete h3dN;; 1161 delete h2W;; 1162 delete h2N;; 1163 ; 1164 // Also we need to set the entries since they have not been correctly calculated during the projection; 1165 // we can only set them to the effective entries; 1166 p2->SetEntries( p2->GetEffectiveEntries() );; 1167 ; 1168 return p2;; 1169 ; 1170}; 1171 ; 1172////////////////////////////////////////////////////////////////////////////////; 1173/// Replace current statistics with the values in array stats.",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:45809,Availability,error,errors,45809,"3::PutStats(stats);; 1178 fTsumwt = stats[11];; 1179 fTsumwt2 = stats[12];; 1180}; 1181 ; 1182////////////////////////////////////////////////////////////////////////////////; 1183/// Reset contents of a Profile3D histogram.; 1184 ; 1185void TProfile3D::Reset(Option_t *option); 1186{; 1187 TH3D::Reset(option);; 1188 fBinSumw2.Reset();; 1189 fBinEntries.Reset();; 1190 TString opt = option;; 1191 opt.ToUpper();; 1192 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1193 fTsumwt = fTsumwt2 = 0;; 1194}; 1195 ; 1196////////////////////////////////////////////////////////////////////////////////; 1197/// Profile histogram is resized along axis such that x is in the axis range.; 1198/// The new axis limits are recomputed by doubling iteratively; 1199/// the current axis range until the specified value x is within the limits.; 1200/// The algorithm makes a copy of the histogram, then loops on all bins; 1201/// of the old histogram to fill the rebinned histogram.; 1202/// Takes into account errors (Sumw2) if any.; 1203/// The axis must be rebinnable before invoking this function.; 1204/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1205 ; 1206void TProfile3D::ExtendAxis(Double_t x, TAxis *axis); 1207{; 1208 TProfile3D* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1209 if ( hold ) {; 1210 fTsumwt = hold->fTsumwt;; 1211 fTsumwt2 = hold->fTsumwt2;; 1212 delete hold;; 1213 }; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Save primitive as a C++ statement(s) on output stream out.; 1218///; 1219/// Note the following restrictions in the code generated:; 1220/// - variable bin size not implemented; 1221/// - SetErrorOption not implemented; 1222 ; 1223void TProfile3D::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1224{; 1225 char quote = '""';; 1226 out <<"" ""<<std::endl;; 1227 out <<"" ""<<ClassName()<<"" *"";; 1228 ; 1229 out << GetName() << "" = new "" << ClassName() << ""("" << quote; 1230 << GetName() ",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:47775,Availability,error,errors,47775,"axis);; 1209 if ( hold ) {; 1210 fTsumwt = hold->fTsumwt;; 1211 fTsumwt2 = hold->fTsumwt2;; 1212 delete hold;; 1213 }; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Save primitive as a C++ statement(s) on output stream out.; 1218///; 1219/// Note the following restrictions in the code generated:; 1220/// - variable bin size not implemented; 1221/// - SetErrorOption not implemented; 1222 ; 1223void TProfile3D::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1224{; 1225 char quote = '""';; 1226 out <<"" ""<<std::endl;; 1227 out <<"" ""<<ClassName()<<"" *"";; 1228 ; 1229 out << GetName() << "" = new "" << ClassName() << ""("" << quote; 1230 << GetName() << quote << "","" << quote<< GetTitle() << quote; 1231 << "","" << GetXaxis()->GetNbins();; 1232 out << "","" << GetXaxis()->GetXmin(); 1233 << "","" << GetXaxis()->GetXmax();; 1234 out << "","" << GetYaxis()->GetNbins();; 1235 out << "","" << GetYaxis()->GetXmin(); 1236 << "","" << GetYaxis()->GetXmax();; 1237 out << "","" << GetZaxis()->GetNbins();; 1238 out << "","" << GetZaxis()->GetXmin(); 1239 << "","" << GetZaxis()->GetXmax();; 1240 out << "","" << fTmin; 1241 << "","" << fTmax;; 1242 out << "");"" << std::endl;; 1243 ; 1244 ; 1245 // save bin entries; 1246 Int_t bin;; 1247 for (bin=0;bin<fNcells;bin++) {; 1248 Double_t bi = GetBinEntries(bin);; 1249 if (bi) {; 1250 out<<"" ""<<GetName()<<""->SetBinEntries(""<<bin<<"",""<<bi<<"");""<<std::endl;; 1251 }; 1252 }; 1253 //save bin contents; 1254 for (bin=0;bin<fNcells;bin++) {; 1255 Double_t bc = fArray[bin];; 1256 if (bc) {; 1257 out<<"" ""<<GetName()<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1258 }; 1259 }; 1260 // save bin errors; 1261 if (fSumw2.fN) {; 1262 for (bin=0;bin<fNcells;bin++) {; 1263 Double_t be = TMath::Sqrt(fSumw2.fArray[bin]);; 1264 if (be) {; 1265 out<<"" ""<<GetName()<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 1266 }; 1267 }; 1268 }; 1269 ; 1270 TH1::SavePrimitiveHelp(out, GetName(), option);; 1271}; 127",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:50680,Availability,error,errors,50680,"ble_t *xBins, Int_t ny, const Double_t *yBins, Int_t nz, const Double_t *zBins); 1307{; 1308 TH1::SetBins(nx,xBins,ny,yBins,nz,zBins);; 1309 fBinEntries.Set(fNcells);; 1310 if (fBinSumw2.fN) fBinSumw2.Set(fNcells);; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// Set total number of bins including under/overflow.; 1315///; 1316/// Reallocate bin contents array; 1317 ; 1318void TProfile3D::SetBinsLength(Int_t n); 1319{; 1320 TH3D::SetBinsLength(n);; 1321 TProfileHelper::BuildArray(this);; 1322}; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Set the buffer size in units of 8 bytes (double).; 1326 ; 1327void TProfile3D::SetBuffer(Int_t buffersize, Option_t *); 1328{; 1329 if (fBuffer) {; 1330 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 1337 }; 1338 if (buffersize < 100) buffersize = 100;; 1339 fBufferSize = 1 + 5*buffersize;; 1340 fBuffer = new Double_t[fBufferSize];; 1341 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:50733,Availability,error,errors,50733," Reallocate bin contents array; 1317 ; 1318void TProfile3D::SetBinsLength(Int_t n); 1319{; 1320 TH3D::SetBinsLength(n);; 1321 TProfileHelper::BuildArray(this);; 1322}; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Set the buffer size in units of 8 bytes (double).; 1326 ; 1327void TProfile3D::SetBuffer(Int_t buffersize, Option_t *); 1328{; 1329 if (fBuffer) {; 1330 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 1337 }; 1338 if (buffersize < 100) buffersize = 100;; 1339 fBufferSize = 1 + 5*buffersize;; 1340 fBuffer = new Double_t[fBufferSize];; 1341 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values ",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:50807,Availability,error,errors,50807," Reallocate bin contents array; 1317 ; 1318void TProfile3D::SetBinsLength(Int_t n); 1319{; 1320 TH3D::SetBinsLength(n);; 1321 TProfileHelper::BuildArray(this);; 1322}; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Set the buffer size in units of 8 bytes (double).; 1326 ; 1327void TProfile3D::SetBuffer(Int_t buffersize, Option_t *); 1328{; 1329 if (fBuffer) {; 1330 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 1337 }; 1338 if (buffersize < 100) buffersize = 100;; 1339 fBufferSize = 1 + 5*buffersize;; 1340 fBuffer = new Double_t[fBufferSize];; 1341 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values ",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:50831,Availability,error,error,50831," Reallocate bin contents array; 1317 ; 1318void TProfile3D::SetBinsLength(Int_t n); 1319{; 1320 TH3D::SetBinsLength(n);; 1321 TProfileHelper::BuildArray(this);; 1322}; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Set the buffer size in units of 8 bytes (double).; 1326 ; 1327void TProfile3D::SetBuffer(Int_t buffersize, Option_t *); 1328{; 1329 if (fBuffer) {; 1330 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 1337 }; 1338 if (buffersize < 100) buffersize = 100;; 1339 fBufferSize = 1 + 5*buffersize;; 1340 fBuffer = new Double_t[fBufferSize];; 1341 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values ",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:50908,Availability,error,error,50908," TProfileHelper::BuildArray(this);; 1322}; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Set the buffer size in units of 8 bytes (double).; 1326 ; 1327void TProfile3D::SetBuffer(Int_t buffersize, Option_t *); 1328{; 1329 if (fBuffer) {; 1330 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 1337 }; 1338 if (buffersize < 100) buffersize = 100;; 1339 fBufferSize = 1 + 5*buffersize;; 1340 fBuffer = new Double_t[fBufferSize];; 1341 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values t and weights w = 1/dt**2; 1362///; 1363/// See TProfile::BuildOptions for explanation of all options; 1364 ; 1365void TProf",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:51114,Availability,error,errors,51114,"30 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 1337 }; 1338 if (buffersize < 100) buffersize = 100;; 1339 fBufferSize = 1 + 5*buffersize;; 1340 fBuffer = new Double_t[fBufferSize];; 1341 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values t and weights w = 1/dt**2; 1362///; 1363/// See TProfile::BuildOptions for explanation of all options; 1364 ; 1365void TProfile3D::SetErrorOption(Option_t *option); 1366{; 1367 TProfileHelper::SetErrorOption(this, option);; 1368}; 1369 ; 1370////////////////////////////////////////////////////////////////////////////////; 1371/// Create/Delete structure to store sum of squares of weights per bin; 1372/// This is ne",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:51380,Availability,error,errors,51380,"30 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 1337 }; 1338 if (buffersize < 100) buffersize = 100;; 1339 fBufferSize = 1 + 5*buffersize;; 1340 fBuffer = new Double_t[fBufferSize];; 1341 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values t and weights w = 1/dt**2; 1362///; 1363/// See TProfile::BuildOptions for explanation of all options; 1364 ; 1365void TProfile3D::SetErrorOption(Option_t *option); 1366{; 1367 TProfileHelper::SetErrorOption(this, option);; 1368}; 1369 ; 1370////////////////////////////////////////////////////////////////////////////////; 1371/// Create/Delete structure to store sum of squares of weights per bin; 1372/// This is ne",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:51519,Availability,error,error,51519,"0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values t and weights w = 1/dt**2; 1362///; 1363/// See TProfile::BuildOptions for explanation of all options; 1364 ; 1365void TProfile3D::SetErrorOption(Option_t *option); 1366{; 1367 TProfileHelper::SetErrorOption(this, option);; 1368}; 1369 ; 1370////////////////////////////////////////////////////////////////////////////////; 1371/// Create/Delete structure to store sum of squares of weights per bin; 1372/// This is needed to compute the correct statistical quantities; 1373/// of a profile filled with weights; 1374///; 1375/// This function is automatically called when the histogram is created; 1376/// if the static function TH1::SetDefaultSumw2 has been called before.; 1377/// If flag = false the structure is ",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:53120,Availability,error,error,53120,"//////////////////; 1371/// Create/Delete structure to store sum of squares of weights per bin; 1372/// This is needed to compute the correct statistical quantities; 1373/// of a profile filled with weights; 1374///; 1375/// This function is automatically called when the histogram is created; 1376/// if the static function TH1::SetDefaultSumw2 has been called before.; 1377/// If flag = false the structure is deleted; 1378 ; 1379void TProfile3D::Sumw2(Bool_t flag); 1380{; 1381 TProfileHelper::Sumw2(this, flag);; 1382}; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfile3D.h; TProfileHelper.h; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefi",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:53255,Availability,error,error,53255," quantities; 1373/// of a profile filled with weights; 1374///; 1375/// This function is automatically called when the histogram is created; 1376/// if the static function TH1::SetDefaultSumw2 has been called before.; 1377/// If flag = false the structure is deleted; 1378 ; 1379void TProfile3D::Sumw2(Bool_t flag); 1380{; 1381 TProfileHelper::Sumw2(this, flag);; 1382}; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfile3D.h; TProfileHelper.h; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArray",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:53527,Availability,error,error,53527,"ed; 1378 ; 1379void TProfile3D::Sumw2(Bool_t flag); 1380{; 1381 TProfileHelper::Sumw2(this, flag);; 1382}; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfile3D.h; TProfileHelper.h; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Copyvoid Copy(TArrayD &array) constDefinition TArrayD.h:42; TArrayD::Setvoid Set(Int_t n) overrideSet size of this array to n doubles.Definition TArrayD.cxx:106; TArrayD::TArrayDTArrayD()Default TArrayD ",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:57536,Availability,error,error,57536,"Zaxis()Definition TH1.h:326; TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::fXaxisTAxis fX",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:62246,Availability,error,error,62246,"n pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile2D.cxx:1918; TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile2D.h:121; TProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,...Definition TProfile3D.h:27; TProfile3D::operator=TProfile3D & operator=(const TProfile3D &profile)Definition TProfile3D.cxx:162; TProfile3D::DoProjectProfile2DTProfile2D * DoProjectProfile2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) const overrideInternal method to project to a 2D Profile.Definition TProfile3D.cxx:1069; TProfile3D::GetWDouble_t * GetW(",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:63448,Availability,error,error,63448,"D.cxx:1918; TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile2D.h:121; TProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,...Definition TProfile3D.h:27; TProfile3D::operator=TProfile3D & operator=(const TProfile3D &profile)Definition TProfile3D.cxx:162; TProfile3D::DoProjectProfile2DTProfile2D * DoProjectProfile2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) const overrideInternal method to project to a 2D Profile.Definition TProfile3D.cxx:1069; TProfile3D::GetWDouble_t * GetW()Definition TProfile3D.h:75; TProfile3D::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile3D.cxx:894; TProfile3D::fgApproximatestatic Bool_t fgApproximateBin error approximation option.Definition TProfile3D.h:42; TProfile3D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile3D.cxx:753; TProfile3D::fScalingBool_t fScaling! True when TProfile3D::Scale is calledDefinition TProfile3D.h:38; TProfile3D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile3D.h:50; TProfile3D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile3D.cxx:1175; TProfile3D::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile3D histogram to a new profile2D histogram.Definition TProfile3D.cxx:350; TProfile3D::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile3D.h:44; TProfile3D::fTsumwt2Double_t fTsumwt2Total Sum of weight*T*T.Definition TProfile3D.h:40; TProfile3D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:63597,Availability,error,errors,63597,"ghts per bin.Definition TProfile2D.cxx:2043; TProfile2D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile2D.h:121; TProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,...Definition TProfile3D.h:27; TProfile3D::operator=TProfile3D & operator=(const TProfile3D &profile)Definition TProfile3D.cxx:162; TProfile3D::DoProjectProfile2DTProfile2D * DoProjectProfile2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) const overrideInternal method to project to a 2D Profile.Definition TProfile3D.cxx:1069; TProfile3D::GetWDouble_t * GetW()Definition TProfile3D.h:75; TProfile3D::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile3D.cxx:894; TProfile3D::fgApproximatestatic Bool_t fgApproximateBin error approximation option.Definition TProfile3D.h:42; TProfile3D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile3D.cxx:753; TProfile3D::fScalingBool_t fScaling! True when TProfile3D::Scale is calledDefinition TProfile3D.h:38; TProfile3D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile3D.h:50; TProfile3D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile3D.cxx:1175; TProfile3D::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile3D histogram to a new profile2D histogram.Definition TProfile3D.cxx:350; TProfile3D::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile3D.h:44; TProfile3D::fTsumwt2Double_t fTsumwt2Total Sum of weight*T*T.Definition TProfile3D.h:40; TProfile3D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)Return bin effective entries for a weighted filled Profile histogram.Definition TProfile3D.cxx:721; TProfile3D::GetStatsvo",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:67614,Availability,error,errors,67614,"3D.cxx:1288; TProfile3D::BuildOptionsvoid BuildOptions(Double_t tmin, Double_t tmax, Option_t *option)Set Profile3D histogram structure and options.Definition TProfile3D.cxx:141; TProfile3D::Classstatic TClass * Class(); TProfile3D::FillInt_t Fill(const Double_t *v)Definition TProfile3D.h:53; TProfile3D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile3D.h:41; TProfile3D::GetBDouble_t * GetB()Definition TProfile3D.h:73; TProfile3D::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TProfile3D.cxx:246; TProfile3D::SetBuffervoid SetBuffer(Int_t buffersize, Option_t *opt="""") overrideSet the buffer size in units of 8 bytes (double).Definition TProfile3D.cxx:1327; TProfile3D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile3D.cxx:1223; TProfile3D::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile3D errors.Definition TProfile3D.cxx:1365; TProfile3D::ProjectionXYZvirtual TH3D * ProjectionXYZ(const char *name=""_pxyz"", Option_t *option=""e"") constProject this profile3D into a 3-D histogram along X,Y,Z.Definition TProfile3D.cxx:961; TProfile3D::AddBool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""") overridePerforms the operation: this = this + c1*f1 .Definition TProfile3D.cxx:172; TProfile3D::GetBinContentDouble_t GetBinContent(Int_t bin) const overrideReturn bin content of a Profile3D histogram.Definition TProfile3D.cxx:691; TProfile3D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile3D.h:35; TProfile3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile3D.cxx:1318; TProfile3D::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile3D histogram.Definition TProfile3D.cxx:704; TProfile3D::GetW2Doub",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:68211,Availability,error,errors,68211,"tBuffervoid SetBuffer(Int_t buffersize, Option_t *opt="""") overrideSet the buffer size in units of 8 bytes (double).Definition TProfile3D.cxx:1327; TProfile3D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile3D.cxx:1223; TProfile3D::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile3D errors.Definition TProfile3D.cxx:1365; TProfile3D::ProjectionXYZvirtual TH3D * ProjectionXYZ(const char *name=""_pxyz"", Option_t *option=""e"") constProject this profile3D into a 3-D histogram along X,Y,Z.Definition TProfile3D.cxx:961; TProfile3D::AddBool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""") overridePerforms the operation: this = this + c1*f1 .Definition TProfile3D.cxx:172; TProfile3D::GetBinContentDouble_t GetBinContent(Int_t bin) const overrideReturn bin content of a Profile3D histogram.Definition TProfile3D.cxx:691; TProfile3D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile3D.h:35; TProfile3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile3D.cxx:1318; TProfile3D::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile3D histogram.Definition TProfile3D.cxx:704; TProfile3D::GetW2Double_t * GetW2()Definition TProfile3D.h:76; TProfile3D::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1) .Definition TProfile3D.cxx:379; TProfile3D::fTsumwtDouble_t fTsumwtTotal Sum of weight*T.Definition TProfile3D.h:39; TProfile3D::Approximatestatic void Approximate(Bool_t approx=kTRUE)Set the fgApproximate flag.Definition TProfile3D.cxx:231; TProfile3D::fTmaxDouble_t fTmaxUpper limit in T (if set)Definition TProfile3D.h:37; TProfile3D::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile3D histogram.Definition TProfile3D.cxx:745; TP",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:69116,Availability,error,error,69116,"ntent of a Profile3D histogram.Definition TProfile3D.cxx:691; TProfile3D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile3D.h:35; TProfile3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile3D.cxx:1318; TProfile3D::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile3D histogram.Definition TProfile3D.cxx:704; TProfile3D::GetW2Double_t * GetW2()Definition TProfile3D.h:76; TProfile3D::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1) .Definition TProfile3D.cxx:379; TProfile3D::fTsumwtDouble_t fTsumwtTotal Sum of weight*T.Definition TProfile3D.h:39; TProfile3D::Approximatestatic void Approximate(Bool_t approx=kTRUE)Set the fgApproximate flag.Definition TProfile3D.cxx:231; TProfile3D::fTmaxDouble_t fTmaxUpper limit in T (if set)Definition TProfile3D.h:37; TProfile3D::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile3D histogram.Definition TProfile3D.cxx:745; TProfileHelper::LabelsInflatestatic void LabelsInflate(T *p, Option_t *)Definition TProfileHelper.h:626; TProfileHelper::GetBinErrorstatic Double_t GetBinError(T *p, Int_t bin)Definition TProfileHelper.h:704; TProfileHelper::ExtendAxisstatic T * ExtendAxis(T *p, Double_t x, TAxis *axis)Definition TProfileHelper.h:430; TProfileHelper::Sumw2static void Sumw2(T *p, Bool_t flag)Definition TProfileHelper.h:529; TProfileHelper::SetBinEntriesstatic void SetBinEntries(T *p, Int_t bin, Double_t w)Definition TProfileHelper.h:768; TProfileHelper::Scalestatic void Scale(T *p, Double_t c1, Option_t *option)Definition TProfileHelper.h:512; TProfileHelper::SetErrorOptionstatic void SetErrorOption(T *p, Option_t *opt)Definition TProfileHelper.h:693; TProfileHelper::Mergestatic Long64_t Merge(T *p, TCollection *list)Definition TProfileHelper.h:167; TProfileHelper::BuildArraystatic void BuildArray(T *p)Definition TP",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:1711,Integrability,rout,routines,1711,"e2D.h""; 14#include ""THashList.h""; 15#include ""TMath.h""; 16#include ""THLimitsFinder.h""; 17#include <iostream>; 18#include ""TError.h""; 19#include ""TClass.h""; 20 ; 21#include ""TProfileHelper.h""; 22 ; 23Bool_t TProfile3D::fgApproximate = kFALSE;; 24 ; 25ClassImp(TProfile3D);; 26 ; 27/** \class TProfile3D; 28 \ingroup Histograms; 29 Profile3D histograms are used to display the mean; 30 value of T and its RMS for each cell in X,Y,Z.; 31 Profile3D histograms are in many cases an; 32 The inter-relation of three measured quantities X, Y, Z and T can always; 33 be visualized by a four-dimensional histogram or scatter-plot;; 34 its representation on the line-printer is not particularly; 35 satisfactory, except for sparse data. If T is an unknown (but single-valued); 36 approximate function of X,Y,Z this function is displayed by a profile3D histogram with; 37 much better precision than by a scatter-plot.; 38 ; 39 The following formulae show the cumulated contents (capital letters) and the values; 40 displayed by the printing or plotting routines (small letters) of the elements for cell I, J.; 41 ; 42 2; 43 H(I,J,K) = sum T E(I,J,K) = sum T; 44 l(I,J,K) = sum l L(I,J,K) = sum l; 45 h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); 46 e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)); 47 ; 48 In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); 49 e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; 50 if the static function TProfile3D::Approximate has been called.; 51 This simple/crude approximation was suggested in order to keep the cell; 52 during a fit operation. But note that this approximation is not the default behaviour.; 53 ; 54 Example of a profile3D histogram; 55~~~~{.cpp}; 56{; 57 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 58 auto hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; 59 Double_t px, py, pz, pt;; 60 TRandom3 r(0);; 61 fo",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:37732,Integrability,depend,depending,37732,"z);; 1007 ; 1008 if (binEntries) cont = GetBinEntries(bin);; 1009 else if (cequalErrors) cont = GetBinError(bin);; 1010 else if (binWeight) cont = GetBinContent(bin) * GetBinEntries(bin);; 1011 else cont = GetBinContent(bin); // default case; 1012 ; 1013 h1->SetBinContent(bin ,cont);; 1014 ; 1015 // if option E projected histogram errors are same as profile; 1016 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1017 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1018 // this is correct only if the profile is unweighted; 1019 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1020 // in case of bin entries and profile is weighted, we need to set also the bin error; 1021 if (binEntries && fBinSumw2.fN ) {; 1022 R__ASSERT( h1->GetSumw2() );; 1023 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1024 }; 1025 }; 1026 }; 1027 }; 1028 h1->SetEntries(fEntries);; 1029 return h1;; 1030}; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Project a 3-D profile into a 2D-profile histogram depending on the option parameter.; 1033///; 1034/// option may contain a combination of the characters x,y,z:; 1035///; 1036/// - option = ""xy"" return the x versus y projection into a TProfile2D histogram; 1037/// - option = ""yx"" return the y versus x projection into a TProfile2D histogram; 1038/// - option = ""xz"" return the x versus z projection into a TProfile2D histogram; 1039/// - option = ""zx"" return the z versus x projection into a TProfile2D histogram; 1040/// - option = ""yz"" return the y versus z projection into a TProfile2D histogram; 1041/// - option = ""zy"" return the z versus y projection into a TProfile2D histogram; 1042///; 1043/// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal along X; 1044///; 1045/// The resulting profile contains the combination of all the considered bins along X; 1046/// By default, all bins are included considering also underflo",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:60506,Integrability,depend,depending,60506," TH3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4763; TH3D::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:4742; TH3D::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.h:380; TH3::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH3.h:34; TH3::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH3.h:35; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::Project3DProfilevirtual TProfile2D * Project3DProfile(Option_t *option=""xy"") constProject a 3-d histogram into a 2-d profile histograms depending on the option parameter option may co...Definition TH3.cxx:2806; TH3::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TH3.h:38; TH3::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH3.h:36; TH3::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TH3.h:37; TH3::fTsumwyzDouble_t fTsumwyzTotal Sum of weight*Y*Z.Definition TH3.h:40; TH3::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz) const overrideSee comments in TH1::GetBin.Definition TH3.cxx:1117; TH3::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH3.cxx:2889; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; ",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:66367,Integrability,depend,depending,66367," number of bins having a label.Definition TProfile3D.cxx:847; TProfile3D::~TProfile3D~TProfile3D() overrideDefault destructor for Profile3D histograms.Definition TProfile3D.cxx:86; TProfile3D::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along axis such that x is in the axis range.Definition TProfile3D.cxx:1206; TProfile3D::fTminDouble_t fTminLower limit in T (if set)Definition TProfile3D.h:36; TProfile3D::Scalevoid Scale(Double_t c1=1, Option_t *option="""") overrideMultiply this profile2D by a constant c1.Definition TProfile3D.cxx:1280; TProfile3D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin This is needed to compute the corr...Definition TProfile3D.cxx:1379; TProfile3D::LabelsInflatevoid LabelsInflate(Option_t *axis=""X"") overrideDouble the number of bins for axis.Definition TProfile3D.cxx:857; TProfile3D::Project3DProfileTProfile2D * Project3DProfile(Option_t *option=""xy"") const overrideProject a 3-D profile into a 2D-profile histogram depending on the option parameter.Definition TProfile3D.cxx:1054; TProfile3D::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile3D.cxx:1288; TProfile3D::BuildOptionsvoid BuildOptions(Double_t tmin, Double_t tmax, Option_t *option)Set Profile3D histogram structure and options.Definition TProfile3D.cxx:141; TProfile3D::Classstatic TClass * Class(); TProfile3D::FillInt_t Fill(const Double_t *v)Definition TProfile3D.h:53; TProfile3D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile3D.h:41; TProfile3D::GetBDouble_t * GetB()Definition TProfile3D.h:73; TProfile3D::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TProfile3D.cxx:246; TProfile3D::SetBuffervoid SetBuffer(Int_t buffersize, Option_t *opt="""") overrideSet the buffer size in units of 8 bytes (double).Definition TP",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:3790,Modifiability,variab,variable,3790,"andau(0,1);; 65 hprof3d->Fill(px,py,pz,pt,1);; 66 }; 67 hprof3d->Draw();; 68}; 69~~~~; 70 NOTE: A TProfile3D is drawn as it was a simple TH3; 71*/; 72 ; 73////////////////////////////////////////////////////////////////////////////////; 74/// Default constructor for Profile3D histograms.; 75 ; 76TProfile3D::TProfile3D(); 77{; 78 fTsumwt = fTsumwt2 = 0;; 79 fScaling = kFALSE;; 80 BuildOptions(0,0,"""");; 81}; 82 ; 83////////////////////////////////////////////////////////////////////////////////; 84/// Default destructor for Profile3D histograms.; 85 ; 86TProfile3D::~TProfile3D(); 87{; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// Normal Constructor for Profile histograms.; 92///; 93/// The first eleven parameters are similar to TH3D::TH3D.; 94/// All values of t are accepted at filling time.; 95/// To fill a profile3D histogram, one must use TProfile3D::Fill function.; 96///; 97/// Note that when filling the profile histogram the function Fill; 98/// checks if the variable t is between fTmin and fTmax.; 99/// If a minimum or maximum value is set for the T scale before filling,; 100/// then all values below tmin or above tmax will be discarded.; 101/// Setting the minimum or maximum value for the T scale before filling; 102/// has the same effect as calling the special TProfile3D constructor below; 103/// where tmin and tmax are specified.; 104///; 105/// H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; 106/// (spread option), or e(I,J,K) if CHOPT=' ' (error on mean).; 107///; 108/// See TProfile3D::BuildOptions for explanation of parameters; 109///; 110/// see other constructors below with all possible combinations of; 111/// fix and variable bin size like in TH3D.; 112 ; 113TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Int_t nz, Double_t zlow,Double_t zup,Option_t *option); 114 : TH3D(name,tit",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:4513,Modifiability,variab,variable,4513,"91/// Normal Constructor for Profile histograms.; 92///; 93/// The first eleven parameters are similar to TH3D::TH3D.; 94/// All values of t are accepted at filling time.; 95/// To fill a profile3D histogram, one must use TProfile3D::Fill function.; 96///; 97/// Note that when filling the profile histogram the function Fill; 98/// checks if the variable t is between fTmin and fTmax.; 99/// If a minimum or maximum value is set for the T scale before filling,; 100/// then all values below tmin or above tmax will be discarded.; 101/// Setting the minimum or maximum value for the T scale before filling; 102/// has the same effect as calling the special TProfile3D constructor below; 103/// where tmin and tmax are specified.; 104///; 105/// H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; 106/// (spread option), or e(I,J,K) if CHOPT=' ' (error on mean).; 107///; 108/// See TProfile3D::BuildOptions for explanation of parameters; 109///; 110/// see other constructors below with all possible combinations of; 111/// fix and variable bin size like in TH3D.; 112 ; 113TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Int_t nz, Double_t zlow,Double_t zup,Option_t *option); 114 : TH3D(name,title,nx,xlow,xup,ny,ylow,yup,nz,zlow,zup); 115{; 116 BuildOptions(0,0,option);; 117 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 118}; 119 ; 120////////////////////////////////////////////////////////////////////////////////; 121/// Create a 3-D Profile with variable bins in X , Y and Z.; 122 ; 123TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Int_t nz,const Double_t *zbins,Option_t *option); 124 : TH3D(name,title,nx,xbins,ny,ybins,nz,zbins); 125{; 126 BuildOptions(0,0,option);; 127}; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:5045,Modifiability,variab,variable,5045,"en fTmin and fTmax.; 99/// If a minimum or maximum value is set for the T scale before filling,; 100/// then all values below tmin or above tmax will be discarded.; 101/// Setting the minimum or maximum value for the T scale before filling; 102/// has the same effect as calling the special TProfile3D constructor below; 103/// where tmin and tmax are specified.; 104///; 105/// H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; 106/// (spread option), or e(I,J,K) if CHOPT=' ' (error on mean).; 107///; 108/// See TProfile3D::BuildOptions for explanation of parameters; 109///; 110/// see other constructors below with all possible combinations of; 111/// fix and variable bin size like in TH3D.; 112 ; 113TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,Double_t xlow,Double_t xup,Int_t ny,Double_t ylow,Double_t yup,Int_t nz, Double_t zlow,Double_t zup,Option_t *option); 114 : TH3D(name,title,nx,xlow,xup,ny,ylow,yup,nz,zlow,zup); 115{; 116 BuildOptions(0,0,option);; 117 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 118}; 119 ; 120////////////////////////////////////////////////////////////////////////////////; 121/// Create a 3-D Profile with variable bins in X , Y and Z.; 122 ; 123TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Int_t nz,const Double_t *zbins,Option_t *option); 124 : TH3D(name,title,nx,xbins,ny,ybins,nz,zbins); 125{; 126 BuildOptions(0,0,option);; 127}; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// Set Profile3D histogram structure and options.; 131///; 132/// - tmin: minimum value allowed for t; 133/// - tmax: maximum value allowed for t; 134/// if (tmin = tmax = 0) there are no limits on the allowed t values (tmin = -inf, tmax = +inf); 135///; 136/// - option: this is the option for the computation of the t error of the profile ( TProfile3D::GetBinErro",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:25260,Modifiability,evolve,evolved,25260,"return 0;; 709 return fBinEntries.fArray[bin];; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Return bin effective entries for a weighted filled Profile histogram.; 714///; 715/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation.; 743/// (see also comments in TProfile::GetBinError); 744 ; 745Double_t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750/////////////////////////",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:35793,Modifiability,variab,variable,35793," ); 958///; 959/// Note that the axis range is not considered when doing the projection; 960 ; 961TH3D *TProfile3D::ProjectionXYZ(const char *name, Option_t *option) const; 962{; 963 ; 964 TString opt = option;; 965 opt.ToLower();; 966 Int_t nx = fXaxis.GetNbins();; 967 Int_t ny = fYaxis.GetNbins();; 968 Int_t nz = fZaxis.GetNbins();; 969 const TArrayD *xbins = fXaxis.GetXbins();; 970 const TArrayD *ybins = fYaxis.GetXbins();; 971 const TArrayD *zbins = fZaxis.GetXbins();; 972 ; 973 // Create the projection histogram; 974 TString pname = name;; 975 if (pname == ""_px"") {; 976 pname = GetName(); pname.Append(""_pxyz"");; 977 }; 978 TH3D *h1 = nullptr ;; 979 if (xbins->fN == 0 && ybins->fN == 0 && zbins->fN == 0); 980 h1 = new TH3D(pname,GetTitle(),nx,fXaxis.GetXmin(),fXaxis.GetXmax(),ny,fYaxis.GetXmin(),fYaxis.GetXmax(),nz,fZaxis.GetXmin(),fZaxis.GetXmax());; 981 else if ( xbins->fN != 0 && ybins->fN != 0 && zbins->fN != 0); 982 h1 = new TH3D(pname,GetTitle(),nx,xbins->GetArray(),ny,ybins->GetArray(), nz,zbins->GetArray() );; 983 else {; 984 Error(""ProjectionXYZ"",""Histogram has an axis with variable bins and an axis with fixed bins. This case is not supported - return a null pointer"");; 985 return nullptr;; 986 }; 987 ; 988 ; 989 Bool_t computeErrors = kFALSE;; 990 Bool_t cequalErrors = kFALSE;; 991 Bool_t binEntries = kFALSE;; 992 Bool_t binWeight = kFALSE;; 993 ; 994 if (opt.Contains(""b"")) binEntries = kTRUE;; 995 if (opt.Contains(""e"")) computeErrors = kTRUE;; 996 if (opt.Contains(""w"")) binWeight = kTRUE;; 997 if (opt.Contains(""c=e"")) {cequalErrors = kTRUE; computeErrors=kFALSE;}; 998 if (computeErrors || binWeight || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 999 ; 1000 // Fill the projected histogram; 1001 Int_t bin,binx,biny,binz;; 1002 Double_t cont;; 1003 for (binx =0;binx<=nx+1;binx++) {; 1004 for (biny =0;biny<=ny+1;biny++) {; 1005 for (binz =0;binz<=nz+1;binz++) {; 1006 bin = GetBin(binx,biny,binz);; 1007 ; 1008 if (binEntries) cont = GetBinEntries(bin);; 100",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:40471,Modifiability,variab,variable,40471,"t is done is different.; 1068 ; 1069TProfile2D *TProfile3D::DoProjectProfile2D(const char* name, const char * title, const TAxis* projX, const TAxis* projY,; 1070 bool originalRange, bool useUF, bool useOF) const; 1071{; 1072 // Get the ranges where we will work.; 1073 Int_t ixmin = projX->GetFirst();; 1074 Int_t ixmax = projX->GetLast();; 1075 Int_t iymin = projY->GetFirst();; 1076 Int_t iymax = projY->GetLast();; 1077 if (ixmin == 0 && ixmax == 0) { ixmin = 1; ixmax = projX->GetNbins(); }; 1078 if (iymin == 0 && iymax == 0) { iymin = 1; iymax = projY->GetNbins(); }; 1079 Int_t nx = ixmax-ixmin+1;; 1080 Int_t ny = iymax-iymin+1;; 1081 ; 1082 // Create the projected profiles; 1083 TProfile2D *p2 = nullptr;; 1084 // Create always a new TProfile2D (not as in the case of TH3 projection); 1085 ; 1086 const TArrayD *xbins = projX->GetXbins();; 1087 const TArrayD *ybins = projY->GetXbins();; 1088 // assume all axis have variable bins or have fixed bins; 1089 if ( originalRange ) {; 1090 if (xbins->fN == 0 && ybins->fN == 0) {; 1091 p2 = new TProfile2D(name,title,projY->GetNbins(),projY->GetXmin(),projY->GetXmax(); 1092 ,projX->GetNbins(),projX->GetXmin(),projX->GetXmax());; 1093 } else {; 1094 p2 = new TProfile2D(name,title,projY->GetNbins(),&ybins->fArray[iymin-1],projX->GetNbins(),&xbins->fArray[ixmin-1]);; 1095 }; 1096 } else {; 1097 if (xbins->fN == 0 && ybins->fN == 0) {; 1098 p2 = new TProfile2D(name,title,ny,projY->GetBinLowEdge(iymin),projY->GetBinUpEdge(iymax); 1099 ,nx,projX->GetBinLowEdge(ixmin),projX->GetBinUpEdge(ixmax));; 1100 } else {; 1101 p2 = new TProfile2D(name,title,ny,&ybins->fArray[iymin-1],nx,&xbins->fArray[ixmin-1]);; 1102 }; 1103 }; 1104 ; 1105 // weights; 1106 bool useWeights = (fBinSumw2.fN != 0);; 1107 if (useWeights) p2->Sumw2();; 1108 ; 1109 // make projection in a 3D first; 1110 TH3D * h3dW = ProjectionXYZ(""h3temp-W"",""W"");; 1111 TH3D * h3dN = ProjectionXYZ(""h3temp-N"",""B"");; 1112 ; 1113 h3dW->SetDirectory(nullptr); h3dN->SetDirectory(nullptr);",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:46453,Modifiability,variab,variable,46453,"axis);; 1209 if ( hold ) {; 1210 fTsumwt = hold->fTsumwt;; 1211 fTsumwt2 = hold->fTsumwt2;; 1212 delete hold;; 1213 }; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Save primitive as a C++ statement(s) on output stream out.; 1218///; 1219/// Note the following restrictions in the code generated:; 1220/// - variable bin size not implemented; 1221/// - SetErrorOption not implemented; 1222 ; 1223void TProfile3D::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1224{; 1225 char quote = '""';; 1226 out <<"" ""<<std::endl;; 1227 out <<"" ""<<ClassName()<<"" *"";; 1228 ; 1229 out << GetName() << "" = new "" << ClassName() << ""("" << quote; 1230 << GetName() << quote << "","" << quote<< GetTitle() << quote; 1231 << "","" << GetXaxis()->GetNbins();; 1232 out << "","" << GetXaxis()->GetXmin(); 1233 << "","" << GetXaxis()->GetXmax();; 1234 out << "","" << GetYaxis()->GetNbins();; 1235 out << "","" << GetYaxis()->GetXmin(); 1236 << "","" << GetYaxis()->GetXmax();; 1237 out << "","" << GetZaxis()->GetNbins();; 1238 out << "","" << GetZaxis()->GetXmin(); 1239 << "","" << GetZaxis()->GetXmax();; 1240 out << "","" << fTmin; 1241 << "","" << fTmax;; 1242 out << "");"" << std::endl;; 1243 ; 1244 ; 1245 // save bin entries; 1246 Int_t bin;; 1247 for (bin=0;bin<fNcells;bin++) {; 1248 Double_t bi = GetBinEntries(bin);; 1249 if (bi) {; 1250 out<<"" ""<<GetName()<<""->SetBinEntries(""<<bin<<"",""<<bi<<"");""<<std::endl;; 1251 }; 1252 }; 1253 //save bin contents; 1254 for (bin=0;bin<fNcells;bin++) {; 1255 Double_t bc = fArray[bin];; 1256 if (bc) {; 1257 out<<"" ""<<GetName()<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1258 }; 1259 }; 1260 // save bin errors; 1261 if (fSumw2.fN) {; 1262 for (bin=0;bin<fNcells;bin++) {; 1263 Double_t be = TMath::Sqrt(fSumw2.fArray[bin]);; 1264 if (be) {; 1265 out<<"" ""<<GetName()<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 1266 }; 1267 }; 1268 }; 1269 ; 1270 TH1::SavePrimitiveHelp(out, GetName(), option);; 1271}; 127",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:49322,Modifiability,variab,variable,49322,"D::Scale(Double_t c1, Option_t *option); 1281{; 1282 TProfileHelper::Scale(this, c1, option);; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286///Set the number of entries in bin.; 1287 ; 1288void TProfile3D::SetBinEntries(Int_t bin, Double_t w); 1289{; 1290 TProfileHelper::SetBinEntries(this, bin, w);; 1291}; 1292 ; 1293////////////////////////////////////////////////////////////////////////////////; 1294/// Redefine x, y and z axis parameters.; 1295 ; 1296void TProfile3D::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); 1297{; 1298 TH1::SetBins(nx, xmin, xmax, ny, ymin, ymax, nz, zmin, zmax);; 1299 fBinEntries.Set(fNcells);; 1300 if (fBinSumw2.fN) fBinSumw2.Set(fNcells);; 1301}; 1302 ; 1303////////////////////////////////////////////////////////////////////////////////; 1304/// Redefine x, y and z axis parameters with variable bin sizes; 1305 ; 1306void TProfile3D::SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins, Int_t nz, const Double_t *zBins); 1307{; 1308 TH1::SetBins(nx,xBins,ny,yBins,nz,zBins);; 1309 fBinEntries.Set(fNcells);; 1310 if (fBinSumw2.fN) fBinSumw2.Set(fNcells);; 1311}; 1312 ; 1313////////////////////////////////////////////////////////////////////////////////; 1314/// Set total number of bins including under/overflow.; 1315///; 1316/// Reallocate bin contents array; 1317 ; 1318void TProfile3D::SetBinsLength(Int_t n); 1319{; 1320 TH3D::SetBinsLength(n);; 1321 TProfileHelper::BuildArray(this);; 1322}; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Set the buffer size in units of 8 bytes (double).; 1326 ; 1327void TProfile3D::SetBuffer(Int_t buffersize, Option_t *); 1328{; 1329 if (fBuffer) {; 1330 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 133",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:57252,Modifiability,extend,extendable,57252,"togram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bi",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:62041,Modifiability,inherit,inherits,62041,"; TH3::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH3.cxx:2889; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile2D.cxx:1918; TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile2D.h:121; TProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,...Definition TProfile3D.h:27; TProfile3D::operator=TProfile3D & operator=(const TProfile3D &profile)Definition TProfile3D.cxx:162; TProfile3D::DoProjectProfile2DTProfile2D * DoProjectProfile2D(const char *name, const char",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:60195,Performance,perform,performing,60195,")Definition TH1.h:391; TH1::fTsumwxDouble_t fTsumwxTotal Sum of weight*X.Definition TH1.h:98; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH3D3-D histogram with a double per channel (see TH1 documentation)Definition TH3.h:363; TH3D::TH3DTH3D()Constructor.Definition TH3.cxx:4669; TH3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4763; TH3D::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:4742; TH3D::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.h:380; TH3::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH3.h:34; TH3::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH3.h:35; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::Project3DProfilevirtual TProfile2D * Project3DProfile(Option_t *option=""xy"") constProject a 3-d histogram into a 2-d profile histograms depending on the option parameter option may co...Definition TH3.cxx:2806; TH3::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TH3.h:38; TH3::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH3.h:36; TH3::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TH3.h:37; TH3::fTsumwyzDouble_t fTsumwyzTotal Sum of weight*Y*Z.Definition TH3.h:40; TH3::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz) const overrideSee comments in TH1::GetBin.Definition TH3.cxx:1117; TH3::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH3.cxx",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:53542,Safety,abort,abort,53542,"w2(Bool_t flag); 1380{; 1381 TProfileHelper::Sumw2(this, flag);; 1382}; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfile3D.h; TProfileHelper.h; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Copyvoid Copy(TArrayD &array) constDefinition TArrayD.h:42; TArrayD::Setvoid Set(Int_t n) overrideSet size of this array to n doubles.Definition TArrayD.cxx:106; TArrayD::TArrayDTArrayD()Default TArrayD ctor.Definition TArrayD.cxx:26; TArr",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:2215,Usability,simpl,simple,2215,"sional histogram or scatter-plot;; 34 its representation on the line-printer is not particularly; 35 satisfactory, except for sparse data. If T is an unknown (but single-valued); 36 approximate function of X,Y,Z this function is displayed by a profile3D histogram with; 37 much better precision than by a scatter-plot.; 38 ; 39 The following formulae show the cumulated contents (capital letters) and the values; 40 displayed by the printing or plotting routines (small letters) of the elements for cell I, J.; 41 ; 42 2; 43 H(I,J,K) = sum T E(I,J,K) = sum T; 44 l(I,J,K) = sum l L(I,J,K) = sum l; 45 h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); 46 e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)); 47 ; 48 In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); 49 e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; 50 if the static function TProfile3D::Approximate has been called.; 51 This simple/crude approximation was suggested in order to keep the cell; 52 during a fit operation. But note that this approximation is not the default behaviour.; 53 ; 54 Example of a profile3D histogram; 55~~~~{.cpp}; 56{; 57 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 58 auto hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; 59 Double_t px, py, pz, pt;; 60 TRandom3 r(0);; 61 for ( Int_t i=0; i<25000; i++) {; 62 r.Rannor(px,py);; 63 pz = px*px + py*py;; 64 pt = r.Landau(0,1);; 65 hprof3d->Fill(px,py,pz,pt,1);; 66 }; 67 hprof3d->Draw();; 68}; 69~~~~; 70 NOTE: A TProfile3D is drawn as it was a simple TH3; 71*/; 72 ; 73////////////////////////////////////////////////////////////////////////////////; 74/// Default constructor for Profile3D histograms.; 75 ; 76TProfile3D::TProfile3D(); 77{; 78 fTsumwt = fTsumwt2 = 0;; 79 fScaling = kFALSE;; 80 BuildOptions(0,0,"""");; 81}; 82 ; 83////////////////////////////////////////////////////////////////////////////////;",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:2889,Usability,simpl,simple,2889,"(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); 46 e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)); 47 ; 48 In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); 49 e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; 50 if the static function TProfile3D::Approximate has been called.; 51 This simple/crude approximation was suggested in order to keep the cell; 52 during a fit operation. But note that this approximation is not the default behaviour.; 53 ; 54 Example of a profile3D histogram; 55~~~~{.cpp}; 56{; 57 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 58 auto hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; 59 Double_t px, py, pz, pt;; 60 TRandom3 r(0);; 61 for ( Int_t i=0; i<25000; i++) {; 62 r.Rannor(px,py);; 63 pz = px*px + py*py;; 64 pt = r.Landau(0,1);; 65 hprof3d->Fill(px,py,pz,pt,1);; 66 }; 67 hprof3d->Draw();; 68}; 69~~~~; 70 NOTE: A TProfile3D is drawn as it was a simple TH3; 71*/; 72 ; 73////////////////////////////////////////////////////////////////////////////////; 74/// Default constructor for Profile3D histograms.; 75 ; 76TProfile3D::TProfile3D(); 77{; 78 fTsumwt = fTsumwt2 = 0;; 79 fScaling = kFALSE;; 80 BuildOptions(0,0,"""");; 81}; 82 ; 83////////////////////////////////////////////////////////////////////////////////; 84/// Default destructor for Profile3D histograms.; 85 ; 86TProfile3D::~TProfile3D(); 87{; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// Normal Constructor for Profile histograms.; 92///; 93/// The first eleven parameters are similar to TH3D::TH3D.; 94/// All values of t are accepted at filling time.; 95/// To fill a profile3D histogram, one must use TProfile3D::Fill function.; 96///; 97/// Note that when filling the profile histogram the function Fill; 98/// checks if the variable t is between fTmin and fTmax.; 99/// If a minimum or maximum value is set for the T scale before filling",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:27267,Usability,simpl,simply,27267,"t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750////////////////////////////////////////////////////////////////////////////////; 751/// Return option to compute profile2D errors.; 752 ; 753Option_t *TProfile3D::GetErrorOption() const; 754{; 755 if (fErrorMode == kERRORSPREAD) return ""s"";; 756 if (fErrorMode == kERRORSPREADI) return ""i"";; 757 if (fErrorMode == kERRORSPREADG) return ""g"";; 758 return """";; 759}; 760 ; 761////////////////////////////////////////////////////////////////////////////////; 762/// fill the array stats from the contents of this profile.; 763///; 764/// The array stats must be correctly dimensioned in the calling program.; 765///; 766/// - stats[0] = sumw; 767/// - stats[1] = sumw2; 768/// - stats[2] = sumwx; 769/// - stats[3] = sumwx2; 770/// - stats[4] = sumwy; 771/// - stats[5] = sumwy2; 772/// - stats[6] = sumwxy; 773/// - stats[7] = sumwz; 774/// - stats[8] = sumwz2; 775/// - stats[9] = sumwxz; 776/// - stats[10]= sumwyz; 777/// - stats[11]= sumwt; 778/// - stats[12]= sumwt2; 779///; 780/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 781/// is simply a copy of the statistics quantities computed at filling time.; 782/// If a sub-range is specified, the function recomputes these quantities; 783/// from the bin contents in the current axis range.; 784 ; 785void TProfile3D::GetStats(Double_t *stats) const; 786{; 787 if (fBuffer) ((TProfile3D*)this)->BufferEmpty();; 788 ; 789 // Loop on bins; 790 if ( (fTsumw == 0 /* && fEntries > 0 */) || fXaxis.TestBit(TAxis::kAxisRange) || fYaxis.TestBit(TAxis::kAxisRange)) {; 791 ; 792 // check for labels axis . In that case corresponding statistics do not make sense and it is set to zero; 793 Bool_t labelXaxis = ((const_cast<TAxis &>(fXaxis)).GetLabels() && fXaxis.CanExtend());; 794 Bool_t labelYaxis = ((const_cast<TAxis &>(fYaxis)).GetLabels() && fYaxis.CanExtend());; 795 Bool_t labelZaxis = ((co",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8cxx_source.html:33605,Usability,simpl,simply,33605,"////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled with all weights =1.; 953/// When the profile is weighted (filled with weights different than 1) the; 954/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 955/// correctly computed from the information stored in the profile. In that case the; 956/// obtained histogram contains as bin error square the weighted sum of the square of the; 957/// profiled observable (TProfile2D::fSumw2[bin] ); 958///; 959/// Note that the axis range is not considered when doing the projection; 960 ; 961TH3D *TProf",MatchSource.WIKI,doc/master/TProfile3D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:1215,Availability,error,errors,1215,"h""; 26 ; 27class TProfile3D : public TH3D {; 28 ; 29public:; 30 friend class TProfileHelper;; 31 friend class TH1Merger;; 32 ; 33protected:; 34 TArrayD fBinEntries; ///< Number of entries per bin; 35 EErrorType fErrorMode; ///< Option to compute errors; 36 Double_t fTmin; ///< Lower limit in T (if set); 37 Double_t fTmax; ///< Upper limit in T (if set); 38 Bool_t fScaling; ///<! True when TProfile3D::Scale is called; 39 Double_t fTsumwt; ///< Total Sum of weight*T; 40 Double_t fTsumwt2; ///< Total Sum of weight*T*T; 41 TArrayD fBinSumw2; ///< Array of sum of squares of weights per bin; 42 static Bool_t fgApproximate; ///< Bin error approximation option; 43 ; 44 Int_t BufferFill(Double_t, Double_t) override {return -2;} //may not use; 45 Int_t BufferFill(Double_t, Double_t, Double_t) override {return -2;} //may not use; 46 Int_t BufferFill(Double_t, Double_t, Double_t, Double_t) override {return -2;} //may not use; 47 virtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t t, Double_t w);; 48 ; 49 // hel",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:1603,Availability,error,error,1603,"h""; 26 ; 27class TProfile3D : public TH3D {; 28 ; 29public:; 30 friend class TProfileHelper;; 31 friend class TH1Merger;; 32 ; 33protected:; 34 TArrayD fBinEntries; ///< Number of entries per bin; 35 EErrorType fErrorMode; ///< Option to compute errors; 36 Double_t fTmin; ///< Lower limit in T (if set); 37 Double_t fTmax; ///< Upper limit in T (if set); 38 Bool_t fScaling; ///<! True when TProfile3D::Scale is called; 39 Double_t fTsumwt; ///< Total Sum of weight*T; 40 Double_t fTsumwt2; ///< Total Sum of weight*T*T; 41 TArrayD fBinSumw2; ///< Array of sum of squares of weights per bin; 42 static Bool_t fgApproximate; ///< Bin error approximation option; 43 ; 44 Int_t BufferFill(Double_t, Double_t) override {return -2;} //may not use; 45 Int_t BufferFill(Double_t, Double_t, Double_t) override {return -2;} //may not use; 46 Int_t BufferFill(Double_t, Double_t, Double_t, Double_t) override {return -2;} //may not use; 47 virtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t t, Double_t w);; 48 ; 49 // hel",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:10283,Availability,error,error,10283," TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Resetvoid Reset()Definition TArrayD.h:47; TArray::fNInt_t fNDefinition TArray.h:38; TAxisClass to manage histogram axis.Definition TAxis.h:31; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TH1MergerDefinition TH1Merger.h:20; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH3D3-D histogram with a double per channel (see TH1 documentation)Definition TH3.h:363; TH3::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH3.cxx:368; TH3::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz) const overrideSee comments in TH1::GetBin.Definition TH3.cxx:1117; TObjectMother of all ROOT objects.Definition TObject.h:41; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,...Definition TProfile3D.h:27; TProfile3D::operator=TProfile3D & operator=(const TProfile3D &profile)Definition TProfile3D.cxx:162; TProfile3D::GetBinErrorSqUncheckedDouble_t GetBinErrorSqUnchecked(Int_t bin) const overrideDefinition TProfile3D.h:67; TProfile3D::DoProjectProfile2DTProfile2D * DoProjectProfile2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) const overrideInternal method to project to a 2D Profile.Definition TProfile3D.cxx:1069; TProfile3D::GetWDouble_t * GetW()Definition TProfile3D.h:75; TProfile3D::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile3D.cxx:894; TProfile3D::fgApproximatestatic Bool_t fgApproximateBin error approximation option",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:11228,Availability,error,error,11228,"ile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,...Definition TProfile3D.h:27; TProfile3D::operator=TProfile3D & operator=(const TProfile3D &profile)Definition TProfile3D.cxx:162; TProfile3D::GetBinErrorSqUncheckedDouble_t GetBinErrorSqUnchecked(Int_t bin) const overrideDefinition TProfile3D.h:67; TProfile3D::DoProjectProfile2DTProfile2D * DoProjectProfile2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) const overrideInternal method to project to a 2D Profile.Definition TProfile3D.cxx:1069; TProfile3D::GetWDouble_t * GetW()Definition TProfile3D.h:75; TProfile3D::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile3D.cxx:894; TProfile3D::fgApproximatestatic Bool_t fgApproximateBin error approximation option.Definition TProfile3D.h:42; TProfile3D::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TProfile3D.h:65; TProfile3D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile3D.cxx:753; TProfile3D::fScalingBool_t fScaling! True when TProfile3D::Scale is calledDefinition TProfile3D.h:38; TProfile3D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile3D.h:50; TProfile3D::FillInt_t Fill(Double_t, Double_t, Double_t) overrideIncrement cell defined by x,y,z by 1 .Definition TProfile3D.h:57; TProfile3D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile3D.cxx:1175; TProfile3D::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile3D histogram to a new prof",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:11592,Availability,error,errors,11592,"inition TProfile3D.cxx:162; TProfile3D::GetBinErrorSqUncheckedDouble_t GetBinErrorSqUnchecked(Int_t bin) const overrideDefinition TProfile3D.h:67; TProfile3D::DoProjectProfile2DTProfile2D * DoProjectProfile2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) const overrideInternal method to project to a 2D Profile.Definition TProfile3D.cxx:1069; TProfile3D::GetWDouble_t * GetW()Definition TProfile3D.h:75; TProfile3D::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile3D.cxx:894; TProfile3D::fgApproximatestatic Bool_t fgApproximateBin error approximation option.Definition TProfile3D.h:42; TProfile3D::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TProfile3D.h:65; TProfile3D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile3D.cxx:753; TProfile3D::fScalingBool_t fScaling! True when TProfile3D::Scale is calledDefinition TProfile3D.h:38; TProfile3D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile3D.h:50; TProfile3D::FillInt_t Fill(Double_t, Double_t, Double_t) overrideIncrement cell defined by x,y,z by 1 .Definition TProfile3D.h:57; TProfile3D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile3D.cxx:1175; TProfile3D::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile3D histogram to a new profile2D histogram.Definition TProfile3D.cxx:350; TProfile3D::SetBinsvoid SetBins(Int_t, const Double_t *) overrideRedefine x axis parameters with variable bin sizes.Definition TProfile3D.h:79; TProfile3D::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile3D.h:44; TProfile3D::GetBinCo",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:16948,Availability,error,errors,16948,"d BuildOptions(Double_t tmin, Double_t tmax, Option_t *option)Set Profile3D histogram structure and options.Definition TProfile3D.cxx:141; TProfile3D::FillInt_t Fill(const Double_t *v)Definition TProfile3D.h:53; TProfile3D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile3D.h:41; TProfile3D::GetBDouble_t * GetB()Definition TProfile3D.h:73; TProfile3D::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TProfile3D.cxx:246; TProfile3D::SetBuffervoid SetBuffer(Int_t buffersize, Option_t *opt="""") overrideSet the buffer size in units of 8 bytes (double).Definition TProfile3D.cxx:1327; TProfile3D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile3D.cxx:1223; TProfile3D::GetTmaxvirtual Double_t GetTmax() constDefinition TProfile3D.h:125; TProfile3D::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile3D errors.Definition TProfile3D.cxx:1365; TProfile3D::BufferFillInt_t BufferFill(Double_t, Double_t, Double_t) overrideDefinition TProfile3D.h:45; TProfile3D::SetBinsvoid SetBins(Int_t, Double_t, Double_t) overrideRedefine x axis parameters.Definition TProfile3D.h:77; TProfile3D::ProjectionXYZvirtual TH3D * ProjectionXYZ(const char *name=""_pxyz"", Option_t *option=""e"") constProject this profile3D into a 3-D histogram along X,Y,Z.Definition TProfile3D.cxx:961; TProfile3D::GetBinErrorDouble_t GetBinError(Int_t, Int_t) const overrideDefinition TProfile3D.h:115; TProfile3D::GetB2Double_t * GetB2()Definition TProfile3D.h:74; TProfile3D::AddBool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""") overridePerforms the operation: this = this + c1*f1 .Definition TProfile3D.cxx:172; TProfile3D::GetBinContentDouble_t GetBinContent(Int_t bin) const overrideReturn bin content of a Profile3D histogram.Definition TProfile3D.cxx:691; TProfile3D::fErrorMo",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:17936,Availability,error,errors,17936," *option="""")Set option to compute profile3D errors.Definition TProfile3D.cxx:1365; TProfile3D::BufferFillInt_t BufferFill(Double_t, Double_t, Double_t) overrideDefinition TProfile3D.h:45; TProfile3D::SetBinsvoid SetBins(Int_t, Double_t, Double_t) overrideRedefine x axis parameters.Definition TProfile3D.h:77; TProfile3D::ProjectionXYZvirtual TH3D * ProjectionXYZ(const char *name=""_pxyz"", Option_t *option=""e"") constProject this profile3D into a 3-D histogram along X,Y,Z.Definition TProfile3D.cxx:961; TProfile3D::GetBinErrorDouble_t GetBinError(Int_t, Int_t) const overrideDefinition TProfile3D.h:115; TProfile3D::GetB2Double_t * GetB2()Definition TProfile3D.h:74; TProfile3D::AddBool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""") overridePerforms the operation: this = this + c1*f1 .Definition TProfile3D.cxx:172; TProfile3D::GetBinContentDouble_t GetBinContent(Int_t bin) const overrideReturn bin content of a Profile3D histogram.Definition TProfile3D.cxx:691; TProfile3D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile3D.h:35; TProfile3D::FillInt_t Fill(Double_t, const char *, const char *, Double_t) overrideIncrement cell defined by x,namey,namez by a weight w.Definition TProfile3D.h:61; TProfile3D::GetBinSumw2virtual const TArrayD * GetBinSumw2() constDefinition TProfile3D.h:121; TProfile3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile3D.cxx:1318; TProfile3D::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile3D histogram.Definition TProfile3D.cxx:704; TProfile3D::GetBinErrorDouble_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const overrideDefinition TProfile3D.h:117; TProfile3D::GetTminvirtual Double_t GetTmin() constDefinition TProfile3D.h:124; TProfile3D::GetW2Double_t * GetW2()Definition TProfile3D.h:76; TProfile3D::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1) .Defini",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:19886,Availability,error,error,19886,"ual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile3D histogram.Definition TProfile3D.cxx:704; TProfile3D::GetBinErrorDouble_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const overrideDefinition TProfile3D.h:117; TProfile3D::GetTminvirtual Double_t GetTmin() constDefinition TProfile3D.h:124; TProfile3D::GetW2Double_t * GetW2()Definition TProfile3D.h:76; TProfile3D::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1) .Definition TProfile3D.cxx:379; TProfile3D::GetBinContentDouble_t GetBinContent(Int_t, Int_t) const overrideDefinition TProfile3D.h:111; TProfile3D::fTsumwtDouble_t fTsumwtTotal Sum of weight*T.Definition TProfile3D.h:39; TProfile3D::FillInt_t Fill(Double_t, Double_t, const char *, Double_t) overrideIncrement cell defined by x,y,namez by a weight w.Definition TProfile3D.h:63; TProfile3D::FillInt_t Fill(const char *, const char *, Double_t, Double_t) overrideIncrement cell defined by namex,namey,z by a weight w.Definition TProfile3D.h:60; TProfile3D::SetBinsvoid SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t) overrideRedefine x and y axis parameters.Definition TProfile3D.h:81; TProfile3D::Approximatestatic void Approximate(Bool_t approx=kTRUE)Set the fgApproximate flag.Definition TProfile3D.cxx:231; TProfile3D::fTmaxDouble_t fTmaxUpper limit in T (if set)Definition TProfile3D.h:37; TProfile3D::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile3D histogram.Definition TProfile3D.cxx:745; TProfileHelperDefinition TProfileHelper.h:30; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; c2return c2Definition legend2.C:14; v@ vDefinition rootcling_impl.cxx:3699. histhistincTProfile3D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:15517,Integrability,depend,depending,15517,"arameters with variable bin sizes.Definition TProfile3D.h:83; TProfile3D::~TProfile3D~TProfile3D() overrideDefault destructor for Profile3D histograms.Definition TProfile3D.cxx:86; TProfile3D::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along axis such that x is in the axis range.Definition TProfile3D.cxx:1206; TProfile3D::fTminDouble_t fTminLower limit in T (if set)Definition TProfile3D.h:36; TProfile3D::Scalevoid Scale(Double_t c1=1, Option_t *option="""") overrideMultiply this profile2D by a constant c1.Definition TProfile3D.cxx:1280; TProfile3D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin This is needed to compute the corr...Definition TProfile3D.cxx:1379; TProfile3D::LabelsInflatevoid LabelsInflate(Option_t *axis=""X"") overrideDouble the number of bins for axis.Definition TProfile3D.cxx:857; TProfile3D::Project3DProfileTProfile2D * Project3DProfile(Option_t *option=""xy"") const overrideProject a 3-D profile into a 2D-profile histogram depending on the option parameter.Definition TProfile3D.cxx:1054; TProfile3D::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile3D.cxx:1288; TProfile3D::BufferFillInt_t BufferFill(Double_t, Double_t, Double_t, Double_t) overrideAccumulate arguments in buffer.Definition TProfile3D.h:46; TProfile3D::BuildOptionsvoid BuildOptions(Double_t tmin, Double_t tmax, Option_t *option)Set Profile3D histogram structure and options.Definition TProfile3D.cxx:141; TProfile3D::FillInt_t Fill(const Double_t *v)Definition TProfile3D.h:53; TProfile3D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile3D.h:41; TProfile3D::GetBDouble_t * GetB()Definition TProfile3D.h:73; TProfile3D::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TProfile3D.cxx:246; TProfile3D::SetBuffervoid SetBuffer(In",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:8809,Modifiability,inherit,inherited,8809,"nt_t nbinsy, Double_t ymin, Double_t ymax,; 142 Int_t nbinsz, Double_t zmin, Double_t zmax) override;; 143 void SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t * yBins, Int_t nz,; 144 const Double_t *zBins) override;; 145 void SetBinsLength(Int_t n=-1) override;; 146 void SetBuffer(Int_t buffersize, Option_t *opt="""") override;; 147 virtual void SetErrorOption(Option_t *option=""""); // *MENU*; 148 void Sumw2(Bool_t flag = kTRUE) override;; 149 ; 150 ClassDefOverride(TProfile3D,8) //Profile3D histogram class; 151};; 152 ; 153#endif; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TH3.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TProfile.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Resetvoid Reset()Definition TArrayD.h:47; TArray::fNInt_t fNDefinition TArray.h:38; TAxisClass to manage histogram axis.Definition TAxis.h:31; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TH1MergerDefinition TH1Merger.h:20; TH1TH1 is the base class of all histogram classes in ROOT.De",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:12353,Modifiability,variab,variable,12353,"tentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TProfile3D.h:65; TProfile3D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile3D.cxx:753; TProfile3D::fScalingBool_t fScaling! True when TProfile3D::Scale is calledDefinition TProfile3D.h:38; TProfile3D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile3D.h:50; TProfile3D::FillInt_t Fill(Double_t, Double_t, Double_t) overrideIncrement cell defined by x,y,z by 1 .Definition TProfile3D.h:57; TProfile3D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile3D.cxx:1175; TProfile3D::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile3D histogram to a new profile2D histogram.Definition TProfile3D.cxx:350; TProfile3D::SetBinsvoid SetBins(Int_t, const Double_t *) overrideRedefine x axis parameters with variable bin sizes.Definition TProfile3D.h:79; TProfile3D::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile3D.h:44; TProfile3D::GetBinContentDouble_t GetBinContent(Int_t binx, Int_t biny, Int_t binz) const overrideDefinition TProfile3D.h:113; TProfile3D::FillInt_t Fill(Double_t, const char *, Double_t, Double_t) overrideIncrement cell defined by x,namey,z by a weight w.Definition TProfile3D.h:62; TProfile3D::fTsumwt2Double_t fTsumwt2Total Sum of weight*T*T.Definition TProfile3D.h:40; TProfile3D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)Return bin effective entries for a weighted filled Profile histogram.Definition TProfile3D.cxx:721; TProfile3D::GetStatsvoid GetStats(Double_t *stats) const overridefill the array stats from the contents of this profile.Definition TProfile3D.cxx:785; TProfile3D::FillInt_t Fill(const char *, const char *, const char *, Double_",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile3D_8h_source.html:14472,Modifiability,variab,variable,14472,"le3D::MultiplyBool_t Multiply(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this*c1*f1 .Definition TProfile3D.cxx:902; TProfile3D::LabelsOptionvoid LabelsOption(Option_t *option=""h"", Option_t *axis=""X"") overrideSet option(s) to draw axis with labels.Definition TProfile3D.cxx:875; TProfile3D::TProfile3DTProfile3D()Default constructor for Profile3D histograms.Definition TProfile3D.cxx:76; TProfile3D::FillInt_t Fill(const char *, Double_t, const char *, Double_t) overrideIncrement cell defined by namex,y,namez by a weight w.Definition TProfile3D.h:59; TProfile3D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile3D.h:120; TProfile3D::fBinEntriesTArrayD fBinEntriesNumber of entries per bin.Definition TProfile3D.h:34; TProfile3D::LabelsDeflatevoid LabelsDeflate(Option_t *axis=""X"") overrideReduce the number of bins for this axis to the number of bins having a label.Definition TProfile3D.cxx:847; TProfile3D::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x and y axis parameters with variable bin sizes.Definition TProfile3D.h:83; TProfile3D::~TProfile3D~TProfile3D() overrideDefault destructor for Profile3D histograms.Definition TProfile3D.cxx:86; TProfile3D::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along axis such that x is in the axis range.Definition TProfile3D.cxx:1206; TProfile3D::fTminDouble_t fTminLower limit in T (if set)Definition TProfile3D.h:36; TProfile3D::Scalevoid Scale(Double_t c1=1, Option_t *option="""") overrideMultiply this profile2D by a constant c1.Definition TProfile3D.cxx:1280; TProfile3D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin This is needed to compute the corr...Definition TProfile3D.cxx:1379; TProfile3D::LabelsInflatevoid LabelsInflate(Option_t *axis=""X"") overrideDouble the number of bins for axis.Definition TProfile3D.cxx:857; TProfile3D::Project3DProfileTProfile2D * ",MatchSource.WIKI,doc/master/TProfile3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:1098,Availability,error,error,1098,"rence Guide ; .  . Loading...; Searching...; No Matches. TProfile.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 29/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TProfile.h""; 13#include ""TBuffer.h""; 14#include ""TMath.h""; 15#include ""TF1.h""; 16#include ""THLimitsFinder.h""; 17#include <iostream>; 18#include ""TError.h""; 19#include ""TClass.h""; 20#include ""TObjString.h""; 21 ; 22#include ""TProfileHelper.h""; 23 ; 24Bool_t TProfile::fgApproximate = kFALSE;; 25 ; 26ClassImp(TProfile);; 27 ; 28/** \class TProfile; 29 \ingroup Histograms; 30 Profile Histogram.; 31 Profile histograms are used to display the mean; 32 value of Y and its error for each bin in X. The displayed error is by default the; 33 standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; 34 Profile histograms are in many cases an; 35 elegant replacement of two-dimensional histograms. The inter-relation of two; 36 measured quantities X and Y can always be visualized by a two-dimensional; 37 histogram or scatter plot, but if Y is an unknown (but single-valued); 38 approximate function of X, this function is displayed by a profile histogram with; 39 much better precision than by a scatter plot.; 40 ; 41 The following formulae show the cumulated contents (capital letters) and the values; 42 displayed by the printing or plotting routines (small letters) of the elements for bin j.; 43 \f[; 44 \begin{align}; 45 H(j) &= \sum w \cdot Y \\; 46 E(j) &= \sum w \cdot Y^2 \\; 47 W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; 48 h(j) &= H(j) / W(j) & &\text",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:1137,Availability,error,error,1137,"entation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 29/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TProfile.h""; 13#include ""TBuffer.h""; 14#include ""TMath.h""; 15#include ""TF1.h""; 16#include ""THLimitsFinder.h""; 17#include <iostream>; 18#include ""TError.h""; 19#include ""TClass.h""; 20#include ""TObjString.h""; 21 ; 22#include ""TProfileHelper.h""; 23 ; 24Bool_t TProfile::fgApproximate = kFALSE;; 25 ; 26ClassImp(TProfile);; 27 ; 28/** \class TProfile; 29 \ingroup Histograms; 30 Profile Histogram.; 31 Profile histograms are used to display the mean; 32 value of Y and its error for each bin in X. The displayed error is by default the; 33 standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; 34 Profile histograms are in many cases an; 35 elegant replacement of two-dimensional histograms. The inter-relation of two; 36 measured quantities X and Y can always be visualized by a two-dimensional; 37 histogram or scatter plot, but if Y is an unknown (but single-valued); 38 approximate function of X, this function is displayed by a profile histogram with; 39 much better precision than by a scatter plot.; 40 ; 41 The following formulae show the cumulated contents (capital letters) and the values; 42 displayed by the printing or plotting routines (small letters) of the elements for bin j.; 43 \f[; 44 \begin{align}; 45 H(j) &= \sum w \cdot Y \\; 46 E(j) &= \sum w \cdot Y^2 \\; 47 W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; 48 h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; 49 s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:1174,Availability,error,error,1174,"entation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 29/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TProfile.h""; 13#include ""TBuffer.h""; 14#include ""TMath.h""; 15#include ""TF1.h""; 16#include ""THLimitsFinder.h""; 17#include <iostream>; 18#include ""TError.h""; 19#include ""TClass.h""; 20#include ""TObjString.h""; 21 ; 22#include ""TProfileHelper.h""; 23 ; 24Bool_t TProfile::fgApproximate = kFALSE;; 25 ; 26ClassImp(TProfile);; 27 ; 28/** \class TProfile; 29 \ingroup Histograms; 30 Profile Histogram.; 31 Profile histograms are used to display the mean; 32 value of Y and its error for each bin in X. The displayed error is by default the; 33 standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; 34 Profile histograms are in many cases an; 35 elegant replacement of two-dimensional histograms. The inter-relation of two; 36 measured quantities X and Y can always be visualized by a two-dimensional; 37 histogram or scatter plot, but if Y is an unknown (but single-valued); 38 approximate function of X, this function is displayed by a profile histogram with; 39 much better precision than by a scatter plot.; 40 ; 41 The following formulae show the cumulated contents (capital letters) and the values; 42 displayed by the printing or plotting routines (small letters) of the elements for bin j.; 43 \f[; 44 \begin{align}; 45 H(j) &= \sum w \cdot Y \\; 46 E(j) &= \sum w \cdot Y^2 \\; 47 W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; 48 h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; 49 s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:2209,Availability,error,error,2209,"error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; 34 Profile histograms are in many cases an; 35 elegant replacement of two-dimensional histograms. The inter-relation of two; 36 measured quantities X and Y can always be visualized by a two-dimensional; 37 histogram or scatter plot, but if Y is an unknown (but single-valued); 38 approximate function of X, this function is displayed by a profile histogram with; 39 much better precision than by a scatter plot.; 40 ; 41 The following formulae show the cumulated contents (capital letters) and the values; 42 displayed by the printing or plotting routines (small letters) of the elements for bin j.; 43 \f[; 44 \begin{align}; 45 H(j) &= \sum w \cdot Y \\; 46 E(j) &= \sum w \cdot Y^2 \\; 47 W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; 48 h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; 49 s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; 50 e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; 51 \end{align}; 52 \f]; 53 The bin content is always the mean of the Y values, but errors change depending on options:; 54 \f[; 55 \begin{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 62 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; 63 \end{cases}; 64 \end{align}; 65 \f]; 66 In the special case where s(j) is zero (eg, case of 1 entry only in one bin); 67 the bin error e(j) is computed from the average of the s(j) for all bins if; 68 the static function TProfile::Approximate() has been called.; ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:2315,Availability,error,errors,2315,"error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; 34 Profile histograms are in many cases an; 35 elegant replacement of two-dimensional histograms. The inter-relation of two; 36 measured quantities X and Y can always be visualized by a two-dimensional; 37 histogram or scatter plot, but if Y is an unknown (but single-valued); 38 approximate function of X, this function is displayed by a profile histogram with; 39 much better precision than by a scatter plot.; 40 ; 41 The following formulae show the cumulated contents (capital letters) and the values; 42 displayed by the printing or plotting routines (small letters) of the elements for bin j.; 43 \f[; 44 \begin{align}; 45 H(j) &= \sum w \cdot Y \\; 46 E(j) &= \sum w \cdot Y^2 \\; 47 W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; 48 h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; 49 s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; 50 e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; 51 \end{align}; 52 \f]; 53 The bin content is always the mean of the Y values, but errors change depending on options:; 54 \f[; 55 \begin{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 62 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; 63 \end{cases}; 64 \end{align}; 65 \f]; 66 In the special case where s(j) is zero (eg, case of 1 entry only in one bin); 67 the bin error e(j) is computed from the average of the s(j) for all bins if; 68 the static function TProfile::Approximate() has been called.; ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:3040,Availability,error,error,3040,"\\; 48 h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; 49 s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; 50 e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; 51 \end{align}; 52 \f]; 53 The bin content is always the mean of the Y values, but errors change depending on options:; 54 \f[; 55 \begin{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 62 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; 63 \end{cases}; 64 \end{align}; 65 \f]; 66 In the special case where s(j) is zero (eg, case of 1 entry only in one bin); 67 the bin error e(j) is computed from the average of the s(j) for all bins if; 68 the static function TProfile::Approximate() has been called.; 69 This simple/crude approximation was suggested in order to keep the bin; 70 during a fit operation. But note that this approximation is not the default behaviour.; 71 See also TProfile::BuildOptions for more on error options.; 72 ; 73 ### Creating and drawing a profile histogram; 74~~~{.cpp}; 75{; 76 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 77 auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 78 Float_t px, py, pz;; 79 for ( Int_t i=0; i<25000; i++) {; 80 gRandom->Rannor(px,py);; 81 pz = px*px + py*py;; 82 hprof->Fill(px,pz,1);; 83 }; 84 hprof->Draw();; 85}; 86~~~; 87*/; 88 ; 89////////////////////////////////////////////////////////////////////////////////; 90/// Default constructor for Profile histograms; 91 ; 92TProfile::TProfile(); 93{; 94 BuildOptions(0,0,"""");; 95}; 96 ; 97//////////////",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:3387,Availability,error,error,3387,"{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 62 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; 63 \end{cases}; 64 \end{align}; 65 \f]; 66 In the special case where s(j) is zero (eg, case of 1 entry only in one bin); 67 the bin error e(j) is computed from the average of the s(j) for all bins if; 68 the static function TProfile::Approximate() has been called.; 69 This simple/crude approximation was suggested in order to keep the bin; 70 during a fit operation. But note that this approximation is not the default behaviour.; 71 See also TProfile::BuildOptions for more on error options.; 72 ; 73 ### Creating and drawing a profile histogram; 74~~~{.cpp}; 75{; 76 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 77 auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 78 Float_t px, py, pz;; 79 for ( Int_t i=0; i<25000; i++) {; 80 gRandom->Rannor(px,py);; 81 pz = px*px + py*py;; 82 hprof->Fill(px,pz,1);; 83 }; 84 hprof->Draw();; 85}; 86~~~; 87*/; 88 ; 89////////////////////////////////////////////////////////////////////////////////; 90/// Default constructor for Profile histograms; 91 ; 92TProfile::TProfile(); 93{; 94 BuildOptions(0,0,"""");; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Default destructor for Profile histograms; 99 ; 100TProfile::~TProfile(); 101{; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Normal Constructor for Profile histograms.; 106///; 107/// The first five ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:5080,Availability,error,errors,5080," for Profile histograms; 99 ; 100TProfile::~TProfile(); 101{; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Normal Constructor for Profile histograms.; 106///; 107/// The first five parameters are similar to TH1D::TH1D.; 108/// All values of y are accepted at filling time.; 109/// To fill a profile histogram, one must use TProfile::Fill function.; 110///; 111/// Note that when filling the profile histogram the function Fill; 112/// checks if the variable y is between fYmin and fYmax.; 113/// If a minimum or maximum value is set for the Y scale before filling,; 114/// then all values below ymin or above ymax will be discarded.; 115/// Setting the minimum or maximum value for the Y scale before filling; 116/// has the same effect as calling the special TProfile constructor below; 117/// where ymin and ymax are specified.; 118///; 119/// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; 120/// (spread option), or e(j) if `CHOPT`='' (error on mean).; 121///; 122/// See TProfile::BuildOptions() for explanation of parameters; 123///; 124/// see also comments in the TH1 base class constructors; 125 ; 126TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Option_t *option); 127: TH1D(name,title,nbins,xlow,xup); 128{; 129 BuildOptions(0,0,option);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Constructor for Profile histograms with variable bin size.; 134///; 135/// See TProfile::BuildOptions() for more explanations on errors; 136/// see also comments in the TH1 base class constructors; 137 ; 138TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Float_t *xbins,Option_t *option); 139: TH1D(name,title,nbins,xbins); 140{; 141 BuildOptions(0,0,option);; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Constructo",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:5170,Availability,error,error,5170," for Profile histograms; 99 ; 100TProfile::~TProfile(); 101{; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Normal Constructor for Profile histograms.; 106///; 107/// The first five parameters are similar to TH1D::TH1D.; 108/// All values of y are accepted at filling time.; 109/// To fill a profile histogram, one must use TProfile::Fill function.; 110///; 111/// Note that when filling the profile histogram the function Fill; 112/// checks if the variable y is between fYmin and fYmax.; 113/// If a minimum or maximum value is set for the Y scale before filling,; 114/// then all values below ymin or above ymax will be discarded.; 115/// Setting the minimum or maximum value for the Y scale before filling; 116/// has the same effect as calling the special TProfile constructor below; 117/// where ymin and ymax are specified.; 118///; 119/// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; 120/// (spread option), or e(j) if `CHOPT`='' (error on mean).; 121///; 122/// See TProfile::BuildOptions() for explanation of parameters; 123///; 124/// see also comments in the TH1 base class constructors; 125 ; 126TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Option_t *option); 127: TH1D(name,title,nbins,xlow,xup); 128{; 129 BuildOptions(0,0,option);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Constructor for Profile histograms with variable bin size.; 134///; 135/// See TProfile::BuildOptions() for more explanations on errors; 136/// see also comments in the TH1 base class constructors; 137 ; 138TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Float_t *xbins,Option_t *option); 139: TH1D(name,title,nbins,xbins); 140{; 141 BuildOptions(0,0,option);; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Constructo",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:5760,Availability,error,errors,5760,"ing the special TProfile constructor below; 117/// where ymin and ymax are specified.; 118///; 119/// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; 120/// (spread option), or e(j) if `CHOPT`='' (error on mean).; 121///; 122/// See TProfile::BuildOptions() for explanation of parameters; 123///; 124/// see also comments in the TH1 base class constructors; 125 ; 126TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Option_t *option); 127: TH1D(name,title,nbins,xlow,xup); 128{; 129 BuildOptions(0,0,option);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Constructor for Profile histograms with variable bin size.; 134///; 135/// See TProfile::BuildOptions() for more explanations on errors; 136/// see also comments in the TH1 base class constructors; 137 ; 138TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Float_t *xbins,Option_t *option); 139: TH1D(name,title,nbins,xbins); 140{; 141 BuildOptions(0,0,option);; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Constructor for Profile histograms with variable bin size.; 146///; 147/// See TProfile::BuildOptions for more explanations on errors; 148/// see also comments in the TH1 base class constructors; 149 ; 150TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Option_t *option); 151: TH1D(name,title,nbins,xbins); 152{; 153 BuildOptions(0,0,option);; 154}; 155 ; 156////////////////////////////////////////////////////////////////////////////////; 157/// Constructor for Profile histograms with variable bin size.; 158/// See TProfile::BuildOptions for more explanations on errors; 159///; 160/// see also comments in the TH1 base class constructors; 161 ; 162TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Double_t ylow,Double_t yup,Option",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:6247,Availability,error,errors,6247,"uble_t xup,Option_t *option); 127: TH1D(name,title,nbins,xlow,xup); 128{; 129 BuildOptions(0,0,option);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Constructor for Profile histograms with variable bin size.; 134///; 135/// See TProfile::BuildOptions() for more explanations on errors; 136/// see also comments in the TH1 base class constructors; 137 ; 138TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Float_t *xbins,Option_t *option); 139: TH1D(name,title,nbins,xbins); 140{; 141 BuildOptions(0,0,option);; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Constructor for Profile histograms with variable bin size.; 146///; 147/// See TProfile::BuildOptions for more explanations on errors; 148/// see also comments in the TH1 base class constructors; 149 ; 150TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Option_t *option); 151: TH1D(name,title,nbins,xbins); 152{; 153 BuildOptions(0,0,option);; 154}; 155 ; 156////////////////////////////////////////////////////////////////////////////////; 157/// Constructor for Profile histograms with variable bin size.; 158/// See TProfile::BuildOptions for more explanations on errors; 159///; 160/// see also comments in the TH1 base class constructors; 161 ; 162TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Double_t ylow,Double_t yup,Option_t *option); 163: TH1D(name,title,nbins,xbins); 164{; 165 BuildOptions(ylow,yup,option);; 166}; 167 ; 168////////////////////////////////////////////////////////////////////////////////; 169/// Constructor for Profile histograms with range in y.; 170///; 171/// The first five parameters are similar to TH1D::TH1D.; 172/// Only the values of Y between ylow and yup will be considered at filling time.; 173/// ylow and yup will also be the maximum and minimum values; 174/// on the y scale",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:6727,Availability,error,errors,6727,"ns,Option_t *option); 139: TH1D(name,title,nbins,xbins); 140{; 141 BuildOptions(0,0,option);; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Constructor for Profile histograms with variable bin size.; 146///; 147/// See TProfile::BuildOptions for more explanations on errors; 148/// see also comments in the TH1 base class constructors; 149 ; 150TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Option_t *option); 151: TH1D(name,title,nbins,xbins); 152{; 153 BuildOptions(0,0,option);; 154}; 155 ; 156////////////////////////////////////////////////////////////////////////////////; 157/// Constructor for Profile histograms with variable bin size.; 158/// See TProfile::BuildOptions for more explanations on errors; 159///; 160/// see also comments in the TH1 base class constructors; 161 ; 162TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Double_t ylow,Double_t yup,Option_t *option); 163: TH1D(name,title,nbins,xbins); 164{; 165 BuildOptions(ylow,yup,option);; 166}; 167 ; 168////////////////////////////////////////////////////////////////////////////////; 169/// Constructor for Profile histograms with range in y.; 170///; 171/// The first five parameters are similar to TH1D::TH1D.; 172/// Only the values of Y between ylow and yup will be considered at filling time.; 173/// ylow and yup will also be the maximum and minimum values; 174/// on the y scale when drawing the profile.; 175///; 176/// See TProfile::BuildOptions for more explanations on errors; 177///; 178/// see also comments in the TH1 base class constructors; 179 ; 180TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Double_t ylow,Double_t yup,Option_t *option); 181: TH1D(name,title,nbins,xlow,xup); 182{; 183 BuildOptions(ylow,yup,option);; 184}; 185 ; 186 ; 187////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:7517,Availability,error,errors,7517,"xplanations on errors; 159///; 160/// see also comments in the TH1 base class constructors; 161 ; 162TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Double_t ylow,Double_t yup,Option_t *option); 163: TH1D(name,title,nbins,xbins); 164{; 165 BuildOptions(ylow,yup,option);; 166}; 167 ; 168////////////////////////////////////////////////////////////////////////////////; 169/// Constructor for Profile histograms with range in y.; 170///; 171/// The first five parameters are similar to TH1D::TH1D.; 172/// Only the values of Y between ylow and yup will be considered at filling time.; 173/// ylow and yup will also be the maximum and minimum values; 174/// on the y scale when drawing the profile.; 175///; 176/// See TProfile::BuildOptions for more explanations on errors; 177///; 178/// see also comments in the TH1 base class constructors; 179 ; 180TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Double_t ylow,Double_t yup,Option_t *option); 181: TH1D(name,title,nbins,xlow,xup); 182{; 183 BuildOptions(ylow,yup,option);; 184}; 185 ; 186 ; 187////////////////////////////////////////////////////////////////////////////////; 188/// Set Profile histogram structure and options.; 189///; 190/// \param[in] ymin minimum value allowed for y; 191/// \param[in] ymax maximum value allowed for y; 192/// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); 193/// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:8263,Availability,error,error,8263,"up will be considered at filling time.; 173/// ylow and yup will also be the maximum and minimum values; 174/// on the y scale when drawing the profile.; 175///; 176/// See TProfile::BuildOptions for more explanations on errors; 177///; 178/// see also comments in the TH1 base class constructors; 179 ; 180TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Double_t ylow,Double_t yup,Option_t *option); 181: TH1D(name,title,nbins,xlow,xup); 182{; 183 BuildOptions(ylow,yup,option);; 184}; 185 ; 186 ; 187////////////////////////////////////////////////////////////////////////////////; 188/// Set Profile histogram structure and options.; 189///; 190/// \param[in] ymin minimum value allowed for y; 191/// \param[in] ymax maximum value allowed for y; 192/// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); 193/// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/S",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:8387,Availability,error,errors,8387,"up will be considered at filling time.; 173/// ylow and yup will also be the maximum and minimum values; 174/// on the y scale when drawing the profile.; 175///; 176/// See TProfile::BuildOptions for more explanations on errors; 177///; 178/// see also comments in the TH1 base class constructors; 179 ; 180TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Double_t ylow,Double_t yup,Option_t *option); 181: TH1D(name,title,nbins,xlow,xup); 182{; 183 BuildOptions(ylow,yup,option);; 184}; 185 ; 186 ; 187////////////////////////////////////////////////////////////////////////////////; 188/// Set Profile histogram structure and options.; 189///; 190/// \param[in] ymin minimum value allowed for y; 191/// \param[in] ymax maximum value allowed for y; 192/// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); 193/// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/S",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:8411,Availability,error,error,8411,"up will be considered at filling time.; 173/// ylow and yup will also be the maximum and minimum values; 174/// on the y scale when drawing the profile.; 175///; 176/// See TProfile::BuildOptions for more explanations on errors; 177///; 178/// see also comments in the TH1 base class constructors; 179 ; 180TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Double_t ylow,Double_t yup,Option_t *option); 181: TH1D(name,title,nbins,xlow,xup); 182{; 183 BuildOptions(ylow,yup,option);; 184}; 185 ; 186 ; 187////////////////////////////////////////////////////////////////////////////////; 188/// Set Profile histogram structure and options.; 189///; 190/// \param[in] ymin minimum value allowed for y; 191/// \param[in] ymax maximum value allowed for y; 192/// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); 193/// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/S",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:8623,Availability,error,errors,8623,"nbins,xlow,xup); 182{; 183 BuildOptions(ylow,yup,option);; 184}; 185 ; 186 ; 187////////////////////////////////////////////////////////////////////////////////; 188/// Set Profile histogram structure and options.; 189///; 190/// \param[in] ymin minimum value allowed for y; 191/// \param[in] ymax maximum value allowed for y; 192/// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); 193/// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 2",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:8647,Availability,error,error,8647,"nbins,xlow,xup); 182{; 183 BuildOptions(ylow,yup,option);; 184}; 185 ; 186 ; 187////////////////////////////////////////////////////////////////////////////////; 188/// Set Profile histogram structure and options.; 189///; 190/// \param[in] ymin minimum value allowed for y; 191/// \param[in] ymax maximum value allowed for y; 192/// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); 193/// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 2",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:8795,Availability,error,error,8795,"nbins,xlow,xup); 182{; 183 BuildOptions(ylow,yup,option);; 184}; 185 ; 186 ; 187////////////////////////////////////////////////////////////////////////////////; 188/// Set Profile histogram structure and options.; 189///; 190/// \param[in] ymin minimum value allowed for y; 191/// \param[in] ymax maximum value allowed for y; 192/// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); 193/// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 2",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:8935,Availability,error,error,8935,"re and options.; 189///; 190/// \param[in] ymin minimum value allowed for y; 191/// \param[in] ymax maximum value allowed for y; 192/// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); 193/// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:8994,Availability,error,error,8994,"re and options.; 189///; 190/// \param[in] ymin minimum value allowed for y; 191/// \param[in] ymax maximum value allowed for y; 192/// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); 193/// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:9285,Availability,error,error,9285,":GetBinError ); 194/// possible values for the options are:; 195/// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); 196/// where S(Y) is the standard deviation (RMS) of the Y data in the bin; 197/// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); 217///; 218/// If a bin has N data points all with the same value Y (especially; 219/// possible when dealing with integers), the spread in Y for that bin; 220/// is zero, and the uncertainty assigned is also zero, and the bin is; 221/// ignored in making subsequent fits.; 222/// T",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:9462,Availability,error,errors,9462,"// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); 217///; 218/// If a bin has N data points all with the same value Y (especially; 219/// possible when dealing with integers), the spread in Y for that bin; 220/// is zero, and the uncertainty assigned is also zero, and the bin is; 221/// ignored in making subsequent fits.; 222/// To avoid this problem one can use an approximation for the standard deviation S(Y),; 223/// by using the average of all the S(Y) of the other Profile bins. To use this approximation; 224/// one must call before TProfile::Approximate; 22",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:9584,Availability,error,error,9584,"// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); 217///; 218/// If a bin has N data points all with the same value Y (especially; 219/// possible when dealing with integers), the spread in Y for that bin; 220/// is zero, and the uncertainty assigned is also zero, and the bin is; 221/// ignored in making subsequent fits.; 222/// To avoid this problem one can use an approximation for the standard deviation S(Y),; 223/// by using the average of all the S(Y) of the other Profile bins. To use this approximation; 224/// one must call before TProfile::Approximate; 22",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:9700,Availability,error,error,9700,"// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); 217///; 218/// If a bin has N data points all with the same value Y (especially; 219/// possible when dealing with integers), the spread in Y for that bin; 220/// is zero, and the uncertainty assigned is also zero, and the bin is; 221/// ignored in making subsequent fits.; 222/// To avoid this problem one can use an approximation for the standard deviation S(Y),; 223/// by using the average of all the S(Y) of the other Profile bins. To use this approximation; 224/// one must call before TProfile::Approximate; 22",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:13391,Availability,error,error,13391,"_t c2); 292{; 293 if (!h1 || !h2) {; 294 Error(""Add"",""Attempt to add a non-existing profile"");; 295 return kFALSE;; 296 }; 297 if (!h1->InheritsFrom(TProfile::Class())) {; 298 Error(""Add"",""Attempt to add a non-profile object"");; 299 return kFALSE;; 300 }; 301 if (!h2->InheritsFrom(TProfile::Class())) {; 302 Error(""Add"",""Attempt to add a non-profile object"");; 303 return kFALSE;; 304 }; 305 Bool_t ret = TProfileHelper::Add(this, h1, h2, c1, c2);; 306 if (c1 < 0 || c2 < 0); 307 ResetStats();; 308 return ret;; 309}; 310 ; 311 ; 312////////////////////////////////////////////////////////////////////////////////; 313/// Static function to set the fgApproximate flag.; 314///; 315///When the flag is true, the function GetBinError; 316/// will approximate the bin error with the average profile error on all bins; 317/// in the following situation only; 318///; 319/// - the number of bins in the profile is less than 1002; 320/// - the bin number of entries is small ( <5); 321/// - the estimated bin error is extremely small compared to the bin content; 322/// (see TProfile::GetBinError); 323 ; 324void TProfile::Approximate(Bool_t approx); 325{; 326 fgApproximate = approx;; 327}; 328 ; 329////////////////////////////////////////////////////////////////////////////////; 330/// Fill histogram with all entries in the buffer.; 331///; 332/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 333/// - action = 0 histogram is filled from the buffer; 334/// - action = 1 histogram is filled and buffer is deleted; 335/// The buffer is automatically deleted when the number of entries; 336/// in the buffer is greater than the number of entries in the histogram; 337 ; 338Int_t TProfile::BufferEmpty(Int_t action); 339{; 340 // do we need to compute the bin size?; 341 if (!fBuffer) return 0;; 342 Int_t nbentries = (Int_t)fBuffer[0];; 343 if (!nbentries) return 0;; 344 Double_t *buffer = fBuffer;; 345 if (nbentries < 0) {; 346 if (action == 0) retur",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:13422,Availability,error,error,13422,"_t c2); 292{; 293 if (!h1 || !h2) {; 294 Error(""Add"",""Attempt to add a non-existing profile"");; 295 return kFALSE;; 296 }; 297 if (!h1->InheritsFrom(TProfile::Class())) {; 298 Error(""Add"",""Attempt to add a non-profile object"");; 299 return kFALSE;; 300 }; 301 if (!h2->InheritsFrom(TProfile::Class())) {; 302 Error(""Add"",""Attempt to add a non-profile object"");; 303 return kFALSE;; 304 }; 305 Bool_t ret = TProfileHelper::Add(this, h1, h2, c1, c2);; 306 if (c1 < 0 || c2 < 0); 307 ResetStats();; 308 return ret;; 309}; 310 ; 311 ; 312////////////////////////////////////////////////////////////////////////////////; 313/// Static function to set the fgApproximate flag.; 314///; 315///When the flag is true, the function GetBinError; 316/// will approximate the bin error with the average profile error on all bins; 317/// in the following situation only; 318///; 319/// - the number of bins in the profile is less than 1002; 320/// - the bin number of entries is small ( <5); 321/// - the estimated bin error is extremely small compared to the bin content; 322/// (see TProfile::GetBinError); 323 ; 324void TProfile::Approximate(Bool_t approx); 325{; 326 fgApproximate = approx;; 327}; 328 ; 329////////////////////////////////////////////////////////////////////////////////; 330/// Fill histogram with all entries in the buffer.; 331///; 332/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 333/// - action = 0 histogram is filled from the buffer; 334/// - action = 1 histogram is filled and buffer is deleted; 335/// The buffer is automatically deleted when the number of entries; 336/// in the buffer is greater than the number of entries in the histogram; 337 ; 338Int_t TProfile::BufferEmpty(Int_t action); 339{; 340 // do we need to compute the bin size?; 341 if (!fBuffer) return 0;; 342 Int_t nbentries = (Int_t)fBuffer[0];; 343 if (!nbentries) return 0;; 344 Double_t *buffer = fBuffer;; 345 if (nbentries < 0) {; 346 if (action == 0) retur",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:13629,Availability,error,error,13629,"_t c2); 292{; 293 if (!h1 || !h2) {; 294 Error(""Add"",""Attempt to add a non-existing profile"");; 295 return kFALSE;; 296 }; 297 if (!h1->InheritsFrom(TProfile::Class())) {; 298 Error(""Add"",""Attempt to add a non-profile object"");; 299 return kFALSE;; 300 }; 301 if (!h2->InheritsFrom(TProfile::Class())) {; 302 Error(""Add"",""Attempt to add a non-profile object"");; 303 return kFALSE;; 304 }; 305 Bool_t ret = TProfileHelper::Add(this, h1, h2, c1, c2);; 306 if (c1 < 0 || c2 < 0); 307 ResetStats();; 308 return ret;; 309}; 310 ; 311 ; 312////////////////////////////////////////////////////////////////////////////////; 313/// Static function to set the fgApproximate flag.; 314///; 315///When the flag is true, the function GetBinError; 316/// will approximate the bin error with the average profile error on all bins; 317/// in the following situation only; 318///; 319/// - the number of bins in the profile is less than 1002; 320/// - the bin number of entries is small ( <5); 321/// - the estimated bin error is extremely small compared to the bin content; 322/// (see TProfile::GetBinError); 323 ; 324void TProfile::Approximate(Bool_t approx); 325{; 326 fgApproximate = approx;; 327}; 328 ; 329////////////////////////////////////////////////////////////////////////////////; 330/// Fill histogram with all entries in the buffer.; 331///; 332/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 333/// - action = 0 histogram is filled from the buffer; 334/// - action = 1 histogram is filled and buffer is deleted; 335/// The buffer is automatically deleted when the number of entries; 336/// in the buffer is greater than the number of entries in the histogram; 337 ; 338Int_t TProfile::BufferEmpty(Int_t action); 339{; 340 // do we need to compute the bin size?; 341 if (!fBuffer) return 0;; 342 Int_t nbentries = (Int_t)fBuffer[0];; 343 if (!nbentries) return 0;; 344 Double_t *buffer = fBuffer;; 345 if (nbentries < 0) {; 346 if (action == 0) retur",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:20280,Availability,error,error,20280,"7 Double_t e0,e1,c12;; 498 if (h1->InheritsFrom(TProfile::Class())) {; 499 cu1 = p1->GetW();; 500 er1 = p1->GetW2();; 501 en1 = p1->GetB();; 502 }; 503 Double_t c0,c1,w,z,x;; 504 for (bin=0;bin<=nbinsx+1;bin++) {; 505 c0 = fArray[bin];; 506 if (cu1) c1 = cu1[bin];; 507 else c1 = h1->GetBinContent(bin);; 508 if (c1) w = c0/c1;; 509 else w = 0;; 510 fArray[bin] = w;; 511 z = TMath::Abs(w);; 512 x = fXaxis.GetBinCenter(bin);; 513 fEntries++;; 514 fTsumw += z;; 515 fTsumw2 += z*z;; 516 fTsumwx += z*x;; 517 fTsumwx2 += z*x*x;; 518 fTsumwy += z*c1;; 519 fTsumwx2 += z*c1*c1;; 520 e0 = fSumw2.fArray[bin];; 521 if (er1) e1 = er1[bin];; 522 else {e1 = h1->GetBinError(bin); e1*=e1;}; 523 c12= c1*c1;; 524 if (!c1) fSumw2.fArray[bin] = 0;; 525 else fSumw2.fArray[bin] = (e0*c1*c1 + e1*c0*c0)/(c12*c12);; 526 if (!en1) continue;; 527 if (!en1[bin]) fBinEntries.fArray[bin] = 0;; 528 else fBinEntries.fArray[bin] /= en1[bin];; 529 }; 530 // maintaining the correct sum of weights square is not supported when dividing; 531 // bin error resulting from division of profile needs to be checked; 532 if (fBinSumw2.fN) {; 533 Warning(""Divide"",""Cannot preserve during the division of profiles the sum of bin weight square"");; 534 fBinSumw2 = TArrayD();; 535 }; 536 ; 537 return kTRUE;; 538}; 539 ; 540////////////////////////////////////////////////////////////////////////////////; 541/// Replace contents of this profile by the division of h1 by h2.; 542///; 543/// `this = c1*h1/(c2*h2)`; 544///; 545/// The function return kFALSE if the divide operation failed; 546 ; 547Bool_t TProfile::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 548{; 549 TString opt = option;; 550 opt.ToLower();; 551 Bool_t binomial = kFALSE;; 552 if (opt.Contains(""b"")) binomial = kTRUE;; 553 if (!h1 || !h2) {; 554 Error(""Divide"",""Attempt to divide a non-existing profile"");; 555 return kFALSE;; 556 }; 557 if (!h1->InheritsFrom(TProfile::Class())) {; 558 Error(""Divide"",""Attempt to divide a non-",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:22130,Availability,error,errors,22130,"it is there since it will become invalid; 569 if (fBuffer) BufferEmpty(1);; 570 ; 571 Int_t nbinsx = GetNbinsX();; 572 //- Check histogram compatibility; 573 if (nbinsx != p1->GetNbinsX() || nbinsx != p2->GetNbinsX()) {; 574 Error(""Divide"",""Attempt to divide profiles with different number of bins"");; 575 return kFALSE;; 576 }; 577 if (!c2) {; 578 Error(""Divide"",""Coefficient of dividing profile cannot be zero"");; 579 return kFALSE;; 580 }; 581 ; 582 //THE ALGORITHM COMPUTING THE ERRORS IS WRONG. HELP REQUIRED; 583 printf(""WARNING!!: The algorithm in TProfile::Divide computing the errors is not accurate\n"");; 584 printf("" Instead of Divide(TProfile *h1, TProfile *h2), do:\n"");; 585 printf("" TH1D *p1 = h1->ProjectionX();\n"");; 586 printf("" TH1D *p2 = h2->ProjectionX();\n"");; 587 printf("" p1->Divide(p2);\n"");; 588 ; 589 //- Reset statistics; 590 fEntries = fTsumw = fTsumw2 = fTsumwx = fTsumwx2 = 0;; 591 ; 592 //- Loop on bins (including underflows/overflows); 593 Int_t bin;; 594 Double_t *cu1 = p1->GetW();; 595 Double_t *cu2 = p2->GetW();; 596 Double_t *er1 = p1->GetW2();; 597 Double_t *er2 = p2->GetW2();; 598 Double_t *en1 = p1->GetB();; 599 Double_t *en2 = p2->GetB();; 600 Double_t b1,b2,w,z,x,ac1,ac2;; 601 //d1 = c1*c1;; 602 //d2 = c2*c2;; 603 ac1 = TMath::Abs(c1);; 604 ac2 = TMath::Abs(c2);; 605 for (bin=0;bin<=nbinsx+1;bin++) {; 606 b1 = cu1[bin];; 607 b2 = cu2[bin];; 608 if (b2) w = c1*b1/(c2*b2);; 609 else w = 0;; 610 fArray[bin] = w;; 611 z = TMath::Abs(w);; 612 x = fXaxis.GetBinCenter(bin);; 613 fEntries++;; 614 fTsumw += z;; 615 fTsumw2 += z*z;; 616 fTsumwx += z*x;; 617 fTsumwx2 += z*x*x;; 618 //fTsumwy += z*x;; 619 //fTsumwy2 += z*x*x;; 620 Double_t e1 = er1[bin];; 621 Double_t e2 = er2[bin];; 622 //Double_t b22= b2*b2*d2;; 623 Double_t b22= b2*b2*TMath::Abs(c2);; 624 if (!b2) fSumw2.fArray[bin] = 0;; 625 else {; 626 if (binomial) {; 627 fSumw2.fArray[bin] = TMath::Abs(w*(1-w)/b2);; 628 } else {; 629 //fSumw2.fArray[bin] = d1*d2*(e1*b2*b2 + e2*b1*b1)/(b22*b22)",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:23841,Availability,error,error,23841,"h::Abs(c1);; 604 ac2 = TMath::Abs(c2);; 605 for (bin=0;bin<=nbinsx+1;bin++) {; 606 b1 = cu1[bin];; 607 b2 = cu2[bin];; 608 if (b2) w = c1*b1/(c2*b2);; 609 else w = 0;; 610 fArray[bin] = w;; 611 z = TMath::Abs(w);; 612 x = fXaxis.GetBinCenter(bin);; 613 fEntries++;; 614 fTsumw += z;; 615 fTsumw2 += z*z;; 616 fTsumwx += z*x;; 617 fTsumwx2 += z*x*x;; 618 //fTsumwy += z*x;; 619 //fTsumwy2 += z*x*x;; 620 Double_t e1 = er1[bin];; 621 Double_t e2 = er2[bin];; 622 //Double_t b22= b2*b2*d2;; 623 Double_t b22= b2*b2*TMath::Abs(c2);; 624 if (!b2) fSumw2.fArray[bin] = 0;; 625 else {; 626 if (binomial) {; 627 fSumw2.fArray[bin] = TMath::Abs(w*(1-w)/b2);; 628 } else {; 629 //fSumw2.fArray[bin] = d1*d2*(e1*b2*b2 + e2*b1*b1)/(b22*b22);; 630 fSumw2.fArray[bin] = ac1*ac2*(e1*b2*b2 + e2*b1*b1)/(b22*b22);; 631 }; 632 }; 633 if (en2[bin]) fBinEntries.fArray[bin] = en1[bin]/en2[bin];; 634 else fBinEntries.fArray[bin] = 0;; 635 }; 636 ; 637 // maintaining the correct sum of weights square is not supported when dividing; 638 // bin error resulting from division of profile needs to be checked; 639 if (fBinSumw2.fN) {; 640 Warning(""Divide"",""Cannot preserve during the division of profiles the sum of bin weight square"");; 641 fBinSumw2 = TArrayD();; 642 }; 643 ; 644 return kTRUE;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Fill a Profile histogram (no weights).; 649 ; 650Int_t TProfile::Fill(Double_t x, Double_t y); 651{; 652 if (fBuffer) return BufferFill(x,y,1);; 653 ; 654 Int_t bin;; 655 if (fYmin != fYmax) {; 656 if (y <fYmin || y> fYmax || TMath::IsNaN(y) ) return -1;; 657 }; 658 ; 659 fEntries++;; 660 bin =fXaxis.FindBin(x);; 661 AddBinContent(bin, y);; 662 fSumw2.fArray[bin] += (Double_t)y*y;; 663 fBinEntries.fArray[bin] += 1;; 664 if (fBinSumw2.fN) fBinSumw2.fArray[bin] += 1;; 665 if (bin == 0 || bin > fXaxis.GetNbins()) {; 666 if (!GetStatOverflowsBehaviour()) return -1;; 667 }; 668 fTsumw++;; 669 fTsumw2++;; 670 fTsumwx += x",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:31114,Availability,error,error,31114,"836 ; 837Double_t TProfile::GetBinEntries(Int_t bin) const; 838{; 839 if (fBuffer) ((TProfile*)this)->BufferEmpty();; 840 ; 841 if (bin < 0 || bin >= fNcells) return 0;; 842 return fBinEntries.fArray[bin];; 843}; 844 ; 845////////////////////////////////////////////////////////////////////////////////; 846/// Return bin effective entries for a weighted filled Profile histogram.; 847/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 848/// The effective entries is defined as the square of the sum of the weights divided by the; 849/// sum of the weights square.; 850/// TProfile::Sumw2() must be called before filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average er",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:31169,Availability,error,errors,31169,"836 ; 837Double_t TProfile::GetBinEntries(Int_t bin) const; 838{; 839 if (fBuffer) ((TProfile*)this)->BufferEmpty();; 840 ; 841 if (bin < 0 || bin >= fNcells) return 0;; 842 return fBinEntries.fArray[bin];; 843}; 844 ; 845////////////////////////////////////////////////////////////////////////////////; 846/// Return bin effective entries for a weighted filled Profile histogram.; 847/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 848/// The effective entries is defined as the square of the sum of the weights divided by the; 849/// sum of the weights square.; 850/// TProfile::Sumw2() must be called before filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average er",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:31227,Availability,error,errors,31227,"836 ; 837Double_t TProfile::GetBinEntries(Int_t bin) const; 838{; 839 if (fBuffer) ((TProfile*)this)->BufferEmpty();; 840 ; 841 if (bin < 0 || bin >= fNcells) return 0;; 842 return fBinEntries.fArray[bin];; 843}; 844 ; 845////////////////////////////////////////////////////////////////////////////////; 846/// Return bin effective entries for a weighted filled Profile histogram.; 847/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 848/// The effective entries is defined as the square of the sum of the weights divided by the; 849/// sum of the weights square.; 850/// TProfile::Sumw2() must be called before filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average er",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:31327,Availability,error,errors,31327,"////////////////////////////////////////////; 846/// Return bin effective entries for a weighted filled Profile histogram.; 847/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 848/// The effective entries is defined as the square of the sum of the weights divided by the; 849/// sum of the weights square.; 850/// TProfile::Sumw2() must be called before filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average error on all bins for these low; 876/// statistics bins giving a very small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 87",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:31497,Availability,error,errors,31497,"ghted profile, it is equivalent to the number of entries per bin; 848/// The effective entries is defined as the square of the sum of the weights divided by the; 849/// sum of the weights square.; 850/// TProfile::Sumw2() must be called before filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average error on all bins for these low; 876/// statistics bins giving a very small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 879/// generated a N^2 problem when projecting a TProfile with a large number of; 880/// bins (eg 100000).; 881/// - in version 3.05/06, a new static fun",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:31719,Availability,error,errors,31719,"efore filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average error on all bins for these low; 876/// statistics bins giving a very small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 879/// generated a N^2 problem when projecting a TProfile with a large number of; 880/// bins (eg 100000).; 881/// - in version 3.05/06, a new static function TProfile::Approximate; 882/// is introduced to enable or disable (default) the approximation.; 883///; 884/// Ideas for improvements of this algorithm are welcome. No suggestions; 885/// received since our call for advice to roottal",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:31749,Availability,error,errors,31749,"efore filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average error on all bins for these low; 876/// statistics bins giving a very small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 879/// generated a N^2 problem when projecting a TProfile with a large number of; 880/// bins (eg 100000).; 881/// - in version 3.05/06, a new static function TProfile::Approximate; 882/// is introduced to enable or disable (default) the approximation.; 883///; 884/// Ideas for improvements of this algorithm are welcome. No suggestions; 885/// received since our call for advice to roottal",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:32070,Availability,error,error,32070,"///////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average error on all bins for these low; 876/// statistics bins giving a very small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 879/// generated a N^2 problem when projecting a TProfile with a large number of; 880/// bins (eg 100000).; 881/// - in version 3.05/06, a new static function TProfile::Approximate; 882/// is introduced to enable or disable (default) the approximation.; 883///; 884/// Ideas for improvements of this algorithm are welcome. No suggestions; 885/// received since our call for advice to roottalk in Jul 2002.; 886/// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html; 887 ; 888Double_t TProfile::GetBinError(Int_t bin) const; 889{; 890 return TProfileHelper::GetBinError((TProfile*)this, bin);; 891}; 892 ; 893////////////////////////////////////////////////////////////////////////////////; 894/// Return option to compute ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:33076,Availability,error,errors,33076,"ery small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 879/// generated a N^2 problem when projecting a TProfile with a large number of; 880/// bins (eg 100000).; 881/// - in version 3.05/06, a new static function TProfile::Approximate; 882/// is introduced to enable or disable (default) the approximation.; 883///; 884/// Ideas for improvements of this algorithm are welcome. No suggestions; 885/// received since our call for advice to roottalk in Jul 2002.; 886/// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html; 887 ; 888Double_t TProfile::GetBinError(Int_t bin) const; 889{; 890 return TProfileHelper::GetBinError((TProfile*)this, bin);; 891}; 892 ; 893////////////////////////////////////////////////////////////////////////////////; 894/// Return option to compute profile errors; 895 ; 896Option_t *TProfile::GetErrorOption() const; 897{; 898 if (fErrorMode == kERRORSPREAD) return ""s"";; 899 if (fErrorMode == kERRORSPREADI) return ""i"";; 900 if (fErrorMode == kERRORSPREADG) return ""g"";; 901 return """";; 902}; 903 ; 904////////////////////////////////////////////////////////////////////////////////; 905/// fill the array stats from the contents of this profile.; 906///; 907/// The array stats must be correctly dimensioned in the calling program.; 908///; 909/// - stats[0] = sumw; 910/// - stats[1] = sumw2; 911/// - stats[2] = sumwx; 912/// - stats[3] = sumwx2; 913/// - stats[4] = sumwy; 914/// - stats[5] = sumwy2; 915///; 916/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 917/// is simply a copy of the statistics quantities computed at filling time.; 918/// If a sub-range is specified, the function recomputes these quantities; 919/// from the bin contents in the current axis range.; 920 ; 921void TProfile::GetStats(Double_t *stats) const; 922{; 923 if (fBuffer) ((TProfile*)this)->BufferEmp",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:36972,Availability,down,down,36972,"///////////////////////////////////////////////////////////; 971/// Reduce the number of bins for this axis to the number of bins having a label.; 972 ; 973void TProfile::LabelsDeflate(Option_t *option); 974{; 975 TProfileHelper::LabelsDeflate(this, option);; 976}; 977 ; 978////////////////////////////////////////////////////////////////////////////////; 979/// Double the number of bins for axis.; 980/// Refill histogram; 981/// This function is called by TAxis::FindBin(const char *label); 982 ; 983void TProfile::LabelsInflate(Option_t *options); 984{; 985 TProfileHelper::LabelsInflate(this, options);; 986}; 987 ; 988////////////////////////////////////////////////////////////////////////////////; 989/// Set option(s) to draw axis with labels.; 990///; 991/// option might have the following values:; 992///; 993/// - ""a"" sort by alphabetic order; 994/// - "">"" sort by decreasing values; 995/// - ""<"" sort by increasing values; 996/// - ""h"" draw labels horizontal; 997/// - ""v"" draw labels vertical; 998/// - ""u"" draw labels up (end of label right adjusted); 999/// - ""d"" draw labels down (start of label left adjusted); 1000 ; 1001void TProfile::LabelsOption(Option_t *option, Option_t * /*ax */); 1002{; 1003 THashList *labels = fXaxis.GetLabels();; 1004 if (!labels) {; 1005 Warning(""LabelsOption"",""Cannot sort. No labels"");; 1006 return;; 1007 }; 1008 TString opt = option;; 1009 opt.ToLower();; 1010 if (opt.Contains(""h"")) {; 1011 fXaxis.SetBit(TAxis::kLabelsHori);; 1012 fXaxis.ResetBit(TAxis::kLabelsVert);; 1013 fXaxis.ResetBit(TAxis::kLabelsDown);; 1014 fXaxis.ResetBit(TAxis::kLabelsUp);; 1015 }; 1016 if (opt.Contains(""v"")) {; 1017 fXaxis.SetBit(TAxis::kLabelsVert);; 1018 fXaxis.ResetBit(TAxis::kLabelsHori);; 1019 fXaxis.ResetBit(TAxis::kLabelsDown);; 1020 fXaxis.ResetBit(TAxis::kLabelsUp);; 1021 }; 1022 if (opt.Contains(""u"")) {; 1023 fXaxis.SetBit(TAxis::kLabelsUp);; 1024 fXaxis.ResetBit(TAxis::kLabelsVert);; 1025 fXaxis.ResetBit(TAxis::kLabelsDown);; 1026 fXaxis.ResetBit(",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:39547,Availability,error,errors,39547," consecutive and starts from the first bin; 1045 // in that case the current code will work fine; 1046 Int_t firstLabelBin = axis->GetNbins() + 1;; 1047 Int_t lastLabelBin = -1;; 1048 for (Int_t i = 0; i < n; ++i) {; 1049 Int_t bin = labels->At(i)->GetUniqueID();; 1050 if (bin < firstLabelBin); 1051 firstLabelBin = bin;; 1052 if (bin > lastLabelBin); 1053 lastLabelBin = bin;; 1054 }; 1055 if (firstLabelBin != 1 || lastLabelBin - firstLabelBin + 1 != n) {; 1056 Error(""LabelsOption"",; 1057 ""%s of TProfile %s contains bins without labels. Sorting will not work correctly - return"",; 1058 axis->GetName(), GetName());; 1059 return;; 1060 }; 1061 // case where label bins are consecutive starting from first bin will work; 1062 Warning(; 1063 ""LabelsOption"",; 1064 ""axis %s of TProfile %s has extra following bins without labels. Sorting will work only for first label bins"",; 1065 axis->GetName(), GetName());; 1066 }; 1067 std::vector<Int_t> a(n);; 1068 Int_t i;; 1069 std::vector<Double_t> cont(n);; 1070 std::vector<Double_t> sumw(n);; 1071 std::vector<Double_t> errors(n);; 1072 std::vector<Double_t> ent(n);; 1073 std::vector<Double_t> binsw2;; 1074 if (fBinSumw2.fN) binsw2.resize(n);; 1075 ; 1076 // delete buffer if it is there since bins will be reordered.; 1077 if (fBuffer); 1078 BufferEmpty(1);; 1079 ; 1080 // make a labelold list but ordered with bins; 1081 // (re-ordered original label list); 1082 std::vector<TObject *> labold(n);; 1083 for (i = 0; i < n; i++); 1084 labold[i] = nullptr;; 1085 TIter nextold(labels);; 1086 TObject *obj;; 1087 while ((obj=nextold())) {; 1088 Int_t bin = obj->GetUniqueID();; 1089 R__ASSERT(bin <= n);; 1090 labold[bin - 1] = obj;; 1091 }; 1092 // order now labold according to bin content; 1093 ; 1094 labels->Clear();; 1095 if (sort > 0) {; 1096 //---sort by values of bins; 1097 for (i=1;i<=n;i++) {; 1098 a[i-1] = i-1;; 1099 sumw[i-1] = fArray[i];; 1100 errors[i-1] = fSumw2.fArray[i];; 1101 ent[i-1] = fBinEntries.fArray[i];; 1102 if (fBinSumw2.",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:40388,Availability,error,errors,40388,"etName(), GetName());; 1059 return;; 1060 }; 1061 // case where label bins are consecutive starting from first bin will work; 1062 Warning(; 1063 ""LabelsOption"",; 1064 ""axis %s of TProfile %s has extra following bins without labels. Sorting will work only for first label bins"",; 1065 axis->GetName(), GetName());; 1066 }; 1067 std::vector<Int_t> a(n);; 1068 Int_t i;; 1069 std::vector<Double_t> cont(n);; 1070 std::vector<Double_t> sumw(n);; 1071 std::vector<Double_t> errors(n);; 1072 std::vector<Double_t> ent(n);; 1073 std::vector<Double_t> binsw2;; 1074 if (fBinSumw2.fN) binsw2.resize(n);; 1075 ; 1076 // delete buffer if it is there since bins will be reordered.; 1077 if (fBuffer); 1078 BufferEmpty(1);; 1079 ; 1080 // make a labelold list but ordered with bins; 1081 // (re-ordered original label list); 1082 std::vector<TObject *> labold(n);; 1083 for (i = 0; i < n; i++); 1084 labold[i] = nullptr;; 1085 TIter nextold(labels);; 1086 TObject *obj;; 1087 while ((obj=nextold())) {; 1088 Int_t bin = obj->GetUniqueID();; 1089 R__ASSERT(bin <= n);; 1090 labold[bin - 1] = obj;; 1091 }; 1092 // order now labold according to bin content; 1093 ; 1094 labels->Clear();; 1095 if (sort > 0) {; 1096 //---sort by values of bins; 1097 for (i=1;i<=n;i++) {; 1098 a[i-1] = i-1;; 1099 sumw[i-1] = fArray[i];; 1100 errors[i-1] = fSumw2.fArray[i];; 1101 ent[i-1] = fBinEntries.fArray[i];; 1102 if (fBinSumw2.fN) binsw2[i - 1] = fBinSumw2.fArray[i];; 1103 if (fBinEntries.fArray[i] == 0) cont[i-1] = 0;; 1104 else cont[i-1] = fArray[i]/fBinEntries.fArray[i];; 1105 }; 1106 if (sort ==1); 1107 TMath::Sort(n,cont.data(),a.data(),kTRUE); //sort by decreasing values; 1108 else; 1109 TMath::Sort(n,cont.data(),a.data(),kFALSE); //sort by increasing values; 1110 for (i=1;i<=n;i++) {; 1111 fArray[i] = sumw[a[i-1]];; 1112 fSumw2.fArray[i] = errors[a[i-1]];; 1113 fBinEntries.fArray[i] = ent[a[i-1]];; 1114 if (fBinSumw2.fN); 1115 fBinSumw2.fArray[i] = binsw2[a[i-1]];; 1116 }; 1117 for (i=0 ;i < n; i++) {; 1118",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:40908,Availability,error,errors,40908,"abold(n);; 1083 for (i = 0; i < n; i++); 1084 labold[i] = nullptr;; 1085 TIter nextold(labels);; 1086 TObject *obj;; 1087 while ((obj=nextold())) {; 1088 Int_t bin = obj->GetUniqueID();; 1089 R__ASSERT(bin <= n);; 1090 labold[bin - 1] = obj;; 1091 }; 1092 // order now labold according to bin content; 1093 ; 1094 labels->Clear();; 1095 if (sort > 0) {; 1096 //---sort by values of bins; 1097 for (i=1;i<=n;i++) {; 1098 a[i-1] = i-1;; 1099 sumw[i-1] = fArray[i];; 1100 errors[i-1] = fSumw2.fArray[i];; 1101 ent[i-1] = fBinEntries.fArray[i];; 1102 if (fBinSumw2.fN) binsw2[i - 1] = fBinSumw2.fArray[i];; 1103 if (fBinEntries.fArray[i] == 0) cont[i-1] = 0;; 1104 else cont[i-1] = fArray[i]/fBinEntries.fArray[i];; 1105 }; 1106 if (sort ==1); 1107 TMath::Sort(n,cont.data(),a.data(),kTRUE); //sort by decreasing values; 1108 else; 1109 TMath::Sort(n,cont.data(),a.data(),kFALSE); //sort by increasing values; 1110 for (i=1;i<=n;i++) {; 1111 fArray[i] = sumw[a[i-1]];; 1112 fSumw2.fArray[i] = errors[a[i-1]];; 1113 fBinEntries.fArray[i] = ent[a[i-1]];; 1114 if (fBinSumw2.fN); 1115 fBinSumw2.fArray[i] = binsw2[a[i-1]];; 1116 }; 1117 for (i=0 ;i < n; i++) {; 1118 obj = labold[a[i]];; 1119 labels->Add(obj);; 1120 obj->SetUniqueID(i+1);; 1121 }; 1122 } else {; 1123 ; 1124 //---alphabetic sort; 1125 // sort labels using vector of strings and TMath::Sort; 1126 // I need to array because labels order in list is not necessary that of the bins; 1127 std::vector<std::string> vecLabels(n);; 1128 for (i = 0; i < n; i++) {; 1129 vecLabels[i] = labold[i]->GetName();; 1130 a[i] = i;; 1131 sumw[i] = fArray[i+1];; 1132 errors[i] = fSumw2.fArray[i+1];; 1133 ent[i] = fBinEntries.fArray[i+1];; 1134 if (fBinSumw2.fN); 1135 binsw2[i] = fBinSumw2.fArray[i+1];; 1136 }; 1137 // sort in ascending order for strings; 1138 TMath::Sort(n, vecLabels.data(), a.data(), kFALSE);; 1139 // set the new labels; 1140 for (i = 0; i < n; i++) {; 1141 TObject *labelObj = labold[a[i]];; 1142 labels->Add(labelObj);; 1143 // set ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:41529,Availability,error,errors,41529," //---sort by values of bins; 1097 for (i=1;i<=n;i++) {; 1098 a[i-1] = i-1;; 1099 sumw[i-1] = fArray[i];; 1100 errors[i-1] = fSumw2.fArray[i];; 1101 ent[i-1] = fBinEntries.fArray[i];; 1102 if (fBinSumw2.fN) binsw2[i - 1] = fBinSumw2.fArray[i];; 1103 if (fBinEntries.fArray[i] == 0) cont[i-1] = 0;; 1104 else cont[i-1] = fArray[i]/fBinEntries.fArray[i];; 1105 }; 1106 if (sort ==1); 1107 TMath::Sort(n,cont.data(),a.data(),kTRUE); //sort by decreasing values; 1108 else; 1109 TMath::Sort(n,cont.data(),a.data(),kFALSE); //sort by increasing values; 1110 for (i=1;i<=n;i++) {; 1111 fArray[i] = sumw[a[i-1]];; 1112 fSumw2.fArray[i] = errors[a[i-1]];; 1113 fBinEntries.fArray[i] = ent[a[i-1]];; 1114 if (fBinSumw2.fN); 1115 fBinSumw2.fArray[i] = binsw2[a[i-1]];; 1116 }; 1117 for (i=0 ;i < n; i++) {; 1118 obj = labold[a[i]];; 1119 labels->Add(obj);; 1120 obj->SetUniqueID(i+1);; 1121 }; 1122 } else {; 1123 ; 1124 //---alphabetic sort; 1125 // sort labels using vector of strings and TMath::Sort; 1126 // I need to array because labels order in list is not necessary that of the bins; 1127 std::vector<std::string> vecLabels(n);; 1128 for (i = 0; i < n; i++) {; 1129 vecLabels[i] = labold[i]->GetName();; 1130 a[i] = i;; 1131 sumw[i] = fArray[i+1];; 1132 errors[i] = fSumw2.fArray[i+1];; 1133 ent[i] = fBinEntries.fArray[i+1];; 1134 if (fBinSumw2.fN); 1135 binsw2[i] = fBinSumw2.fArray[i+1];; 1136 }; 1137 // sort in ascending order for strings; 1138 TMath::Sort(n, vecLabels.data(), a.data(), kFALSE);; 1139 // set the new labels; 1140 for (i = 0; i < n; i++) {; 1141 TObject *labelObj = labold[a[i]];; 1142 labels->Add(labelObj);; 1143 // set the corresponding bin. NB bin starts from 1; 1144 labelObj->SetUniqueID(i + 1);; 1145 if (gDebug); 1146 std::cout << ""bin "" << i + 1 << "" setting new labels for axis "" << labold.at(a[i])->GetName() << "" from ""; 1147 << a[i] << std::endl;; 1148 }; 1149 ; 1150 for (i=0; i < n; i++) {; 1151 fArray[i+1] = sumw[a[i]];; 1152 fSumw2.fArray[i+1] = errors[a[i]];; 11",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:42261,Availability,error,errors,42261," 1126 // I need to array because labels order in list is not necessary that of the bins; 1127 std::vector<std::string> vecLabels(n);; 1128 for (i = 0; i < n; i++) {; 1129 vecLabels[i] = labold[i]->GetName();; 1130 a[i] = i;; 1131 sumw[i] = fArray[i+1];; 1132 errors[i] = fSumw2.fArray[i+1];; 1133 ent[i] = fBinEntries.fArray[i+1];; 1134 if (fBinSumw2.fN); 1135 binsw2[i] = fBinSumw2.fArray[i+1];; 1136 }; 1137 // sort in ascending order for strings; 1138 TMath::Sort(n, vecLabels.data(), a.data(), kFALSE);; 1139 // set the new labels; 1140 for (i = 0; i < n; i++) {; 1141 TObject *labelObj = labold[a[i]];; 1142 labels->Add(labelObj);; 1143 // set the corresponding bin. NB bin starts from 1; 1144 labelObj->SetUniqueID(i + 1);; 1145 if (gDebug); 1146 std::cout << ""bin "" << i + 1 << "" setting new labels for axis "" << labold.at(a[i])->GetName() << "" from ""; 1147 << a[i] << std::endl;; 1148 }; 1149 ; 1150 for (i=0; i < n; i++) {; 1151 fArray[i+1] = sumw[a[i]];; 1152 fSumw2.fArray[i+1] = errors[a[i]];; 1153 fBinEntries.fArray[i+1] = ent[a[i]];; 1154 if (fBinSumw2.fN); 1155 fBinSumw2.fArray[i+1] = binsw2[a[i]];; 1156 }; 1157 }; 1158 // need to set to zero the statistics if axis has been sorted; 1159 // see for example TH3::PutStats for definition of s vector; 1160 bool labelsAreSorted = kFALSE;; 1161 for (i = 0; i < n; ++i) {; 1162 if (a[i] != i) {; 1163 labelsAreSorted = kTRUE;; 1164 break;; 1165 }; 1166 }; 1167 if (labelsAreSorted) {; 1168 double s[TH1::kNstat];; 1169 GetStats(s);; 1170 // if (iaxis == 1) {; 1171 s[2] = 0; // fTsumwx; 1172 s[3] = 0; // fTsumwx2; 1173 PutStats(s);; 1174 }; 1175}; 1176 ; 1177////////////////////////////////////////////////////////////////////////////////; 1178///Merge all histograms in the collection in this histogram.; 1179///; 1180/// This function computes the min/max for the x axis,; 1181/// compute a new number of bins, if necessary,; 1182/// add bin contents, errors and statistics.; 1183/// If overflows are present and limits are different",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:43189,Availability,error,errors,43189,"m ""; 1147 << a[i] << std::endl;; 1148 }; 1149 ; 1150 for (i=0; i < n; i++) {; 1151 fArray[i+1] = sumw[a[i]];; 1152 fSumw2.fArray[i+1] = errors[a[i]];; 1153 fBinEntries.fArray[i+1] = ent[a[i]];; 1154 if (fBinSumw2.fN); 1155 fBinSumw2.fArray[i+1] = binsw2[a[i]];; 1156 }; 1157 }; 1158 // need to set to zero the statistics if axis has been sorted; 1159 // see for example TH3::PutStats for definition of s vector; 1160 bool labelsAreSorted = kFALSE;; 1161 for (i = 0; i < n; ++i) {; 1162 if (a[i] != i) {; 1163 labelsAreSorted = kTRUE;; 1164 break;; 1165 }; 1166 }; 1167 if (labelsAreSorted) {; 1168 double s[TH1::kNstat];; 1169 GetStats(s);; 1170 // if (iaxis == 1) {; 1171 s[2] = 0; // fTsumwx; 1172 s[3] = 0; // fTsumwx2; 1173 PutStats(s);; 1174 }; 1175}; 1176 ; 1177////////////////////////////////////////////////////////////////////////////////; 1178///Merge all histograms in the collection in this histogram.; 1179///; 1180/// This function computes the min/max for the x axis,; 1181/// compute a new number of bins, if necessary,; 1182/// add bin contents, errors and statistics.; 1183/// If overflows are present and limits are different the function will fail.; 1184/// The function returns the total number of entries in the result histogram; 1185/// if the merge is successful, -1 otherwise.; 1186///; 1187/// IMPORTANT remark. The axis x may have different number; 1188/// of bins and different limits, BUT the largest bin width must be; 1189/// a multiple of the smallest bin width and the upper limit must also; 1190/// be a multiple of the bin width.; 1191 ; 1192Long64_t TProfile::Merge(TCollection *li); 1193{; 1194 return TProfileHelper::Merge(this, li);; 1195}; 1196 ; 1197////////////////////////////////////////////////////////////////////////////////; 1198/// Performs the operation: this = this*c1*f1; 1199///; 1200/// The function return kFALSE if the Multiply operation failed; 1201 ; 1202Bool_t TProfile::Multiply(TF1 *f1, Double_t c1); 1203{; 1204 ; 1205 if (!f1) {; 1206 E",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:46081,Availability,error,errors,46081,"///////////////////////////////////////////; 1240/// Multiply this profile by h1.; 1241///; 1242/// `this = this*h1`; 1243 ; 1244Bool_t TProfile::Multiply(const TH1 *); 1245{; 1246 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1247 return kFALSE;; 1248}; 1249 ; 1250 ; 1251////////////////////////////////////////////////////////////////////////////////; 1252/// Replace contents of this profile by multiplication of h1 by h2.; 1253///; 1254/// `this = (c1*h1)*(c2*h2)`; 1255 ; 1256Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1257{; 1258 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1259 return kFALSE;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Project this profile into a 1-D histogram along X; 1264///; 1265/// The projection is always of the type TH1D.; 1266///; 1267/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// project",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:46164,Availability,error,errors,46164,"///////////////////////////////////////////; 1240/// Multiply this profile by h1.; 1241///; 1242/// `this = this*h1`; 1243 ; 1244Bool_t TProfile::Multiply(const TH1 *); 1245{; 1246 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1247 return kFALSE;; 1248}; 1249 ; 1250 ; 1251////////////////////////////////////////////////////////////////////////////////; 1252/// Replace contents of this profile by multiplication of h1 by h2.; 1253///; 1254/// `this = (c1*h1)*(c2*h2)`; 1255 ; 1256Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1257{; 1258 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1259 return kFALSE;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Project this profile into a 1-D histogram along X; 1264///; 1265/// The projection is always of the type TH1D.; 1266///; 1267/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// project",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:46308,Availability,error,errors,46308,"n of h1 by h2.; 1253///; 1254/// `this = (c1*h1)*(c2*h2)`; 1255 ; 1256Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1257{; 1258 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1259 return kFALSE;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Project this profile into a 1-D histogram along X; 1264///; 1265/// The projection is always of the type TH1D.; 1266///; 1267/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// projected histogram obtained with this option will not be correct.; 1282 ; 1283TH1D *TProfile::ProjectionX(const char *name, Option_t *option) const; 1284{; 1285 ; 1286 TString opt = option;; 1287 opt.ToLower();; 1288 Int_t nx = fXaxis.GetNbins();; 1289 ; 1290 // Create the projection histogram; 1291 TString pname = name;; 1292 if (pname == ""_px"") {; 1293 pname = GetName();; 1294 pname.Append(""_px"");; 1295 }; 1296 TH1D *h1;; 1297 const TArrayD ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:46657,Availability,error,errors,46657,"n of h1 by h2.; 1253///; 1254/// `this = (c1*h1)*(c2*h2)`; 1255 ; 1256Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1257{; 1258 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1259 return kFALSE;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Project this profile into a 1-D histogram along X; 1264///; 1265/// The projection is always of the type TH1D.; 1266///; 1267/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// projected histogram obtained with this option will not be correct.; 1282 ; 1283TH1D *TProfile::ProjectionX(const char *name, Option_t *option) const; 1284{; 1285 ; 1286 TString opt = option;; 1287 opt.ToLower();; 1288 Int_t nx = fXaxis.GetNbins();; 1289 ; 1290 // Create the projection histogram; 1291 TString pname = name;; 1292 if (pname == ""_px"") {; 1293 pname = GetName();; 1294 pname.Append(""_px"");; 1295 }; 1296 TH1D *h1;; 1297 const TArrayD ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:47079,Availability,error,error,47079,"re computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// projected histogram obtained with this option will not be correct.; 1282 ; 1283TH1D *TProfile::ProjectionX(const char *name, Option_t *option) const; 1284{; 1285 ; 1286 TString opt = option;; 1287 opt.ToLower();; 1288 Int_t nx = fXaxis.GetNbins();; 1289 ; 1290 // Create the projection histogram; 1291 TString pname = name;; 1292 if (pname == ""_px"") {; 1293 pname = GetName();; 1294 pname.Append(""_px"");; 1295 }; 1296 TH1D *h1;; 1297 const TArrayD *bins = fXaxis.GetXbins();; 1298 if (bins->fN == 0) {; 1299 h1 = new TH1D(pname,GetTitle(),nx,fXaxis.GetXmin(),fXaxis.GetXmax());; 1300 } else {; 1301 h1 = new TH1D(pname,GetTitle(),nx,bins->fArray);; 1302 }; 1303 Bool_t computeErrors = kFALSE;; 1304 Bool_t cequalErrors = kFALSE;; 1305 Bool_t binEntries = kFALSE;; 1306 Bool_t binWeight = kFALSE;; 1307 if (opt.Contains(""b"")) binEntries = kTRUE;; 1308 if (opt.Contains(""e"")) computeErrors = kTRUE;; 1309 if (opt.Contains(""w"")) binWeight = kTRUE;; 1310 if (opt.Contains(""c=e"")) {cequalErrors = kTRUE; computeErrors=kFA",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:48646,Availability,error,errors,48646,");; 1298 if (bins->fN == 0) {; 1299 h1 = new TH1D(pname,GetTitle(),nx,fXaxis.GetXmin(),fXaxis.GetXmax());; 1300 } else {; 1301 h1 = new TH1D(pname,GetTitle(),nx,bins->fArray);; 1302 }; 1303 Bool_t computeErrors = kFALSE;; 1304 Bool_t cequalErrors = kFALSE;; 1305 Bool_t binEntries = kFALSE;; 1306 Bool_t binWeight = kFALSE;; 1307 if (opt.Contains(""b"")) binEntries = kTRUE;; 1308 if (opt.Contains(""e"")) computeErrors = kTRUE;; 1309 if (opt.Contains(""w"")) binWeight = kTRUE;; 1310 if (opt.Contains(""c=e"")) {cequalErrors = kTRUE; computeErrors=kFALSE;}; 1311 if (computeErrors || binWeight || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 1312 ; 1313 // Fill the projected histogram; 1314 Double_t cont;; 1315 for (Int_t bin =0;bin<=nx+1;bin++) {; 1316 ; 1317 if (binEntries) cont = GetBinEntries(bin);; 1318 else if (cequalErrors) cont = GetBinError(bin);; 1319 else if (binWeight) cont = fArray[bin]; // bin content * bin entries; 1320 else cont = GetBinContent(bin); // default case; 1321 ; 1322 h1->SetBinContent(bin ,cont);; 1323 ; 1324 // if option E projected histogram errors are same as profile; 1325 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1326 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1327 // this is correct only if the profile is filled with weights =1; 1328 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1329 // in case of bin entries and profile is weighted, we need to set also the bin error; 1330 if (binEntries && fBinSumw2.fN ) {; 1331 R__ASSERT( h1->GetSumw2() );; 1332 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1333 }; 1334 ; 1335 }; 1336 ; 1337 // Copy the axis attributes and the axis labels if needed.; 1338 h1->GetXaxis()->ImportAttributes(this->GetXaxis());; 1339 h1->GetYaxis()->ImportAttributes(this->GetYaxis());; 1340 THashList* labels=this->GetXaxis()->GetLabels();; 1341 if (labels) {; 1342 TIter iL(labels);; 1343 TObjString* lb;; 1344 Int_t i = 1;; 1345 while ((lb=(TObjStr",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:48774,Availability,error,error,48774,");; 1298 if (bins->fN == 0) {; 1299 h1 = new TH1D(pname,GetTitle(),nx,fXaxis.GetXmin(),fXaxis.GetXmax());; 1300 } else {; 1301 h1 = new TH1D(pname,GetTitle(),nx,bins->fArray);; 1302 }; 1303 Bool_t computeErrors = kFALSE;; 1304 Bool_t cequalErrors = kFALSE;; 1305 Bool_t binEntries = kFALSE;; 1306 Bool_t binWeight = kFALSE;; 1307 if (opt.Contains(""b"")) binEntries = kTRUE;; 1308 if (opt.Contains(""e"")) computeErrors = kTRUE;; 1309 if (opt.Contains(""w"")) binWeight = kTRUE;; 1310 if (opt.Contains(""c=e"")) {cequalErrors = kTRUE; computeErrors=kFALSE;}; 1311 if (computeErrors || binWeight || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 1312 ; 1313 // Fill the projected histogram; 1314 Double_t cont;; 1315 for (Int_t bin =0;bin<=nx+1;bin++) {; 1316 ; 1317 if (binEntries) cont = GetBinEntries(bin);; 1318 else if (cequalErrors) cont = GetBinError(bin);; 1319 else if (binWeight) cont = fArray[bin]; // bin content * bin entries; 1320 else cont = GetBinContent(bin); // default case; 1321 ; 1322 h1->SetBinContent(bin ,cont);; 1323 ; 1324 // if option E projected histogram errors are same as profile; 1325 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1326 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1327 // this is correct only if the profile is filled with weights =1; 1328 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1329 // in case of bin entries and profile is weighted, we need to set also the bin error; 1330 if (binEntries && fBinSumw2.fN ) {; 1331 R__ASSERT( h1->GetSumw2() );; 1332 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1333 }; 1334 ; 1335 }; 1336 ; 1337 // Copy the axis attributes and the axis labels if needed.; 1338 h1->GetXaxis()->ImportAttributes(this->GetXaxis());; 1339 h1->GetYaxis()->ImportAttributes(this->GetYaxis());; 1340 THashList* labels=this->GetXaxis()->GetLabels();; 1341 if (labels) {; 1342 TIter iL(labels);; 1343 TObjString* lb;; 1344 Int_t i = 1;; 1345 while ((lb=(TObjStr",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:49057,Availability,error,error,49057,"inWeight = kTRUE;; 1310 if (opt.Contains(""c=e"")) {cequalErrors = kTRUE; computeErrors=kFALSE;}; 1311 if (computeErrors || binWeight || (binEntries && fBinSumw2.fN) ) h1->Sumw2();; 1312 ; 1313 // Fill the projected histogram; 1314 Double_t cont;; 1315 for (Int_t bin =0;bin<=nx+1;bin++) {; 1316 ; 1317 if (binEntries) cont = GetBinEntries(bin);; 1318 else if (cequalErrors) cont = GetBinError(bin);; 1319 else if (binWeight) cont = fArray[bin]; // bin content * bin entries; 1320 else cont = GetBinContent(bin); // default case; 1321 ; 1322 h1->SetBinContent(bin ,cont);; 1323 ; 1324 // if option E projected histogram errors are same as profile; 1325 if (computeErrors ) h1->SetBinError(bin , GetBinError(bin) );; 1326 // in case of option W bin error is deduced from bin sum of z**2 values of profile; 1327 // this is correct only if the profile is filled with weights =1; 1328 if (binWeight) h1->GetSumw2()->fArray[bin] = fSumw2.fArray[bin];; 1329 // in case of bin entries and profile is weighted, we need to set also the bin error; 1330 if (binEntries && fBinSumw2.fN ) {; 1331 R__ASSERT( h1->GetSumw2() );; 1332 h1->GetSumw2()->fArray[bin] = fBinSumw2.fArray[bin];; 1333 }; 1334 ; 1335 }; 1336 ; 1337 // Copy the axis attributes and the axis labels if needed.; 1338 h1->GetXaxis()->ImportAttributes(this->GetXaxis());; 1339 h1->GetYaxis()->ImportAttributes(this->GetYaxis());; 1340 THashList* labels=this->GetXaxis()->GetLabels();; 1341 if (labels) {; 1342 TIter iL(labels);; 1343 TObjString* lb;; 1344 Int_t i = 1;; 1345 while ((lb=(TObjString*)iL())) {; 1346 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 1347 i++;; 1348 }; 1349 }; 1350 ; 1351 h1->SetEntries(fEntries);; 1352 return h1;; 1353}; 1354 ; 1355////////////////////////////////////////////////////////////////////////////////; 1356/// Replace current statistics with the values in array stats.; 1357 ; 1358void TProfile::PutStats(Double_t *stats); 1359{; 1360 fTsumw = stats[0];; 1361 fTsumw2 = stats[1];; 1362 fTsumwx = stat",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:50586,Availability,error,errors,50586,"1344 Int_t i = 1;; 1345 while ((lb=(TObjString*)iL())) {; 1346 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 1347 i++;; 1348 }; 1349 }; 1350 ; 1351 h1->SetEntries(fEntries);; 1352 return h1;; 1353}; 1354 ; 1355////////////////////////////////////////////////////////////////////////////////; 1356/// Replace current statistics with the values in array stats.; 1357 ; 1358void TProfile::PutStats(Double_t *stats); 1359{; 1360 fTsumw = stats[0];; 1361 fTsumw2 = stats[1];; 1362 fTsumwx = stats[2];; 1363 fTsumwx2 = stats[3];; 1364 fTsumwy = stats[4];; 1365 fTsumwy2 = stats[5];; 1366}; 1367 ; 1368////////////////////////////////////////////////////////////////////////////////; 1369/// Rebin this profile grouping ngroup bins together.; 1370///; 1371/// ## case 1 xbins=0; 1372/// if newname is not blank a new temporary profile hnew is created.; 1373/// else the current profile is modified (default); 1374/// The parameter ngroup indicates how many bins of this have to me merged; 1375/// into one bin of hnew; 1376/// If the original profile has errors stored (via Sumw2), the resulting; 1377/// profile has new errors correctly calculated.; 1378///; 1379/// examples: if hp is an existing TProfile histogram with 100 bins; 1380///; 1381/// ~~~ {.cpp}; 1382/// hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; 1383/// hp->Rebin(5); //merges five bins in one in hp; 1384/// TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; 1385/// //merging 5 bins of hp in one bin; 1386/// ~~~; 1387///; 1388/// NOTE: If ngroup is not an exact divider of the number of bins,; 1389/// the top limit of the rebinned profile is changed; 1390/// to the upper edge of the bin=newbins*ngroup and the corresponding; 1391/// bins are added to the overflow bin.; 1392/// Statistics will be recomputed from the new bin contents.; 1393///; 1394/// ## case 2 xbins!=0; 1395/// a new profile is created (you should specify newname).; 1396/// The parameter ngroup is the n",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:50652,Availability,error,errors,50652,"1344 Int_t i = 1;; 1345 while ((lb=(TObjString*)iL())) {; 1346 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 1347 i++;; 1348 }; 1349 }; 1350 ; 1351 h1->SetEntries(fEntries);; 1352 return h1;; 1353}; 1354 ; 1355////////////////////////////////////////////////////////////////////////////////; 1356/// Replace current statistics with the values in array stats.; 1357 ; 1358void TProfile::PutStats(Double_t *stats); 1359{; 1360 fTsumw = stats[0];; 1361 fTsumw2 = stats[1];; 1362 fTsumwx = stats[2];; 1363 fTsumwx2 = stats[3];; 1364 fTsumwy = stats[4];; 1365 fTsumwy2 = stats[5];; 1366}; 1367 ; 1368////////////////////////////////////////////////////////////////////////////////; 1369/// Rebin this profile grouping ngroup bins together.; 1370///; 1371/// ## case 1 xbins=0; 1372/// if newname is not blank a new temporary profile hnew is created.; 1373/// else the current profile is modified (default); 1374/// The parameter ngroup indicates how many bins of this have to me merged; 1375/// into one bin of hnew; 1376/// If the original profile has errors stored (via Sumw2), the resulting; 1377/// profile has new errors correctly calculated.; 1378///; 1379/// examples: if hp is an existing TProfile histogram with 100 bins; 1380///; 1381/// ~~~ {.cpp}; 1382/// hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; 1383/// hp->Rebin(5); //merges five bins in one in hp; 1384/// TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; 1385/// //merging 5 bins of hp in one bin; 1386/// ~~~; 1387///; 1388/// NOTE: If ngroup is not an exact divider of the number of bins,; 1389/// the top limit of the rebinned profile is changed; 1390/// to the upper edge of the bin=newbins*ngroup and the corresponding; 1391/// bins are added to the overflow bin.; 1392/// Statistics will be recomputed from the new bin contents.; 1393///; 1394/// ## case 2 xbins!=0; 1395/// a new profile is created (you should specify newname).; 1396/// The parameter ngroup is the n",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:58120,Availability,error,errors,58120,"; 1554 binContent += oldBins[i];; 1555 binCount += oldCount[i];; 1556 binError += oldErrors[i];; 1557 if (fBinSumw2.fN) binSumw2 += oldBinw2[i];; 1558 }; 1559 hnew->fArray[newbins+1] = binContent;; 1560 hnew->fBinEntries[newbins+1] = binCount;; 1561 hnew->fSumw2[newbins+1] = binError;; 1562 if ( fBinSumw2.fN ) hnew->fBinSumw2[newbins+1] = binSumw2;; 1563 ; 1564 ; 1565 delete [] oldBins;; 1566 delete [] oldCount;; 1567 delete [] oldErrors;; 1568 if (oldBinw2) delete [] oldBinw2;; 1569 return hnew;; 1570}; 1571 ; 1572////////////////////////////////////////////////////////////////////////////////; 1573/// Profile histogram is resized along x axis such that x is in the axis range.; 1574/// The new axis limits are recomputed by doubling iteratively; 1575/// the current axis range until the specified value x is within the limits.; 1576/// The algorithm makes a copy of the histogram, then loops on all bins; 1577/// of the old histogram to fill the extended histogram.; 1578/// Takes into account errors (Sumw2) if any.; 1579/// The axis must be extendable before invoking this function.; 1580///; 1581/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1582 ; 1583void TProfile::ExtendAxis(Double_t x, TAxis *axis); 1584{; 1585 TProfile* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1586 if ( hold ) {; 1587 fTsumwy = hold->fTsumwy;; 1588 fTsumwy2 = hold->fTsumwy2;; 1589 ; 1590 delete hold;; 1591 }; 1592}; 1593 ; 1594////////////////////////////////////////////////////////////////////////////////; 1595/// Reset contents of a Profile histogram.; 1596 ; 1597void TProfile::Reset(Option_t *option); 1598{; 1599 TH1D::Reset(option);; 1600 fBinEntries.Reset();; 1601 fBinSumw2.Reset();; 1602 TString opt = option;; 1603 opt.ToUpper();; 1604 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1605 fTsumwy = 0;; 1606 fTsumwy2 = 0;; 1607}; 1608 ; 1609////////////////////////////////////////////////////////////////////////////////; 1610/// Save primitive as a C++ statement(s) on output str",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:61213,Availability,error,errors,61213," << GetXaxis()->GetXbins()->fArray[i];; 1629 }; 1630 out << ""}; "" << std::endl;; 1631 }; 1632 ; 1633 char quote = '""';; 1634 out<<"" ""<<std::endl;; 1635 out<<"" ""<<ClassName()<<"" *"";; 1636 ; 1637 //histogram pointer has by default the histogram name.; 1638 //however, in case histogram has no directory, it is safer to add a incremental suffix; 1639 static Int_t hcounter = 0;; 1640 TString histName = gInterpreter->MapCppName(GetName());; 1641 if (!fDirectory) {; 1642 hcounter++;; 1643 histName += ""__"";; 1644 histName += hcounter;; 1645 }; 1646 const char *hname = histName.Data();; 1647 ; 1648 out << hname << "" = new "" << ClassName() << ""("" << quote << hname << quote << "","" << quote << GetTitle() << quote; 1649 << "","" << GetXaxis()->GetNbins();; 1650 if (nonEqiX); 1651 out << "", xAxis"";; 1652 else; 1653 out << "","" << GetXaxis()->GetXmin(); 1654 << "","" << GetXaxis()->GetXmax(); 1655 <<"",""<<quote<<GetErrorOption()<<quote<<"");""<<std::endl;; 1656 ; 1657 // save bin entries; 1658 Int_t bin;; 1659 for (bin=0;bin<fNcells;bin++) {; 1660 Double_t bi = GetBinEntries(bin);; 1661 if (bi) {; 1662 out<<"" ""<<hname<<""->SetBinEntries(""<<bin<<"",""<<bi<<"");""<<std::endl;; 1663 }; 1664 }; 1665 //save bin contents; 1666 for (bin=0;bin<fNcells;bin++) {; 1667 Double_t bc = fArray[bin];; 1668 if (bc) {; 1669 out<<"" ""<<hname<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1670 }; 1671 }; 1672 // save bin errors; 1673 if (fSumw2.fN) {; 1674 for (bin=0;bin<fNcells;bin++) {; 1675 Double_t be = TMath::Sqrt(fSumw2.fArray[bin]);; 1676 if (be) {; 1677 out<<"" ""<<hname<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 1678 }; 1679 }; 1680 }; 1681 ; 1682 TH1::SavePrimitiveHelp(out, hname, option);; 1683}; 1684 ; 1685////////////////////////////////////////////////////////////////////////////////; 1686/// Multiply this profile by a constant c1.; 1687///; 1688/// `this = c1*this`; 1689///; 1690/// This function uses the services of TProfile::Add; 1691 ; 1692void TProfile::Scale(Double_t c1, Option_t * o",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:63786,Availability,error,errors,63786,"///////////////////////////////////; 1716/// Redefine x axis parameters.; 1717 ; 1718void TProfile::SetBins(Int_t nx, const Double_t *xbins); 1719{; 1720 fXaxis.Set(nx,xbins);; 1721 fNcells = nx+2;; 1722 SetBinsLength(fNcells);; 1723}; 1724 ; 1725////////////////////////////////////////////////////////////////////////////////; 1726/// Set total number of bins including under/overflow.; 1727/// Reallocate bin contents array; 1728 ; 1729void TProfile::SetBinsLength(Int_t n); 1730{; 1731 TH1D::SetBinsLength(n);; 1732 TProfileHelper::BuildArray(this);; 1733}; 1734 ; 1735////////////////////////////////////////////////////////////////////////////////; 1736/// Set the buffer size in units of 8 bytes (double).; 1737 ; 1738void TProfile::SetBuffer(Int_t buffersize, Option_t *); 1739{; 1740 if (fBuffer) {; 1741 BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:63839,Availability,error,errors,63839,"// Reallocate bin contents array; 1728 ; 1729void TProfile::SetBinsLength(Int_t n); 1730{; 1731 TH1D::SetBinsLength(n);; 1732 TProfileHelper::BuildArray(this);; 1733}; 1734 ; 1735////////////////////////////////////////////////////////////////////////////////; 1736/// Set the buffer size in units of 8 bytes (double).; 1737 ; 1738void TProfile::SetBuffer(Int_t buffersize, Option_t *); 1739{; 1740 if (fBuffer) {; 1741 BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y a",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:63921,Availability,error,errors,63921,"// Reallocate bin contents array; 1728 ; 1729void TProfile::SetBinsLength(Int_t n); 1730{; 1731 TH1D::SetBinsLength(n);; 1732 TProfileHelper::BuildArray(this);; 1733}; 1734 ; 1735////////////////////////////////////////////////////////////////////////////////; 1736/// Set the buffer size in units of 8 bytes (double).; 1737 ; 1738void TProfile::SetBuffer(Int_t buffersize, Option_t *); 1739{; 1740 if (fBuffer) {; 1741 BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y a",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:63945,Availability,error,error,63945,"// Reallocate bin contents array; 1728 ; 1729void TProfile::SetBinsLength(Int_t n); 1730{; 1731 TH1D::SetBinsLength(n);; 1732 TProfileHelper::BuildArray(this);; 1733}; 1734 ; 1735////////////////////////////////////////////////////////////////////////////////; 1736/// Set the buffer size in units of 8 bytes (double).; 1737 ; 1738void TProfile::SetBuffer(Int_t buffersize, Option_t *); 1739{; 1740 if (fBuffer) {; 1741 BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y a",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:64022,Availability,error,error,64022,"ofileHelper::BuildArray(this);; 1733}; 1734 ; 1735////////////////////////////////////////////////////////////////////////////////; 1736/// Set the buffer size in units of 8 bytes (double).; 1737 ; 1738void TProfile::SetBuffer(Int_t buffersize, Option_t *); 1739{; 1740 if (fBuffer) {; 1741 BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y and weights w = 1/dy**2; 1774///; 1775/// See TProfile::BuildOptions for a detailed explanation of all options; 1776 ; 1777void T",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:64225,Availability,error,errors,64225,"BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y and weights w = 1/dy**2; 1774///; 1775/// See TProfile::BuildOptions for a detailed explanation of all options; 1776 ; 1777void TProfile::SetErrorOption(Option_t *option); 1778{; 1779 TProfileHelper::SetErrorOption(this, option);; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Stream an object of class TProfile.; 1784 ; 1785void TProfile::Streamer(TBuffer &",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:64488,Availability,error,errors,64488,"BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y and weights w = 1/dy**2; 1774///; 1775/// See TProfile::BuildOptions for a detailed explanation of all options; 1776 ; 1777void TProfile::SetErrorOption(Option_t *option); 1778{; 1779 TProfileHelper::SetErrorOption(this, option);; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Stream an object of class TProfile.; 1784 ; 1785void TProfile::Streamer(TBuffer &",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:64627,Availability,error,error,64627,"0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y and weights w = 1/dy**2; 1774///; 1775/// See TProfile::BuildOptions for a detailed explanation of all options; 1776 ; 1777void TProfile::SetErrorOption(Option_t *option); 1778{; 1779 TProfileHelper::SetErrorOption(this, option);; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Stream an object of class TProfile.; 1784 ; 1785void TProfile::Streamer(TBuffer &R__b); 1786{; 1787 if (R__b.IsReading()) {; 1788 UInt_t R__s, R__c;; 1789 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 1790 if (R__v > 2) {; 1791 R__b.ReadClassBuffer(TProfile::Class(), this, R__v, R__s, R__c);; 1792 return;; 1793 }; 1794 //====process old versions before automatic schema ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:65698,Availability,error,errorMode,65698,"ombining measurements y +/- dy,; 1773/// and the profile is filled with values y and weights w = 1/dy**2; 1774///; 1775/// See TProfile::BuildOptions for a detailed explanation of all options; 1776 ; 1777void TProfile::SetErrorOption(Option_t *option); 1778{; 1779 TProfileHelper::SetErrorOption(this, option);; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Stream an object of class TProfile.; 1784 ; 1785void TProfile::Streamer(TBuffer &R__b); 1786{; 1787 if (R__b.IsReading()) {; 1788 UInt_t R__s, R__c;; 1789 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 1790 if (R__v > 2) {; 1791 R__b.ReadClassBuffer(TProfile::Class(), this, R__v, R__s, R__c);; 1792 return;; 1793 }; 1794 //====process old versions before automatic schema evolution; 1795 TH1D::Streamer(R__b);; 1796 fBinEntries.Streamer(R__b);; 1797 Int_t errorMode;; 1798 R__b >> errorMode;; 1799 fErrorMode = (EErrorType)errorMode;; 1800 if (R__v < 2) {; 1801 Float_t ymin,ymax;; 1802 R__b >> ymin; fYmin = ymin;; 1803 R__b >> ymax; fYmax = ymax;; 1804 } else {; 1805 R__b >> fYmin;; 1806 R__b >> fYmax;; 1807 }; 1808 R__b.CheckByteCount(R__s, R__c, TProfile::IsA());; 1809 //====end of old versions; 1810 ; 1811 } else {; 1812 R__b.WriteClassBuffer(TProfile::Class(),this);; 1813 }; 1814}; 1815////////////////////////////////////////////////////////////////////////////////; 1816/// Create/delete structure to store sum of squares of weights per bin.; 1817///; 1818/// This is needed to compute the correct statistical quantities; 1819/// of a profile filled with weights; 1820///; 1821/// This function is automatically called when the histogram is created; 1822/// if the static function TH1::SetDefaultSumw2 has been called before.; 1823/// If flag is false the structure is deleted; 1824 ; 1825void TProfile::Sumw2(Bool_t flag); 1826{; 1827 TProfileHelper::Sumw2(this, flag);; 1828}; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; Boo",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:65723,Availability,error,errorMode,65723,"ombining measurements y +/- dy,; 1773/// and the profile is filled with values y and weights w = 1/dy**2; 1774///; 1775/// See TProfile::BuildOptions for a detailed explanation of all options; 1776 ; 1777void TProfile::SetErrorOption(Option_t *option); 1778{; 1779 TProfileHelper::SetErrorOption(this, option);; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Stream an object of class TProfile.; 1784 ; 1785void TProfile::Streamer(TBuffer &R__b); 1786{; 1787 if (R__b.IsReading()) {; 1788 UInt_t R__s, R__c;; 1789 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 1790 if (R__v > 2) {; 1791 R__b.ReadClassBuffer(TProfile::Class(), this, R__v, R__s, R__c);; 1792 return;; 1793 }; 1794 //====process old versions before automatic schema evolution; 1795 TH1D::Streamer(R__b);; 1796 fBinEntries.Streamer(R__b);; 1797 Int_t errorMode;; 1798 R__b >> errorMode;; 1799 fErrorMode = (EErrorType)errorMode;; 1800 if (R__v < 2) {; 1801 Float_t ymin,ymax;; 1802 R__b >> ymin; fYmin = ymin;; 1803 R__b >> ymax; fYmax = ymax;; 1804 } else {; 1805 R__b >> fYmin;; 1806 R__b >> fYmax;; 1807 }; 1808 R__b.CheckByteCount(R__s, R__c, TProfile::IsA());; 1809 //====end of old versions; 1810 ; 1811 } else {; 1812 R__b.WriteClassBuffer(TProfile::Class(),this);; 1813 }; 1814}; 1815////////////////////////////////////////////////////////////////////////////////; 1816/// Create/delete structure to store sum of squares of weights per bin.; 1817///; 1818/// This is needed to compute the correct statistical quantities; 1819/// of a profile filled with weights; 1820///; 1821/// This function is automatically called when the histogram is created; 1822/// if the static function TH1::SetDefaultSumw2 has been called before.; 1823/// If flag is false the structure is deleted; 1824 ; 1825void TProfile::Sumw2(Bool_t flag); 1826{; 1827 TProfileHelper::Sumw2(this, flag);; 1828}; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; Boo",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:65765,Availability,error,errorMode,65765,"ombining measurements y +/- dy,; 1773/// and the profile is filled with values y and weights w = 1/dy**2; 1774///; 1775/// See TProfile::BuildOptions for a detailed explanation of all options; 1776 ; 1777void TProfile::SetErrorOption(Option_t *option); 1778{; 1779 TProfileHelper::SetErrorOption(this, option);; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Stream an object of class TProfile.; 1784 ; 1785void TProfile::Streamer(TBuffer &R__b); 1786{; 1787 if (R__b.IsReading()) {; 1788 UInt_t R__s, R__c;; 1789 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 1790 if (R__v > 2) {; 1791 R__b.ReadClassBuffer(TProfile::Class(), this, R__v, R__s, R__c);; 1792 return;; 1793 }; 1794 //====process old versions before automatic schema evolution; 1795 TH1D::Streamer(R__b);; 1796 fBinEntries.Streamer(R__b);; 1797 Int_t errorMode;; 1798 R__b >> errorMode;; 1799 fErrorMode = (EErrorType)errorMode;; 1800 if (R__v < 2) {; 1801 Float_t ymin,ymax;; 1802 R__b >> ymin; fYmin = ymin;; 1803 R__b >> ymax; fYmax = ymax;; 1804 } else {; 1805 R__b >> fYmin;; 1806 R__b >> fYmax;; 1807 }; 1808 R__b.CheckByteCount(R__s, R__c, TProfile::IsA());; 1809 //====end of old versions; 1810 ; 1811 } else {; 1812 R__b.WriteClassBuffer(TProfile::Class(),this);; 1813 }; 1814}; 1815////////////////////////////////////////////////////////////////////////////////; 1816/// Create/delete structure to store sum of squares of weights per bin.; 1817///; 1818/// This is needed to compute the correct statistical quantities; 1819/// of a profile filled with weights; 1820///; 1821/// This function is automatically called when the histogram is created; 1822/// if the static function TH1::SetDefaultSumw2 has been called before.; 1823/// If flag is false the structure is deleted; 1824 ; 1825void TProfile::Sumw2(Bool_t flag); 1826{; 1827 TProfileHelper::Sumw2(this, flag);; 1828}; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; Boo",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:67429,Availability,error,error,67429,"d with weights; 1820///; 1821/// This function is automatically called when the histogram is created; 1822/// if the static function TH1::SetDefaultSumw2 has been called before.; 1823/// If flag is false the structure is deleted; 1824 ; 1825void TProfile::Sumw2(Bool_t flag); 1826{; 1827 TProfileHelper::Sumw2(this, flag);; 1828}; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TF1.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TMath.h; TObjString.h; TProfileHelper.h; TProfile.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; gDebugInt_t gDebugDefinition TROOT.cxx:597; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition T",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:73198,Availability,error,error,73198," overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:10501; TH1D::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10483; TH1D::Streamervoid Streamer(TBuffer &) overrideStream a class object.; TH1D::TH1DTH1D()Constructor.Definition TH1.cxx:10402; TH1D::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.h:684; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::Classstatic TClass * Class(); TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SavePrimitiveHelpvirtual void S",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:73950,Availability,error,error,73950," squares of weights.Definition TH1.h:97; TH1::Classstatic TClass * Class(); TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; T",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:77844,Availability,error,error,77844,"ss.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProfileHelper::LabelsInflatestatic void LabelsInflate(T *p, Option_t *)Definition TProfileHelper.h:626; TProfileHelper::GetBinErrorstatic Double_t GetBinError(T *p, Int_t bin)Definition TProfileHelper.h:704; TProfileHelper::ExtendAxisstatic T * ExtendAxis(T *p, Double_t x, TAxis *axis)Definition TProfileHelper.h:430; TProfileHelper::Sumw2static void Sumw2(T *p, Bool_t flag)Definition TProfileHelper.h:529; TProfileHelper::SetBinEntriesstatic void SetBinEntries(T *p, Int_t bin, Double_t w)Definition TProfileHelper.h:768; TProfileHelper::Scalestatic void Scale(T *p, Double_t c",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:77980,Availability,error,error,77980,"nition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProfileHelper::LabelsInflatestatic void LabelsInflate(T *p, Option_t *)Definition TProfileHelper.h:626; TProfileHelper::GetBinErrorstatic Double_t GetBinError(T *p, Int_t bin)Definition TProfileHelper.h:704; TProfileHelper::ExtendAxisstatic T * ExtendAxis(T *p, Double_t x, TAxis *axis)Definition TProfileHelper.h:430; TProfileHelper::Sumw2static void Sumw2(T *p, Bool_t flag)Definition TProfileHelper.h:529; TProfileHelper::SetBinEntriesstatic void SetBinEntries(T *p, Int_t bin, Double_t w)Definition TProfileHelper.h:768; TProfileHelper::Scalestatic void Scale(T *p, Double_t c1, Option_t *option)Definition TProfileHelper.h:512; TProfileHelper::SetErrorOptionstatic void SetErrorOption(T *p, Option_t *opt)Def",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:80312,Availability,error,error,80312,"on TProfileHelper.h:71; TProfileHelper::GetBinEffectiveEntriesstatic Double_t GetBinEffectiveEntries(T *p, Int_t bin)Definition TProfileHelper.h:143; TProfileHelper::LabelsDeflatestatic void LabelsDeflate(T *p, Option_t *)Definition TProfileHelper.h:560; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::GetBinContentDouble_t GetBinContent(Int_t bin) const overrideReturn bin content of a Profile histogram.Definition TProfile.cxx:824; TProfile::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin) constReturn bin effective entries for a weighted filled Profile histogram.Definition TProfile.cxx:853; TProfile::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1).Definition TProfile.cxx:453; TProfile::RebinTH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideRebin this profile grouping ngroup bins together.Definition TProfile.cxx:1410; TProfile::fgApproximatestatic Bool_t fgApproximatebin error approximation optionDefinition TProfile.h:48; TProfile::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along x axis such that x is in the axis range.Definition TProfile.cxx:1583; TProfile::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile.cxx:1358; TProfile::BuildOptionsvoid BuildOptions(Double_t ymin, Double_t ymax, Option_t *option)Set Profile histogram structure and options.Definition TProfile.cxx:227; TProfile::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile.h:40; TProfile::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile.cxx:1192; TProfile::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile histogram to a new profile histogram.Definition TProfile.cxx:423; TProfile::fYmaxDouble_t fYmaxUpper limit in Y (if set)Definition TProfile.h:42; TProfile::",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:80902,Availability,error,errors,80902,"r a weighted filled Profile histogram.Definition TProfile.cxx:853; TProfile::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1).Definition TProfile.cxx:453; TProfile::RebinTH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideRebin this profile grouping ngroup bins together.Definition TProfile.cxx:1410; TProfile::fgApproximatestatic Bool_t fgApproximatebin error approximation optionDefinition TProfile.h:48; TProfile::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along x axis such that x is in the axis range.Definition TProfile.cxx:1583; TProfile::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile.cxx:1358; TProfile::BuildOptionsvoid BuildOptions(Double_t ymin, Double_t ymax, Option_t *option)Set Profile histogram structure and options.Definition TProfile.cxx:227; TProfile::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile.h:40; TProfile::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile.cxx:1192; TProfile::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile histogram to a new profile histogram.Definition TProfile.cxx:423; TProfile::fYmaxDouble_t fYmaxUpper limit in Y (if set)Definition TProfile.h:42; TProfile::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile.cxx:1700; TProfile::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Option_t *option=""e"") constProject this profile into a 1-D histogram along X.Definition TProfile.cxx:1283; TProfile::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile errors.Definition TProfile.cxx:1777; TProfile::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on outp",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:81701,Availability,error,errors,81701,"tats.Definition TProfile.cxx:1358; TProfile::BuildOptionsvoid BuildOptions(Double_t ymin, Double_t ymax, Option_t *option)Set Profile histogram structure and options.Definition TProfile.cxx:227; TProfile::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile.h:40; TProfile::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile.cxx:1192; TProfile::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile histogram to a new profile histogram.Definition TProfile.cxx:423; TProfile::fYmaxDouble_t fYmaxUpper limit in Y (if set)Definition TProfile.h:42; TProfile::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile.cxx:1700; TProfile::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Option_t *option=""e"") constProject this profile into a 1-D histogram along X.Definition TProfile.cxx:1283; TProfile::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile errors.Definition TProfile.cxx:1777; TProfile::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile.cxx:1612; TProfile::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile histogram.Definition TProfile.cxx:837; TProfile::Classstatic TClass * Class(); TProfile::LabelsDeflatevoid LabelsDeflate(Option_t *axis=""X"") overrideReduce the number of bins for this axis to the number of bins having a label.Definition TProfile.cxx:973; TProfile::GetB2Double_t * GetB2()Definition TProfile.h:65; TProfile::Streamervoid Streamer(TBuffer &) overrideStream an object of class TProfile.Definition TProfile.cxx:1785; TProfile::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile.cxx:1729; TProfile::Scalevoid Scale(Double_t c1=1, Option_t *option=""",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:84069,Availability,error,error,84069,"errideSet the buffer size in units of 8 bytes (double).Definition TProfile.cxx:1738; TProfile::FillNvoid FillN(Int_t, const Double_t *, const Double_t *, Int_t) overrideFill this histogram with an array x and weights w.Definition TProfile.h:63; TProfile::operator=TProfile & operator=(const TProfile &profile)Definition TProfile.cxx:249; TProfile::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/delete structure to store sum of squares of weights per bin.Definition TProfile.cxx:1825; TProfile::LabelsInflatevoid LabelsInflate(Option_t *axis=""X"") overrideDouble the number of bins for axis.Definition TProfile.cxx:983; TProfile::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TProfile.h:45; TProfile::MultiplyBool_t Multiply(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this*c1*f1.Definition TProfile.cxx:1202; TProfile::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile.h:46; TProfile::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile histogram.Definition TProfile.cxx:888; TProfile::AddBool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""") overridePerforms the operation: this = this + c1*f1.Definition TProfile.cxx:259; TProfile::FillInt_t Fill(const Double_t *v)Definition TProfile.h:55; TProfile::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TProfile.h:44; TProfile::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile.h:50; TProfile::GetBDouble_t * GetB()Definition TProfile.h:64; TProfile::~TProfile~TProfile() overrideDefault destructor for Profile histograms.Definition TProfile.cxx:100; TProfile::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile.h:54; TProfile::fYminDouble_t fYminLower limit in Y (if set)Definition TProfile.h:41; TProfile::fBinEntriesTArrayD fBinEntriesnumber of entries per binDefinition TProfile.h:39; TProfile::GetWDouble_t * GetW()Definition TProfile.h:66; ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:85584,Availability,error,errors,85584,"ile.h:50; TProfile::GetBDouble_t * GetB()Definition TProfile.h:64; TProfile::~TProfile~TProfile() overrideDefault destructor for Profile histograms.Definition TProfile.cxx:100; TProfile::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile.h:54; TProfile::fYminDouble_t fYminLower limit in Y (if set)Definition TProfile.h:41; TProfile::fBinEntriesTArrayD fBinEntriesnumber of entries per binDefinition TProfile.h:39; TProfile::GetWDouble_t * GetW()Definition TProfile.h:66; TProfile::Approximatestatic void Approximate(Bool_t approx=kTRUE)Static function to set the fgApproximate flag.Definition TProfile.cxx:324; TProfile::fScalingBool_t fScaling! True when TProfile::Scale is calledDefinition TProfile.h:43; TProfile::GetStatsvoid GetStats(Double_t *stats) const overridefill the array stats from the contents of this profile.Definition TProfile.cxx:921; TProfile::IsATClass * IsA() const overrideDefinition TProfile.h:138; TProfile::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile errors.Definition TProfile.cxx:896; TProfile::LabelsOptionvoid LabelsOption(Option_t *option=""h"", Option_t *axis=""X"") overrideSet option(s) to draw axis with labels.Definition TProfile.cxx:1001; TProfile::GetW2Double_t * GetW2()Definition TProfile.h:67; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1D",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:86817,Availability,down,down,86817,"TProfile.cxx:324; TProfile::fScalingBool_t fScaling! True when TProfile::Scale is calledDefinition TProfile.h:43; TProfile::GetStatsvoid GetStats(Double_t *stats) const overridefill the array stats from the contents of this profile.Definition TProfile.cxx:921; TProfile::IsATClass * IsA() const overrideDefinition TProfile.h:138; TProfile::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile errors.Definition TProfile.cxx:896; TProfile::LabelsOptionvoid LabelsOption(Option_t *option=""h"", Option_t *axis=""X"") overrideSet option(s) to draw axis with labels.Definition TProfile.cxx:1001; TProfile::GetW2Double_t * GetW2()Definition TProfile.h:67; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. histhistsrcTProfile.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:1795,Integrability,rout,routines,1795,"iostream>; 18#include ""TError.h""; 19#include ""TClass.h""; 20#include ""TObjString.h""; 21 ; 22#include ""TProfileHelper.h""; 23 ; 24Bool_t TProfile::fgApproximate = kFALSE;; 25 ; 26ClassImp(TProfile);; 27 ; 28/** \class TProfile; 29 \ingroup Histograms; 30 Profile Histogram.; 31 Profile histograms are used to display the mean; 32 value of Y and its error for each bin in X. The displayed error is by default the; 33 standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; 34 Profile histograms are in many cases an; 35 elegant replacement of two-dimensional histograms. The inter-relation of two; 36 measured quantities X and Y can always be visualized by a two-dimensional; 37 histogram or scatter plot, but if Y is an unknown (but single-valued); 38 approximate function of X, this function is displayed by a profile histogram with; 39 much better precision than by a scatter plot.; 40 ; 41 The following formulae show the cumulated contents (capital letters) and the values; 42 displayed by the printing or plotting routines (small letters) of the elements for bin j.; 43 \f[; 44 \begin{align}; 45 H(j) &= \sum w \cdot Y \\; 46 E(j) &= \sum w \cdot Y^2 \\; 47 W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; 48 h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; 49 s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; 50 e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; 51 \end{align}; 52 \f]; 53 The bin content is always the mean of the Y values, but errors change depending on options:; 54 \f[; 55 \begin{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for stori",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:2329,Integrability,depend,depending,2329,"error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; 34 Profile histograms are in many cases an; 35 elegant replacement of two-dimensional histograms. The inter-relation of two; 36 measured quantities X and Y can always be visualized by a two-dimensional; 37 histogram or scatter plot, but if Y is an unknown (but single-valued); 38 approximate function of X, this function is displayed by a profile histogram with; 39 much better precision than by a scatter plot.; 40 ; 41 The following formulae show the cumulated contents (capital letters) and the values; 42 displayed by the printing or plotting routines (small letters) of the elements for bin j.; 43 \f[; 44 \begin{align}; 45 H(j) &= \sum w \cdot Y \\; 46 E(j) &= \sum w \cdot Y^2 \\; 47 W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; 48 h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; 49 s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; 50 e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; 51 \end{align}; 52 \f]; 53 The bin content is always the mean of the Y values, but errors change depending on options:; 54 \f[; 55 \begin{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 62 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; 63 \end{cases}; 64 \end{align}; 65 \f]; 66 In the special case where s(j) is zero (eg, case of 1 entry only in one bin); 67 the bin error e(j) is computed from the average of the s(j) for all bins if; 68 the static function TProfile::Approximate() has been called.; ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:77431,Integrability,message,message,77431,"TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProfileHelper::LabelsInflatestatic void LabelsInflate(T *p, Option_t *)Definition TProfileHelper.h:626; TProfileHelper::GetBinErrorstatic Double_t GetBinError(T",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:77850,Integrability,message,message,77850,"ss.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProfileHelper::LabelsInflatestatic void LabelsInflate(T *p, Option_t *)Definition TProfileHelper.h:626; TProfileHelper::GetBinErrorstatic Double_t GetBinError(T *p, Int_t bin)Definition TProfileHelper.h:704; TProfileHelper::ExtendAxisstatic T * ExtendAxis(T *p, Double_t x, TAxis *axis)Definition TProfileHelper.h:430; TProfileHelper::Sumw2static void Sumw2(T *p, Bool_t flag)Definition TProfileHelper.h:529; TProfileHelper::SetBinEntriesstatic void SetBinEntries(T *p, Int_t bin, Double_t w)Definition TProfileHelper.h:768; TProfileHelper::Scalestatic void Scale(T *p, Double_t c",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:77986,Integrability,message,message,77986,"nition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProfileHelper::LabelsInflatestatic void LabelsInflate(T *p, Option_t *)Definition TProfileHelper.h:626; TProfileHelper::GetBinErrorstatic Double_t GetBinError(T *p, Int_t bin)Definition TProfileHelper.h:704; TProfileHelper::ExtendAxisstatic T * ExtendAxis(T *p, Double_t x, TAxis *axis)Definition TProfileHelper.h:430; TProfileHelper::Sumw2static void Sumw2(T *p, Bool_t flag)Definition TProfileHelper.h:529; TProfileHelper::SetBinEntriesstatic void SetBinEntries(T *p, Int_t bin, Double_t w)Definition TProfileHelper.h:768; TProfileHelper::Scalestatic void Scale(T *p, Double_t c1, Option_t *option)Definition TProfileHelper.h:512; TProfileHelper::SetErrorOptionstatic void SetErrorOption(T *p, Option_t *opt)Def",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:4638,Modifiability,variab,variable,4638,"sus px"",100,-4,4,0,20);; 78 Float_t px, py, pz;; 79 for ( Int_t i=0; i<25000; i++) {; 80 gRandom->Rannor(px,py);; 81 pz = px*px + py*py;; 82 hprof->Fill(px,pz,1);; 83 }; 84 hprof->Draw();; 85}; 86~~~; 87*/; 88 ; 89////////////////////////////////////////////////////////////////////////////////; 90/// Default constructor for Profile histograms; 91 ; 92TProfile::TProfile(); 93{; 94 BuildOptions(0,0,"""");; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Default destructor for Profile histograms; 99 ; 100TProfile::~TProfile(); 101{; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Normal Constructor for Profile histograms.; 106///; 107/// The first five parameters are similar to TH1D::TH1D.; 108/// All values of y are accepted at filling time.; 109/// To fill a profile histogram, one must use TProfile::Fill function.; 110///; 111/// Note that when filling the profile histogram the function Fill; 112/// checks if the variable y is between fYmin and fYmax.; 113/// If a minimum or maximum value is set for the Y scale before filling,; 114/// then all values below ymin or above ymax will be discarded.; 115/// Setting the minimum or maximum value for the Y scale before filling; 116/// has the same effect as calling the special TProfile constructor below; 117/// where ymin and ymax are specified.; 118///; 119/// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; 120/// (spread option), or e(j) if `CHOPT`='' (error on mean).; 121///; 122/// See TProfile::BuildOptions() for explanation of parameters; 123///; 124/// see also comments in the TH1 base class constructors; 125 ; 126TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Option_t *option); 127: TH1D(name,title,nbins,xlow,xup); 128{; 129 BuildOptions(0,0,option);; 130}; 131 ; 132////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:5671,Modifiability,variab,variable,5671,"ccepted at filling time.; 109/// To fill a profile histogram, one must use TProfile::Fill function.; 110///; 111/// Note that when filling the profile histogram the function Fill; 112/// checks if the variable y is between fYmin and fYmax.; 113/// If a minimum or maximum value is set for the Y scale before filling,; 114/// then all values below ymin or above ymax will be discarded.; 115/// Setting the minimum or maximum value for the Y scale before filling; 116/// has the same effect as calling the special TProfile constructor below; 117/// where ymin and ymax are specified.; 118///; 119/// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; 120/// (spread option), or e(j) if `CHOPT`='' (error on mean).; 121///; 122/// See TProfile::BuildOptions() for explanation of parameters; 123///; 124/// see also comments in the TH1 base class constructors; 125 ; 126TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Option_t *option); 127: TH1D(name,title,nbins,xlow,xup); 128{; 129 BuildOptions(0,0,option);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Constructor for Profile histograms with variable bin size.; 134///; 135/// See TProfile::BuildOptions() for more explanations on errors; 136/// see also comments in the TH1 base class constructors; 137 ; 138TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Float_t *xbins,Option_t *option); 139: TH1D(name,title,nbins,xbins); 140{; 141 BuildOptions(0,0,option);; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Constructor for Profile histograms with variable bin size.; 146///; 147/// See TProfile::BuildOptions for more explanations on errors; 148/// see also comments in the TH1 base class constructors; 149 ; 150TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Option_t *option); 151: ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:6160,Modifiability,variab,variable,6160,"ing the special TProfile constructor below; 117/// where ymin and ymax are specified.; 118///; 119/// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; 120/// (spread option), or e(j) if `CHOPT`='' (error on mean).; 121///; 122/// See TProfile::BuildOptions() for explanation of parameters; 123///; 124/// see also comments in the TH1 base class constructors; 125 ; 126TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Option_t *option); 127: TH1D(name,title,nbins,xlow,xup); 128{; 129 BuildOptions(0,0,option);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Constructor for Profile histograms with variable bin size.; 134///; 135/// See TProfile::BuildOptions() for more explanations on errors; 136/// see also comments in the TH1 base class constructors; 137 ; 138TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Float_t *xbins,Option_t *option); 139: TH1D(name,title,nbins,xbins); 140{; 141 BuildOptions(0,0,option);; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Constructor for Profile histograms with variable bin size.; 146///; 147/// See TProfile::BuildOptions for more explanations on errors; 148/// see also comments in the TH1 base class constructors; 149 ; 150TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Option_t *option); 151: TH1D(name,title,nbins,xbins); 152{; 153 BuildOptions(0,0,option);; 154}; 155 ; 156////////////////////////////////////////////////////////////////////////////////; 157/// Constructor for Profile histograms with variable bin size.; 158/// See TProfile::BuildOptions for more explanations on errors; 159///; 160/// see also comments in the TH1 base class constructors; 161 ; 162TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Double_t ylow,Double_t yup,Option",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:6648,Modifiability,variab,variable,6648,"uble_t xup,Option_t *option); 127: TH1D(name,title,nbins,xlow,xup); 128{; 129 BuildOptions(0,0,option);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Constructor for Profile histograms with variable bin size.; 134///; 135/// See TProfile::BuildOptions() for more explanations on errors; 136/// see also comments in the TH1 base class constructors; 137 ; 138TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Float_t *xbins,Option_t *option); 139: TH1D(name,title,nbins,xbins); 140{; 141 BuildOptions(0,0,option);; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Constructor for Profile histograms with variable bin size.; 146///; 147/// See TProfile::BuildOptions for more explanations on errors; 148/// see also comments in the TH1 base class constructors; 149 ; 150TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Option_t *option); 151: TH1D(name,title,nbins,xbins); 152{; 153 BuildOptions(0,0,option);; 154}; 155 ; 156////////////////////////////////////////////////////////////////////////////////; 157/// Constructor for Profile histograms with variable bin size.; 158/// See TProfile::BuildOptions for more explanations on errors; 159///; 160/// see also comments in the TH1 base class constructors; 161 ; 162TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Double_t *xbins,Double_t ylow,Double_t yup,Option_t *option); 163: TH1D(name,title,nbins,xbins); 164{; 165 BuildOptions(ylow,yup,option);; 166}; 167 ; 168////////////////////////////////////////////////////////////////////////////////; 169/// Constructor for Profile histograms with range in y.; 170///; 171/// The first five parameters are similar to TH1D::TH1D.; 172/// Only the values of Y between ylow and yup will be considered at filling time.; 173/// ylow and yup will also be the maximum and minimum values; 174/// on the y scale",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:31253,Modifiability,evolve,evolved,31253,"836 ; 837Double_t TProfile::GetBinEntries(Int_t bin) const; 838{; 839 if (fBuffer) ((TProfile*)this)->BufferEmpty();; 840 ; 841 if (bin < 0 || bin >= fNcells) return 0;; 842 return fBinEntries.fArray[bin];; 843}; 844 ; 845////////////////////////////////////////////////////////////////////////////////; 846/// Return bin effective entries for a weighted filled Profile histogram.; 847/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 848/// The effective entries is defined as the square of the sum of the weights divided by the; 849/// sum of the weights square.; 850/// TProfile::Sumw2() must be called before filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average er",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:51540,Modifiability,variab,variable,51540,"ors stored (via Sumw2), the resulting; 1377/// profile has new errors correctly calculated.; 1378///; 1379/// examples: if hp is an existing TProfile histogram with 100 bins; 1380///; 1381/// ~~~ {.cpp}; 1382/// hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; 1383/// hp->Rebin(5); //merges five bins in one in hp; 1384/// TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; 1385/// //merging 5 bins of hp in one bin; 1386/// ~~~; 1387///; 1388/// NOTE: If ngroup is not an exact divider of the number of bins,; 1389/// the top limit of the rebinned profile is changed; 1390/// to the upper edge of the bin=newbins*ngroup and the corresponding; 1391/// bins are added to the overflow bin.; 1392/// Statistics will be recomputed from the new bin contents.; 1393///; 1394/// ## case 2 xbins!=0; 1395/// a new profile is created (you should specify newname).; 1396/// The parameter ngroup is the number of variable size bins in the created profile; 1397/// The array xbins must contain ngroup+1 elements that represent the low-edge; 1398/// of the bins.; 1399/// The data of the old bins are added to the new bin which contains the bin center; 1400/// of the old bins. It is possible that information from the old binning are attached; 1401/// to the under-/overflow bins of the new binning.; 1402///; 1403/// examples: if hp is an existing TProfile with 100 bins; 1404///; 1405/// ~~~ {.cpp}; 1406/// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; 1407/// hp->Rebin(24,""hpnew"",xbins); //creates a new variable bin size profile hpnew; 1408/// ~~~; 1409 ; 1410TH1 *TProfile::Rebin(Int_t ngroup, const char*newname, const Double_t *xbins); 1411{; 1412 Int_t nbins = fXaxis.GetNbins();; 1413 Double_t xmin = fXaxis.GetXmin();; 1414 Double_t xmax = fXaxis.GetXmax();; 1415 if ((ngroup <= 0) || (ngroup > nbins)) {; 1416 Error(""Rebin"", ""Illegal value of ngroup=%d"",ngroup);; 1417 return nullptr;; 1418 }; 1419 if (!newna",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:52177,Modifiability,variab,variable,52177,"ed; 1390/// to the upper edge of the bin=newbins*ngroup and the corresponding; 1391/// bins are added to the overflow bin.; 1392/// Statistics will be recomputed from the new bin contents.; 1393///; 1394/// ## case 2 xbins!=0; 1395/// a new profile is created (you should specify newname).; 1396/// The parameter ngroup is the number of variable size bins in the created profile; 1397/// The array xbins must contain ngroup+1 elements that represent the low-edge; 1398/// of the bins.; 1399/// The data of the old bins are added to the new bin which contains the bin center; 1400/// of the old bins. It is possible that information from the old binning are attached; 1401/// to the under-/overflow bins of the new binning.; 1402///; 1403/// examples: if hp is an existing TProfile with 100 bins; 1404///; 1405/// ~~~ {.cpp}; 1406/// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; 1407/// hp->Rebin(24,""hpnew"",xbins); //creates a new variable bin size profile hpnew; 1408/// ~~~; 1409 ; 1410TH1 *TProfile::Rebin(Int_t ngroup, const char*newname, const Double_t *xbins); 1411{; 1412 Int_t nbins = fXaxis.GetNbins();; 1413 Double_t xmin = fXaxis.GetXmin();; 1414 Double_t xmax = fXaxis.GetXmax();; 1415 if ((ngroup <= 0) || (ngroup > nbins)) {; 1416 Error(""Rebin"", ""Illegal value of ngroup=%d"",ngroup);; 1417 return nullptr;; 1418 }; 1419 if (!newname && xbins) {; 1420 Error(""Rebin"",""if xbins is specified, newname must be given"");; 1421 return nullptr;; 1422 }; 1423 ; 1424 Int_t newbins = nbins/ngroup;; 1425 if (!xbins) {; 1426 Int_t nbg = nbins/ngroup;; 1427 if (nbg*ngroup != nbins) {; 1428 Warning(""Rebin"", ""ngroup=%d must be an exact divider of nbins=%d"",ngroup,nbins);; 1429 }; 1430 }; 1431 else {; 1432 // in the case of xbins given (rebinning in variable bins) ngroup is the new number of bins.; 1433 // and number of grouped bins is not constant.; 1434 // when looping for setting the contents for the new histogram we; 1435 // need to loop on all bin",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:52998,Modifiability,variab,variable,52998,"he new bin which contains the bin center; 1400/// of the old bins. It is possible that information from the old binning are attached; 1401/// to the under-/overflow bins of the new binning.; 1402///; 1403/// examples: if hp is an existing TProfile with 100 bins; 1404///; 1405/// ~~~ {.cpp}; 1406/// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; 1407/// hp->Rebin(24,""hpnew"",xbins); //creates a new variable bin size profile hpnew; 1408/// ~~~; 1409 ; 1410TH1 *TProfile::Rebin(Int_t ngroup, const char*newname, const Double_t *xbins); 1411{; 1412 Int_t nbins = fXaxis.GetNbins();; 1413 Double_t xmin = fXaxis.GetXmin();; 1414 Double_t xmax = fXaxis.GetXmax();; 1415 if ((ngroup <= 0) || (ngroup > nbins)) {; 1416 Error(""Rebin"", ""Illegal value of ngroup=%d"",ngroup);; 1417 return nullptr;; 1418 }; 1419 if (!newname && xbins) {; 1420 Error(""Rebin"",""if xbins is specified, newname must be given"");; 1421 return nullptr;; 1422 }; 1423 ; 1424 Int_t newbins = nbins/ngroup;; 1425 if (!xbins) {; 1426 Int_t nbg = nbins/ngroup;; 1427 if (nbg*ngroup != nbins) {; 1428 Warning(""Rebin"", ""ngroup=%d must be an exact divider of nbins=%d"",ngroup,nbins);; 1429 }; 1430 }; 1431 else {; 1432 // in the case of xbins given (rebinning in variable bins) ngroup is the new number of bins.; 1433 // and number of grouped bins is not constant.; 1434 // when looping for setting the contents for the new histogram we; 1435 // need to loop on all bins of original histogram. Set then ngroup=nbins; 1436 newbins = ngroup;; 1437 ngroup = nbins;; 1438 }; 1439 ; 1440 // Save old bin contents into a new array; 1441 Double_t *oldBins = new Double_t[nbins+2];; 1442 Double_t *oldCount = new Double_t[nbins+2];; 1443 Double_t *oldErrors = new Double_t[nbins+2];; 1444 Double_t *oldBinw2 = (fBinSumw2.fN ? new Double_t[nbins+2] : nullptr );; 1445 Int_t bin, i;; 1446 Double_t *cu1 = GetW();; 1447 Double_t *er1 = GetW2();; 1448 Double_t *en1 = GetB();; 1449 Double_t *ew1 = GetB2();; 1450 ;",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:54616,Modifiability,variab,variable,54616,"1 = GetW2();; 1448 Double_t *en1 = GetB();; 1449 Double_t *ew1 = GetB2();; 1450 ; 1451 for (bin=0;bin<=nbins+1;bin++) {; 1452 oldBins[bin] = cu1[bin];; 1453 oldCount[bin] = en1[bin];; 1454 oldErrors[bin] = er1[bin];; 1455 if (ew1 && fBinSumw2.fN) oldBinw2[bin] = ew1[bin];; 1456 }; 1457 ; 1458 // create a clone of the old histogram if newname is specified; 1459 TProfile *hnew = this;; 1460 if ((newname && strlen(newname) > 0) || xbins) {; 1461 hnew = (TProfile*)Clone(newname);; 1462 }; 1463 ; 1464 // in case of ngroup not an excat divider of nbins,; 1465 // top limit is changed (see NOTE in method comment); 1466 if(!xbins && (newbins*ngroup != nbins)) {; 1467 xmax = fXaxis.GetBinUpEdge(newbins*ngroup);; 1468 hnew->fTsumw = 0; //stats must be reset because top bins will be moved to overflow bin; 1469 }; 1470 ; 1471 // set correctly the axis and resizes the bin arrays; 1472 if(!xbins && (fXaxis.GetXbins()->GetSize() > 0)){; 1473 // for rebinning of variable bins in a constant group; 1474 Double_t *bins = new Double_t[newbins+1];; 1475 for(i = 0; i <= newbins; ++i) bins[i] = fXaxis.GetBinLowEdge(1+i*ngroup);; 1476 hnew->SetBins(newbins,bins); //this also changes the bin array's; 1477 delete [] bins;; 1478 } else if (xbins) {; 1479 // when rebinning in variable bins; 1480 hnew->SetBins(newbins,xbins);; 1481 } else {; 1482 hnew->SetBins(newbins,xmin,xmax);; 1483 }; 1484 ; 1485 // merge bin contents ignoring now underflow/overflows; 1486 if (fBinSumw2.fN) hnew->Sumw2();; 1487 ; 1488 // Start merging only once the new lowest edge is reached; 1489 Int_t startbin = 1;; 1490 const Double_t newxmin = hnew->GetXaxis()->GetBinLowEdge(1);; 1491 while( fXaxis.GetBinCenter(startbin) < newxmin && startbin <= nbins ) {; 1492 startbin++;; 1493 }; 1494 ; 1495 Double_t *cu2 = hnew->GetW();; 1496 Double_t *er2 = hnew->GetW2();; 1497 Double_t *en2 = hnew->GetB();; 1498 Double_t *ew2 = hnew->GetB2();; 1499 Int_t oldbin = startbin;; 1500 Double_t binContent, binCount, binError, binSumw2;; 15",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:54924,Modifiability,variab,variable,54924,"1457 ; 1458 // create a clone of the old histogram if newname is specified; 1459 TProfile *hnew = this;; 1460 if ((newname && strlen(newname) > 0) || xbins) {; 1461 hnew = (TProfile*)Clone(newname);; 1462 }; 1463 ; 1464 // in case of ngroup not an excat divider of nbins,; 1465 // top limit is changed (see NOTE in method comment); 1466 if(!xbins && (newbins*ngroup != nbins)) {; 1467 xmax = fXaxis.GetBinUpEdge(newbins*ngroup);; 1468 hnew->fTsumw = 0; //stats must be reset because top bins will be moved to overflow bin; 1469 }; 1470 ; 1471 // set correctly the axis and resizes the bin arrays; 1472 if(!xbins && (fXaxis.GetXbins()->GetSize() > 0)){; 1473 // for rebinning of variable bins in a constant group; 1474 Double_t *bins = new Double_t[newbins+1];; 1475 for(i = 0; i <= newbins; ++i) bins[i] = fXaxis.GetBinLowEdge(1+i*ngroup);; 1476 hnew->SetBins(newbins,bins); //this also changes the bin array's; 1477 delete [] bins;; 1478 } else if (xbins) {; 1479 // when rebinning in variable bins; 1480 hnew->SetBins(newbins,xbins);; 1481 } else {; 1482 hnew->SetBins(newbins,xmin,xmax);; 1483 }; 1484 ; 1485 // merge bin contents ignoring now underflow/overflows; 1486 if (fBinSumw2.fN) hnew->Sumw2();; 1487 ; 1488 // Start merging only once the new lowest edge is reached; 1489 Int_t startbin = 1;; 1490 const Double_t newxmin = hnew->GetXaxis()->GetBinLowEdge(1);; 1491 while( fXaxis.GetBinCenter(startbin) < newxmin && startbin <= nbins ) {; 1492 startbin++;; 1493 }; 1494 ; 1495 Double_t *cu2 = hnew->GetW();; 1496 Double_t *er2 = hnew->GetW2();; 1497 Double_t *en2 = hnew->GetB();; 1498 Double_t *ew2 = hnew->GetB2();; 1499 Int_t oldbin = startbin;; 1500 Double_t binContent, binCount, binError, binSumw2;; 1501 for (bin = 1;bin<=newbins;bin++) {; 1502 binContent = 0;; 1503 binCount = 0;; 1504 binError = 0;; 1505 binSumw2 = 0;; 1506 ; 1507 //for xbins != 0: ngroup == nbins; 1508 Int_t imax = ngroup;; 1509 Double_t xbinmax = hnew->GetXaxis()->GetBinUpEdge(bin);; 1510 for (i=0;i<ngroup;i+",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:58072,Modifiability,extend,extended,58072,"inCount = 0;; 1550 binError = 0;; 1551 binSumw2 = 0;; 1552 for(i=oldbin;i<=nbins+1;i++); 1553 {; 1554 binContent += oldBins[i];; 1555 binCount += oldCount[i];; 1556 binError += oldErrors[i];; 1557 if (fBinSumw2.fN) binSumw2 += oldBinw2[i];; 1558 }; 1559 hnew->fArray[newbins+1] = binContent;; 1560 hnew->fBinEntries[newbins+1] = binCount;; 1561 hnew->fSumw2[newbins+1] = binError;; 1562 if ( fBinSumw2.fN ) hnew->fBinSumw2[newbins+1] = binSumw2;; 1563 ; 1564 ; 1565 delete [] oldBins;; 1566 delete [] oldCount;; 1567 delete [] oldErrors;; 1568 if (oldBinw2) delete [] oldBinw2;; 1569 return hnew;; 1570}; 1571 ; 1572////////////////////////////////////////////////////////////////////////////////; 1573/// Profile histogram is resized along x axis such that x is in the axis range.; 1574/// The new axis limits are recomputed by doubling iteratively; 1575/// the current axis range until the specified value x is within the limits.; 1576/// The algorithm makes a copy of the histogram, then loops on all bins; 1577/// of the old histogram to fill the extended histogram.; 1578/// Takes into account errors (Sumw2) if any.; 1579/// The axis must be extendable before invoking this function.; 1580///; 1581/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1582 ; 1583void TProfile::ExtendAxis(Double_t x, TAxis *axis); 1584{; 1585 TProfile* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1586 if ( hold ) {; 1587 fTsumwy = hold->fTsumwy;; 1588 fTsumwy2 = hold->fTsumwy2;; 1589 ; 1590 delete hold;; 1591 }; 1592}; 1593 ; 1594////////////////////////////////////////////////////////////////////////////////; 1595/// Reset contents of a Profile histogram.; 1596 ; 1597void TProfile::Reset(Option_t *option); 1598{; 1599 TH1D::Reset(option);; 1600 fBinEntries.Reset();; 1601 fBinSumw2.Reset();; 1602 TString opt = option;; 1603 opt.ToUpper();; 1604 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1605 fTsumwy = 0;; 1606 fTsumwy2 = 0;; 1607}; 1608 ; 1609/////////////////////////////////////////////",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:58169,Modifiability,extend,extendable,58169,"i];; 1556 binError += oldErrors[i];; 1557 if (fBinSumw2.fN) binSumw2 += oldBinw2[i];; 1558 }; 1559 hnew->fArray[newbins+1] = binContent;; 1560 hnew->fBinEntries[newbins+1] = binCount;; 1561 hnew->fSumw2[newbins+1] = binError;; 1562 if ( fBinSumw2.fN ) hnew->fBinSumw2[newbins+1] = binSumw2;; 1563 ; 1564 ; 1565 delete [] oldBins;; 1566 delete [] oldCount;; 1567 delete [] oldErrors;; 1568 if (oldBinw2) delete [] oldBinw2;; 1569 return hnew;; 1570}; 1571 ; 1572////////////////////////////////////////////////////////////////////////////////; 1573/// Profile histogram is resized along x axis such that x is in the axis range.; 1574/// The new axis limits are recomputed by doubling iteratively; 1575/// the current axis range until the specified value x is within the limits.; 1576/// The algorithm makes a copy of the histogram, then loops on all bins; 1577/// of the old histogram to fill the extended histogram.; 1578/// Takes into account errors (Sumw2) if any.; 1579/// The axis must be extendable before invoking this function.; 1580///; 1581/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1582 ; 1583void TProfile::ExtendAxis(Double_t x, TAxis *axis); 1584{; 1585 TProfile* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1586 if ( hold ) {; 1587 fTsumwy = hold->fTsumwy;; 1588 fTsumwy2 = hold->fTsumwy2;; 1589 ; 1590 delete hold;; 1591 }; 1592}; 1593 ; 1594////////////////////////////////////////////////////////////////////////////////; 1595/// Reset contents of a Profile histogram.; 1596 ; 1597void TProfile::Reset(Option_t *option); 1598{; 1599 TH1D::Reset(option);; 1600 fBinEntries.Reset();; 1601 fBinSumw2.Reset();; 1602 TString opt = option;; 1603 opt.ToUpper();; 1604 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1605 fTsumwy = 0;; 1606 fTsumwy2 = 0;; 1607}; 1608 ; 1609////////////////////////////////////////////////////////////////////////////////; 1610/// Save primitive as a C++ statement(s) on output stream out.; 1611 ; 1612void TProfile::SavePrimitive(std::ostr",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:59294,Modifiability,variab,variable,59294,"xis(Double_t x, TAxis *axis); 1584{; 1585 TProfile* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1586 if ( hold ) {; 1587 fTsumwy = hold->fTsumwy;; 1588 fTsumwy2 = hold->fTsumwy2;; 1589 ; 1590 delete hold;; 1591 }; 1592}; 1593 ; 1594////////////////////////////////////////////////////////////////////////////////; 1595/// Reset contents of a Profile histogram.; 1596 ; 1597void TProfile::Reset(Option_t *option); 1598{; 1599 TH1D::Reset(option);; 1600 fBinEntries.Reset();; 1601 fBinSumw2.Reset();; 1602 TString opt = option;; 1603 opt.ToUpper();; 1604 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1605 fTsumwy = 0;; 1606 fTsumwy2 = 0;; 1607}; 1608 ; 1609////////////////////////////////////////////////////////////////////////////////; 1610/// Save primitive as a C++ statement(s) on output stream out.; 1611 ; 1612void TProfile::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1613{; 1614 //Note the following restrictions in the code generated:; 1615 // - variable bin size not implemented; 1616 // - SetErrorOption not implemented; 1617 ; 1618 Bool_t nonEqiX = kFALSE;; 1619 Int_t i;; 1620 // Check if the profile has equidistant X bins or not. If not, we; 1621 // create an array holding the bins.; 1622 if (GetXaxis()->GetXbins()->fN && GetXaxis()->GetXbins()->fArray) {; 1623 nonEqiX = kTRUE;; 1624 out << "" Double_t xAxis["" << GetXaxis()->GetXbins()->fN; 1625 << ""] = {"";; 1626 for (i = 0; i < GetXaxis()->GetXbins()->fN; i++) {; 1627 if (i != 0) out << "", "";; 1628 out << GetXaxis()->GetXbins()->fArray[i];; 1629 }; 1630 out << ""}; "" << std::endl;; 1631 }; 1632 ; 1633 char quote = '""';; 1634 out<<"" ""<<std::endl;; 1635 out<<"" ""<<ClassName()<<"" *"";; 1636 ; 1637 //histogram pointer has by default the histogram name.; 1638 //however, in case histogram has no directory, it is safer to add a incremental suffix; 1639 static Int_t hcounter = 0;; 1640 TString histName = gInterpreter->MapCppName(GetName());; 1641 if (!fDirectory) {; 1642 hcounter++;; 1643 histNa",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:73477,Modifiability,extend,extendable,73477,"eam a class object.; TH1D::TH1DTH1D()Constructor.Definition TH1.cxx:10402; TH1D::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.h:684; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::Classstatic TClass * Class(); TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:77696,Modifiability,inherit,inherits,77696,"errideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProfileHelper::LabelsInflatestatic void LabelsInflate(T *p, Option_t *)Definition TProfileHelper.h:626; TProfileHelper::GetBinErrorstatic Double_t GetBinError(T *p, Int_t bin)Definition TProfileHelper.h:704; TProfileHelper::ExtendAxisstatic T * ExtendAxis(T *p, Double_t x, TAxis *axis)Definition TProfileHelper.h:430; TProfileHelper::Sumw2static void Sumw2(T *p, Bool_t flag)Definition TProf",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:10297,Safety,avoid,avoid,10297,"weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); 217///; 218/// If a bin has N data points all with the same value Y (especially; 219/// possible when dealing with integers), the spread in Y for that bin; 220/// is zero, and the uncertainty assigned is also zero, and the bin is; 221/// ignored in making subsequent fits.; 222/// To avoid this problem one can use an approximation for the standard deviation S(Y),; 223/// by using the average of all the S(Y) of the other Profile bins. To use this approximation; 224/// one must call before TProfile::Approximate; 225/// This approximation applies only for the default and the 's' options; 226 ; 227void TProfile::BuildOptions(Double_t ymin, Double_t ymax, Option_t *option); 228{; 229 SetErrorOption(option);; 230 ; 231 // create extra profile data structure (bin entries/ y^2 and sum of weight square); 232 TProfileHelper::BuildArray(this);; 233 ; 234 fYmin = ymin;; 235 fYmax = ymax;; 236 fScaling = kFALSE;; 237 fTsumwy = fTsumwy2 = 0;; 238 ; 239}; 240 ; 241////////////////////////////////////////////////////////////////////////////////; 242/// Copy constructor.; 243 ; 244TProfile::TProfile(const TProfile &profile) : TH1D(); 245{; 246 profile.TProfile::Copy(*this);; 247}; 248 ; 249TProfile &TProfile::operator=(const TProfile &profile); 250{; 251 if (this != &profile); 252 profile.TProfile::Copy(*this);; 253 return *this;; 254}; 255 ; 256////",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:60120,Safety,safe,safer,60120,"14 //Note the following restrictions in the code generated:; 1615 // - variable bin size not implemented; 1616 // - SetErrorOption not implemented; 1617 ; 1618 Bool_t nonEqiX = kFALSE;; 1619 Int_t i;; 1620 // Check if the profile has equidistant X bins or not. If not, we; 1621 // create an array holding the bins.; 1622 if (GetXaxis()->GetXbins()->fN && GetXaxis()->GetXbins()->fArray) {; 1623 nonEqiX = kTRUE;; 1624 out << "" Double_t xAxis["" << GetXaxis()->GetXbins()->fN; 1625 << ""] = {"";; 1626 for (i = 0; i < GetXaxis()->GetXbins()->fN; i++) {; 1627 if (i != 0) out << "", "";; 1628 out << GetXaxis()->GetXbins()->fArray[i];; 1629 }; 1630 out << ""}; "" << std::endl;; 1631 }; 1632 ; 1633 char quote = '""';; 1634 out<<"" ""<<std::endl;; 1635 out<<"" ""<<ClassName()<<"" *"";; 1636 ; 1637 //histogram pointer has by default the histogram name.; 1638 //however, in case histogram has no directory, it is safer to add a incremental suffix; 1639 static Int_t hcounter = 0;; 1640 TString histName = gInterpreter->MapCppName(GetName());; 1641 if (!fDirectory) {; 1642 hcounter++;; 1643 histName += ""__"";; 1644 histName += hcounter;; 1645 }; 1646 const char *hname = histName.Data();; 1647 ; 1648 out << hname << "" = new "" << ClassName() << ""("" << quote << hname << quote << "","" << quote << GetTitle() << quote; 1649 << "","" << GetXaxis()->GetNbins();; 1650 if (nonEqiX); 1651 out << "", xAxis"";; 1652 else; 1653 out << "","" << GetXaxis()->GetXmin(); 1654 << "","" << GetXaxis()->GetXmax(); 1655 <<"",""<<quote<<GetErrorOption()<<quote<<"");""<<std::endl;; 1656 ; 1657 // save bin entries; 1658 Int_t bin;; 1659 for (bin=0;bin<fNcells;bin++) {; 1660 Double_t bi = GetBinEntries(bin);; 1661 if (bi) {; 1662 out<<"" ""<<hname<<""->SetBinEntries(""<<bin<<"",""<<bi<<"");""<<std::endl;; 1663 }; 1664 }; 1665 //save bin contents; 1666 for (bin=0;bin<fNcells;bin++) {; 1667 Double_t bc = fArray[bin];; 1668 if (bc) {; 1669 out<<"" ""<<hname<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1670 }; 1671 }; 1672 // save bin errors; 167",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:76183,Security,hash,hash,76183,"axisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH1::fTsumwxDouble_t fTsumwxTotal Sum of weight*X.Definition TH1.h:98; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition THashList.cxx:189; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique obje",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:71592,Testability,test,tested,71592,"inition TAxis.cxx:458; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::ReadVersionvirtual Version_t ReadVersion(UInt_t *start=nullptr, UInt_t *bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class=nullptr)=0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TF11-Dim function classDefinition TF1.h:233; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::RejectedPointstatic Bool_t RejectedPoint()See TF1::RejectPoint above.Definition TF1.cxx:3692; TF1::IsInsidevirtual Bool_t IsInside(const Double_t *x) constreturn kTRUE if the point is inside the function rangeDefinition TF1.h:626; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:10501; TH1D::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10483; TH1D::Streamervoid Streamer(TBuffer &) overrideStream a class object.; TH1D::TH1DTH1D()Constructor.Definition TH1.cxx:10402; TH1D::AddBin",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:3182,Usability,simpl,simple,3182,"ean} \\; 51 \end{align}; 52 \f]; 53 The bin content is always the mean of the Y values, but errors change depending on options:; 54 \f[; 55 \begin{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 62 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; 63 \end{cases}; 64 \end{align}; 65 \f]; 66 In the special case where s(j) is zero (eg, case of 1 entry only in one bin); 67 the bin error e(j) is computed from the average of the s(j) for all bins if; 68 the static function TProfile::Approximate() has been called.; 69 This simple/crude approximation was suggested in order to keep the bin; 70 during a fit operation. But note that this approximation is not the default behaviour.; 71 See also TProfile::BuildOptions for more on error options.; 72 ; 73 ### Creating and drawing a profile histogram; 74~~~{.cpp}; 75{; 76 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 77 auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 78 Float_t px, py, pz;; 79 for ( Int_t i=0; i<25000; i++) {; 80 gRandom->Rannor(px,py);; 81 pz = px*px + py*py;; 82 hprof->Fill(px,pz,1);; 83 }; 84 hprof->Draw();; 85}; 86~~~; 87*/; 88 ; 89////////////////////////////////////////////////////////////////////////////////; 90/// Default constructor for Profile histograms; 91 ; 92TProfile::TProfile(); 93{; 94 BuildOptions(0,0,"""");; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Default destructor for Profile histograms; 99 ; 100TProfile::~TProfile(); 101{; 102}; 103 ; 104/////////////////",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:33824,Usability,simpl,simply,33824," Jul 2002.; 886/// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html; 887 ; 888Double_t TProfile::GetBinError(Int_t bin) const; 889{; 890 return TProfileHelper::GetBinError((TProfile*)this, bin);; 891}; 892 ; 893////////////////////////////////////////////////////////////////////////////////; 894/// Return option to compute profile errors; 895 ; 896Option_t *TProfile::GetErrorOption() const; 897{; 898 if (fErrorMode == kERRORSPREAD) return ""s"";; 899 if (fErrorMode == kERRORSPREADI) return ""i"";; 900 if (fErrorMode == kERRORSPREADG) return ""g"";; 901 return """";; 902}; 903 ; 904////////////////////////////////////////////////////////////////////////////////; 905/// fill the array stats from the contents of this profile.; 906///; 907/// The array stats must be correctly dimensioned in the calling program.; 908///; 909/// - stats[0] = sumw; 910/// - stats[1] = sumw2; 911/// - stats[2] = sumwx; 912/// - stats[3] = sumwx2; 913/// - stats[4] = sumwy; 914/// - stats[5] = sumwy2; 915///; 916/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 917/// is simply a copy of the statistics quantities computed at filling time.; 918/// If a sub-range is specified, the function recomputes these quantities; 919/// from the bin contents in the current axis range.; 920 ; 921void TProfile::GetStats(Double_t *stats) const; 922{; 923 if (fBuffer) ((TProfile*)this)->BufferEmpty();; 924 ; 925 // Loop on bins; 926 Int_t bin, binx;; 927 // identify the case of labels with extension of axis range; 928 // in this case the statistics in x does not make any sense; 929 Bool_t labelHist = ((const_cast<TAxis&>(fXaxis)).GetLabels() && fXaxis.CanExtend() );; 930 ; 931 if ( (fTsumw == 0 /* && fEntries > 0 */) || fXaxis.TestBit(TAxis::kAxisRange) ) {; 932 for (bin=0;bin<6;bin++) stats[bin] = 0;; 933 if (!fBinEntries.fArray) return;; 934 Int_t firstBinX = fXaxis.GetFirst();; 935 Int_t lastBinX = fXaxis.GetLast();; 936 // include underflow/overflow if TH1::StatOverf",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8cxx_source.html:46319,Usability,simpl,simply,46319,"n of h1 by h2.; 1253///; 1254/// `this = (c1*h1)*(c2*h2)`; 1255 ; 1256Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1257{; 1258 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1259 return kFALSE;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Project this profile into a 1-D histogram along X; 1264///; 1265/// The projection is always of the type TH1D.; 1266///; 1267/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// projected histogram obtained with this option will not be correct.; 1282 ; 1283TH1D *TProfile::ProjectionX(const char *name, Option_t *option) const; 1284{; 1285 ; 1286 TString opt = option;; 1287 opt.ToLower();; 1288 Int_t nx = fXaxis.GetNbins();; 1289 ; 1290 // Create the projection histogram; 1291 TString pname = name;; 1292 if (pname == ""_px"") {; 1293 pname = GetName();; 1294 pname.Append(""_px"");; 1295 }; 1296 TH1D *h1;; 1297 const TArrayD ",MatchSource.WIKI,doc/master/TProfile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html
https://root.cern/doc/master/TProfile_8h.html:209,Integrability,depend,dependency,209,". ROOT: hist/hist/inc/TProfile.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TProfile.h File Reference. #include ""TH1.h"". Include dependency graph for TProfile.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TProfile;  Profile Histogram. More...;  . Enumerations; enum  EErrorType { kERRORMEAN = 0; , kERRORSPREAD; , kERRORSPREADI; , kERRORSPREADG; };  . Enumeration Type Documentation. ◆ EErrorType. enum EErrorType. EnumeratorkERRORMEAN ; kERRORSPREAD ; kERRORSPREADI ; kERRORSPREADG . Definition at line 28 of file TProfile.h. histhistincTProfile.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TProfile_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h.html
https://root.cern/doc/master/TProfile_8h_source.html:1311,Availability,error,errors,1311,"**************************************/; 11 ; 12#ifndef ROOT_TProfile; 13#define ROOT_TProfile; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TProfile //; 19// //; 20// Profile histogram class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TH1.h""; 25 ; 26class TProfileHelper;; 27 ; 28enum EErrorType { kERRORMEAN = 0, kERRORSPREAD, kERRORSPREADI, kERRORSPREADG };; 29 ; 30class TF1;; 31 ; 32class TProfile : public TH1D {; 33 ; 34public:; 35 friend class TProfileHelper;; 36 friend class TH1Merger;; 37 ; 38protected:; 39 TArrayD fBinEntries; ///< number of entries per bin; 40 EErrorType fErrorMode; ///< Option to compute errors; 41 Double_t fYmin; ///< Lower limit in Y (if set); 42 Double_t fYmax; ///< Upper limit in Y (if set); 43 Bool_t fScaling; ///<! True when TProfile::Scale is called; 44 Double_t fTsumwy; ///< Total Sum of weight*Y; 45 Double_t fTsumwy2; ///< Total Sum of weight*Y*Y; 46 TArrayD fBinSumw2; ///< Array of sum of squares of weights per bin; 47 ; 48 static Bool_t fgApproximate; ///< bin error approximation option; 49 ; 50 Int_t BufferFill(Double_t, Double_t) override {return -2;} //may not use; 51 virtual Int_t BufferFill(Double_t x, Double_t y, Double_t w);; 52 ; 53 // helper methods for the Merge unification in TProfileHelper; 54 void SetBins(const Int_t* nbins, const Double_t* range) { SetBins(nbins[0], range[0], range[1]); };; 55 Int_t Fill(const Double_t* v) { return Fill(v[0], v[1], v[2]); };; 56 ; 57 Double_t RetrieveBinContent(Int_t bin) const override { return (fBinEntries.fArray[bin] > 0) ? fArray[bin]/fBinEntries.fArray[bin] : 0; }; 58 //virtual void UpdateBinContent(Int_t bin, Double_t content);; 59 Double_t GetBinErrorSqUnchecked(Int_t bin) const override { Double_t err = GetBinError(bin); return err*err; }; 60 ; 61private:; 62 Int_t Fill(Double_t) override { MayNotUse(""Fill(Double_t)""); return -1;}; 63 void FillN(Int_t, con",MatchSource.WIKI,doc/master/TProfile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html
https://root.cern/doc/master/TProfile_8h_source.html:1702,Availability,error,error,1702,"**************************************/; 11 ; 12#ifndef ROOT_TProfile; 13#define ROOT_TProfile; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TProfile //; 19// //; 20// Profile histogram class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TH1.h""; 25 ; 26class TProfileHelper;; 27 ; 28enum EErrorType { kERRORMEAN = 0, kERRORSPREAD, kERRORSPREADI, kERRORSPREADG };; 29 ; 30class TF1;; 31 ; 32class TProfile : public TH1D {; 33 ; 34public:; 35 friend class TProfileHelper;; 36 friend class TH1Merger;; 37 ; 38protected:; 39 TArrayD fBinEntries; ///< number of entries per bin; 40 EErrorType fErrorMode; ///< Option to compute errors; 41 Double_t fYmin; ///< Lower limit in Y (if set); 42 Double_t fYmax; ///< Upper limit in Y (if set); 43 Bool_t fScaling; ///<! True when TProfile::Scale is called; 44 Double_t fTsumwy; ///< Total Sum of weight*Y; 45 Double_t fTsumwy2; ///< Total Sum of weight*Y*Y; 46 TArrayD fBinSumw2; ///< Array of sum of squares of weights per bin; 47 ; 48 static Bool_t fgApproximate; ///< bin error approximation option; 49 ; 50 Int_t BufferFill(Double_t, Double_t) override {return -2;} //may not use; 51 virtual Int_t BufferFill(Double_t x, Double_t y, Double_t w);; 52 ; 53 // helper methods for the Merge unification in TProfileHelper; 54 void SetBins(const Int_t* nbins, const Double_t* range) { SetBins(nbins[0], range[0], range[1]); };; 55 Int_t Fill(const Double_t* v) { return Fill(v[0], v[1], v[2]); };; 56 ; 57 Double_t RetrieveBinContent(Int_t bin) const override { return (fBinEntries.fArray[bin] > 0) ? fArray[bin]/fBinEntries.fArray[bin] : 0; }; 58 //virtual void UpdateBinContent(Int_t bin, Double_t content);; 59 Double_t GetBinErrorSqUnchecked(Int_t bin) const override { Double_t err = GetBinError(bin); return err*err; }; 60 ; 61private:; 62 Int_t Fill(Double_t) override { MayNotUse(""Fill(Double_t)""); return -1;}; 63 void FillN(Int_t, con",MatchSource.WIKI,doc/master/TProfile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html
https://root.cern/doc/master/TProfile_8h_source.html:10548,Availability,error,error,10548," this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TProfileHelperDefinition TProfileHelper.h:30; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::GetBinContentDouble_t GetBinContent(Int_t bin) const overrideReturn bin content of a Profile histogram.Definition TProfile.cxx:824; TProfile::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin) constReturn bin effective entries for a weighted filled Profile histogram.Definition TProfile.cxx:853; TProfile::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile.h:111; TProfile::DivideBool_t Divide(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this/(c1*f1).Definition TProfile.cxx:453; TProfile::RebinTH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideRebin this profile grouping ngroup bins together.Definition TProfile.cxx:1410; TProfile::fgApproximatestatic Bool_t fgApproximatebin error approximation optionDefinition TProfile.h:48; TProfile::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along x axis such that x is in the axis range.Definition TProfile.cxx:1583; TProfile::GetBinContentDouble_t GetBinContent(Int_t bin, Int_t, Int_t) const overrideDefinition TProfile.h:105; TProfile::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile.cxx:1358; TProfile::BuildOptionsvoid BuildOptions(Double_t ymin, Double_t ymax, Option_t *option)Set Profile histogram structure and options.Definition TProfile.cxx:227; TProfile::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x, y and z axis parameters with variable bin sizes.Definition TProfile.h:74; TProfile::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile.h:40; TProfile::MergeLong64_t Merge(TCollection *list) override",MatchSource.WIKI,doc/master/TProfile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html
https://root.cern/doc/master/TProfile_8h_source.html:11449,Availability,error,errors,11449," this profile grouping ngroup bins together.Definition TProfile.cxx:1410; TProfile::fgApproximatestatic Bool_t fgApproximatebin error approximation optionDefinition TProfile.h:48; TProfile::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along x axis such that x is in the axis range.Definition TProfile.cxx:1583; TProfile::GetBinContentDouble_t GetBinContent(Int_t bin, Int_t, Int_t) const overrideDefinition TProfile.h:105; TProfile::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile.cxx:1358; TProfile::BuildOptionsvoid BuildOptions(Double_t ymin, Double_t ymax, Option_t *option)Set Profile histogram structure and options.Definition TProfile.cxx:227; TProfile::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x, y and z axis parameters with variable bin sizes.Definition TProfile.h:74; TProfile::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile.h:40; TProfile::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile.cxx:1192; TProfile::FillInt_t Fill(Double_t) overrideIncrement bin with abscissa X by 1.Definition TProfile.h:62; TProfile::GetYmaxvirtual Double_t GetYmax() constDefinition TProfile.h:116; TProfile::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile histogram to a new profile histogram.Definition TProfile.cxx:423; TProfile::GetYminvirtual Double_t GetYmin() constDefinition TProfile.h:115; TProfile::SetBinsvoid SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t) overrideRedefine x and y axis parameters.Definition TProfile.h:68; TProfile::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x and y axis parameters with variable bin sizes.Definition TProfile.h:70; TProfile::GetBinSumw2virtual const TArrayD * GetBinSumw2() constDefinition TProfil",MatchSource.WIKI,doc/master/TProfile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html
https://root.cern/doc/master/TProfile_8h_source.html:12917,Availability,error,errors,12917,"a Profile histogram to a new profile histogram.Definition TProfile.cxx:423; TProfile::GetYminvirtual Double_t GetYmin() constDefinition TProfile.h:115; TProfile::SetBinsvoid SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t) overrideRedefine x and y axis parameters.Definition TProfile.h:68; TProfile::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x and y axis parameters with variable bin sizes.Definition TProfile.h:70; TProfile::GetBinSumw2virtual const TArrayD * GetBinSumw2() constDefinition TProfile.h:112; TProfile::fYmaxDouble_t fYmaxUpper limit in Y (if set)Definition TProfile.h:42; TProfile::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile.cxx:1700; TProfile::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Option_t *option=""e"") constProject this profile into a 1-D histogram along X.Definition TProfile.cxx:1283; TProfile::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile errors.Definition TProfile.cxx:1777; TProfile::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile.cxx:1612; TProfile::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile histogram.Definition TProfile.cxx:837; TProfile::LabelsDeflatevoid LabelsDeflate(Option_t *axis=""X"") overrideReduce the number of bins for this axis to the number of bins having a label.Definition TProfile.cxx:973; TProfile::GetB2Double_t * GetB2()Definition TProfile.h:65; TProfile::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile.cxx:1729; TProfile::Scalevoid Scale(Double_t c1=1, Option_t *option="""") overrideMultiply this profile by a constant c1.Definition TProfile.cxx:1692; TProfile::TProfileTProfile()Default constructor for Profile histograms.Defin",MatchSource.WIKI,doc/master/TProfile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html
https://root.cern/doc/master/TProfile_8h_source.html:15741,Availability,error,error,15741,":LabelsInflatevoid LabelsInflate(Option_t *axis=""X"") overrideDouble the number of bins for axis.Definition TProfile.cxx:983; TProfile::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TProfile.h:45; TProfile::SetBinsvoid SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Int_t, Double_t, Double_t) overrideRedefine x, y and z axis parameters.Definition TProfile.h:72; TProfile::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TProfile.h:57; TProfile::GetBinContentDouble_t GetBinContent(Int_t bin, Int_t) const overrideDefinition TProfile.h:104; TProfile::MultiplyBool_t Multiply(TF1 *h1, Double_t c1=1) overridePerforms the operation: this = this*c1*f1.Definition TProfile.cxx:1202; TProfile::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile.h:46; TProfile::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile histogram.Definition TProfile.cxx:888; TProfile::AddBool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""") overridePerforms the operation: this = this + c1*f1.Definition TProfile.cxx:259; TProfile::GetBinErrorDouble_t GetBinError(Int_t bin, Int_t, Int_t) const overrideDefinition TProfile.h:108; TProfile::FillInt_t Fill(const Double_t *v)Definition TProfile.h:55; TProfile::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TProfile.h:44; TProfile::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile.h:50; TProfile::GetBDouble_t * GetB()Definition TProfile.h:64; TProfile::~TProfile~TProfile() overrideDefault destructor for Profile histograms.Definition TProfile.cxx:100; TProfile::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile.h:54; TProfile::fYminDouble_t fYminLower limit in Y (if set)Definition TProfile.h:41; TProfile::fBinEntriesTArrayD fBinEntries",MatchSource.WIKI,doc/master/TProfile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html
https://root.cern/doc/master/TProfile_8h_source.html:17396,Availability,error,errors,17396,"ofile::FillInt_t Fill(const Double_t *v)Definition TProfile.h:55; TProfile::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TProfile.h:44; TProfile::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile.h:50; TProfile::GetBDouble_t * GetB()Definition TProfile.h:64; TProfile::~TProfile~TProfile() overrideDefault destructor for Profile histograms.Definition TProfile.cxx:100; TProfile::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile.h:54; TProfile::fYminDouble_t fYminLower limit in Y (if set)Definition TProfile.h:41; TProfile::fBinEntriesTArrayD fBinEntriesnumber of entries per binDefinition TProfile.h:39; TProfile::GetBinErrorDouble_t GetBinError(Int_t bin, Int_t) const overrideDefinition TProfile.h:107; TProfile::GetWDouble_t * GetW()Definition TProfile.h:66; TProfile::Approximatestatic void Approximate(Bool_t approx=kTRUE)Static function to set the fgApproximate flag.Definition TProfile.cxx:324; TProfile::fScalingBool_t fScaling! True when TProfile::Scale is calledDefinition TProfile.h:43; TProfile::GetStatsvoid GetStats(Double_t *stats) const overridefill the array stats from the contents of this profile.Definition TProfile.cxx:921; TProfile::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile errors.Definition TProfile.cxx:896; TProfile::LabelsOptionvoid LabelsOption(Option_t *option=""h"", Option_t *axis=""X"") overrideSet option(s) to draw axis with labels.Definition TProfile.cxx:1001; TProfile::GetW2Double_t * GetW2()Definition TProfile.h:67; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; c2return c2Definition legend2.C:14; v@ vDefinition rootcling_impl.cxx:3699. histhistincTProfile.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TProfile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html
https://root.cern/doc/master/TProfile_8h_source.html:11345,Modifiability,variab,variable,11345,"c1*f1).Definition TProfile.cxx:453; TProfile::RebinTH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideRebin this profile grouping ngroup bins together.Definition TProfile.cxx:1410; TProfile::fgApproximatestatic Bool_t fgApproximatebin error approximation optionDefinition TProfile.h:48; TProfile::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along x axis such that x is in the axis range.Definition TProfile.cxx:1583; TProfile::GetBinContentDouble_t GetBinContent(Int_t bin, Int_t, Int_t) const overrideDefinition TProfile.h:105; TProfile::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile.cxx:1358; TProfile::BuildOptionsvoid BuildOptions(Double_t ymin, Double_t ymax, Option_t *option)Set Profile histogram structure and options.Definition TProfile.cxx:227; TProfile::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x, y and z axis parameters with variable bin sizes.Definition TProfile.h:74; TProfile::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile.h:40; TProfile::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile.cxx:1192; TProfile::FillInt_t Fill(Double_t) overrideIncrement bin with abscissa X by 1.Definition TProfile.h:62; TProfile::GetYmaxvirtual Double_t GetYmax() constDefinition TProfile.h:116; TProfile::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile histogram to a new profile histogram.Definition TProfile.cxx:423; TProfile::GetYminvirtual Double_t GetYmin() constDefinition TProfile.h:115; TProfile::SetBinsvoid SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t) overrideRedefine x and y axis parameters.Definition TProfile.h:68; TProfile::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x and y a",MatchSource.WIKI,doc/master/TProfile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html
https://root.cern/doc/master/TProfile_8h_source.html:12293,Modifiability,variab,variable,12293,"uble_t *, Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x, y and z axis parameters with variable bin sizes.Definition TProfile.h:74; TProfile::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile.h:40; TProfile::MergeLong64_t Merge(TCollection *list) overrideMerge all histograms in the collection in this histogram.Definition TProfile.cxx:1192; TProfile::FillInt_t Fill(Double_t) overrideIncrement bin with abscissa X by 1.Definition TProfile.h:62; TProfile::GetYmaxvirtual Double_t GetYmax() constDefinition TProfile.h:116; TProfile::Copyvoid Copy(TObject &hnew) const overrideCopy a Profile histogram to a new profile histogram.Definition TProfile.cxx:423; TProfile::GetYminvirtual Double_t GetYmin() constDefinition TProfile.h:115; TProfile::SetBinsvoid SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t) overrideRedefine x and y axis parameters.Definition TProfile.h:68; TProfile::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x and y axis parameters with variable bin sizes.Definition TProfile.h:70; TProfile::GetBinSumw2virtual const TArrayD * GetBinSumw2() constDefinition TProfile.h:112; TProfile::fYmaxDouble_t fYmaxUpper limit in Y (if set)Definition TProfile.h:42; TProfile::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile.cxx:1700; TProfile::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Option_t *option=""e"") constProject this profile into a 1-D histogram along X.Definition TProfile.cxx:1283; TProfile::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile errors.Definition TProfile.cxx:1777; TProfile::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile.cxx:1612; TProfile::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile his",MatchSource.WIKI,doc/master/TProfile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:7582,Availability,alive,alive,7582,"8 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, argv);; 198#endif; 199 ; 200 mainThreadState = PyEval_SaveThread();; 201 }; 202 ; 203 {; 204 // For the Python API calls; 205 PyGILRAII gilRaii;; 206 ; 207 // force loading of the ROOT module; 208 const int ret = PyRun_SimpleString(const_cast<char *>(""import ROOT""));; 209 if (ret != 0) {; 210 std::cerr << ""Error: import ROOT failed, check your PYTHONPATH environmental variable."" << std::endl;; 211 return kFALSE;; 212 }; 213 ; 214 if (!gMainDict) {; 215 ; 216 // retrieve the main dictionary; 217 gMainDict = PyModule_GetDict(PyImport_AddModule(const_cast<char *>(""__main__"")));; 218 // The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDict).; 219 // Like this, we avoid unexpectedly affecting how long __main__ is kept; 220 // alive. The gMainDict is only used in Exec(), ExecScript(), and Eval(),; 221 // which should not be called after __main__ is garbage collected anyway.; 222 }; 223 }; 224 ; 225 // python side class construction, managed by ROOT; 226 gROOT->AddClassGenerator(new TPyClassGenerator);; 227 ; 228 // declare success ...; 229 isInitialized = kTRUE;; 230 return kTRUE;; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// Import the named python module and create Cling equivalents for its classes; 235/// and methods.; 236 ; 237Bool_t TPython::Import(const char *mod_name); 238{; 239 // setup; 240 if (!Initialize()); 241 return false;; 242 ; 243 PyGILRAII gilRaii;; 244 ; 245 if (!CPyCppyy::Import(mod_name)) {; 246 return false;; 247 }; 248 ; 249 // force creation of the module as a namespace; 250 TClass::GetClass(mod_name, kTRUE);; 251 ; 252 PyObject *modNameObj = PyUnicode_FromString(mod_name);; 253 PyObject",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:10110,Availability,avail,available,10110,"int i = 0; i < PyList_GET_SIZE(values); ++i) {; 263 PyObject *value = PyList_GET_ITEM(values, i);; 264 Py_INCREF(value);; 265 ; 266 // collect classes; 267 if (PyType_Check(value) || PyObject_HasAttr(value, basesStr.obj())) {; 268 // get full class name (including module); 269 PyObject *pyClName = PyObject_GetAttr(value, cppNameStr.obj());; 270 if (!pyClName) {; 271 pyClName = PyObject_GetAttr(value, nameStr.obj());; 272 }; 273 ; 274 if (PyErr_Occurred()); 275 PyErr_Clear();; 276 ; 277 // build full, qualified name; 278 std::string fullname = mod_name;; 279 fullname += ""."";; 280 fullname += PyUnicode_AsUTF8(pyClName);; 281 ; 282 // force class creation (this will eventually call TPyClassGenerator); 283 TClass::GetClass(fullname.c_str(), kTRUE);; 284 ; 285 Py_XDECREF(pyClName);; 286 }; 287 ; 288 Py_DECREF(value);; 289 }; 290 ; 291 Py_DECREF(values);; 292 Py_DECREF(mod);; 293 Py_DECREF(modNameObj);; 294 ; 295 if (PyErr_Occurred()); 296 return kFALSE;; 297 return kTRUE;; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// Execute the give python script as if it were a macro (effectively an; 302/// execfile in __main__), and create Cling equivalents for any newly available; 303/// python classes.; 304 ; 305void TPython::LoadMacro(const char *name); 306{; 307 // setup; 308 if (!Initialize()); 309 return;; 310 ; 311 PyGILRAII gilRaii;; 312 ; 313 // obtain a reference to look for new classes later; 314 PyObject *old = PyDict_Values(gMainDict);; 315 ; 316// actual execution; 317#if PY_VERSION_HEX < 0x03000000; 318 Exec((std::string(""execfile(\"""") + name + ""\"")"").c_str());; 319#else; 320 Exec((std::string(""__pyroot_f = open(\"""") + name +; 321 ""\""); ""; 322 ""exec(__pyroot_f.read()); ""; 323 ""__pyroot_f.close(); del __pyroot_f""); 324 .c_str());; 325#endif; 326 ; 327 // obtain new __main__ contents; 328 PyObject *current = PyDict_Values(gMainDict);; 329 ; 330 CachedPyString basesStr{""__bases__""};; 331 CachedPyString moduleStr{""__",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:15075,Availability,error,error,15075,"apped over to the std::any result.; 421/// The default value is `""_anyresult""`.; 422/// \return bool Returns `true` if the command was successfully executed,; 423/// otherwise returns `false`.; 424 ; 425Bool_t TPython::Exec(const char *cmd, std::any *result, std::string const &resultName); 426{; 427 // setup; 428 if (!Initialize()); 429 return kFALSE;; 430 ; 431 PyGILRAII gilRaii;; 432 ; 433 std::stringstream command;; 434 // Add the actual command; 435 command << cmd;; 436 // Swap the std::any with the one in the C++ world if required; 437 if (result) {; 438 command << ""; ROOT.Internal.SwapWithObjAtAddr['std::any']("" << resultName << "", ""; 439 << reinterpret_cast<std::intptr_t>(result) << "")"";; 440 }; 441 ; 442 // execute the command; 443 PyObject *pyObjectResult =; 444 PyRun_String(const_cast<char *>(command.str().c_str()), Py_file_input, gMainDict, gMainDict);; 445 ; 446 // test for error; 447 if (pyObjectResult) {; 448 Py_DECREF(pyObjectResult);; 449 return kTRUE;; 450 }; 451 ; 452 PyErr_Print();; 453 return kFALSE;; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Evaluate a python expression (e.g. ""ROOT.TBrowser()"").; 458///; 459/// Caution: do not hold on to the return value: either store it in a builtin; 460/// type (implicit casting will work), or in a pointer to a ROOT object (explicit; 461/// casting to a void* is required).; 462///; 463/// \deprecated Use TPython::Exec() with an std::any output parameter instead.; 464 ; 465const TPyReturn TPython::Eval(const char *expr); 466{; 467 // setup; 468 if (!Initialize()); 469 return TPyReturn();; 470 ; 471 PyGILRAII gilRaii;; 472 ; 473 // evaluate the expression; 474 PyObject *result = PyRun_String(const_cast<char *>(expr), Py_eval_input, gMainDict, gMainDict);; 475 ; 476 // report errors as appropriate; return void; 477 if (!result) {; 478 PyErr_Print();; 479 return TPyReturn();; 480 }; 481 ; 482 // results that require no conversion; 483 if (result == Py_No",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:15997,Availability,error,errors,15997,"3 return kFALSE;; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Evaluate a python expression (e.g. ""ROOT.TBrowser()"").; 458///; 459/// Caution: do not hold on to the return value: either store it in a builtin; 460/// type (implicit casting will work), or in a pointer to a ROOT object (explicit; 461/// casting to a void* is required).; 462///; 463/// \deprecated Use TPython::Exec() with an std::any output parameter instead.; 464 ; 465const TPyReturn TPython::Eval(const char *expr); 466{; 467 // setup; 468 if (!Initialize()); 469 return TPyReturn();; 470 ; 471 PyGILRAII gilRaii;; 472 ; 473 // evaluate the expression; 474 PyObject *result = PyRun_String(const_cast<char *>(expr), Py_eval_input, gMainDict, gMainDict);; 475 ; 476 // report errors as appropriate; return void; 477 if (!result) {; 478 PyErr_Print();; 479 return TPyReturn();; 480 }; 481 ; 482 // results that require no conversion; 483 if (result == Py_None || CPyCppyy::Instance_Check(result) || PyBytes_Check(result) || PyFloat_Check(result) ||; 484 PyLong_Check(result)); 485 return TPyReturn(result);; 486 ; 487 // explicit conversion for python type required; 488 PyObject *pyclass = PyObject_GetAttrString(result, const_cast<char *>(""__class__""));; 489 if (pyclass != 0) {; 490 CachedPyString moduleStr{""__module__""};; 491 CachedPyString nameStr{""__name__""};; 492 ; 493 // retrieve class name and the module in which it resides; 494 PyObject *name = PyObject_GetAttr(pyclass, nameStr.obj());; 495 PyObject *module = PyObject_GetAttr(pyclass, moduleStr.obj());; 496 ; 497 // concat name; 498 std::string qname = std::string(PyUnicode_AsUTF8(module)) + '.' + PyUnicode_AsUTF8(name);; 499 Py_DECREF(module);; 500 Py_DECREF(name);; 501 Py_DECREF(pyclass);; 502 ; 503 // locate ROOT style class with this name; 504 TClass *klass = TClass::GetClass(qname.c_str());; 505 ; 506 // construct general ROOT python object that pretends to be of class 'klass'; 507 if (klass != 0);",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:21242,Availability,error,errors,21242,"/ setup; 614 if (!Initialize()); 615 return kFALSE;; 616 ; 617 PyGILRAII gilRaii;; 618 ; 619 // direct pointer comparison of type member; 620 return CPyCppyy::Overload_CheckExact(pyobject);; 621}; 622 ; 623////////////////////////////////////////////////////////////////////////////////; 624/// Extract the object pointer held by the CPPInstance pyobject.; 625 ; 626void *TPython::CPPInstance_AsVoidPtr(PyObject *pyobject); 627{; 628 // setup; 629 if (!Initialize()); 630 return 0;; 631 ; 632 PyGILRAII gilRaii;; 633 ; 634 // get held object (may be null); 635 return CPyCppyy::Instance_AsVoidPtr(pyobject);; 636}; 637 ; 638////////////////////////////////////////////////////////////////////////////////; 639/// Bind the addr to a python object of class defined by classname.; 640 ; 641PyObject *TPython::CPPInstance_FromVoidPtr(void *addr, const char *classname, Bool_t python_owns); 642{; 643 // setup; 644 if (!Initialize()); 645 return 0;; 646 ; 647 PyGILRAII gilRaii;; 648 ; 649 // perform cast (the call will check TClass and addr, and set python errors); 650 // give ownership, for ref-counting, to the python side, if so requested; 651 return CPyCppyy::Instance_FromVoidPtr(addr, classname, python_owns);; 652}; API.h; PyBytes_Check#define PyBytes_CheckDefinition CPyCppyy.h:61; PyObject_object PyObjectDefinition PyMethodBase.h:43; Riostream.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClassRef.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth G",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:5873,Modifiability,config,config,5873,"e); }; 130};; 131 ; 132} // namespace; 133 ; 134//- static public members ----------------------------------------------------; 135/// Initialization method: setup the python interpreter and load the; 136/// ROOT module.; 137Bool_t TPython::Initialize(); 138{; 139 // Don't initialize Python from two concurrent threads; 140 static std::mutex initMutex;; 141 const std::lock_guard<std::mutex> lock(initMutex);; 142 ; 143 static Bool_t isInitialized = kFALSE;; 144 if (isInitialized); 145 return kTRUE;; 146 ; 147 if (!Py_IsInitialized()) {; 148// this happens if Cling comes in first; 149#if PY_VERSION_HEX < 0x03020000; 150 PyEval_InitThreads();; 151#endif; 152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 163 PyStatus status;; 164 PyConfig config;; 165 ; 166 PyConfig_InitPythonConfig(&config);; 167 ; 168 status = PyConfig_SetArgv(&config, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""Error when initializing Python."" << std::endl;; 179 return kFALSE;; 180 }; 181 PyConfig_Clear(&config);; 182#endif; 183#if PY_VERSION_HEX >= 0x03020000; 184#if PY_VERSION_HEX < 0x03090000; 185 PyEval_InitThreads();; 186#endif; 187#endif; 188 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, a",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:5919,Modifiability,config,config,5919,"e); }; 130};; 131 ; 132} // namespace; 133 ; 134//- static public members ----------------------------------------------------; 135/// Initialization method: setup the python interpreter and load the; 136/// ROOT module.; 137Bool_t TPython::Initialize(); 138{; 139 // Don't initialize Python from two concurrent threads; 140 static std::mutex initMutex;; 141 const std::lock_guard<std::mutex> lock(initMutex);; 142 ; 143 static Bool_t isInitialized = kFALSE;; 144 if (isInitialized); 145 return kTRUE;; 146 ; 147 if (!Py_IsInitialized()) {; 148// this happens if Cling comes in first; 149#if PY_VERSION_HEX < 0x03020000; 150 PyEval_InitThreads();; 151#endif; 152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 163 PyStatus status;; 164 PyConfig config;; 165 ; 166 PyConfig_InitPythonConfig(&config);; 167 ; 168 status = PyConfig_SetArgv(&config, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""Error when initializing Python."" << std::endl;; 179 return kFALSE;; 180 }; 181 PyConfig_Clear(&config);; 182#endif; 183#if PY_VERSION_HEX >= 0x03020000; 184#if PY_VERSION_HEX < 0x03090000; 185 PyEval_InitThreads();; 186#endif; 187#endif; 188 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, a",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:5966,Modifiability,config,config,5966,"e); }; 130};; 131 ; 132} // namespace; 133 ; 134//- static public members ----------------------------------------------------; 135/// Initialization method: setup the python interpreter and load the; 136/// ROOT module.; 137Bool_t TPython::Initialize(); 138{; 139 // Don't initialize Python from two concurrent threads; 140 static std::mutex initMutex;; 141 const std::lock_guard<std::mutex> lock(initMutex);; 142 ; 143 static Bool_t isInitialized = kFALSE;; 144 if (isInitialized); 145 return kTRUE;; 146 ; 147 if (!Py_IsInitialized()) {; 148// this happens if Cling comes in first; 149#if PY_VERSION_HEX < 0x03020000; 150 PyEval_InitThreads();; 151#endif; 152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 163 PyStatus status;; 164 PyConfig config;; 165 ; 166 PyConfig_InitPythonConfig(&config);; 167 ; 168 status = PyConfig_SetArgv(&config, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""Error when initializing Python."" << std::endl;; 179 return kFALSE;; 180 }; 181 PyConfig_Clear(&config);; 182#endif; 183#if PY_VERSION_HEX >= 0x03020000; 184#if PY_VERSION_HEX < 0x03090000; 185 PyEval_InitThreads();; 186#endif; 187#endif; 188 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, a",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:6047,Modifiability,config,config,6047,"e); }; 130};; 131 ; 132} // namespace; 133 ; 134//- static public members ----------------------------------------------------; 135/// Initialization method: setup the python interpreter and load the; 136/// ROOT module.; 137Bool_t TPython::Initialize(); 138{; 139 // Don't initialize Python from two concurrent threads; 140 static std::mutex initMutex;; 141 const std::lock_guard<std::mutex> lock(initMutex);; 142 ; 143 static Bool_t isInitialized = kFALSE;; 144 if (isInitialized); 145 return kTRUE;; 146 ; 147 if (!Py_IsInitialized()) {; 148// this happens if Cling comes in first; 149#if PY_VERSION_HEX < 0x03020000; 150 PyEval_InitThreads();; 151#endif; 152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 163 PyStatus status;; 164 PyConfig config;; 165 ; 166 PyConfig_InitPythonConfig(&config);; 167 ; 168 status = PyConfig_SetArgv(&config, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""Error when initializing Python."" << std::endl;; 179 return kFALSE;; 180 }; 181 PyConfig_Clear(&config);; 182#endif; 183#if PY_VERSION_HEX >= 0x03020000; 184#if PY_VERSION_HEX < 0x03090000; 185 PyEval_InitThreads();; 186#endif; 187#endif; 188 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, a",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:6205,Modifiability,config,config,6205,"> lock(initMutex);; 142 ; 143 static Bool_t isInitialized = kFALSE;; 144 if (isInitialized); 145 return kTRUE;; 146 ; 147 if (!Py_IsInitialized()) {; 148// this happens if Cling comes in first; 149#if PY_VERSION_HEX < 0x03020000; 150 PyEval_InitThreads();; 151#endif; 152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 163 PyStatus status;; 164 PyConfig config;; 165 ; 166 PyConfig_InitPythonConfig(&config);; 167 ; 168 status = PyConfig_SetArgv(&config, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""Error when initializing Python."" << std::endl;; 179 return kFALSE;; 180 }; 181 PyConfig_Clear(&config);; 182#endif; 183#if PY_VERSION_HEX >= 0x03020000; 184#if PY_VERSION_HEX < 0x03090000; 185 PyEval_InitThreads();; 186#endif; 187#endif; 188 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, argv);; 198#endif; 199 ; 200 mainThreadState = PyEval_SaveThread();; 201 }; 202 ; 203 {; 204 // For the Python API calls; 205 PyGILRAII gilRaii;; 206 ; 207 // force loading of the ROOT module; 208 const int ret = PyRun_SimpleString(const_cast<char *>(""import ROOT""));; 209 if (ret != 0) {; 210 std::cerr << ""Error: import ROOT failed, check your PYTHONPATH environmental variable."" << std::e",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:6274,Modifiability,config,config,6274,"> lock(initMutex);; 142 ; 143 static Bool_t isInitialized = kFALSE;; 144 if (isInitialized); 145 return kTRUE;; 146 ; 147 if (!Py_IsInitialized()) {; 148// this happens if Cling comes in first; 149#if PY_VERSION_HEX < 0x03020000; 150 PyEval_InitThreads();; 151#endif; 152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 163 PyStatus status;; 164 PyConfig config;; 165 ; 166 PyConfig_InitPythonConfig(&config);; 167 ; 168 status = PyConfig_SetArgv(&config, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""Error when initializing Python."" << std::endl;; 179 return kFALSE;; 180 }; 181 PyConfig_Clear(&config);; 182#endif; 183#if PY_VERSION_HEX >= 0x03020000; 184#if PY_VERSION_HEX < 0x03090000; 185 PyEval_InitThreads();; 186#endif; 187#endif; 188 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, argv);; 198#endif; 199 ; 200 mainThreadState = PyEval_SaveThread();; 201 }; 202 ; 203 {; 204 // For the Python API calls; 205 PyGILRAII gilRaii;; 206 ; 207 // force loading of the ROOT module; 208 const int ret = PyRun_SimpleString(const_cast<char *>(""import ROOT""));; 209 if (ret != 0) {; 210 std::cerr << ""Error: import ROOT failed, check your PYTHONPATH environmental variable."" << std::e",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:6397,Modifiability,config,config,6397,"152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 163 PyStatus status;; 164 PyConfig config;; 165 ; 166 PyConfig_InitPythonConfig(&config);; 167 ; 168 status = PyConfig_SetArgv(&config, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""Error when initializing Python."" << std::endl;; 179 return kFALSE;; 180 }; 181 PyConfig_Clear(&config);; 182#endif; 183#if PY_VERSION_HEX >= 0x03020000; 184#if PY_VERSION_HEX < 0x03090000; 185 PyEval_InitThreads();; 186#endif; 187#endif; 188 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, argv);; 198#endif; 199 ; 200 mainThreadState = PyEval_SaveThread();; 201 }; 202 ; 203 {; 204 // For the Python API calls; 205 PyGILRAII gilRaii;; 206 ; 207 // force loading of the ROOT module; 208 const int ret = PyRun_SimpleString(const_cast<char *>(""import ROOT""));; 209 if (ret != 0) {; 210 std::cerr << ""Error: import ROOT failed, check your PYTHONPATH environmental variable."" << std::endl;; 211 return kFALSE;; 212 }; 213 ; 214 if (!gMainDict) {; 215 ; 216 // retrieve the main dictionary; 217 gMainDict = PyModule_GetDict(PyImport_AddModule(const_cast<char *>(""__main__"")));; 218 // The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDic",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:7205,Modifiability,variab,variable,7205,"fig, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""Error when initializing Python."" << std::endl;; 179 return kFALSE;; 180 }; 181 PyConfig_Clear(&config);; 182#endif; 183#if PY_VERSION_HEX >= 0x03020000; 184#if PY_VERSION_HEX < 0x03090000; 185 PyEval_InitThreads();; 186#endif; 187#endif; 188 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, argv);; 198#endif; 199 ; 200 mainThreadState = PyEval_SaveThread();; 201 }; 202 ; 203 {; 204 // For the Python API calls; 205 PyGILRAII gilRaii;; 206 ; 207 // force loading of the ROOT module; 208 const int ret = PyRun_SimpleString(const_cast<char *>(""import ROOT""));; 209 if (ret != 0) {; 210 std::cerr << ""Error: import ROOT failed, check your PYTHONPATH environmental variable."" << std::endl;; 211 return kFALSE;; 212 }; 213 ; 214 if (!gMainDict) {; 215 ; 216 // retrieve the main dictionary; 217 gMainDict = PyModule_GetDict(PyImport_AddModule(const_cast<char *>(""__main__"")));; 218 // The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDict).; 219 // Like this, we avoid unexpectedly affecting how long __main__ is kept; 220 // alive. The gMainDict is only used in Exec(), ExecScript(), and Eval(),; 221 // which should not be called after __main__ is garbage collected anyway.; 222 }; 223 }; 224 ; 225 // python side class construction, managed by ROOT; 226 gROOT->AddClassGenerator(new TPyClassGenerator);; 227 ; 228 // declare success ...; 229 isInitialized = kTRUE;; 230 return kTRUE;; 231}; 232 ; 233//////////",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:13668,Modifiability,variab,variable,13668,"xecScript(const char *name, int argc, const char **argv); 382{; 383 ; 384 // setup; 385 if (!Initialize()); 386 return;; 387 ; 388 PyGILRAII gilRaii;; 389 ; 390 // verify arguments; 391 if (!name) {; 392 std::cerr << ""Error: no file name specified."" << std::endl;; 393 return;; 394 }; 395 ; 396 std::vector<std::string> args(argc);; 397 for (int i = 0; i < argc; ++i) {; 398 args[i] = argv[i];; 399 }; 400 CPyCppyy::ExecScript(name, args);; 401}; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Executes a Python command within the current Python environment.; 405///; 406/// This function initializes the Python environment if it is not already; 407/// initialized. It then executes the specified Python command string using the; 408/// Python C API.; 409///; 410/// In the Python command, you can change the value of a special TPyResult; 411/// object returned by TPyBuffer(). If the optional result parameter is; 412/// non-zero, the result parameter will be swapped with a std::any variable on; 413/// the Python side. You need to define this variable yourself, and it needs to; 414/// be of type std::any and its name needs to be `""_anyresult""` by default.; 415/// Like this, you can pass information from Python back to C++.; 416///; 417/// \param cmd The Python command to be executed as a string.; 418/// \param result Optional pointer to a std::any object that can be used to; 419/// transfer results from Python to C++.; 420/// \param resultName Name of the Python variable that is swapped over to the std::any result.; 421/// The default value is `""_anyresult""`.; 422/// \return bool Returns `true` if the command was successfully executed,; 423/// otherwise returns `false`.; 424 ; 425Bool_t TPython::Exec(const char *cmd, std::any *result, std::string const &resultName); 426{; 427 // setup; 428 if (!Initialize()); 429 return kFALSE;; 430 ; 431 PyGILRAII gilRaii;; 432 ; 433 std::stringstream command;; 434 // Add the actual command; 43",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:13729,Modifiability,variab,variable,13729,"gilRaii;; 389 ; 390 // verify arguments; 391 if (!name) {; 392 std::cerr << ""Error: no file name specified."" << std::endl;; 393 return;; 394 }; 395 ; 396 std::vector<std::string> args(argc);; 397 for (int i = 0; i < argc; ++i) {; 398 args[i] = argv[i];; 399 }; 400 CPyCppyy::ExecScript(name, args);; 401}; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Executes a Python command within the current Python environment.; 405///; 406/// This function initializes the Python environment if it is not already; 407/// initialized. It then executes the specified Python command string using the; 408/// Python C API.; 409///; 410/// In the Python command, you can change the value of a special TPyResult; 411/// object returned by TPyBuffer(). If the optional result parameter is; 412/// non-zero, the result parameter will be swapped with a std::any variable on; 413/// the Python side. You need to define this variable yourself, and it needs to; 414/// be of type std::any and its name needs to be `""_anyresult""` by default.; 415/// Like this, you can pass information from Python back to C++.; 416///; 417/// \param cmd The Python command to be executed as a string.; 418/// \param result Optional pointer to a std::any object that can be used to; 419/// transfer results from Python to C++.; 420/// \param resultName Name of the Python variable that is swapped over to the std::any result.; 421/// The default value is `""_anyresult""`.; 422/// \return bool Returns `true` if the command was successfully executed,; 423/// otherwise returns `false`.; 424 ; 425Bool_t TPython::Exec(const char *cmd, std::any *result, std::string const &resultName); 426{; 427 // setup; 428 if (!Initialize()); 429 return kFALSE;; 430 ; 431 PyGILRAII gilRaii;; 432 ; 433 std::stringstream command;; 434 // Add the actual command; 435 command << cmd;; 436 // Swap the std::any with the one in the C++ world if required; 437 if (result) {; 438 command << ""; ROOT.Internal.Swap",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:14157,Modifiability,variab,variable,14157,"////////; 404/// Executes a Python command within the current Python environment.; 405///; 406/// This function initializes the Python environment if it is not already; 407/// initialized. It then executes the specified Python command string using the; 408/// Python C API.; 409///; 410/// In the Python command, you can change the value of a special TPyResult; 411/// object returned by TPyBuffer(). If the optional result parameter is; 412/// non-zero, the result parameter will be swapped with a std::any variable on; 413/// the Python side. You need to define this variable yourself, and it needs to; 414/// be of type std::any and its name needs to be `""_anyresult""` by default.; 415/// Like this, you can pass information from Python back to C++.; 416///; 417/// \param cmd The Python command to be executed as a string.; 418/// \param result Optional pointer to a std::any object that can be used to; 419/// transfer results from Python to C++.; 420/// \param resultName Name of the Python variable that is swapped over to the std::any result.; 421/// The default value is `""_anyresult""`.; 422/// \return bool Returns `true` if the command was successfully executed,; 423/// otherwise returns `false`.; 424 ; 425Bool_t TPython::Exec(const char *cmd, std::any *result, std::string const &resultName); 426{; 427 // setup; 428 if (!Initialize()); 429 return kFALSE;; 430 ; 431 PyGILRAII gilRaii;; 432 ; 433 std::stringstream command;; 434 // Add the actual command; 435 command << cmd;; 436 // Swap the std::any with the one in the C++ world if required; 437 if (result) {; 438 command << ""; ROOT.Internal.SwapWithObjAtAddr['std::any']("" << resultName << "", ""; 439 << reinterpret_cast<std::intptr_t>(result) << "")"";; 440 }; 441 ; 442 // execute the command; 443 PyObject *pyObjectResult =; 444 PyRun_String(const_cast<char *>(command.str().c_str()), Py_file_input, gMainDict, gMainDict);; 445 ; 446 // test for error; 447 if (pyObjectResult) {; 448 Py_DECREF(pyObjectResult);; 449 return kTRUE;; 4",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:18961,Modifiability,inherit,inheritance,18961,"ring(gMainDict, const_cast<char *>(label), bound) == 0;; 535 Py_DECREF(bound);; 536 ; 537 return bOk;; 538 }; 539 }; 540 ; 541 return kFALSE;; 542}; 543 ; 544////////////////////////////////////////////////////////////////////////////////; 545/// Enter an interactive python session (exit with ^D). State is preserved; 546/// between successive calls.; 547 ; 548void TPython::Prompt(); 549{; 550 // setup; 551 if (!Initialize()) {; 552 return;; 553 }; 554 ; 555 PyGILRAII gilRaii;; 556 ; 557 // enter i/o interactive mode; 558 PyRun_InteractiveLoop(stdin, const_cast<char *>(""\0""));; 559}; 560 ; 561////////////////////////////////////////////////////////////////////////////////; 562/// Test whether the type of the given pyobject is of CPPInstance type or any; 563/// derived type.; 564 ; 565Bool_t TPython::CPPInstance_Check(PyObject *pyobject); 566{; 567 // setup; 568 if (!Initialize()); 569 return kFALSE;; 570 ; 571 PyGILRAII gilRaii;; 572 ; 573 // detailed walk through inheritance hierarchy; 574 return CPyCppyy::Instance_Check(pyobject);; 575}; 576 ; 577////////////////////////////////////////////////////////////////////////////////; 578/// Test whether the type of the given pyobject is CPPinstance type.; 579 ; 580Bool_t TPython::CPPInstance_CheckExact(PyObject *pyobject); 581{; 582 // setup; 583 if (!Initialize()); 584 return kFALSE;; 585 ; 586 PyGILRAII gilRaii;; 587 ; 588 // direct pointer comparison of type member; 589 return CPyCppyy::Instance_CheckExact(pyobject);; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Test whether the type of the given pyobject is of CPPOverload type or any; 594/// derived type.; 595 ; 596Bool_t TPython::CPPOverload_Check(PyObject *pyobject); 597{; 598 // setup; 599 if (!Initialize()); 600 return kFALSE;; 601 ; 602 PyGILRAII gilRaii;; 603 ; 604 // detailed walk through inheritance hierarchy; 605 return CPyCppyy::Overload_Check(pyobject);; 606}; 607 ; 608//////////////////////////////",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:19867,Modifiability,inherit,inheritance,19867,ALSE;; 570 ; 571 PyGILRAII gilRaii;; 572 ; 573 // detailed walk through inheritance hierarchy; 574 return CPyCppyy::Instance_Check(pyobject);; 575}; 576 ; 577////////////////////////////////////////////////////////////////////////////////; 578/// Test whether the type of the given pyobject is CPPinstance type.; 579 ; 580Bool_t TPython::CPPInstance_CheckExact(PyObject *pyobject); 581{; 582 // setup; 583 if (!Initialize()); 584 return kFALSE;; 585 ; 586 PyGILRAII gilRaii;; 587 ; 588 // direct pointer comparison of type member; 589 return CPyCppyy::Instance_CheckExact(pyobject);; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Test whether the type of the given pyobject is of CPPOverload type or any; 594/// derived type.; 595 ; 596Bool_t TPython::CPPOverload_Check(PyObject *pyobject); 597{; 598 // setup; 599 if (!Initialize()); 600 return kFALSE;; 601 ; 602 PyGILRAII gilRaii;; 603 ; 604 // detailed walk through inheritance hierarchy; 605 return CPyCppyy::Overload_Check(pyobject);; 606}; 607 ; 608////////////////////////////////////////////////////////////////////////////////; 609/// Test whether the type of the given pyobject is CPPOverload type.; 610 ; 611Bool_t TPython::CPPOverload_CheckExact(PyObject *pyobject); 612{; 613 // setup; 614 if (!Initialize()); 615 return kFALSE;; 616 ; 617 PyGILRAII gilRaii;; 618 ; 619 // direct pointer comparison of type member; 620 return CPyCppyy::Overload_CheckExact(pyobject);; 621}; 622 ; 623////////////////////////////////////////////////////////////////////////////////; 624/// Extract the object pointer held by the CPPInstance pyobject.; 625 ; 626void *TPython::CPPInstance_AsVoidPtr(PyObject *pyobject); 627{; 628 // setup; 629 if (!Initialize()); 630 return 0;; 631 ; 632 PyGILRAII gilRaii;; 633 ; 634 // get held object (may be null); 635 return CPyCppyy::Instance_AsVoidPtr(pyobject);; 636}; 637 ; 638/////////////////////////////////////////////////////////////////////////////,MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:2820,Performance,load,load,2820,"a TNamed on the python side, and transfer it back and forth.; 50/// root [1] std::any res1;; 51/// root [2] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed']('hello', '')"", &res1);; 52/// root [3] TPython::Bind(&std::any_cast<TNamed&>(res1), ""n"");; 53/// root [4] std::any res2;; 54/// root [5] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed*', 'TNamed*'](n)"", &res2);; 55/// root [6] (&std::any_cast<TNamed&>(res1) == std::any_cast<TNamed*>(res2)); 56/// (bool) true; 57///; 58/// // Variables can cross-over by using an `std::any` with a specific name.; 59/// root [6] TPython::Exec(""_anyresult = ROOT.std.make_any['Int_t'](1 + 1)"", &res1);; 60/// root [7] std::any_cast<int>(res1); 61/// (int) 2; 62/// ~~~; 63///; 64/// And with a python file `MyPyClass.py` like this:; 65/// ~~~{.py}; 66/// print 'creating class MyPyClass ... '; 67///; 68/// class MyPyClass:; 69/// def __init__( self ):; 70/// print 'in MyPyClass.__init__'; 71///; 72/// def gime( self, what ):; 73/// return what; 74/// ~~~; 75/// one can load a python module, and use the class. Casts are; 76/// necessary as the type information can not be otherwise derived.; 77/// ~~~{.cpp}; 78/// root [6] TPython::LoadMacro( ""MyPyClass.py"" );; 79/// creating class MyPyClass ...; 80/// root [7] MyPyClass m;; 81/// in MyPyClass.__init__; 82/// root [8] std::string s = (char*)m.gime( ""aap"" );; 83/// root [9] s; 84/// (class TString)""aap""; 85/// ~~~; 86/// It is possible to switch between interpreters by calling `TPython::Prompt()`; 87/// on the Cling side, while returning with `^D` (EOF). State is preserved between; 88/// successive switches.; 89///; 90/// The API part provides (direct) C++ access to the bindings functionality of; 91/// PyROOT. It allows verifying that you deal with a PyROOT python object in the; 92/// first place (CPPInstance_Check for CPPInstance and any derived types, as well; 93/// as CPPInstance_CheckExact for CPPInstance's only); and it allows conversions; 94/// of `void*` to an CPPInstanc",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:5025,Performance,load,load,5025,"----------------------------------------------------------; 97ClassImp(TPython);; 98static PyObject *gMainDict = 0;; 99 ; 100namespace {; 101 ; 102class CachedPyString {; 103 ; 104public:; 105 CachedPyString(const char *name) : fObj{PyUnicode_FromString(name)} {}; 106 ; 107 CachedPyString(CachedPyString const &) = delete;; 108 CachedPyString(CachedPyString &&) = delete;; 109 CachedPyString &operator=(CachedPyString const &) = delete;; 110 CachedPyString &operator=(CachedPyString &&) = delete;; 111 ; 112 ~CachedPyString() { Py_DECREF(fObj); }; 113 ; 114 PyObject *obj() { return fObj; }; 115 ; 116private:; 117 PyObject *fObj = nullptr;; 118};; 119 ; 120PyThreadState *mainThreadState;; 121 ; 122// To acquire the GIL as described here:; 123// https://docs.python.org/3/c-api/init.html#non-python-created-threads; 124class PyGILRAII {; 125 PyGILState_STATE m_GILState;; 126 ; 127public:; 128 PyGILRAII() : m_GILState(PyGILState_Ensure()) {}; 129 ~PyGILRAII() { PyGILState_Release(m_GILState); }; 130};; 131 ; 132} // namespace; 133 ; 134//- static public members ----------------------------------------------------; 135/// Initialization method: setup the python interpreter and load the; 136/// ROOT module.; 137Bool_t TPython::Initialize(); 138{; 139 // Don't initialize Python from two concurrent threads; 140 static std::mutex initMutex;; 141 const std::lock_guard<std::mutex> lock(initMutex);; 142 ; 143 static Bool_t isInitialized = kFALSE;; 144 if (isInitialized); 145 return kTRUE;; 146 ; 147 if (!Py_IsInitialized()) {; 148// this happens if Cling comes in first; 149#if PY_VERSION_HEX < 0x03020000; 150 PyEval_InitThreads();; 151#endif; 152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 16",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:5135,Performance,concurren,concurrent,5135,"ator=(CachedPyString &&) = delete;; 111 ; 112 ~CachedPyString() { Py_DECREF(fObj); }; 113 ; 114 PyObject *obj() { return fObj; }; 115 ; 116private:; 117 PyObject *fObj = nullptr;; 118};; 119 ; 120PyThreadState *mainThreadState;; 121 ; 122// To acquire the GIL as described here:; 123// https://docs.python.org/3/c-api/init.html#non-python-created-threads; 124class PyGILRAII {; 125 PyGILState_STATE m_GILState;; 126 ; 127public:; 128 PyGILRAII() : m_GILState(PyGILState_Ensure()) {}; 129 ~PyGILRAII() { PyGILState_Release(m_GILState); }; 130};; 131 ; 132} // namespace; 133 ; 134//- static public members ----------------------------------------------------; 135/// Initialization method: setup the python interpreter and load the; 136/// ROOT module.; 137Bool_t TPython::Initialize(); 138{; 139 // Don't initialize Python from two concurrent threads; 140 static std::mutex initMutex;; 141 const std::lock_guard<std::mutex> lock(initMutex);; 142 ; 143 static Bool_t isInitialized = kFALSE;; 144 if (isInitialized); 145 return kTRUE;; 146 ; 147 if (!Py_IsInitialized()) {; 148// this happens if Cling comes in first; 149#if PY_VERSION_HEX < 0x03020000; 150 PyEval_InitThreads();; 151#endif; 152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 163 PyStatus status;; 164 PyConfig config;; 165 ; 166 PyConfig_InitPythonConfig(&config);; 167 ; 168 status = PyConfig_SetArgv(&config, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""E",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:6999,Performance,load,loading,6999,"fig, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""Error when initializing Python."" << std::endl;; 179 return kFALSE;; 180 }; 181 PyConfig_Clear(&config);; 182#endif; 183#if PY_VERSION_HEX >= 0x03020000; 184#if PY_VERSION_HEX < 0x03090000; 185 PyEval_InitThreads();; 186#endif; 187#endif; 188 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, argv);; 198#endif; 199 ; 200 mainThreadState = PyEval_SaveThread();; 201 }; 202 ; 203 {; 204 // For the Python API calls; 205 PyGILRAII gilRaii;; 206 ; 207 // force loading of the ROOT module; 208 const int ret = PyRun_SimpleString(const_cast<char *>(""import ROOT""));; 209 if (ret != 0) {; 210 std::cerr << ""Error: import ROOT failed, check your PYTHONPATH environmental variable."" << std::endl;; 211 return kFALSE;; 212 }; 213 ; 214 if (!gMainDict) {; 215 ; 216 // retrieve the main dictionary; 217 gMainDict = PyModule_GetDict(PyImport_AddModule(const_cast<char *>(""__main__"")));; 218 // The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDict).; 219 // Like this, we avoid unexpectedly affecting how long __main__ is kept; 220 // alive. The gMainDict is only used in Exec(), ExecScript(), and Eval(),; 221 // which should not be called after __main__ is garbage collected anyway.; 222 }; 223 }; 224 ; 225 // python side class construction, managed by ROOT; 226 gROOT->AddClassGenerator(new TPyClassGenerator);; 227 ; 228 // declare success ...; 229 isInitialized = kTRUE;; 230 return kTRUE;; 231}; 232 ; 233//////////",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:21176,Performance,perform,perform,21176,"/ setup; 614 if (!Initialize()); 615 return kFALSE;; 616 ; 617 PyGILRAII gilRaii;; 618 ; 619 // direct pointer comparison of type member; 620 return CPyCppyy::Overload_CheckExact(pyobject);; 621}; 622 ; 623////////////////////////////////////////////////////////////////////////////////; 624/// Extract the object pointer held by the CPPInstance pyobject.; 625 ; 626void *TPython::CPPInstance_AsVoidPtr(PyObject *pyobject); 627{; 628 // setup; 629 if (!Initialize()); 630 return 0;; 631 ; 632 PyGILRAII gilRaii;; 633 ; 634 // get held object (may be null); 635 return CPyCppyy::Instance_AsVoidPtr(pyobject);; 636}; 637 ; 638////////////////////////////////////////////////////////////////////////////////; 639/// Bind the addr to a python object of class defined by classname.; 640 ; 641PyObject *TPython::CPPInstance_FromVoidPtr(void *addr, const char *classname, Bool_t python_owns); 642{; 643 // setup; 644 if (!Initialize()); 645 return 0;; 646 ; 647 PyGILRAII gilRaii;; 648 ; 649 // perform cast (the call will check TClass and addr, and set python errors); 650 // give ownership, for ref-counting, to the python side, if so requested; 651 return CPyCppyy::Instance_FromVoidPtr(addr, classname, python_owns);; 652}; API.h; PyBytes_Check#define PyBytes_CheckDefinition CPyCppyy.h:61; PyObject_object PyObjectDefinition PyMethodBase.h:43; Riostream.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClassRef.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth G",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:22797,Performance,load,load,22797,"char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; TObject.h; gMainDictstatic PyObject * gMainDictDefinition TPython.cxx:98; TPython.h; operator=Binding & operator=(OUT(*fun)(void))Definition TRInterface_Binding.h:15; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TPyClassGeneratorDefinition TPyClassGenerator.h:18; TPyReturnDefinition TPyReturn.h:30; TPythonAccessing the Python interpreter from C++.Definition TPython.h:44; TPython::ExecScriptstatic void ExecScript(const char *name, int argc=0, const char **argv=nullptr)Execute a python stand-alone script, with argv CLI arguments.Definition TPython.cxx:381; TPython::Importstatic Bool_t Import(const char *name)Import the named python module and create Cling equivalents for its classes and methods.Definition TPython.cxx:237; TPython::LoadMacrostatic void LoadMacro(const char *name)Execute the give python script as if it were a macro (effectively an execfile in main),...Definition TPython.cxx:305; TPython::Execstatic Bool_t Exec(c",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:24226,Performance,load,load,24226,"Accessing the Python interpreter from C++.Definition TPython.h:44; TPython::ExecScriptstatic void ExecScript(const char *name, int argc=0, const char **argv=nullptr)Execute a python stand-alone script, with argv CLI arguments.Definition TPython.cxx:381; TPython::Importstatic Bool_t Import(const char *name)Import the named python module and create Cling equivalents for its classes and methods.Definition TPython.cxx:237; TPython::LoadMacrostatic void LoadMacro(const char *name)Execute the give python script as if it were a macro (effectively an execfile in main),...Definition TPython.cxx:305; TPython::Execstatic Bool_t Exec(const char *cmd, std::any *result=nullptr, std::string const &resultName=""_anyresult"")Executes a Python command within the current Python environment.Definition TPython.cxx:425; TPython::Evalstatic const TPyReturn Eval(const char *expr) R__DEPRECATED(6Evaluate a python expression (e.g.Definition TPython.cxx:465; TPython::Initializestatic Bool_t Initialize()Initialization method: setup the python interpreter and load the ROOT module.Definition TPython.cxx:137; bool; CPyCppyy::Instance_CheckExactCPYCPPYY_EXTERN bool Instance_CheckExact(PyObject *pyobject)Definition API.cxx:177; CPyCppyy::Overload_CheckCPYCPPYY_EXTERN bool Overload_Check(PyObject *pyobject)Definition API.cxx:236; CPyCppyy::Overload_CheckExactCPYCPPYY_EXTERN bool Overload_CheckExact(PyObject *pyobject)Definition API.cxx:247; CPyCppyy::ImportCPYCPPYY_EXTERN bool Import(const std::string &name)Definition API.cxx:259; CPyCppyy::ExecScriptCPYCPPYY_EXTERN void ExecScript(const std::string &name, const std::vector< std::string > &args)Definition API.cxx:318; CPyCppyy::Instance_CheckCPYCPPYY_EXTERN bool Instance_Check(PyObject *pyobject)Definition API.cxx:166; CPyCppyy::Instance_FromVoidPtrCPYCPPYY_EXTERN PyObject * Instance_FromVoidPtr(void *addr, const std::string &classname, bool python_owns=false)Definition API.cxx:121; CPyCppyy::Instance_AsVoidPtrCPYCPPYY_EXTERN void * Instance_AsVoidPtr(",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:7519,Safety,avoid,avoid,7519,"8 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, argv);; 198#endif; 199 ; 200 mainThreadState = PyEval_SaveThread();; 201 }; 202 ; 203 {; 204 // For the Python API calls; 205 PyGILRAII gilRaii;; 206 ; 207 // force loading of the ROOT module; 208 const int ret = PyRun_SimpleString(const_cast<char *>(""import ROOT""));; 209 if (ret != 0) {; 210 std::cerr << ""Error: import ROOT failed, check your PYTHONPATH environmental variable."" << std::endl;; 211 return kFALSE;; 212 }; 213 ; 214 if (!gMainDict) {; 215 ; 216 // retrieve the main dictionary; 217 gMainDict = PyModule_GetDict(PyImport_AddModule(const_cast<char *>(""__main__"")));; 218 // The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDict).; 219 // Like this, we avoid unexpectedly affecting how long __main__ is kept; 220 // alive. The gMainDict is only used in Exec(), ExecScript(), and Eval(),; 221 // which should not be called after __main__ is garbage collected anyway.; 222 }; 223 }; 224 ; 225 // python side class construction, managed by ROOT; 226 gROOT->AddClassGenerator(new TPyClassGenerator);; 227 ; 228 // declare success ...; 229 isInitialized = kTRUE;; 230 return kTRUE;; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// Import the named python module and create Cling equivalents for its classes; 235/// and methods.; 236 ; 237Bool_t TPython::Import(const char *mod_name); 238{; 239 // setup; 240 if (!Initialize()); 241 return false;; 242 ; 243 PyGILRAII gilRaii;; 244 ; 245 if (!CPyCppyy::Import(mod_name)) {; 246 return false;; 247 }; 248 ; 249 // force creation of the module as a namespace; 250 TClass::GetClass(mod_name, kTRUE);; 251 ; 252 PyObject *modNameObj = PyUnicode_FromString(mod_name);; 253 PyObject",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:1235,Security,access,access,1235,"riginal PyROOT code by Wim Lavrijsen, LBL; 3//; 4// /*************************************************************************; 5// * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; 6// * All rights reserved. *; 7// * *; 8// * For the licensing terms see $ROOTSYS/LICENSE. *; 9// * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10// *************************************************************************/; 11 ; 12// Bindings; 13// CPyCppyy.h must be go first, since it includes Python.h, which must be; 14// included before any standard header; 15#include ""CPyCppyy/API.h""; 16#include ""TPython.h""; 17#include ""TPyClassGenerator.h""; 18 ; 19// ROOT; 20#include ""TROOT.h""; 21#include ""TClassRef.h""; 22#include ""TObject.h""; 23 ; 24#include <Riostream.h>; 25 ; 26// Standard; 27#include <mutex>; 28#include <sstream>; 29#include <stdio.h>; 30#include <string>; 31 ; 32/// \class TPython; 33/// Accessing the Python interpreter from C++.; 34///; 35/// The TPython class allows for access to python objects from Cling. The current; 36/// functionality is only basic: ROOT objects and builtin types can freely cross; 37/// the boundary between the two interpreters, python objects can be instantiated; 38/// and their methods can be called. All other cross-coding is based on strings; 39/// that are run on the python interpreter.; 40///; 41/// Examples:; 42///; 43/// ~~~{.cpp}; 44/// $ root -l; 45/// // Execute a string of python code.; 46/// root [0] TPython::Exec( ""print('Hello World!')"" );; 47/// Hello World!; 48///; 49/// // Create a TNamed on the python side, and transfer it back and forth.; 50/// root [1] std::any res1;; 51/// root [2] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed']('hello', '')"", &res1);; 52/// root [3] TPython::Bind(&std::any_cast<TNamed&>(res1), ""n"");; 53/// root [4] std::any res2;; 54/// root [5] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed*', 'TNamed*'](n)"", &res2);; 55/// root [6] (&std::any_cast<TNamed&>(res1) == std::a",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:3467,Security,access,access,3467,":any_cast<int>(res1); 61/// (int) 2; 62/// ~~~; 63///; 64/// And with a python file `MyPyClass.py` like this:; 65/// ~~~{.py}; 66/// print 'creating class MyPyClass ... '; 67///; 68/// class MyPyClass:; 69/// def __init__( self ):; 70/// print 'in MyPyClass.__init__'; 71///; 72/// def gime( self, what ):; 73/// return what; 74/// ~~~; 75/// one can load a python module, and use the class. Casts are; 76/// necessary as the type information can not be otherwise derived.; 77/// ~~~{.cpp}; 78/// root [6] TPython::LoadMacro( ""MyPyClass.py"" );; 79/// creating class MyPyClass ...; 80/// root [7] MyPyClass m;; 81/// in MyPyClass.__init__; 82/// root [8] std::string s = (char*)m.gime( ""aap"" );; 83/// root [9] s; 84/// (class TString)""aap""; 85/// ~~~; 86/// It is possible to switch between interpreters by calling `TPython::Prompt()`; 87/// on the Cling side, while returning with `^D` (EOF). State is preserved between; 88/// successive switches.; 89///; 90/// The API part provides (direct) C++ access to the bindings functionality of; 91/// PyROOT. It allows verifying that you deal with a PyROOT python object in the; 92/// first place (CPPInstance_Check for CPPInstance and any derived types, as well; 93/// as CPPInstance_CheckExact for CPPInstance's only); and it allows conversions; 94/// of `void*` to an CPPInstance and vice versa.; 95 ; 96//- data ---------------------------------------------------------------------; 97ClassImp(TPython);; 98static PyObject *gMainDict = 0;; 99 ; 100namespace {; 101 ; 102class CachedPyString {; 103 ; 104public:; 105 CachedPyString(const char *name) : fObj{PyUnicode_FromString(name)} {}; 106 ; 107 CachedPyString(CachedPyString const &) = delete;; 108 CachedPyString(CachedPyString &&) = delete;; 109 CachedPyString &operator=(CachedPyString const &) = delete;; 110 CachedPyString &operator=(CachedPyString &&) = delete;; 111 ; 112 ~CachedPyString() { Py_DECREF(fObj); }; 113 ; 114 PyObject *obj() { return fObj; }; 115 ; 116private:; 117 PyObject *fOb",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:12559,Testability,test,test,12559,"lear();; 348 ; 349 // need to check for both exact and derived (differences exist between older and newer; 350 // versions of python ... bug?); 351 if ((pyModName && pyClName) && ((PyUnicode_CheckExact(pyModName) && PyUnicode_CheckExact(pyClName)) ||; 352 (PyUnicode_Check(pyModName) && PyUnicode_Check(pyClName)))) {; 353 // build full, qualified name; 354 std::string fullname = PyUnicode_AsUTF8(pyModName);; 355 fullname += '.';; 356 fullname += PyUnicode_AsUTF8(pyClName);; 357 ; 358 // force class creation (this will eventually call TPyClassGenerator); 359 TClass::GetClass(fullname.c_str(), kTRUE);; 360 }; 361 ; 362 Py_XDECREF(pyClName);; 363 Py_XDECREF(pyModName);; 364 }; 365 }; 366 ; 367 Py_DECREF(value);; 368 }; 369 ; 370 Py_DECREF(current);; 371 Py_DECREF(old);; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Execute a python stand-alone script, with argv CLI arguments.; 376///; 377/// example of use:; 378/// const char* argv[] = { ""1"", ""2"", ""3"" };; 379/// TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );; 380 ; 381void TPython::ExecScript(const char *name, int argc, const char **argv); 382{; 383 ; 384 // setup; 385 if (!Initialize()); 386 return;; 387 ; 388 PyGILRAII gilRaii;; 389 ; 390 // verify arguments; 391 if (!name) {; 392 std::cerr << ""Error: no file name specified."" << std::endl;; 393 return;; 394 }; 395 ; 396 std::vector<std::string> args(argc);; 397 for (int i = 0; i < argc; ++i) {; 398 args[i] = argv[i];; 399 }; 400 CPyCppyy::ExecScript(name, args);; 401}; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Executes a Python command within the current Python environment.; 405///; 406/// This function initializes the Python environment if it is not already; 407/// initialized. It then executes the specified Python command string using the; 408/// Python C API.; 409///; 410/// In the Python command, you can change the value of a spe",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8cxx_source.html:15066,Testability,test,test,15066,"apped over to the std::any result.; 421/// The default value is `""_anyresult""`.; 422/// \return bool Returns `true` if the command was successfully executed,; 423/// otherwise returns `false`.; 424 ; 425Bool_t TPython::Exec(const char *cmd, std::any *result, std::string const &resultName); 426{; 427 // setup; 428 if (!Initialize()); 429 return kFALSE;; 430 ; 431 PyGILRAII gilRaii;; 432 ; 433 std::stringstream command;; 434 // Add the actual command; 435 command << cmd;; 436 // Swap the std::any with the one in the C++ world if required; 437 if (result) {; 438 command << ""; ROOT.Internal.SwapWithObjAtAddr['std::any']("" << resultName << "", ""; 439 << reinterpret_cast<std::intptr_t>(result) << "")"";; 440 }; 441 ; 442 // execute the command; 443 PyObject *pyObjectResult =; 444 PyRun_String(const_cast<char *>(command.str().c_str()), Py_file_input, gMainDict, gMainDict);; 445 ; 446 // test for error; 447 if (pyObjectResult) {; 448 Py_DECREF(pyObjectResult);; 449 return kTRUE;; 450 }; 451 ; 452 PyErr_Print();; 453 return kFALSE;; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Evaluate a python expression (e.g. ""ROOT.TBrowser()"").; 458///; 459/// Caution: do not hold on to the return value: either store it in a builtin; 460/// type (implicit casting will work), or in a pointer to a ROOT object (explicit; 461/// casting to a void* is required).; 462///; 463/// \deprecated Use TPython::Exec() with an std::any output parameter instead.; 464 ; 465const TPyReturn TPython::Eval(const char *expr); 466{; 467 // setup; 468 if (!Initialize()); 469 return TPyReturn();; 470 ; 471 PyGILRAII gilRaii;; 472 ; 473 // evaluate the expression; 474 PyObject *result = PyRun_String(const_cast<char *>(expr), Py_eval_input, gMainDict, gMainDict);; 475 ; 476 // report errors as appropriate; return void; 477 if (!result) {; 478 PyErr_Print();; 479 return TPyReturn();; 480 }; 481 ; 482 // results that require no conversion; 483 if (result == Py_No",MatchSource.WIKI,doc/master/TPython_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html
https://root.cern/doc/master/TPython_8h_source.html:1569,Availability,avail,available,1569,"*********************************/; 11 ; 12#ifndef ROOT_TPython; 13#define ROOT_TPython; 14 ; 15//////////////////////////////////////////////////////////////////////////////; 16// //; 17// TPython //; 18// //; 19// Access to the python interpreter and API onto PyROOT. //; 20// //; 21//////////////////////////////////////////////////////////////////////////////; 22 ; 23// Bindings; 24#include ""TPyReturn.h""; 25 ; 26// ROOT; 27#include ""TObject.h""; 28 ; 29#include ""ROOT/RConfig.hxx"" // R__DEPRECATED; 30 ; 31#include <any>; 32#include <cstdint>; 33 ; 34namespace ROOT {; 35namespace Internal {; 36 ; 37// Internal helper for PyROOT to swap with an object is at a specific address.; 38template<class T>; 39inline void SwapWithObjAtAddr(T &a, std::intptr_t b) { std::swap(a, *reinterpret_cast<T*>(b)); }; 40 ; 41}; 42}; 43 ; 44class TPython {; 45 ; 46private:; 47 static Bool_t Initialize();; 48 ; 49public:; 50 // import a python module, making its classes available; 51 static Bool_t Import(const char *name);; 52 ; 53 // load a python script as if it were a macro; 54 static void LoadMacro(const char *name);; 55 ; 56 // execute a python stand-alone script, with argv CLI arguments; 57 static void ExecScript(const char *name, int argc = 0, const char **argv = nullptr);; 58 ; 59 // execute a python statement (e.g. ""import ROOT"" ); 60 static Bool_t Exec(const char *cmd, std::any *result = nullptr, std::string const& resultName=""_anyresult"");; 61 ; 62 // evaluate a python expression (e.g. ""1+1""); 63 static const TPyReturn Eval(const char *expr) R__DEPRECATED(6,36, ""Use TPython::Exec() with an std::any output parameter instead."");; 64 ; 65 // bind a ROOT object with, at the python side, the name ""label""; 66 static Bool_t Bind(TObject *object, const char *label);; 67 ; 68 // enter an interactive python session (exit with ^D); 69 static void Prompt();; 70 ; 71 // type verifiers for CPPInstance; 72 static Bool_t CPPInstance_Check(PyObject *pyobject);; 73 static Bool_t CPPInstance_CheckEx",MatchSource.WIKI,doc/master/TPython_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8h_source.html
https://root.cern/doc/master/TPython_8h_source.html:1635,Performance,load,load,1635,"*********************************/; 11 ; 12#ifndef ROOT_TPython; 13#define ROOT_TPython; 14 ; 15//////////////////////////////////////////////////////////////////////////////; 16// //; 17// TPython //; 18// //; 19// Access to the python interpreter and API onto PyROOT. //; 20// //; 21//////////////////////////////////////////////////////////////////////////////; 22 ; 23// Bindings; 24#include ""TPyReturn.h""; 25 ; 26// ROOT; 27#include ""TObject.h""; 28 ; 29#include ""ROOT/RConfig.hxx"" // R__DEPRECATED; 30 ; 31#include <any>; 32#include <cstdint>; 33 ; 34namespace ROOT {; 35namespace Internal {; 36 ; 37// Internal helper for PyROOT to swap with an object is at a specific address.; 38template<class T>; 39inline void SwapWithObjAtAddr(T &a, std::intptr_t b) { std::swap(a, *reinterpret_cast<T*>(b)); }; 40 ; 41}; 42}; 43 ; 44class TPython {; 45 ; 46private:; 47 static Bool_t Initialize();; 48 ; 49public:; 50 // import a python module, making its classes available; 51 static Bool_t Import(const char *name);; 52 ; 53 // load a python script as if it were a macro; 54 static void LoadMacro(const char *name);; 55 ; 56 // execute a python stand-alone script, with argv CLI arguments; 57 static void ExecScript(const char *name, int argc = 0, const char **argv = nullptr);; 58 ; 59 // execute a python statement (e.g. ""import ROOT"" ); 60 static Bool_t Exec(const char *cmd, std::any *result = nullptr, std::string const& resultName=""_anyresult"");; 61 ; 62 // evaluate a python expression (e.g. ""1+1""); 63 static const TPyReturn Eval(const char *expr) R__DEPRECATED(6,36, ""Use TPython::Exec() with an std::any output parameter instead."");; 64 ; 65 // bind a ROOT object with, at the python side, the name ""label""; 66 static Bool_t Bind(TObject *object, const char *label);; 67 ; 68 // enter an interactive python session (exit with ^D); 69 static void Prompt();; 70 ; 71 // type verifiers for CPPInstance; 72 static Bool_t CPPInstance_Check(PyObject *pyobject);; 73 static Bool_t CPPInstance_CheckEx",MatchSource.WIKI,doc/master/TPython_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8h_source.html
https://root.cern/doc/master/TPython_8h_source.html:5072,Performance,load,load,5072," TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; namechar name[80]Definition TGX11.cxx:110; TObject.h; TPyReturn.h; TObjectMother of all ROOT objects.Definition TObject.h:41; TPyReturnDefinition TPyReturn.h:30; TPythonAccessing the Python interpreter from C++.Definition TPython.h:44; TPython::ExecScriptstatic void ExecScript(const char *name, int argc=0, const char **argv=nullptr)Execute a python stand-alone script, with argv CLI arguments.Definition TPython.cxx:381; TPython::Importstatic Bool_t Import(const char *name)Import the named python module and create Cling equivalents for its classes and methods.Definition TPython.cxx:237; TPython::LoadMacrostatic void LoadMacro(const char *name)Execute the give python script as if it were a macro (effectively an execfile in main),...Definition TPython.cxx:305; TPython::Execstatic Bool_t Exec(const char *cmd, std::any *result=nullptr, std::string const &resultName=""_anyresult"")Executes a Python command within the current Python environment.Definition TPython.cxx:425; TPython::Evalstatic const TPyReturn Eval(const char *expr) R__DEPRECATED(6Evaluate a python expression (e.g.Definition TPython.cxx:465; TPython::Initializestatic Bool_t Initialize()Initialization method: setup the python interpreter and load the ROOT module.Definition TPython.cxx:137; bool; ROOT::Internal::SwapWithObjAtAddrvoid SwapWithObjAtAddr(T &a, std::intptr_t b)Definition TPython.h:39; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. bindingstpythonincTPython.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TPython_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TPython_8h_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:5757,Availability,error,error,5757,"//////////////////////////////////////////////////////////////////////; 149/// Almost the same as TClass::GetMethodWithPrototype().; 150 ; 151TMethod *GetMethodWithPrototype(TClass *cl, const char *method,; 152 const char *proto, Int_t &nargs); 153{; 154 nargs = 0;; 155 ; 156 if (!gInterpreter || cl == nullptr) return nullptr;; 157 ; 158 TMethod *m = cl->GetMethodWithPrototype(method,proto);; 159 if (m) nargs = m->GetNargs();; 160 return m;; 161}; 162 ; 163////////////////////////////////////////////////////////////////////////////////; 164/// Almost the same as TClass::GetMethod().; 165 ; 166static TMethod *GetMethod(TClass *cl, const char *method, const char *params); 167{; 168 if (!gInterpreter || cl == nullptr) return nullptr;; 169 return cl->GetMethod(method,params);; 170}; 171 ; 172}; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Checking of consistency of sender/receiver methods/arguments.; 176/// Returns -1 on error, otherwise number or arguments of signal function.; 177/// Static method.; 178 ; 179Int_t TQObject::CheckConnectArgs(TQObject *sender,; 180 TClass *sender_class, const char *signal,; 181 TClass *receiver_class, const char *slot); 182{; 183 auto len = strlen(signal)+1;; 184 char *signal_method = new char[len];; 185 if (signal_method) strlcpy(signal_method, signal, len);; 186 ; 187 char *signal_proto;; 188 char *tmp;; 189 ; 190 if ((signal_proto = strchr(signal_method,'('))) {; 191 // substitute first '(' symbol with '\0'; 192 *signal_proto++ = '\0';; 193 // substitute last ')' symbol with '\0'; 194 if ((tmp = strrchr(signal_proto,')'))) *tmp = '\0';; 195 }; 196 ; 197 if (!signal_proto) signal_proto = (char*)""""; // avoid zero strings; 198 ; 199 // if delegation object TQObjSender is used get the real sender class; 200 if (sender && sender_class == TQObjSender::Class()) {; 201 sender_class = TClass::GetClass(sender->GetSenderClassName());; 202 if (!sender_class) {; 203 ::Error(""TQObject::CheckConnec",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:35937,Availability,error,error,35937,"nction which simplifies making connection in interpreted ROOT session; 1066///; 1067/// ConnectCINT - connects to interpreter(CINT) command; 1068 ; 1069Bool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot); 1070{; 1071 TString str = ""ProcessLine(="";; 1072 str += '""';; 1073 str += slot;; 1074 str += '""';; 1075 str += "")"";; 1076 return TQObject::Connect(sender, signal, ""TInterpreter"",; 1077 gInterpreter, str.Data());; 1078}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; RQ_OBJECT.h; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TBaseClass.h; TBuffer.h; TClass.h; TDataType.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TH",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:15658,Deployability,update,update,15658,"(cls->GetListOfBases());; 461 TBaseClass *base;; 462 while ((base = (TBaseClass*) next_base_class())); 463 {; 464 CollectClassSignalLists(list, base->GetClassPointer());; 465 }; 466 }; 467}; 468 ; 469////////////////////////////////////////////////////////////////////////////////; 470/// 1. If slot_name = 0 => makes signal defined by the signal_name; 471/// to be the first in the fListOfSignals, this decreases; 472/// the time for lookup.; 473/// 2. If slot_name != 0 => makes slot defined by the slot_name; 474/// to be executed first when signal_name is emitted.; 475/// Signal name is not compressed.; 476 ; 477void TQObject::HighPriority(const char *signal_name, const char *slot_name); 478{; 479 if (!fListOfSignals) return;; 480 TQConnectionList *clist = (TQConnectionList*); 481 fListOfSignals->FindObject(signal_name);; 482 ; 483 if (!clist) return; // not found; 484 if (!slot_name) { // update list of signal lists; 485 fListOfSignals->Remove(clist); // remove and add first; 486 fListOfSignals->AddFirst(clist);; 487 return;; 488 } else { // slot_name != 0 , update signal list; 489 TQConnection *con = (TQConnection*) clist->FindObject(slot_name);; 490 if (!con) return; // not found; 491 clist->Remove(con); // remove and add as first; 492 clist->AddFirst(con);; 493 }; 494}; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// 1. If slot_name = 0 => makes signal defined by the signal_name; 498/// to be the last in the fListOfSignals, this increase the time; 499/// for lookup.; 500/// 2. If slot_name != 0 => makes slot defined by the slot_name; 501/// to be executed last when signal_name is emitted.; 502/// Signal name is not compressed.; 503 ; 504void TQObject::LowPriority(const char *signal_name, const char *slot_name); 505{; 506 if (!fListOfSignals) return;; 507 TQConnectionList *clist = (TQConnectionList*); 508 fListOfSignals->FindObject(signal_name);; 509 ; 510 if (!clist) return;; 511 if (!slot_name) {; 512 fListOfSigna",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:15831,Deployability,update,update,15831,"(cls->GetListOfBases());; 461 TBaseClass *base;; 462 while ((base = (TBaseClass*) next_base_class())); 463 {; 464 CollectClassSignalLists(list, base->GetClassPointer());; 465 }; 466 }; 467}; 468 ; 469////////////////////////////////////////////////////////////////////////////////; 470/// 1. If slot_name = 0 => makes signal defined by the signal_name; 471/// to be the first in the fListOfSignals, this decreases; 472/// the time for lookup.; 473/// 2. If slot_name != 0 => makes slot defined by the slot_name; 474/// to be executed first when signal_name is emitted.; 475/// Signal name is not compressed.; 476 ; 477void TQObject::HighPriority(const char *signal_name, const char *slot_name); 478{; 479 if (!fListOfSignals) return;; 480 TQConnectionList *clist = (TQConnectionList*); 481 fListOfSignals->FindObject(signal_name);; 482 ; 483 if (!clist) return; // not found; 484 if (!slot_name) { // update list of signal lists; 485 fListOfSignals->Remove(clist); // remove and add first; 486 fListOfSignals->AddFirst(clist);; 487 return;; 488 } else { // slot_name != 0 , update signal list; 489 TQConnection *con = (TQConnection*) clist->FindObject(slot_name);; 490 if (!con) return; // not found; 491 clist->Remove(con); // remove and add as first; 492 clist->AddFirst(con);; 493 }; 494}; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// 1. If slot_name = 0 => makes signal defined by the signal_name; 498/// to be the last in the fListOfSignals, this increase the time; 499/// for lookup.; 500/// 2. If slot_name != 0 => makes slot defined by the slot_name; 501/// to be executed last when signal_name is emitted.; 502/// Signal name is not compressed.; 503 ; 504void TQObject::LowPriority(const char *signal_name, const char *slot_name); 505{; 506 if (!fListOfSignals) return;; 507 TQConnectionList *clist = (TQConnectionList*); 508 fListOfSignals->FindObject(signal_name);; 509 ; 510 if (!clist) return;; 511 if (!slot_name) {; 512 fListOfSigna",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:16884,Deployability,update,update,16884," TQConnection *con = (TQConnection*) clist->FindObject(slot_name);; 490 if (!con) return; // not found; 491 clist->Remove(con); // remove and add as first; 492 clist->AddFirst(con);; 493 }; 494}; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// 1. If slot_name = 0 => makes signal defined by the signal_name; 498/// to be the last in the fListOfSignals, this increase the time; 499/// for lookup.; 500/// 2. If slot_name != 0 => makes slot defined by the slot_name; 501/// to be executed last when signal_name is emitted.; 502/// Signal name is not compressed.; 503 ; 504void TQObject::LowPriority(const char *signal_name, const char *slot_name); 505{; 506 if (!fListOfSignals) return;; 507 TQConnectionList *clist = (TQConnectionList*); 508 fListOfSignals->FindObject(signal_name);; 509 ; 510 if (!clist) return;; 511 if (!slot_name) {; 512 fListOfSignals->Remove(clist); // remove and add first; 513 fListOfSignals->AddLast(clist);; 514 return;; 515 } else { // slot_name != 0 , update signal list; 516 TQConnection *con = (TQConnection*) clist->FindObject(slot_name);; 517 if (!con) return;; 518 clist->Remove(con); // remove and add as last; 519 clist->AddLast(con);; 520 }; 521}; 522 ; 523////////////////////////////////////////////////////////////////////////////////; 524/// Return true if there is any object connected to this signal.; 525/// Only checks for object signals.; 526 ; 527Bool_t TQObject::HasConnection(const char *signal_name) const; 528{; 529 if (!fListOfSignals); 530 return kFALSE;; 531 ; 532 TString signal = CompressName(signal_name);; 533 ; 534 return (fListOfSignals->FindObject(signal) != nullptr);; 535}; 536 ; 537////////////////////////////////////////////////////////////////////////////////; 538/// Return number of signals for this object.; 539/// Only checks for object signals.; 540 ; 541Int_t TQObject::NumberOfSignals() const; 542{; 543 if (fListOfSignals); 544 return fListOfSignals->GetSize();; 545 return 0;;",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:1671,Energy Efficiency,power,powerfull,1671,"*******/; 11 ; 12/** \class TQObject; 13\ingroup Base; 14 ; 15This is the ROOT implementation of the Qt object communication; 16mechanism (see also http://www.troll.no/qt/metaobjects.html); 17 ; 18Signals and slots are used for communication between objects.; 19When an object has changed in some way that might be interesting; 20for the outside world, it emits a signal to tell whoever is; 21listening. All slots that are connected to this signal will be; 22activated (called). It is even possible to connect a signal; 23directly to another signal (this will emit the second signal; 24immediately whenever the first is emitted.) There is no limitation; 25on the number of slots that can be connected to a signal.; 26The slots will be activated in the order they were connected; 27to the signal. This mechanism allows objects to be easily reused,; 28because the object that emits a signal does not need to know; 29to which objects the signals are connected.; 30Together, signals and slots make up a powerfull component; 31programming mechanism.; 32 ; 33### Signals; 34 ; 35~~~ {.cpp}; 36 Destroyed(); 37~~~; 38Signal emitted when object is destroyed.; 39This signal could be connected to some garbage-collector object.; 40 ; 41~~~ {.cpp}; 42 ChangedBy(const char *method_name); 43~~~; 44This signal is emitted when some important data members of; 45the object were changed. method_name parameter can be used; 46as an identifier of the modifier method.; 47 ; 48~~~ {.cpp}; 49 Message(const char *msg); 50~~~; 51 ; 52General purpose message signal; 53*/; 54 ; 55#include ""TQObject.h""; 56#include ""TQConnection.h""; 57#include ""THashList.h""; 58#include ""TPRegexp.h""; 59#include ""TROOT.h""; 60#include ""TBuffer.h""; 61#include ""TClass.h""; 62#include ""TMethod.h""; 63#include ""TBaseClass.h""; 64#include ""TDataType.h""; 65#include ""TInterpreter.h""; 66#include ""TQClass.h""; 67#include ""TError.h""; 68#include <iostream>; 69#include ""RQ_OBJECT.h""; 70#include ""TVirtualMutex.h""; 71#include ""RConfigure.h""; 72#include",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:12649,Energy Efficiency,allocate,allocated,12649,"saved ...; 365 connection->Remove(this); // remove back reference; 366 if (connection->IsEmpty()) SafeDelete(connection);; 367 continue; // .. continue from saved link; 368 }; 369 }; 370 lnk = lnk->Next();; 371 }; 372 return return_value;; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// List signal name and list all connections in this signal list.; 377 ; 378void TQConnectionList::ls(Option_t *option) const; 379{; 380 std::cout << ""TQConnectionList:"" << ""\t"" << GetName() << std::endl;; 381 ((TQConnectionList*)this)->R__FOR_EACH(TQConnection,Print)(option);; 382}; 383 ; 384 ; 385////////////////////////////////////////////////////////////////////////////////; 386/// TQObject Constructor.; 387/// Comment:; 388/// - In order to minimize memory allocation fListOfSignals and; 389/// fListOfConnections are allocated only if it is neccesary; 390/// - When fListOfSignals/fListOfConnections are empty they will; 391/// be deleted; 392 ; 393TQObject::TQObject(); 394{; 395 fListOfSignals = nullptr;; 396 fListOfConnections = nullptr;; 397 fSignalsBlocked = kFALSE;; 398}; 399 ; 400////////////////////////////////////////////////////////////////////////////////; 401/// TQObject Destructor.; 402/// - delete all connections and signal list; 403 ; 404TQObject::~TQObject(); 405{; 406 if (!gROOT) return;; 407 ; 408 Destroyed(); // emit ""Destroyed()"" signal; 409 ; 410 if (fListOfSignals) {; 411 fListOfSignals->Delete();; 412 SafeDelete(fListOfSignals); // delete list of signals; 413 }; 414 ; 415 // loop over all connections and remove references to this object; 416 if (fListOfConnections) {; 417 TIter next_connection(fListOfConnections);; 418 TQConnection *connection;; 419 ; 420 while ((connection = (TQConnection*)next_connection())) {; 421 TIter next_list(connection);; 422 TQConnectionList *list;; 423 while ((list = (TQConnectionList*)next_list())) {; 424 list->Remove(connection);; 425 if (list->IsEmpty()) SafeDelete(list);; 426 }",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:2203,Integrability,message,message,2203,"directly to another signal (this will emit the second signal; 24immediately whenever the first is emitted.) There is no limitation; 25on the number of slots that can be connected to a signal.; 26The slots will be activated in the order they were connected; 27to the signal. This mechanism allows objects to be easily reused,; 28because the object that emits a signal does not need to know; 29to which objects the signals are connected.; 30Together, signals and slots make up a powerfull component; 31programming mechanism.; 32 ; 33### Signals; 34 ; 35~~~ {.cpp}; 36 Destroyed(); 37~~~; 38Signal emitted when object is destroyed.; 39This signal could be connected to some garbage-collector object.; 40 ; 41~~~ {.cpp}; 42 ChangedBy(const char *method_name); 43~~~; 44This signal is emitted when some important data members of; 45the object were changed. method_name parameter can be used; 46as an identifier of the modifier method.; 47 ; 48~~~ {.cpp}; 49 Message(const char *msg); 50~~~; 51 ; 52General purpose message signal; 53*/; 54 ; 55#include ""TQObject.h""; 56#include ""TQConnection.h""; 57#include ""THashList.h""; 58#include ""TPRegexp.h""; 59#include ""TROOT.h""; 60#include ""TBuffer.h""; 61#include ""TClass.h""; 62#include ""TMethod.h""; 63#include ""TBaseClass.h""; 64#include ""TDataType.h""; 65#include ""TInterpreter.h""; 66#include ""TQClass.h""; 67#include ""TError.h""; 68#include <iostream>; 69#include ""RQ_OBJECT.h""; 70#include ""TVirtualMutex.h""; 71#include ""RConfigure.h""; 72#include ""strlcpy.h""; 73 ; 74void *gTQSender; // A pointer to the object that sent the last signal.; 75 // Getting access to the sender might be practical; 76 // when many signals are connected to a single slot.; 77 ; 78Bool_t TQObject::fgAllSignalsBlocked = kFALSE;; 79 ; 80 ; 81ClassImpQ(TQObject); 82ClassImpQ(TQObjSender); 83ClassImpQ(TQClass); 84 ; 85////////////////////////////////////////////////////////////////////////////////; 86/// Removes ""const"" words and blanks from full (with prototype); 87/// method name and res",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:47954,Integrability,interface,interface,47954," TQObject.cxx:527; TQObject::ConnectToClassstatic Bool_t ConnectToClass(TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot)Create connection between sender and receiver.Definition TQObject.cxx:563; TQObject::IsAvirtual TClass * IsA() constDefinition TQObject.h:229; TQObject::LowPriorityvirtual void LowPriority(const char *signal_name, const char *slot_name=nullptr)Definition TQObject.cxx:504; TQObject::DisconnectBool_t Disconnect(const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr)Disconnects signal of this object from slot of receiver.Definition TQObject.cxx:1027; TQObject::AreAllSignalsBlockedstatic Bool_t AreAllSignalsBlocked()Returns true if all signals are blocked.Definition TQObject.cxx:1049; TQObject::HighPriorityvirtual void HighPriority(const char *signal_name, const char *slot_name=nullptr)Definition TQObject.cxx:477; TQObject::Classstatic TClass * Class(); TQObject::Connectedvirtual void Connected(const char *)Definition TQObject.h:194; TStringTokenProvides iteration through tokens of a given string.Definition TPRegexp.h:143; TStringToken::AtEndBool_t AtEnd() constDefinition TPRegexp.h:156; TStringToken::NextTokenBool_t NextToken()Get the next token, it is stored in this TString.Definition TPRegexp.cxx:1066; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; Cppyy::GetMethodRPY_EXPORTED TCppMethod_t GetMethod(TCppScope_t scope, TCppIndex_t imeth)Definition clingwrapper.cxx:1550; mTMarker mDefinition textangle.C:8. corebasesrcTQObject.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:38863,Modifiability,inherit,inherits,38863," GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4478; TClass::GetMethodWithPrototypeTMethod * GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4523; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::GetNameconst char * GetName() const overrideReturn name of this collection.Definition TCollection.cxx:351; TCollection::fNameTString fNameDefinition TCollection.h:149; TCollection::Printvoid Print(Option_t *option="""") const overrideDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:14416,Performance,perform,performed,14416,"onnections) {; 417 TIter next_connection(fListOfConnections);; 418 TQConnection *connection;; 419 ; 420 while ((connection = (TQConnection*)next_connection())) {; 421 TIter next_list(connection);; 422 TQConnectionList *list;; 423 while ((list = (TQConnectionList*)next_list())) {; 424 list->Remove(connection);; 425 if (list->IsEmpty()) SafeDelete(list);; 426 }; 427 }; 428 SafeDelete(fListOfConnections);; 429 }; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// Returns pointer to list of signals of this class.; 434 ; 435TList *TQObject::GetListOfClassSignals() const; 436{; 437 TQClass *qcl = nullptr;; 438 ; 439 qcl = dynamic_cast<TQClass*>(IsA());; 440 ; 441 return qcl ? qcl->fListOfSignals : nullptr; //!!; 442}; 443 ; 444////////////////////////////////////////////////////////////////////////////////; 445/// Collect class signal lists from class cls and all its; 446/// base-classes.; 447///; 448/// The recursive traversal is not performed for classes not; 449/// deriving from TQClass.; 450 ; 451void TQObject::CollectClassSignalLists(TList& list, TClass* cls); 452{; 453 TQClass *qcl = dynamic_cast<TQClass*>(cls);; 454 if (qcl); 455 {; 456 if (qcl->fListOfSignals); 457 list.Add(qcl->fListOfSignals);; 458 ; 459 // Descend into base-classes.; 460 TIter next_base_class(cls->GetListOfBases());; 461 TBaseClass *base;; 462 while ((base = (TBaseClass*) next_base_class())); 463 {; 464 CollectClassSignalLists(list, base->GetClassPointer());; 465 }; 466 }; 467}; 468 ; 469////////////////////////////////////////////////////////////////////////////////; 470/// 1. If slot_name = 0 => makes signal defined by the signal_name; 471/// to be the first in the fListOfSignals, this decreases; 472/// the time for lookup.; 473/// 2. If slot_name != 0 => makes slot defined by the slot_name; 474/// to be executed first when signal_name is emitted.; 475/// Signal name is not compressed.; 476 ; 477void TQObject::HighPriority(const char *signa",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:37855,Performance,load,load,37855,"finition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; THashList.h; TInterpreter.h; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TMethod.h; TPRegexp.h; TQClass.h; TQConnection.h; gTQSendervoid * gTQSenderDefinition TQObject.cxx:74; ConnectCINTBool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot)Global function which simplifies making connection in interpreted ROOT session.Definition TQObject.cxx:1069; TQObject.h; ClassImpQ#define ClassImpQ(name)Definition TQObject.h:283; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; protoconst char * protoDefinition civetweb.c:17535; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4478; TClass::GetMethodWithPrototypeTMethod * GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4523; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRU",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:39066,Performance,load,load,39066,"lassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4478; TClass::GetMethodWithPrototypeTMethod * GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4523; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::GetNameconst char * GetName() const overrideReturn name of this collection.Definition TCollection.cxx:351; TCollection::fNameTString fNameDefinition TCollection.h:149; TCollection::Printvoid Print(Option_t *option="""") const overrideDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDataType::GetFullTypeNameconst char * GetFullTypeName() constGet full type description of typedef, e,g.: ""class TDirectory*"".Definition TDataType.cxx:175; TFunctionGlobal funct",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:42289,Performance,perform,performed,42289,"t::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMethod::GetCommentStringvirtual const char * GetCommentString()Returns a comment string from the class declaration.Definition TMethod.cxx:107; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions).Definition TPRegexp.h:97; TPMERegexp::SubstituteInt_t Substitute(TString &s, const TString &r, Bool_t doDollarSubst=kTRUE)Substitute matching part of s with r, dollar back-ref substitution is performed if doDollarSubst is t...Definition TPRegexp.cxx:963; TQClassDefinition TQClass.h:33; TQConnectionListTQConnectionList is the named list of connections, see also TQConnection class.Definition TQObject.cxx:309; TQConnectionList::lsvoid ls(Option_t *option="""") const overrideList signal name and list all connections in this signal list.Definition TQObject.cxx:378; TQConnectionList::TQConnectionListTQConnectionList(const char *name, Int_t nsigargs)Definition TQObject.cxx:315; TQConnectionList::DisconnectBool_t Disconnect(void *receiver=nullptr, const char *slot_name=nullptr)Remove connection from the list.Definition TQObject.cxx:344; TQConnectionList::GetNargsInt_t GetNargs() constDefinition TQObject.cxx:320; TQConnectionList::fSignalArgsInt_t fSignalArgsDefinition TQObject.cxx:312; TQConnectionList::~TQConnectionListvirtual ~TQConnectionList()Destructor.Definition TQObject.cxx:327; TQConnectionTQConnection clas",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:6486,Safety,avoid,avoid,6486,,MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:8407,Safety,avoid,avoid,8407,"mment = 0;; 226 if (signalMethod != (TMethod *) -1) // -1 in case of interpreted class; 227 comment = signalMethod->GetCommentString();; 228 ; 229 if (!comment || !comment[0] || strstr(comment,""*SIGNAL"")){; 230 ::Error(""TQObject::CheckConnectArgs"",; 231 ""signal %s::%s(%s), to declare signal use comment //*SIGNAL*"",; 232 sender_class->GetName(), signal_method, signal_proto);; 233 delete [] signal_method;; 234 return -1;; 235 }; 236#endif; 237 ; 238 // cleaning; 239 delete [] signal_method;; 240 ; 241 auto len2 = strlen(slot)+1;; 242 char *slot_method = new char[len2];; 243 if (slot_method) strlcpy(slot_method, slot, len2);; 244 ; 245 char *slot_proto;; 246 char *slot_params = nullptr;; 247 ; 248 if ((slot_proto = strchr(slot_method,'('))) {; 249 ; 250 // substitute first '(' symbol with '\0'; 251 *slot_proto++ = '\0';; 252 ; 253 // substitute last ')' symbol with '\0'; 254 if ((tmp = strrchr(slot_proto,')'))) *tmp = '\0';; 255 }; 256 ; 257 if (!slot_proto) slot_proto = (char*)""""; // avoid zero strings; 258 if ((slot_params = strchr(slot_proto,'='))) *slot_params = ' ';; 259 ; 260 TFunction *slotMethod = nullptr;; 261 if (!receiver_class) {; 262 // case of slot_method is compiled/intrepreted function; 263 slotMethod = gROOT->GetGlobalFunction(slot_method,nullptr,kFALSE);; 264 } else {; 265 slotMethod = !slot_params ?; 266 GetMethodWithPrototype(receiver_class,; 267 slot_method,; 268 slot_proto,; 269 nargs) :; 270 GetMethod(receiver_class,; 271 slot_method, slot_params);; 272 }; 273 ; 274 if (!slotMethod) {; 275 if (!slot_params) {; 276 ::Error(""TQObject::CheckConnectArgs"", ""slot %s(%s) does not exist"",; 277 receiver_class ? Form(""%s::%s"", receiver_class->GetName(),; 278 slot_method) : slot_method, slot_proto);; 279 } else {; 280 ::Error(""TQObject::CheckConnectArgs"", ""slot %s(%s) does not exist"",; 281 receiver_class ? Form(""%s::%s"", receiver_class->GetName(),; 282 slot_method) : slot_method, slot_params);; 283 }; 284 delete [] slot_method;; 285 return -1;; 286 }; 287 ;",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:2780,Security,access,access,2780,"d.; 39This signal could be connected to some garbage-collector object.; 40 ; 41~~~ {.cpp}; 42 ChangedBy(const char *method_name); 43~~~; 44This signal is emitted when some important data members of; 45the object were changed. method_name parameter can be used; 46as an identifier of the modifier method.; 47 ; 48~~~ {.cpp}; 49 Message(const char *msg); 50~~~; 51 ; 52General purpose message signal; 53*/; 54 ; 55#include ""TQObject.h""; 56#include ""TQConnection.h""; 57#include ""THashList.h""; 58#include ""TPRegexp.h""; 59#include ""TROOT.h""; 60#include ""TBuffer.h""; 61#include ""TClass.h""; 62#include ""TMethod.h""; 63#include ""TBaseClass.h""; 64#include ""TDataType.h""; 65#include ""TInterpreter.h""; 66#include ""TQClass.h""; 67#include ""TError.h""; 68#include <iostream>; 69#include ""RQ_OBJECT.h""; 70#include ""TVirtualMutex.h""; 71#include ""RConfigure.h""; 72#include ""strlcpy.h""; 73 ; 74void *gTQSender; // A pointer to the object that sent the last signal.; 75 // Getting access to the sender might be practical; 76 // when many signals are connected to a single slot.; 77 ; 78Bool_t TQObject::fgAllSignalsBlocked = kFALSE;; 79 ; 80 ; 81ClassImpQ(TQObject); 82ClassImpQ(TQObjSender); 83ClassImpQ(TQClass); 84 ; 85////////////////////////////////////////////////////////////////////////////////; 86/// Removes ""const"" words and blanks from full (with prototype); 87/// method name and resolve any typedefs in the method signature.; 88/// If a null or empty string is passed in, an empty string; 89/// is returned.; 90///; 91/// Example:; 92/// ~~~ {.cpp}; 93/// CompressName("" Draw(const char *, const char *,; 94/// Option_t * , Int_t , Int_t)"");; 95/// ~~~; 96/// returns the string ""Draw(char*,char*,char*,int,int)"".; 97 ; 98TString TQObject::CompressName(const char *method_name); 99{; 100 TString res(method_name);; 101 if (res.IsNull()); 102 return res;; 103 ; 104 {; 105 static TVirtualMutex * lock = nullptr;; 106 R__LOCKGUARD2(lock);; 107 ; 108 static TPMERegexp *constRe = nullptr, *wspaceRe = nullptr;;",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:40458,Security,hash,hash,40458,"rrideDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDataType::GetFullTypeNameconst char * GetFullTypeName() constGet full type description of typedef, e,g.: ""class TDirectory*"".Definition TDataType.cxx:175; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsOptInt_t GetNargsOpt() constNumber of function optional (default) arguments.Definition TFunction.cxx:184; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginn",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:34942,Usability,simpl,simplifies,34942,"//////////////////////////; 1035/// Stream an object of class TQObject.; 1036 ; 1037void TQObject::Streamer(TBuffer &R__b); 1038{; 1039 if (R__b.IsReading()) {; 1040 // nothing to read; 1041 } else {; 1042 // nothing to write; 1043 }; 1044}; 1045 ; 1046////////////////////////////////////////////////////////////////////////////////; 1047/// Returns true if all signals are blocked.; 1048 ; 1049Bool_t TQObject::AreAllSignalsBlocked(); 1050{; 1051 return fgAllSignalsBlocked;; 1052}; 1053 ; 1054////////////////////////////////////////////////////////////////////////////////; 1055/// Block or unblock all signals. Returns the previous block status.; 1056 ; 1057Bool_t TQObject::BlockAllSignals(Bool_t b); 1058{; 1059 Bool_t ret = fgAllSignalsBlocked;; 1060 fgAllSignalsBlocked = b;; 1061 return ret;; 1062}; 1063 ; 1064////////////////////////////////////////////////////////////////////////////////; 1065/// Global function which simplifies making connection in interpreted ROOT session; 1066///; 1067/// ConnectCINT - connects to interpreter(CINT) command; 1068 ; 1069Bool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot); 1070{; 1071 TString str = ""ProcessLine(="";; 1072 str += '""';; 1073 str += slot;; 1074 str += '""';; 1075 str += "")"";; 1076 return TQObject::Connect(sender, signal, ""TInterpreter"",; 1077 gInterpreter, str.Data());; 1078}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; RQ_OBJECT.h; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TBaseClass.h; TBuffer.h; TClass.h; TDataType.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; optionOption_t Option_t optionD",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8cxx_source.html:37230,Usability,simpl,simplifies,37230,"ze void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; THashList.h; TInterpreter.h; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TMethod.h; TPRegexp.h; TQClass.h; TQConnection.h; gTQSendervoid * gTQSenderDefinition TQObject.cxx:74; ConnectCINTBool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot)Global function which simplifies making connection in interpreted ROOT session.Definition TQObject.cxx:1069; TQObject.h; ClassImpQ#define ClassImpQ(name)Definition TQObject.h:283; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; protoconst char * protoDefinition civetweb.c:17535; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::G",MatchSource.WIKI,doc/master/TQObject_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html
https://root.cern/doc/master/TQObject_8h_source.html:1806,Energy Efficiency,power,powerful,1806,"lementation of the Qt object communication //; 18// mechanism (see also https://doc.qt.io/qt-5/metaobjects.html) //; 19// //; 20// Signals and slots are used for communication between objects. //; 21// When an object has changed in some way that might be interesting //; 22// for the outside world, it emits a signal to tell whoever is //; 23// listening. All slots that are connected to this signal will be //; 24// activated (called). It is even possible to connect a signal //; 25// directly to another signal (this will emit the second signal //; 26// immediately whenever the first is emitted.) There is no limitation //; 27// on the number of slots that can be connected to a signal. //; 28// The slots will be activated in the order they were connected //; 29// to the signal. This mechanism allows objects to be easily reused, //; 30// because the object that emits a signal does not need to know //; 31// to what the signals are connected to. //; 32// Together, signals and slots make up a powerful component //; 33// programming mechanism. //; 34// //; 35// This implementation is provided by //; 36// Valeriy Onuchin (onuchin@sirius.ihep.su). //; 37// //; 38//////////////////////////////////////////////////////////////////////////; 39 ; 40#include ""TList.h""; 41#include ""TString.h""; 42#include ""TVirtualQConnection.h""; 43 ; 44class TClass;; 45 ; 46R__EXTERN void *gTQSender; // the latest sender object; 47 ; 48class TQObject {; 49 ; 50protected:; 51 TList *fListOfSignals; //! list of signals from this object; 52 TList *fListOfConnections; //! list of connections to this object; 53 Bool_t fSignalsBlocked; //! flag used for suppression of signals; 54 ; 55 static Bool_t fgAllSignalsBlocked; // flag used for suppression of all signals; 56 ; 57 virtual void *GetSender() { return this; }; 58 virtual const char *GetSenderClassName() const { return """"; }; 59 ; 60 ; 61 static Bool_t ConnectToClass(TQObject *sender,; 62 const char *signal,; 63 TClass *receiver_class,; 64 void *receiver",MatchSource.WIKI,doc/master/TQObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8h_source.html
https://root.cern/doc/master/TQObject_8h_source.html:4089,Modifiability,variab,variable,4089,"t char *signal,; 75 TClass *receiver_class, const char *slot);; 76 ; 77 static TString CompressName(const char *method_name);; 78 ; 79private:; 80 TQObject(const TQObject &) = delete;; 81 TQObject& operator=(const TQObject &) = delete;; 82 ; 83public:; 84 TQObject();; 85 virtual ~TQObject();; 86 ; 87 TList *GetListOfClassSignals() const;; 88 TList *GetListOfSignals() const { return fListOfSignals; }; 89 TList *GetListOfConnections() const { return fListOfConnections; }; 90 ; 91 Bool_t AreSignalsBlocked() const { return fSignalsBlocked; }; 92 Bool_t BlockSignals(Bool_t b); 93 { Bool_t ret = fSignalsBlocked; fSignalsBlocked = b; return ret; }; 94 ; 95 void CollectClassSignalLists(TList& list, TClass* cls);; 96 ; 97 ///////////////////////////////////////////////////////////////////////////////; 98 /// Emit a signal with a varying number of arguments.; 99 ///; 100 template <typename... T> void EmitVA(const char *signal_name, Int_t /* nargs */, const T&... params); 101 {; 102 // Activate signal with variable argument list.; 103 // For internal use and for var arg EmitVA() in RQ_OBJECT.h.; 104 ; 105 if (fSignalsBlocked || AreAllSignalsBlocked()); 106 return;; 107 ; 108 TList classSigLists;; 109 CollectClassSignalLists(classSigLists, IsA());; 110 ; 111 if (classSigLists.IsEmpty() && !fListOfSignals); 112 return;; 113 ; 114 TString signal = CompressName(signal_name);; 115 ; 116 TVirtualQConnection *connection = nullptr;; 117 ; 118 // execute class signals; 119 TList *sigList;; 120 TIter nextSigList(&classSigLists);; 121 while ((sigList = (TList*) nextSigList()) != nullptr) {; 122 TIter nextcl((TList*) sigList->FindObject(signal));; 123 while ((connection = static_cast<TVirtualQConnection*>(nextcl())) != nullptr) {; 124 gTQSender = GetSender();; 125 connection->SetArgs(params...);; 126 connection->SendSignal();; 127 }; 128 }; 129 if (!fListOfSignals); 130 return;; 131 ; 132 // execute object signals; 133 TIter next((TList*) fListOfSignals->FindObject(signal));; 134 while (f",MatchSource.WIKI,doc/master/TQObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8h_source.html
https://root.cern/doc/master/TQObject_8h_source.html:9271,Usability,simpl,simplifies,9271,"legation object; 237 TString fSenderClass; //class name of delegation object; 238 ; 239 void *GetSender() override { return fSender; }; 240 const char *GetSenderClassName() const override { return fSenderClass.Data(); }; 241 ; 242private:; 243 TQObjSender(const TQObjSender&) = delete;; 244 TQObjSender& operator=(const TQObjSender&) = delete;; 245 ; 246public:; 247 TQObjSender() : TQObject(), fSender(nullptr), fSenderClass() { }; 248 virtual ~TQObjSender() { Disconnect(); }; 249 ; 250 virtual void SetSender(void *sender) { fSender = sender; }; 251 void SetSenderClassName(const char *sclass = """") { fSenderClass = sclass; }; 252 ; 253 ClassDefOverride(TQObjSender,0) //Used to ""delegate"" TQObject functionality; 254 //to interpreted classes, see also RQ_OBJECT.h; 255};; 256 ; 257 ; 258 ; 259// Global function which simplifies making connections in interpreted; 260// ROOT session; 261//; 262// ConnectCINT - connects to interpreter(CINT) command; 263 ; 264extern Bool_t ConnectCINT(TQObject *sender, const char *signal,; 265 const char *slot);; 266 ; 267#ifdef G__DICTIONARY; 268// This include makes it possible to have a single connection; 269// from all objects of the same class but is only needed in; 270// the dictionary.; 271#include ""TQClass.h""; 272#endif; 273 ; 274 ; 275//---- ClassImpQ macro ----------------------------------------------; 276//; 277// This macro used to correspond to the ClassImp macro and should be used; 278// for classes derived from TQObject instead of the ClassImp macro.; 279// This macro makes it possible to have a single connection from; 280// all objects of the same class.; 281// *** It is now obsolete ***; 282 ; 283#define ClassImpQ(name) \; 284 ClassImp(name); 285 ; 286#endif; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; ClassDefOverride#define ClassDe",MatchSource.WIKI,doc/master/TQObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8h_source.html
https://root.cern/doc/master/TQObject_8h_source.html:10681,Usability,simpl,simplifies,10681,"eded in; 270// the dictionary.; 271#include ""TQClass.h""; 272#endif; 273 ; 274 ; 275//---- ClassImpQ macro ----------------------------------------------; 276//; 277// This macro used to correspond to the ClassImp macro and should be used; 278// for classes derived from TQObject instead of the ClassImp macro.; 279// This macro makes it possible to have a single connection from; 280// all objects of the same class.; 281// *** It is now obsolete ***; 282 ; 283#define ClassImpQ(name) \; 284 ClassImp(name); 285 ; 286#endif; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TList.h; TQClass.h; gTQSenderR__EXTERN void * gTQSenderDefinition TQObject.h:46; ConnectCINTBool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot)Global function which simplifies making connection in interpreted ROOT session.Definition TQObject.cxx:1069; TString.h; TVirtualQConnection.h; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TQObjSenderDefinition TQObject.h:233; TQObjSender::SetSendervirtual void SetSender(void *sender)Definition TQObject.h:250; TQObjSender::fSenderClassTString fSenderClassDefinition TQObject.h:237; TQObjSender::TQObjSenderTQObjSender(const TQObjSender &)=delete; TQObjSender::~TQObjSendervirtual ~TQObjSender()Definition TQObject.h:248; TQObjSender::operator=TQObjSender & operator=(const TQObjSender &)=delete; TQObjSender::SetSenderClas",MatchSource.WIKI,doc/master/TQObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TQObject_8h_source.html
https://root.cern/doc/master/TRandom2_8h_source.html:2247,Availability,mask,mask,2247," override;; 36 Double_t Rndm( ) override;; 37 using TRandom::Rndm;; 38 void RndmArray(Int_t n, Float_t *array) override;; 39 void RndmArray(Int_t n, Double_t *array) override;; 40 void SetSeed(ULong_t seed=0) override;; 41 UInt_t GetSeed() const override;; 42 ; 43 ClassDefOverride(TRandom2, 1) // Random number generator with periodicity of 10**26; 44};; 45 ; 46R__EXTERN TRandom *gRandom;; 47 ; 48#endif; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Float_tfloat Float_tDefinition RtypesCore.h:57; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; gRandomR__EXTERN TRandom * gRandomDefinition TRandom2.h:46; TRandom.h; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom2::~TRandom2~TRandom2() overrideDefault destructor.Definition TRandom2.cxx:45; TRandom2::RndmDouble_t Rndm() overrideTausWorth generator from L'Ecuyer, uses as seed 3x32bits integers Use a mask of 0xffffffffUL to make ...Definition TRandom2.cxx:55; TRandom2::RndmArrayvoid RndmArray(Int_t n, Float_t *array) overrideReturn an array of n random numbers uniformly distributed in ]0,1].Definition TRandom2.cxx:74; TRandom2::SetSeedvoid SetSeed(ULong_t seed=0) overrideSet the generator seed.Definition TRandom2.cxx:122; TRandom2::GetSeedUInt_t GetSeed() const overrideReturns one of the seeds of the generator.Definition TRandom2.cxx:166; TRandom2::fSeed1UInt_t fSeed1Definition TRandom2.h:30; TRandom2::fSeed2UInt_t fSeed2Definition TRandom2.h:31; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16. mathmathcoreincTRandom2.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TRandom2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom2_8h_source.html
https://root.cern/doc/master/TRandom3_8cxx_source.html:7026,Deployability,upgrade,upgraded,7026," i < kN-1 ; i++) {; 175 y = (fMt[i] & kUpperMask) | (fMt[i+1] & kLowerMask);; 176 fMt[i] = fMt[i+kM-kN] ^ (y >> 1) ^ ((y & 0x1) ? kMatrixA : 0x0);; 177 }; 178 ; 179 y = (fMt[kN-1] & kUpperMask) | (fMt[0] & kLowerMask);; 180 fMt[kN-1] = fMt[kM-1] ^ (y >> 1) ^ ((y & 0x1) ? kMatrixA : 0x0);; 181 fCount624 = 0;; 182 }; 183 ; 184 y = fMt[fCount624++];; 185 y ^= (y >> 11);; 186 y ^= ((y << 7 ) & kTemperingMaskB );; 187 y ^= ((y << 15) & kTemperingMaskC );; 188 y ^= (y >> 18);; 189 ; 190 if (y) {; 191 array[k] = Double_t( y * 2.3283064365386963e-10); // * Power(2,-32); 192 k++;; 193 }; 194 }; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198/// Set the random generator sequence; 199/// if seed is 0 (default value) a TUUID is generated and used to fill; 200/// the first 8 integers of the seed array.; 201/// In this case the seed is guaranteed to be unique in space and time.; 202/// Use upgraded seeding procedure to fix a known problem when seeding with values; 203/// with many zero in the bit pattern (like 2**28).; 204/// see http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html; 205 ; 206void TRandom3::SetSeed(ULong_t seed); 207{; 208 TRandom::SetSeed(seed);; 209 fCount624 = 624;; 210 if (seed > 0) {; 211 fMt[0] = fSeed;; 212 ; 213 // use multipliers from Knuth's ""Art of Computer Programming"" Vol. 2, 3rd Ed. p.106; 214 for(Int_t i=1; i<624; i++) {; 215 fMt[i] = (1812433253 * ( fMt[i-1] ^ ( fMt[i-1] >> 30)) + i );; 216 }; 217 ; 218 } else {; 219 ; 220 // use TRandom2 (which is based on TUUId to generate the seed; 221 // TRandom2 works fairly well and has been tested against example; 222 // layout in https://savannah.cern.ch/bugs/?99516; 223 TRandom2 r(0);; 224 for (Int_t i = 0; i< 624; i++) {; 225 fMt[i] = static_cast<UInt_t> (4294967296.*r.Rndm());; 226 }; 227 // warm up the generator calling it 10 times; 228 for (Int_t i = 0; i < 10; ++i) Rndm();; 229 }; 230 ; 231 ; 232}; 233 ; 234/////////////////////////",MatchSource.WIKI,doc/master/TRandom3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom3_8cxx_source.html
https://root.cern/doc/master/TRandom3_8cxx_source.html:963,Testability,test,tests,963,". ROOT: math/mathcore/src/TRandom3.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TRandom3.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: Peter Malzacher 31/08/99; 3 ; 4/**; 5 ; 6\class TRandom3; 7 ; 8Random number generator class based on; 9 M. Matsumoto and T. Nishimura,; 10 Mersenne Twister: A 623-diminsionally equidistributed; 11 uniform pseudorandom number generator; 12 ACM Transactions on Modeling and Computer Simulation,; 13 Vol. 8, No. 1, January 1998, pp 3--30.; 14 ; 15For more information see the Mersenne Twister homepage; 16 [http://www.math.keio.ac.jp/~matumoto/emt.html]; 17 ; 18Advantage:; 19 ; 20- large period 2**19937 -1; 21- relatively fast (slightly slower than TRandom2 but much faster than TRandom1); 22 ; 23Drawback:; 24- a relative large internal state of 624 integers ; 25- generate only 32 random bits ; 26- not passing all the random generator tests. It fails some tests in TestU01; 27 (see [http://simul.iro.umontreal.ca/testu01/tu01.html]); 28 ; 29An altenativly excellent generator passing all tests of TestU01, having 61 random bits and ; 30fast as Mersenne and Twister is MIXMAX (TRandomMixMax). ; 31 ; 32@ingroup Random; 33 ; 34*/; 35 ; 36//////////////////////////////////////////////////////////////////////; 37// Aug.99 ROOT implementation based on CLHEP by P.Malzacher; 38//; 39// the original code contains the following copyright notice:; 40/* This library is free software; you can redistribute it and/or */; 41/* modify it under the terms of the GNU Library General Public */; 42/* License as published by the Free Software Foundation; either */; 43/* version 2 of the License, or (at your option) any later */; 44/* version. */; 45/* This library is distributed in the hope that it will be useful, */; 46/* but WITHOUT ANY WARRANTY; without even the implied warranty of */; 47/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. */; 48/* See the GNU Library Genera",MatchSource.WIKI,doc/master/TRandom3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom3_8cxx_source.html
https://root.cern/doc/master/TRandom3_8cxx_source.html:984,Testability,test,tests,984,". ROOT: math/mathcore/src/TRandom3.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TRandom3.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: Peter Malzacher 31/08/99; 3 ; 4/**; 5 ; 6\class TRandom3; 7 ; 8Random number generator class based on; 9 M. Matsumoto and T. Nishimura,; 10 Mersenne Twister: A 623-diminsionally equidistributed; 11 uniform pseudorandom number generator; 12 ACM Transactions on Modeling and Computer Simulation,; 13 Vol. 8, No. 1, January 1998, pp 3--30.; 14 ; 15For more information see the Mersenne Twister homepage; 16 [http://www.math.keio.ac.jp/~matumoto/emt.html]; 17 ; 18Advantage:; 19 ; 20- large period 2**19937 -1; 21- relatively fast (slightly slower than TRandom2 but much faster than TRandom1); 22 ; 23Drawback:; 24- a relative large internal state of 624 integers ; 25- generate only 32 random bits ; 26- not passing all the random generator tests. It fails some tests in TestU01; 27 (see [http://simul.iro.umontreal.ca/testu01/tu01.html]); 28 ; 29An altenativly excellent generator passing all tests of TestU01, having 61 random bits and ; 30fast as Mersenne and Twister is MIXMAX (TRandomMixMax). ; 31 ; 32@ingroup Random; 33 ; 34*/; 35 ; 36//////////////////////////////////////////////////////////////////////; 37// Aug.99 ROOT implementation based on CLHEP by P.Malzacher; 38//; 39// the original code contains the following copyright notice:; 40/* This library is free software; you can redistribute it and/or */; 41/* modify it under the terms of the GNU Library General Public */; 42/* License as published by the Free Software Foundation; either */; 43/* version 2 of the License, or (at your option) any later */; 44/* version. */; 45/* This library is distributed in the hope that it will be useful, */; 46/* but WITHOUT ANY WARRANTY; without even the implied warranty of */; 47/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. */; 48/* See the GNU Library Genera",MatchSource.WIKI,doc/master/TRandom3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom3_8cxx_source.html
https://root.cern/doc/master/TRandom3_8cxx_source.html:1116,Testability,test,tests,1116,"ndom3.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: Peter Malzacher 31/08/99; 3 ; 4/**; 5 ; 6\class TRandom3; 7 ; 8Random number generator class based on; 9 M. Matsumoto and T. Nishimura,; 10 Mersenne Twister: A 623-diminsionally equidistributed; 11 uniform pseudorandom number generator; 12 ACM Transactions on Modeling and Computer Simulation,; 13 Vol. 8, No. 1, January 1998, pp 3--30.; 14 ; 15For more information see the Mersenne Twister homepage; 16 [http://www.math.keio.ac.jp/~matumoto/emt.html]; 17 ; 18Advantage:; 19 ; 20- large period 2**19937 -1; 21- relatively fast (slightly slower than TRandom2 but much faster than TRandom1); 22 ; 23Drawback:; 24- a relative large internal state of 624 integers ; 25- generate only 32 random bits ; 26- not passing all the random generator tests. It fails some tests in TestU01; 27 (see [http://simul.iro.umontreal.ca/testu01/tu01.html]); 28 ; 29An altenativly excellent generator passing all tests of TestU01, having 61 random bits and ; 30fast as Mersenne and Twister is MIXMAX (TRandomMixMax). ; 31 ; 32@ingroup Random; 33 ; 34*/; 35 ; 36//////////////////////////////////////////////////////////////////////; 37// Aug.99 ROOT implementation based on CLHEP by P.Malzacher; 38//; 39// the original code contains the following copyright notice:; 40/* This library is free software; you can redistribute it and/or */; 41/* modify it under the terms of the GNU Library General Public */; 42/* License as published by the Free Software Foundation; either */; 43/* version 2 of the License, or (at your option) any later */; 44/* version. */; 45/* This library is distributed in the hope that it will be useful, */; 46/* but WITHOUT ANY WARRANTY; without even the implied warranty of */; 47/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. */; 48/* See the GNU Library General Public License for more details. */; 49/* You should have received a copy of the GNU Library General */; 50/* Public License along wit",MatchSource.WIKI,doc/master/TRandom3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom3_8cxx_source.html
https://root.cern/doc/master/TRandom3_8cxx_source.html:7730,Testability,test,tested,7730,"; // * Power(2,-32); 192 k++;; 193 }; 194 }; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198/// Set the random generator sequence; 199/// if seed is 0 (default value) a TUUID is generated and used to fill; 200/// the first 8 integers of the seed array.; 201/// In this case the seed is guaranteed to be unique in space and time.; 202/// Use upgraded seeding procedure to fix a known problem when seeding with values; 203/// with many zero in the bit pattern (like 2**28).; 204/// see http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html; 205 ; 206void TRandom3::SetSeed(ULong_t seed); 207{; 208 TRandom::SetSeed(seed);; 209 fCount624 = 624;; 210 if (seed > 0) {; 211 fMt[0] = fSeed;; 212 ; 213 // use multipliers from Knuth's ""Art of Computer Programming"" Vol. 2, 3rd Ed. p.106; 214 for(Int_t i=1; i<624; i++) {; 215 fMt[i] = (1812433253 * ( fMt[i-1] ^ ( fMt[i-1] >> 30)) + i );; 216 }; 217 ; 218 } else {; 219 ; 220 // use TRandom2 (which is based on TUUId to generate the seed; 221 // TRandom2 works fairly well and has been tested against example; 222 // layout in https://savannah.cern.ch/bugs/?99516; 223 TRandom2 r(0);; 224 for (Int_t i = 0; i< 624; i++) {; 225 fMt[i] = static_cast<UInt_t> (4294967296.*r.Rndm());; 226 }; 227 // warm up the generator calling it 10 times; 228 for (Int_t i = 0; i < 10; ++i) Rndm();; 229 }; 230 ; 231 ; 232}; 233 ; 234////////////////////////////////////////////////////////////////////////////////; 235/// Stream an object of class TRandom3.; 236 ; 237void TRandom3::Streamer(TBuffer &R__b); 238{; 239 if (R__b.IsReading()) {; 240 UInt_t R__s, R__c;; 241 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 242 if (R__v > 1) {; 243 R__b.ReadClassBuffer(TRandom3::Class(), this, R__v, R__s, R__c);; 244 return;; 245 }; 246 //====process old versions before automatic schema evolution; 247 TRandom::Streamer(R__b);; 248 R__b.ReadStaticArray(fMt);; 249 R__b >> fCount624;; 250 R__b.CheckByteCoun",MatchSource.WIKI,doc/master/TRandom3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom3_8cxx_source.html
https://root.cern/doc/master/TRandom3_8h.html:214,Integrability,depend,dependency,214,". ROOT: math/mathcore/inc/TRandom3.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TRandom3.h File Reference. #include ""TRandom.h"". Include dependency graph for TRandom3.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TRandom3;  Random number generator class based on M. More...;  . Variables; R__EXTERN TRandom * gRandom;  . Variable Documentation. ◆ gRandom. R__EXTERN TRandom* gRandom. Definition at line 50 of file TRandom3.h. mathmathcoreincTRandom3.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TRandom3_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom3_8h.html
https://root.cern/doc/master/TRandomGen_8h.html:331,Integrability,depend,dependency,331,". ROOT: math/mathcore/inc/TRandomGen.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs ; TRandomGen.h File Reference. #include ""TRandom.h""; #include <string>; #include ""Math/StdEngine.h""; #include ""Math/MixMaxEngine.h""; #include ""Math/RanluxppEngine.h"". Include dependency graph for TRandomGen.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TRandomGen< Engine >;  . Typedefs; typedef TRandomGen< ROOT::Math::MixMaxEngine< 240, 0 > > TRandomMixMax;  MIXMAX generator based on a state of N=240. ;  ; typedef TRandomGen< ROOT::Math::MixMaxEngine< 17, 0 > > TRandomMixMax17;  MIXMAX generator based on a state of N=17. ;  ; typedef TRandomGen< ROOT::Math::MixMaxEngine< 256, 2 > > TRandomMixMax256;  MIXMAX generator based on a state of N=256, based on the generator described in this paper: ;  ; typedef TRandomGen< ROOT::Math::StdEngine< std::mt19937_64 > > TRandomMT64;  Generator based on a the Mersenne-Twister generator with 64 bits, using the implementation provided by the standard library, std::mt19937_64 (see http://www.cplusplus.com/reference/random/mt19937_64/ ) ;  ; typedef TRandomGen< ROOT::Math::StdEngine< std::ranlux48 > > TRandomRanlux48;  Generator based on a the RanLux generator with 48 bits, using the implementation provided by the standard library, std::ranlux48 (see http://www.cplusplus.com/reference/random/ranlux48/ ) ;  ; typedef TRandomGen< ROOT::Math::RanluxppEngine2048 > TRandomRanluxpp;  . Typedef Documentation. ◆ TRandomRanluxpp. typedef TRandomGen<ROOT::Math::RanluxppEngine2048> TRandomRanluxpp. Definition at line 132 of file TRandomGen.h. mathmathcoreincTRandomGen.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TRandomGen_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandomGen_8h.html
https://root.cern/doc/master/TRandom_8cxx_source.html:13657,Availability,avail,available,13657,"43 x = r*TMath::Cos(phi);; 244 y = r*TMath::Sin(phi);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Returns an exponential deviate.; 249///; 250/// exp( -t/tau ); 251 ; 252Double_t TRandom::Exp(Double_t tau); 253{; 254 Double_t x = Rndm(); // uniform on ] 0, 1 ]; 255 Double_t t = -tau * TMath::Log( x ); // convert to exponential distribution; 256 return t;; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Samples a random number from the standard Normal (Gaussian) Distribution; 261/// with the given mean and sigma.; 262/// Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger; 263/// This is one of the fastest existing method for generating normal random variables.; 264/// It is a factor 2/3 faster than the polar (Box-Muller) method used in the previous; 265/// version of TRandom::Gaus. The speed is comparable to the Ziggurat method (from Marsaglia); 266/// implemented for example in GSL and available in the MathMore library.; 267///; 268/// REFERENCE: - W. Hoermann and G. Derflinger (1990):; 269/// The ACR Method for generating normal random variables,; 270/// OR Spektrum 12 (1990), 181-185.; 271///; 272/// Implementation taken from; 273/// UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien; 274 ; 275Double_t TRandom::Gaus(Double_t mean, Double_t sigma); 276{; 277 const Double_t kC1 = 1.448242853;; 278 const Double_t kC2 = 3.307147487;; 279 const Double_t kC3 = 1.46754004;; 280 const Double_t kD1 = 1.036467755;; 281 const Double_t kD2 = 5.295844968;; 282 const Double_t kD3 = 3.631288474;; 283 const Double_t kHm = 0.483941449;; 284 const Double_t kZm = 0.107981933;; 285 const Double_t kHp = 4.132731354;; 286 const Double_t kZp = 18.52161694;; 287 const Double_t kPhln = 0.4515827053;; 288 const Double_t kHm1 = 0.516058551;; 289 const Double_t kHp1 = 3.132731354;; 290 const Double_t kHzm = 0.375959516;; 291 const Dou",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:18073,Availability,error,error,18073,"386 return res;; 387}; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Generates a random integer N according to a Poisson law.; 391/// Prob(N) = exp(-mean)*mean^N/Factorial(N); 392///; 393/// Use a different procedure according to the mean value.; 394/// The algorithm is the same used by CLHEP.; 395/// For lower value (mean < 25) use the rejection method based on; 396/// the exponential.; 397/// For higher values use a rejection method comparing with a Lorentzian; 398/// distribution, as suggested by several authors.; 399/// This routine returns now an unsigned 64 bit integer; 400/// For large values, larger than 1.84e+19, we print an error message; 401/// advising to use the Trandom::PoissonD for such large values,; 402/// and return the max value UINT64_MAX; 403 ; 404ULong64_t TRandom::Poisson(Double_t mean); 405{; 406 ULong64_t n;; 407 if (mean <= 0) return 0;; 408 if (mean < 25) {; 409 Double_t expmean = TMath::Exp(-mean);; 410 Double_t pir = 1;; 411 n = -1;; 412 while(true) {; 413 n++;; 414 pir *= Rndm();; 415 if (pir <= expmean) break;; 416 }; 417 return n;; 418 }; 419 // for large value we use inversion method; 420 else if (mean < 1E9) {; 421 Double_t em, t, y;; 422 Double_t sq, alxm, g;; 423 Double_t pi = TMath::Pi();; 424 ; 425 sq = TMath::Sqrt(2.0*mean);; 426 alxm = TMath::Log(mean);; 427 g = mean*alxm - TMath::LnGamma(mean + 1.0);; 428 ; 429 do {; 430 do {; 431 y = TMath::Tan(pi*Rndm());; 432 em = sq*y + mean;; 433 } while( em < 0.0 );; 434 ; 435 em = TMath::Floor(em);; 436 t = 0.9*(1.0 + y*y)* TMath::Exp(em*alxm - TMath::LnGamma(em + 1.0) - g);; 437 } while( Rndm() > t );; 438 ; 439 return static_cast<ULong64_t>(em);; 440 ; 441 }; 442 else {; 443 // use Gaussian approximation for very large values; 444 Double_t x = Gaus(0, 1) * TMath::Sqrt(mean) + mean + 0.5;; 445 if (x > TMath::Limits<ULong64_t>::Max()) {; 446 Error(""Poisson"", ""Overflow in return value. Use PoissonD instead."");; 447 return TMath::Limits<",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:31702,Availability,error,error,31702,"3.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TUUID.h; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::WriteTObjectvirtual Int_t WriteTObject(const TObject *obj, const char *name=nullptr, Option_t *="""", Int_t=0)Write an object with proper type checking.Definition TDirectory.cxx:1400; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::ReadTObjectvirtual Int_t ReadTObject(TObject *, const char *)Definition TDirectory.h:249; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmArrayvirtual void RndmArray(Int_t n, Float_t *array)Return an array of n random numbers uniformly distributed in ]0,1].Definition TRandom.cxx:595; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TRandom::WriteRandomvirtual void WriteRandom(const char *filename) constWrites random generator status to filename.Definition TRandom.cxx:700; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::fSeedUInt_t fSeedDefinition TRandom.h:30; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed follo",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:35842,Availability,down,downward,35842,"ool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TUUIDThis class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDent...Definition TUUID.h:42; TUUID::GetUUIDvoid GetUUID(UChar_t uuid[16]) constReturn uuid in specified buffer (16 byte = 128 bits).Definition TUUID.cxx:695; double; int; unsigned int; ROOT::Math::landau_quantiledouble landau_quantile(double z, double xi=1)Inverse ( ) of the cumulative distribution function of the lower tail of the Landau distribution (lan...Definition QuantFuncMathCore.cxx:189; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::LnGammaDouble_t LnGamma(Double_t z)Computation of ln[gamma(z)] for all z.Definition TMath.cxx:509; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; TMath::LimitsDefinition TMath.h:40",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:7410,Deployability,continuous,continuous,7410,"4- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96- Poisson(Double_t mean); 97- Binomial(Int_t ntot, Double_t prob); 98 ; 99Random numbers distributed according to 1-d, 2-d or 3-d distributions contained in TF1, TF2 or TF3 objects can also be; 100generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : \code{.cpp} TF1; 101*f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10); double r = f1->GetRandom(); \endcode or you can use the UNURAN; 102package. You need in this case to initialize UNURAN to the function you would like to generate. \code{.cpp} TUnuran u;; 103 u.Init(TUnuranDistrCont(f1));; 104 double r = u.Sample();; 105\endcode; 106 ; 107The techniques of using directly a TF1,2 or 3 function is powerful and; 108can be used to generate numbers in the defined range of the function.; 109Getting a number from a TF1,2,3 function is also quite fast.; 110UNURAN is a powerful and flexible tool which contains various methods for; 111generate random numbers for continuous distributions of one and multi-dimension.; 112It requires some set-up (initialization) phase and can be very fast when the distribution; 113parameters are not changed for every call.; 114 ; 115The following table shows some timings (in nanosecond/call); 116for basic functions, TF1 functions and using UNURAN obtained running; 117the tutorial math/testrandom.C; 118Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; 119Linux SLC4 64 bit and compiled with gcc 3.4; 120 ; 121~~~~; 122Distribution nanoseconds/call; 123 TRandom TRandom1 TRandom2 TRandom3; 124Rndm.............. 5.000 105.000 7.000 10.000; 125RndmArray......... 4.000 104.000 6.000 9.000; 126Gaus.............. 36.000 180.000 40.000 48.000; 127Rannor............ 118.000 220.000 120.000 124.000; 128Landau............ 22.000 123.000 26.000 31.000; 129Exponential....... 93.000 198.000 98.000 104.000; 130Binomial(5,0.5)... 30.000 548.000 46.000 65.000; 131B",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:7148,Energy Efficiency,power,powerful,7148,"call; 87 ; 88The following methods are provided to generate random numbers distributed according to some basic distributions:; 89 ; 90- Exp(Double_t tau); 91- Integer(UInt_t imax); 92- Gaus(Double_t mean, Double_t sigma); 93- Rndm(); 94- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96- Poisson(Double_t mean); 97- Binomial(Int_t ntot, Double_t prob); 98 ; 99Random numbers distributed according to 1-d, 2-d or 3-d distributions contained in TF1, TF2 or TF3 objects can also be; 100generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : \code{.cpp} TF1; 101*f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10); double r = f1->GetRandom(); \endcode or you can use the UNURAN; 102package. You need in this case to initialize UNURAN to the function you would like to generate. \code{.cpp} TUnuran u;; 103 u.Init(TUnuranDistrCont(f1));; 104 double r = u.Sample();; 105\endcode; 106 ; 107The techniques of using directly a TF1,2 or 3 function is powerful and; 108can be used to generate numbers in the defined range of the function.; 109Getting a number from a TF1,2,3 function is also quite fast.; 110UNURAN is a powerful and flexible tool which contains various methods for; 111generate random numbers for continuous distributions of one and multi-dimension.; 112It requires some set-up (initialization) phase and can be very fast when the distribution; 113parameters are not changed for every call.; 114 ; 115The following table shows some timings (in nanosecond/call); 116for basic functions, TF1 functions and using UNURAN obtained running; 117the tutorial math/testrandom.C; 118Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; 119Linux SLC4 64 bit and compiled with gcc 3.4; 120 ; 121~~~~; 122Distribution nanoseconds/call; 123 TRandom TRandom1 TRandom2 TRandom3; 124Rndm.............. 5.000 105.000 7.000 10.000; 125RndmArray......... 4.000 104.000 6.000 9.000; 126Gaus.............. 36.000 180.",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:7316,Energy Efficiency,power,powerful,7316,"4- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96- Poisson(Double_t mean); 97- Binomial(Int_t ntot, Double_t prob); 98 ; 99Random numbers distributed according to 1-d, 2-d or 3-d distributions contained in TF1, TF2 or TF3 objects can also be; 100generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : \code{.cpp} TF1; 101*f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10); double r = f1->GetRandom(); \endcode or you can use the UNURAN; 102package. You need in this case to initialize UNURAN to the function you would like to generate. \code{.cpp} TUnuran u;; 103 u.Init(TUnuranDistrCont(f1));; 104 double r = u.Sample();; 105\endcode; 106 ; 107The techniques of using directly a TF1,2 or 3 function is powerful and; 108can be used to generate numbers in the defined range of the function.; 109Getting a number from a TF1,2,3 function is also quite fast.; 110UNURAN is a powerful and flexible tool which contains various methods for; 111generate random numbers for continuous distributions of one and multi-dimension.; 112It requires some set-up (initialization) phase and can be very fast when the distribution; 113parameters are not changed for every call.; 114 ; 115The following table shows some timings (in nanosecond/call); 116for basic functions, TF1 functions and using UNURAN obtained running; 117the tutorial math/testrandom.C; 118Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; 119Linux SLC4 64 bit and compiled with gcc 3.4; 120 ; 121~~~~; 122Distribution nanoseconds/call; 123 TRandom TRandom1 TRandom2 TRandom3; 124Rndm.............. 5.000 105.000 7.000 10.000; 125RndmArray......... 4.000 104.000 6.000 9.000; 126Gaus.............. 36.000 180.000 40.000 48.000; 127Rannor............ 118.000 220.000 120.000 124.000; 128Landau............ 22.000 123.000 26.000 31.000; 129Exponential....... 93.000 198.000 98.000 104.000; 130Binomial(5,0.5)... 30.000 548.000 46.000 65.000; 131B",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:35763,Energy Efficiency,power,power,35763,"max)Returns a random integer uniformly distributed on the interval [ 0, imax-1 ].Definition TRandom.cxx:361; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TUUIDThis class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDent...Definition TUUID.h:42; TUUID::GetUUIDvoid GetUUID(UChar_t uuid[16]) constReturn uuid in specified buffer (16 byte = 128 bits).Definition TUUID.cxx:695; double; int; unsigned int; ROOT::Math::landau_quantiledouble landau_quantile(double z, double xi=1)Inverse ( ) of the cumulative distribution function of the lower tail of the Landau distribution (lan...Definition QuantFuncMathCore.cxx:189; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::LnGammaDouble_t LnGamma(Double_t z)Computation of ln[gamma(z)] for all z.Definition TMath.cxx:509; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of par",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:808,Integrability,interface,interface,808,". ROOT: math/mathcore/src/TRandom.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TRandom.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: Rene Brun, Lorenzo Moneta 15/12/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13 ; 14\class TRandom; 15 ; 16@ingroup Random; 17 ; 18This is the base class for the ROOT Random number generators.; 19This class defines the ROOT Random number interface and it should not be instantiated directly but used via its derived; 20classes. The generator provided in TRandom itself is a LCG (Linear Congruential Generator), the <a; 21href=""https://www.gnu.org/software/gsl/manual/html_node/Unix-random-number-generators.html"">BSD `rand` generator</a>,; 22that it should not be used because its period is only 2**31, i.e. approximately 2 billion events, that can be generated; 23in just few seconds.; 24 ; 25To generate random numbers, one should use one of the derived classes, which are:; 26- TRandom3: it is based on the ""Mersenne Twister generator"",; 27it is fast and a very long period of about \f$10^{6000}\f$. However it fails some of the most stringent tests of the; 28<a href=""http://simul.iro.umontreal.ca/testu01/tu01.html"">TestU01 suite</a>.; 29In addition this generator provide only numbers with 32 random bits, which might be not sufficient for some application; 30based on double or extended precision. This generator is however used in ROOT used to instantiate the global pointer to; 31the ROOT generator, *gRandom*.; 32- ::TRandomRanluxpp : New implementation of the Ranlux generator algorithm based on a fast modular multiplic",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:17966,Integrability,rout,routine,17966,"77/// function landau_quantile(x,sigma), which provides; 378/// the inverse of the landau cumulative distribution.; 379/// landau_quantile has been converted from CERNLIB ranlan(G110).; 380 ; 381Double_t TRandom::Landau(Double_t mu, Double_t sigma); 382{; 383 if (sigma <= 0) return 0;; 384 Double_t x = Rndm();; 385 Double_t res = mu + ROOT::Math::landau_quantile(x, sigma);; 386 return res;; 387}; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Generates a random integer N according to a Poisson law.; 391/// Prob(N) = exp(-mean)*mean^N/Factorial(N); 392///; 393/// Use a different procedure according to the mean value.; 394/// The algorithm is the same used by CLHEP.; 395/// For lower value (mean < 25) use the rejection method based on; 396/// the exponential.; 397/// For higher values use a rejection method comparing with a Lorentzian; 398/// distribution, as suggested by several authors.; 399/// This routine returns now an unsigned 64 bit integer; 400/// For large values, larger than 1.84e+19, we print an error message; 401/// advising to use the Trandom::PoissonD for such large values,; 402/// and return the max value UINT64_MAX; 403 ; 404ULong64_t TRandom::Poisson(Double_t mean); 405{; 406 ULong64_t n;; 407 if (mean <= 0) return 0;; 408 if (mean < 25) {; 409 Double_t expmean = TMath::Exp(-mean);; 410 Double_t pir = 1;; 411 n = -1;; 412 while(true) {; 413 n++;; 414 pir *= Rndm();; 415 if (pir <= expmean) break;; 416 }; 417 return n;; 418 }; 419 // for large value we use inversion method; 420 else if (mean < 1E9) {; 421 Double_t em, t, y;; 422 Double_t sq, alxm, g;; 423 Double_t pi = TMath::Pi();; 424 ; 425 sq = TMath::Sqrt(2.0*mean);; 426 alxm = TMath::Log(mean);; 427 g = mean*alxm - TMath::LnGamma(mean + 1.0);; 428 ; 429 do {; 430 do {; 431 y = TMath::Tan(pi*Rndm());; 432 em = sq*y + mean;; 433 } while( em < 0.0 );; 434 ; 435 em = TMath::Floor(em);; 436 t = 0.9*(1.0 + y*y)* TMath::Exp(em*alxm - TMath::LnGamma(em + 1",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:18079,Integrability,message,message,18079,"386 return res;; 387}; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Generates a random integer N according to a Poisson law.; 391/// Prob(N) = exp(-mean)*mean^N/Factorial(N); 392///; 393/// Use a different procedure according to the mean value.; 394/// The algorithm is the same used by CLHEP.; 395/// For lower value (mean < 25) use the rejection method based on; 396/// the exponential.; 397/// For higher values use a rejection method comparing with a Lorentzian; 398/// distribution, as suggested by several authors.; 399/// This routine returns now an unsigned 64 bit integer; 400/// For large values, larger than 1.84e+19, we print an error message; 401/// advising to use the Trandom::PoissonD for such large values,; 402/// and return the max value UINT64_MAX; 403 ; 404ULong64_t TRandom::Poisson(Double_t mean); 405{; 406 ULong64_t n;; 407 if (mean <= 0) return 0;; 408 if (mean < 25) {; 409 Double_t expmean = TMath::Exp(-mean);; 410 Double_t pir = 1;; 411 n = -1;; 412 while(true) {; 413 n++;; 414 pir *= Rndm();; 415 if (pir <= expmean) break;; 416 }; 417 return n;; 418 }; 419 // for large value we use inversion method; 420 else if (mean < 1E9) {; 421 Double_t em, t, y;; 422 Double_t sq, alxm, g;; 423 Double_t pi = TMath::Pi();; 424 ; 425 sq = TMath::Sqrt(2.0*mean);; 426 alxm = TMath::Log(mean);; 427 g = mean*alxm - TMath::LnGamma(mean + 1.0);; 428 ; 429 do {; 430 do {; 431 y = TMath::Tan(pi*Rndm());; 432 em = sq*y + mean;; 433 } while( em < 0.0 );; 434 ; 435 em = TMath::Floor(em);; 436 t = 0.9*(1.0 + y*y)* TMath::Exp(em*alxm - TMath::LnGamma(em + 1.0) - g);; 437 } while( Rndm() > t );; 438 ; 439 return static_cast<ULong64_t>(em);; 440 ; 441 }; 442 else {; 443 // use Gaussian approximation for very large values; 444 Double_t x = Gaus(0, 1) * TMath::Sqrt(mean) + mean + 0.5;; 445 if (x > TMath::Limits<ULong64_t>::Max()) {; 446 Error(""Poisson"", ""Overflow in return value. Use PoissonD instead."");; 447 return TMath::Limits<",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:24672,Integrability,depend,depends,24672,"7 fSeed = (1103515245 * fSeed + 12345) & 0x7fffffffUL;; 588 if (fSeed) {array[i] = kCONS*fSeed; i++;}; 589 }; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Return an array of n random numbers uniformly distributed in ]0,1].; 594 ; 595void TRandom::RndmArray(Int_t n, Float_t *array); 596{; 597 const Double_t kCONS = 4.6566128730774E-10; // (1/pow(2,31)); 598 Int_t i=0;; 599 while (i<n) {; 600 fSeed = (1103515245 * fSeed + 12345) & 0x7fffffffUL;; 601 if (fSeed) {array[i] = Float_t(kCONS*fSeed); i++;}; 602 }; 603}; 604 ; 605////////////////////////////////////////////////////////////////////////////////; 606/// Set the random generator seed. Note that default value is zero, which is; 607/// different than the default value used when constructing the class.; 608/// If the seed is zero the seed is set to a random value; 609/// which in case of TRandom depends on the lowest 4 bytes of TUUID; 610/// The UUID will be identical if SetSeed(0) is called with time smaller than 100 ns; 611/// Instead if a different generator implementation is used (TRandom1, 2 or 3); 612/// the seed is generated using a 128 bit UUID. This results in different seeds; 613/// and then random sequence for every SetSeed(0) call.; 614 ; 615void TRandom::SetSeed(ULong_t seed); 616{; 617 if( seed==0 ) {; 618 TUUID u;; 619 UChar_t uuid[16];; 620 u.GetUUID(uuid);; 621 fSeed = UInt_t(uuid[3])*16777216 + UInt_t(uuid[2])*65536 + UInt_t(uuid[1])*256 + UInt_t(uuid[0]);; 622 } else {; 623 fSeed = seed;; 624 }; 625}; 626 ; 627////////////////////////////////////////////////////////////////////////////////; 628/// \brief Get the random generator seed.; 629///; 630/// \warning Might not be the initial seed!; 631///; 632/// Note that this function returns the given seed only when using; 633/// as random generator engine TRandom itself, which is an LCG generator; 634/// and it has as seed (state) only one 32 bit word.; 635/// In case of the other generators G",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:31708,Integrability,message,message,31708,"3.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TUUID.h; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::WriteTObjectvirtual Int_t WriteTObject(const TObject *obj, const char *name=nullptr, Option_t *="""", Int_t=0)Write an object with proper type checking.Definition TDirectory.cxx:1400; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::ReadTObjectvirtual Int_t ReadTObject(TObject *, const char *)Definition TDirectory.h:249; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmArrayvirtual void RndmArray(Int_t n, Float_t *array)Return an array of n random numbers uniformly distributed in ]0,1].Definition TRandom.cxx:595; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TRandom::WriteRandomvirtual void WriteRandom(const char *filename) constWrites random generator status to filename.Definition TRandom.cxx:700; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::fSeedUInt_t fSeedDefinition TRandom.h:30; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed follo",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:1755,Modifiability,extend,extended,1755,"m; 17 ; 18This is the base class for the ROOT Random number generators.; 19This class defines the ROOT Random number interface and it should not be instantiated directly but used via its derived; 20classes. The generator provided in TRandom itself is a LCG (Linear Congruential Generator), the <a; 21href=""https://www.gnu.org/software/gsl/manual/html_node/Unix-random-number-generators.html"">BSD `rand` generator</a>,; 22that it should not be used because its period is only 2**31, i.e. approximately 2 billion events, that can be generated; 23in just few seconds.; 24 ; 25To generate random numbers, one should use one of the derived classes, which are:; 26- TRandom3: it is based on the ""Mersenne Twister generator"",; 27it is fast and a very long period of about \f$10^{6000}\f$. However it fails some of the most stringent tests of the; 28<a href=""http://simul.iro.umontreal.ca/testu01/tu01.html"">TestU01 suite</a>.; 29In addition this generator provide only numbers with 32 random bits, which might be not sufficient for some application; 30based on double or extended precision. This generator is however used in ROOT used to instantiate the global pointer to; 31the ROOT generator, *gRandom*.; 32- ::TRandomRanluxpp : New implementation of the Ranlux generator algorithm based on a fast modular multiplication of; 33576 bits. This new implementation is built on the idea and the original code of Alexei Sibidanov, described in his; 34<a href=""https://arxiv.org/abs/1705.03123"">paper </a>. It generates random numbers with 52 bit precision (double; 35precision) and it has an higher luxury level than the original Ranlux generator (`p = 2048` instead of `p=794`).; 36- ::TRandomMixMax: Generator based on the family of the MIXMAX matrix generators (see the; 37<a href=""https://mixmax.hepforge.org"">MIXMAX HEPFORGE Web page</a> and the documentation of the class; 38ROOT::Math::MixMaxEngine for more information), that are base on the Asanov dynamical C systems. This generator has a; 39state of N",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:7329,Modifiability,flexible,flexible,7329,"4- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96- Poisson(Double_t mean); 97- Binomial(Int_t ntot, Double_t prob); 98 ; 99Random numbers distributed according to 1-d, 2-d or 3-d distributions contained in TF1, TF2 or TF3 objects can also be; 100generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : \code{.cpp} TF1; 101*f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10); double r = f1->GetRandom(); \endcode or you can use the UNURAN; 102package. You need in this case to initialize UNURAN to the function you would like to generate. \code{.cpp} TUnuran u;; 103 u.Init(TUnuranDistrCont(f1));; 104 double r = u.Sample();; 105\endcode; 106 ; 107The techniques of using directly a TF1,2 or 3 function is powerful and; 108can be used to generate numbers in the defined range of the function.; 109Getting a number from a TF1,2,3 function is also quite fast.; 110UNURAN is a powerful and flexible tool which contains various methods for; 111generate random numbers for continuous distributions of one and multi-dimension.; 112It requires some set-up (initialization) phase and can be very fast when the distribution; 113parameters are not changed for every call.; 114 ; 115The following table shows some timings (in nanosecond/call); 116for basic functions, TF1 functions and using UNURAN obtained running; 117the tutorial math/testrandom.C; 118Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; 119Linux SLC4 64 bit and compiled with gcc 3.4; 120 ; 121~~~~; 122Distribution nanoseconds/call; 123 TRandom TRandom1 TRandom2 TRandom3; 124Rndm.............. 5.000 105.000 7.000 10.000; 125RndmArray......... 4.000 104.000 6.000 9.000; 126Gaus.............. 36.000 180.000 40.000 48.000; 127Rannor............ 118.000 220.000 120.000 124.000; 128Landau............ 22.000 123.000 26.000 31.000; 129Exponential....... 93.000 198.000 98.000 104.000; 130Binomial(5,0.5)... 30.000 548.000 46.000 65.000; 131B",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:13415,Modifiability,variab,variables,13415,"uted over a circle of given radius.; 237/// Input : r = circle radius; 238/// Output: x,y a random 2-d vector of length r; 239 ; 240void TRandom::Circle(Double_t &x, Double_t &y, Double_t r); 241{; 242 Double_t phi = Uniform(0,TMath::TwoPi());; 243 x = r*TMath::Cos(phi);; 244 y = r*TMath::Sin(phi);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Returns an exponential deviate.; 249///; 250/// exp( -t/tau ); 251 ; 252Double_t TRandom::Exp(Double_t tau); 253{; 254 Double_t x = Rndm(); // uniform on ] 0, 1 ]; 255 Double_t t = -tau * TMath::Log( x ); // convert to exponential distribution; 256 return t;; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Samples a random number from the standard Normal (Gaussian) Distribution; 261/// with the given mean and sigma.; 262/// Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger; 263/// This is one of the fastest existing method for generating normal random variables.; 264/// It is a factor 2/3 faster than the polar (Box-Muller) method used in the previous; 265/// version of TRandom::Gaus. The speed is comparable to the Ziggurat method (from Marsaglia); 266/// implemented for example in GSL and available in the MathMore library.; 267///; 268/// REFERENCE: - W. Hoermann and G. Derflinger (1990):; 269/// The ACR Method for generating normal random variables,; 270/// OR Spektrum 12 (1990), 181-185.; 271///; 272/// Implementation taken from; 273/// UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien; 274 ; 275Double_t TRandom::Gaus(Double_t mean, Double_t sigma); 276{; 277 const Double_t kC1 = 1.448242853;; 278 const Double_t kC2 = 3.307147487;; 279 const Double_t kC3 = 1.46754004;; 280 const Double_t kD1 = 1.036467755;; 281 const Double_t kD2 = 5.295844968;; 282 const Double_t kD3 = 3.631288474;; 283 const Double_t kHm = 0.483941449;; 284 const Double_t kZm = 0.107981933;; 285 con",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:13811,Modifiability,variab,variables,13811,"l deviate.; 249///; 250/// exp( -t/tau ); 251 ; 252Double_t TRandom::Exp(Double_t tau); 253{; 254 Double_t x = Rndm(); // uniform on ] 0, 1 ]; 255 Double_t t = -tau * TMath::Log( x ); // convert to exponential distribution; 256 return t;; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Samples a random number from the standard Normal (Gaussian) Distribution; 261/// with the given mean and sigma.; 262/// Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger; 263/// This is one of the fastest existing method for generating normal random variables.; 264/// It is a factor 2/3 faster than the polar (Box-Muller) method used in the previous; 265/// version of TRandom::Gaus. The speed is comparable to the Ziggurat method (from Marsaglia); 266/// implemented for example in GSL and available in the MathMore library.; 267///; 268/// REFERENCE: - W. Hoermann and G. Derflinger (1990):; 269/// The ACR Method for generating normal random variables,; 270/// OR Spektrum 12 (1990), 181-185.; 271///; 272/// Implementation taken from; 273/// UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien; 274 ; 275Double_t TRandom::Gaus(Double_t mean, Double_t sigma); 276{; 277 const Double_t kC1 = 1.448242853;; 278 const Double_t kC2 = 3.307147487;; 279 const Double_t kC3 = 1.46754004;; 280 const Double_t kD1 = 1.036467755;; 281 const Double_t kD2 = 5.295844968;; 282 const Double_t kD3 = 3.631288474;; 283 const Double_t kHm = 0.483941449;; 284 const Double_t kZm = 0.107981933;; 285 const Double_t kHp = 4.132731354;; 286 const Double_t kZp = 18.52161694;; 287 const Double_t kPhln = 0.4515827053;; 288 const Double_t kHm1 = 0.516058551;; 289 const Double_t kHp1 = 3.132731354;; 290 const Double_t kHzm = 0.375959516;; 291 const Double_t kHzmp = 0.591923442;; 292 /*zhm 0.967882898*/; 293 ; 294 const Double_t kAs = 0.8853395638;; 295 const Double_t kBs = 0.2452635696;; 296 const Double_t kCs = 0.2770276848;; 2",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:1517,Testability,test,tests,1517,"ntributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13 ; 14\class TRandom; 15 ; 16@ingroup Random; 17 ; 18This is the base class for the ROOT Random number generators.; 19This class defines the ROOT Random number interface and it should not be instantiated directly but used via its derived; 20classes. The generator provided in TRandom itself is a LCG (Linear Congruential Generator), the <a; 21href=""https://www.gnu.org/software/gsl/manual/html_node/Unix-random-number-generators.html"">BSD `rand` generator</a>,; 22that it should not be used because its period is only 2**31, i.e. approximately 2 billion events, that can be generated; 23in just few seconds.; 24 ; 25To generate random numbers, one should use one of the derived classes, which are:; 26- TRandom3: it is based on the ""Mersenne Twister generator"",; 27it is fast and a very long period of about \f$10^{6000}\f$. However it fails some of the most stringent tests of the; 28<a href=""http://simul.iro.umontreal.ca/testu01/tu01.html"">TestU01 suite</a>.; 29In addition this generator provide only numbers with 32 random bits, which might be not sufficient for some application; 30based on double or extended precision. This generator is however used in ROOT used to instantiate the global pointer to; 31the ROOT generator, *gRandom*.; 32- ::TRandomRanluxpp : New implementation of the Ranlux generator algorithm based on a fast modular multiplication of; 33576 bits. This new implementation is built on the idea and the original code of Alexei Sibidanov, described in his; 34<a href=""https://arxiv.org/abs/1705.03123"">paper </a>. It generates random numbers with 52 bit precision (double; 35precision) and it has an higher luxury level than the original Ranlux generator (`p = 2048` instead of `p=794`).; 36- ::TRandomMixMax: Generator based on the family of the MIXMAX matrix generators (see the; 37<a href=""https://mixmax.hepforge.org"">MIXMAX HEPFORGE Web ",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:5579,Testability,test,tests,5579,"ref=""http://www.cplusplus.com/reference/random/ranlux48/"">std::ranlux48</a>). The drawback of this generator is its; 58slow generation time.; 59- TRandom2 is based on the Tausworthe generator of L'Ecuyer, and it has the advantage; 60of being fast and using only 3 words (of 32 bits) for the state. The period however is not impressively long, it is; 6110**26.; 62 ; 63Using the template TRandomGen class (template on the contained Engine type), it is possible to add any generator based; 64on the standard C++ random library (see the C++ <a href=""http://www.cplusplus.com/reference/random/"">random</a>; 65documentation.) or different variants of the MIXMAX generator using the ROOT::Math::MixMaxEngine. Some of the listed; 66generator above (e.g. TRandomMixMax256 or TRandomMT64) are convenient typedef's of generator built using the template; 67TRandomGen class.; 68 ; 69Please note also that this class (TRandom) implements also a very simple generator (linear congruential) with period =; 70\f$10^9\f$, known to have defects (the lower random bits are correlated) and it is failing the majority of the random; 71number generator tests. Therefore it should NOT be used in any statistical study.; 72 ; 73The following table shows some timings (in nanoseconds/call); 74for the random numbers obtained using a macbookpro 2.6 GHz Intel Core i7 CPU:; 75 ; 76 ; 77- TRandom 3 ns/call (but this is a very BAD Generator, not to be used); 78- TRandom2 5 ns/call; 79- TRandom3 5 ns/call; 80- ::TRandomMixMax 6 ns/call; 81- ::TRandomMixMax17 6 ns/call; 82- ::TRandomMT64 9 ns/call; 83- ::TRandomMixMax256 10 ns/call; 84- ::TRandomRanluxpp 14 ns/call; 85- ::TRandom1 80 ns/call; 86- ::TRandomRanlux48 250 ns/call; 87 ; 88The following methods are provided to generate random numbers distributed according to some basic distributions:; 89 ; 90- Exp(Double_t tau); 91- Integer(UInt_t imax); 92- Gaus(Double_t mean, Double_t sigma); 93- Rndm(); 94- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96-",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:7769,Testability,test,testrandom,7769,"distributed following abs(sin(x)/x)*sqrt(x) you can do : \code{.cpp} TF1; 101*f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10); double r = f1->GetRandom(); \endcode or you can use the UNURAN; 102package. You need in this case to initialize UNURAN to the function you would like to generate. \code{.cpp} TUnuran u;; 103 u.Init(TUnuranDistrCont(f1));; 104 double r = u.Sample();; 105\endcode; 106 ; 107The techniques of using directly a TF1,2 or 3 function is powerful and; 108can be used to generate numbers in the defined range of the function.; 109Getting a number from a TF1,2,3 function is also quite fast.; 110UNURAN is a powerful and flexible tool which contains various methods for; 111generate random numbers for continuous distributions of one and multi-dimension.; 112It requires some set-up (initialization) phase and can be very fast when the distribution; 113parameters are not changed for every call.; 114 ; 115The following table shows some timings (in nanosecond/call); 116for basic functions, TF1 functions and using UNURAN obtained running; 117the tutorial math/testrandom.C; 118Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; 119Linux SLC4 64 bit and compiled with gcc 3.4; 120 ; 121~~~~; 122Distribution nanoseconds/call; 123 TRandom TRandom1 TRandom2 TRandom3; 124Rndm.............. 5.000 105.000 7.000 10.000; 125RndmArray......... 4.000 104.000 6.000 9.000; 126Gaus.............. 36.000 180.000 40.000 48.000; 127Rannor............ 118.000 220.000 120.000 124.000; 128Landau............ 22.000 123.000 26.000 31.000; 129Exponential....... 93.000 198.000 98.000 104.000; 130Binomial(5,0.5)... 30.000 548.000 46.000 65.000; 131Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; 132Poisson(3)........ 96.000 494.000 109.000 125.000; 133Poisson(10)....... 138.000 1236.000 165.000 203.000; 134Poisson(70)....... 818.000 1195.000 835.000 844.000; 135Poisson(100)...... 837.000 1218.000 849.000 864.000; 136GausTF1........... 83.000 180.000 8",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:15956,Testability,log,log,15956,"st Double_t kHzmp = 0.591923442;; 292 /*zhm 0.967882898*/; 293 ; 294 const Double_t kAs = 0.8853395638;; 295 const Double_t kBs = 0.2452635696;; 296 const Double_t kCs = 0.2770276848;; 297 const Double_t kB = 0.5029324303;; 298 const Double_t kX0 = 0.4571828819;; 299 const Double_t kYm = 0.187308492 ;; 300 const Double_t kS = 0.7270572718 ;; 301 const Double_t kT = 0.03895759111;; 302 ; 303 Double_t result;; 304 Double_t rn,x,y,z;; 305 ; 306 do {; 307 y = Rndm();; 308 ; 309 if (y>kHm1) {; 310 result = kHp*y-kHp1; break; }; 311 ; 312 else if (y<kZm) {; 313 rn = kZp*y-1;; 314 result = (rn>0) ? (1+rn) : (-1+rn);; 315 break;; 316 }; 317 ; 318 else if (y<kHm) {; 319 rn = Rndm();; 320 rn = rn-1+rn;; 321 z = (rn>0) ? 2-rn : -2-rn;; 322 if ((kC1-y)*(kC3+TMath::Abs(z))<kC2) {; 323 result = z; break; }; 324 else {; 325 x = rn*rn;; 326 if ((y+kD1)*(kD3+x)<kD2) {; 327 result = rn; break; }; 328 else if (kHzmp-y<exp(-(z*z+kPhln)/2)) {; 329 result = z; break; }; 330 else if (y+kHzm<exp(-(x+kPhln)/2)) {; 331 result = rn; break; }; 332 }; 333 }; 334 ; 335 while (true) {; 336 x = Rndm();; 337 y = kYm * Rndm();; 338 z = kX0 - kS*x - y;; 339 if (z>0); 340 rn = 2+y/x;; 341 else {; 342 x = 1-x;; 343 y = kYm-y;; 344 rn = -(2+y/x);; 345 }; 346 if ((y-kAs+x)*(kCs+x)+kBs<0) {; 347 result = rn; break; }; 348 else if (y<x+kT); 349 if (rn*rn<4*(kB-log(x))) {; 350 result = rn; break; }; 351 }; 352 } while(false);; 353 ; 354 return mean + sigma * result;; 355}; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Returns a random integer uniformly distributed on the interval [ 0, imax-1 ].; 359/// Note that the interval contains the values of 0 and imax-1 but not imax.; 360 ; 361UInt_t TRandom::Integer(UInt_t imax); 362{; 363 UInt_t ui;; 364 ui = (UInt_t)(imax*Rndm());; 365 return ui;; 366}; 367 ; 368////////////////////////////////////////////////////////////////////////////////; 369/// Generate a random number following a Landau distribution; 370/// ",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:36059,Testability,log,logarithm,36059,"tifier), also known as GUIDs (Globally Unique IDent...Definition TUUID.h:42; TUUID::GetUUIDvoid GetUUID(UChar_t uuid[16]) constReturn uuid in specified buffer (16 byte = 128 bits).Definition TUUID.cxx:695; double; int; unsigned int; ROOT::Math::landau_quantiledouble landau_quantile(double z, double xi=1)Inverse ( ) of the cumulative distribution function of the lower tail of the Landau distribution (lan...Definition QuantFuncMathCore.cxx:189; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::LnGammaDouble_t LnGamma(Double_t z)Computation of ln[gamma(z)] for all z.Definition TMath.cxx:509; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; TMath::LimitsDefinition TMath.h:407; TMath::Limits::Maxstatic T Max()Returns minimum double representation.Definition TMath.h:933. mathmathcoresrcTRandom.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:5385,Usability,simpl,simple,5385,"ref=""http://www.cplusplus.com/reference/random/ranlux48/"">std::ranlux48</a>). The drawback of this generator is its; 58slow generation time.; 59- TRandom2 is based on the Tausworthe generator of L'Ecuyer, and it has the advantage; 60of being fast and using only 3 words (of 32 bits) for the state. The period however is not impressively long, it is; 6110**26.; 62 ; 63Using the template TRandomGen class (template on the contained Engine type), it is possible to add any generator based; 64on the standard C++ random library (see the C++ <a href=""http://www.cplusplus.com/reference/random/"">random</a>; 65documentation.) or different variants of the MIXMAX generator using the ROOT::Math::MixMaxEngine. Some of the listed; 66generator above (e.g. TRandomMixMax256 or TRandomMT64) are convenient typedef's of generator built using the template; 67TRandomGen class.; 68 ; 69Please note also that this class (TRandom) implements also a very simple generator (linear congruential) with period =; 70\f$10^9\f$, known to have defects (the lower random bits are correlated) and it is failing the majority of the random; 71number generator tests. Therefore it should NOT be used in any statistical study.; 72 ; 73The following table shows some timings (in nanoseconds/call); 74for the random numbers obtained using a macbookpro 2.6 GHz Intel Core i7 CPU:; 75 ; 76 ; 77- TRandom 3 ns/call (but this is a very BAD Generator, not to be used); 78- TRandom2 5 ns/call; 79- TRandom3 5 ns/call; 80- ::TRandomMixMax 6 ns/call; 81- ::TRandomMixMax17 6 ns/call; 82- ::TRandomMT64 9 ns/call; 83- ::TRandomMixMax256 10 ns/call; 84- ::TRandomRanluxpp 14 ns/call; 85- ::TRandom1 80 ns/call; 86- ::TRandomRanlux48 250 ns/call; 87 ; 88The following methods are provided to generate random numbers distributed according to some basic distributions:; 89 ; 90- Exp(Double_t tau); 91- Integer(UInt_t imax); 92- Gaus(Double_t mean, Double_t sigma); 93- Rndm(); 94- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96-",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8cxx_source.html:9831,Usability,simpl,simple,9831,"40PoissonUNURAN(100) 62.000 256.000 69.000 78.000; 141~~~~; 142 ; 143Note that the time to generate a number from an arbitrary TF1 function; 144using TF1::GetRandom or using TUnuran is independent of the complexity of the function.; 145 ; 146TH1::FillRandom(TH1 *) or TH1::FillRandom(const char *tf1name); 147can be used to fill an histogram (1-d, 2-d, 3-d from an existing histogram; 148or from an existing function.; 149 ; 150Note this interesting feature when working with objects.; 151 You can use several TRandom objects, each with their ""independent""; 152 random sequence. For example, one can imagine; 153~~~~; 154 TRandom *eventGenerator = new TRandom();; 155 TRandom *tracking = new TRandom();; 156~~~~; 157 `eventGenerator` can be used to generate the event kinematics.; 158 tracking can be used to track the generated particles with random numbers; 159 independent from eventGenerator.; 160 This very interesting feature gives the possibility to work with simple; 161 and very fast random number generators without worrying about; 162 random number periodicity as it was the case with Fortran.; 163 One can use TRandom::SetSeed to modify the seed of one generator.; 164 ; 165A TRandom object may be written to a Root file; 166 ; 167- as part of another object; 168- or with its own key (example: `gRandom->Write(""Random"")` ) ;; 169 ; 170*/; 171 ; 172#include ""TROOT.h""; 173#include ""TMath.h""; 174#include ""TRandom.h""; 175#include ""TRandom3.h""; 176#include ""TSystem.h""; 177#include ""TDirectory.h""; 178#include ""Math/QuantFuncMathCore.h""; 179#include ""TUUID.h""; 180#include ""TError.h""; 181 ; 182ClassImp(TRandom);; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// Default constructor. For seed see SetSeed().; 186 ; 187TRandom::TRandom(UInt_t seed): TNamed(""Random"",""Default Random number generator""); 188{; 189 SetSeed(seed);; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// Default de",MatchSource.WIKI,doc/master/TRandom_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html
https://root.cern/doc/master/TRandom_8h.html:244,Integrability,depend,dependency,244,". ROOT: math/mathcore/inc/TRandom.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TRandom.h File Reference. #include ""Math/TRandomEngine.h""; #include ""TNamed.h"". Include dependency graph for TRandom.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TRandom;  This is the base class for the ROOT Random number generators. More...;  . Variables; R__EXTERN TRandom * gRandom;  . Variable Documentation. ◆ gRandom. R__EXTERN TRandom* gRandom. Definition at line 62 of file TRandom.h. mathmathcoreincTRandom.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TRandom_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRandom_8h.html
https://root.cern/doc/master/transparency_8C.html:570,Availability,avail,available,570,". ROOT: tutorials/graphics/transparency.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. transparency.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro demonstrates the use of color transparency. ; It is done by specifying the alpha value of a given color. For instance; ellipse->SetFillColorAlpha(9, 0.571);; changes the ellipse fill color to the index 9 with an alpha value of 0.571. 0. would be fully transparent (invisible) and 1. completely opaque (the default).; The transparency is available on all platforms when the flag OpenGL.CanvasPreferGL is set to 1 in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. X11 does not support transparency. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript. ; void transparency(); {; auto c1 = new TCanvas(""c1"", ""c1"",224,330,700,527);; c1->Range(-0.125,-0.125,1.125,1.125);; ; auto tex = new TLatex(0.06303724,0.0194223,""This text is opaque and this line is transparent"");; tex->SetLineWidth(2);; tex->Draw();; ; auto arrow = new TArrow(0.5555158,0.07171314,0.8939828,0.6195219,0.05,""|>"");; arrow->SetLineWidth(4);; arrow->SetAngle(30);; arrow->Draw();; ; // Draw a transparent graph.; Double_t x[10] = {; 0.5232808, 0.8724928, 0.9280086, 0.7059456, 0.7399714,; 0.4659742, 0.8241404, 0.4838825, 0.7936963, 0.743553};; Double_t y[10] = {; 0.7290837, 0.9631474, 0.4775896, 0.6494024, 0.3555777,; 0.622012, 0.7938247, 0.9482072, 0.3904382, 0.2410359};; auto graph = new TGraph(10,x,y);; graph->SetLineColorAlpha(46, 0.1);; graph->SetLineWidth(7);; graph->Draw(""l"");; ; // Draw an ellipse with opaque colors.; auto ellipse = new TEllipse(0.1740688,0.8352632,0.1518625,0.1010526,0,360,0);; ellipse->SetFillColor(30);; ellipse->SetLineColor(51);; ellipse->SetLineWidth(3);; ellipse->Draw();; ; // Draw an ellipse with transparent colors, above the previous one.; ellipse = new TEllipse(0.2985315,0.7092105,0.1566977,0.1868421,0,",MatchSource.WIKI,doc/master/transparency_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/transparency_8C.html
https://root.cern/doc/master/tree0_8C.html:2688,Availability,error,errorbars,2688," numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""); //energy of det a; tree->Draw(""a.e"",""3*(-.2<b.e && b.e<.2)"",""same""); // same but with condition on energy b; scaled by 3; c1->cd(2);; tree->Draw(""b.e:a.e"","""",""colz""); // one energy against the other; c1->cd(3);; tree->Draw(""b.t"","""",""e""); // time of b with errorbars; tree->Draw(""a.t"","""",""same""); // overlay time of detector a; c1->cd(4);; tree->Draw(""b.t:a.t""); // plot time b again time a; ; cout<<endl;; cout<<""You can now examine the structure of your tree in the TreeViewer""<<endl;; cout<<endl;; }; ; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassImp#define ClassImp(name)Definition Rtypes.h:382; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; TTree.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TObjectMother of all ROOT objects.Definition TObject.h:41; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Def",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:1128,Energy Efficiency,energy,energy,1128,"unning this macro create an instance of Det and Event; Det d;; Event e;; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; EventDefinition collection_proxies.C:172; now you can see the effect of the ClassDef() and ClassImp() macros. (for the Det class these commands are commented!) For instance 'e' now knows who it is:; cout<<e.Class_Name()<<endl;; whereas d does not.; The methods that are added by the ClassDef()/Imp() macro can be listed with; .class; .class Event; .class Det; ; #include <TRandom.h>; #include <TTree.h>; #include <TCanvas.h>; #include <TStyle.h>; ; #include <Riostream.h>; ; //class Det : public TObject {; class Det { // each detector gives an energy and time signal; public:; Double_t e; //energy; Double_t t; //time; ; // ClassDef(Det,1); };; ; //ClassImp(Det); ; //class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:1175,Energy Efficiency,energy,energy,1175,"unning this macro create an instance of Det and Event; Det d;; Event e;; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; EventDefinition collection_proxies.C:172; now you can see the effect of the ClassDef() and ClassImp() macros. (for the Det class these commands are commented!) For instance 'e' now knows who it is:; cout<<e.Class_Name()<<endl;; whereas d does not.; The methods that are added by the ClassDef()/Imp() macro can be listed with; .class; .class Event; .class Det; ; #include <TRandom.h>; #include <TTree.h>; #include <TCanvas.h>; #include <TStyle.h>; ; #include <Riostream.h>; ; //class Det : public TObject {; class Det { // each detector gives an energy and time signal; public:; Double_t e; //energy; Double_t t; //time; ; // ClassDef(Det,1); };; ; //ClassImp(Det); ; //class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:1617,Energy Efficiency,energy,energy,1617,"unning this macro create an instance of Det and Event; Det d;; Event e;; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; EventDefinition collection_proxies.C:172; now you can see the effect of the ClassDef() and ClassImp() macros. (for the Det class these commands are commented!) For instance 'e' now knows who it is:; cout<<e.Class_Name()<<endl;; whereas d does not.; The methods that are added by the ClassDef()/Imp() macro can be listed with; .class; .class Event; .class Det; ; #include <TRandom.h>; #include <TTree.h>; #include <TCanvas.h>; #include <TStyle.h>; ; #include <Riostream.h>; ; //class Det : public TObject {; class Det { // each detector gives an energy and time signal; public:; Double_t e; //energy; Double_t t; //time; ; // ClassDef(Det,1); };; ; //ClassImp(Det); ; //class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:2434,Energy Efficiency,energy,energy,2434,"ent,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""); //energy of det a; tree->Draw(""a.e"",""3*(-.2<b.e && b.e<.2)"",""same""); // same but with condition on energy b; scaled by 3; c1->cd(2);; tree->Draw(""b.e:a.e"","""",""colz""); // one energy against the other; c1->cd(3);; tree->Draw(""b.t"","""",""e""); // time of b with errorbars; tree->Draw(""a.t"","""",""same""); // overlay time of detector a; c1->cd(4);; tree->Draw(""b.t:a.t""); // plot time b again time a; ; cout<<endl;; cout<<""You can now examine the structure of your tree in the TreeViewer""<<endl;; cout<<endl;; }; ; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassImp#define ClassImp(name)Definition Rtypes.h:382; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; TTree.h; TCanvasThe Canvas class.Definition TCanvas.h",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:2531,Energy Efficiency,energy,energy,2531,"ree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""); //energy of det a; tree->Draw(""a.e"",""3*(-.2<b.e && b.e<.2)"",""same""); // same but with condition on energy b; scaled by 3; c1->cd(2);; tree->Draw(""b.e:a.e"","""",""colz""); // one energy against the other; c1->cd(3);; tree->Draw(""b.t"","""",""e""); // time of b with errorbars; tree->Draw(""a.t"","""",""same""); // overlay time of detector a; c1->cd(4);; tree->Draw(""b.t:a.t""); // plot time b again time a; ; cout<<endl;; cout<<""You can now examine the structure of your tree in the TreeViewer""<<endl;; cout<<endl;; }; ; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassImp#define ClassImp(name)Definition Rtypes.h:382; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; TTree.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TObjectMother of all ROOT objects.Definition TObject.h:41; TRandom::Gausvirtual Dou",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:2606,Energy Efficiency,energy,energy,2606,"gy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""); //energy of det a; tree->Draw(""a.e"",""3*(-.2<b.e && b.e<.2)"",""same""); // same but with condition on energy b; scaled by 3; c1->cd(2);; tree->Draw(""b.e:a.e"","""",""colz""); // one energy against the other; c1->cd(3);; tree->Draw(""b.t"","""",""e""); // time of b with errorbars; tree->Draw(""a.t"","""",""same""); // overlay time of detector a; c1->cd(4);; tree->Draw(""b.t:a.t""); // plot time b again time a; ; cout<<endl;; cout<<""You can now examine the structure of your tree in the TreeViewer""<<endl;; cout<<endl;; }; ; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassImp#define ClassImp(name)Definition Rtypes.h:382; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; TTree.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TObjectMother of all ROOT objects.Definition TObject.h:41; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard ",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:2342,Modifiability,variab,variables,2342,"class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""); //energy of det a; tree->Draw(""a.e"",""3*(-.2<b.e && b.e<.2)"",""same""); // same but with condition on energy b; scaled by 3; c1->cd(2);; tree->Draw(""b.e:a.e"","""",""colz""); // one energy against the other; c1->cd(3);; tree->Draw(""b.t"","""",""e""); // time of b with errorbars; tree->Draw(""a.t"","""",""same""); // overlay time of detector a; c1->cd(4);; tree->Draw(""b.t:a.t""); // plot time b again time a; ; cout<<endl;; cout<<""You can now examine the structure of your tree in the TreeViewer""<<endl;; cout<<endl;; }; ; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassImp#define ClassImp(name)Definition Rtypes.h:382; ClassDefOverride#define Cl",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:1110,Safety,detect,detector,1110,"unning this macro create an instance of Det and Event; Det d;; Event e;; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; EventDefinition collection_proxies.C:172; now you can see the effect of the ClassDef() and ClassImp() macros. (for the Det class these commands are commented!) For instance 'e' now knows who it is:; cout<<e.Class_Name()<<endl;; whereas d does not.; The methods that are added by the ClassDef()/Imp() macro can be listed with; .class; .class Event; .class Det; ; #include <TRandom.h>; #include <TTree.h>; #include <TCanvas.h>; #include <TStyle.h>; ; #include <Riostream.h>; ; //class Det : public TObject {; class Det { // each detector gives an energy and time signal; public:; Double_t e; //energy; Double_t t; //time; ; // ClassDef(Det,1); };; ; //ClassImp(Det); ; //class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:1380,Safety,detect,detectors,1380,"unning this macro create an instance of Det and Event; Det d;; Event e;; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; EventDefinition collection_proxies.C:172; now you can see the effect of the ClassDef() and ClassImp() macros. (for the Det class these commands are commented!) For instance 'e' now knows who it is:; cout<<e.Class_Name()<<endl;; whereas d does not.; The methods that are added by the ClassDef()/Imp() macro can be listed with; .class; .class Event; .class Det; ; #include <TRandom.h>; #include <TTree.h>; #include <TCanvas.h>; #include <TStyle.h>; ; #include <Riostream.h>; ; //class Det : public TObject {; class Det { // each detector gives an energy and time signal; public:; Double_t e; //energy; Double_t t; //time; ; // ClassDef(Det,1); };; ; //ClassImp(Det); ; //class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:2747,Safety,detect,detector,2747,") {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""); //energy of det a; tree->Draw(""a.e"",""3*(-.2<b.e && b.e<.2)"",""same""); // same but with condition on energy b; scaled by 3; c1->cd(2);; tree->Draw(""b.e:a.e"","""",""colz""); // one energy against the other; c1->cd(3);; tree->Draw(""b.t"","""",""e""); // time of b with errorbars; tree->Draw(""a.t"","""",""same""); // overlay time of detector a; c1->cd(4);; tree->Draw(""b.t:a.t""); // plot time b again time a; ; cout<<endl;; cout<<""You can now examine the structure of your tree in the TreeViewer""<<endl;; cout<<endl;; }; ; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassImp#define ClassImp(name)Definition Rtypes.h:382; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; TTree.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TObjectMother of all ROOT objects.Definition TObject.h:41; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideM",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree0_8C.html:317,Security,access,access,317,". ROOT: tutorials/tree/tree0.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree0.C File ReferenceTutorials » Tree tutorials. Detailed Description; Simple Event class example ; execute as: .x tree0.C++; You have to copy it first to a directory where you have write access! Note that .x tree0.C cannot work with this example. Effect of ClassDef() and ClassImp() macros; After running this macro create an instance of Det and Event; Det d;; Event e;; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; EventDefinition collection_proxies.C:172; now you can see the effect of the ClassDef() and ClassImp() macros. (for the Det class these commands are commented!) For instance 'e' now knows who it is:; cout<<e.Class_Name()<<endl;; whereas d does not.; The methods that are added by the ClassDef()/Imp() macro can be listed with; .class; .class Event; .class Det; ; #include <TRandom.h>; #include <TTree.h>; #include <TCanvas.h>; #include <TStyle.h>; ; #include <Riostream.h>; ; //class Det : public TObject {; class Det { // each detector gives an energy and time signal; public:; Double_t e; //energy; Double_t t; //time; ; // ClassDef(Det,1); };; ; //ClassImp(Det); ; //class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1",MatchSource.WIKI,doc/master/tree0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree0_8C.html
https://root.cern/doc/master/tree1_8C.html:1760,Availability,alive,alive,1760,"s. For example following one of the sessions above, one can start the session: .L tree1.C; tree1r();; ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; ; void tree1w(); {; //create a Tree file tree1.root; ; //create the file, the Tree and a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""random"",&random,""random/D"");; t1.Branch(""ev"",&ev,""ev/I"");; ; //fill the tree; for (Int_t i=0;i<10000;i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t1.Write();; }; ; void tree1r(); {; //read the Tree generated by tree1w and fill two histograms; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddress(""pz"",&pz);; t1->SetBranchAddress(""random"",&random);; t1->SetBranchAddress(""ev"",&ev);; ; //create two histograms; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-3,3);; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",30,-3,3,30,-3,3);; ; //read all entries and fill the histograms; Long64_t nentries = t1->GetEntries();; for (Long64_t i=0;i<nentries;i++) {; t1->GetEntry(i);; hpx->Fill(px);; hpxpy->Fill(px,py);; }; ; //we do not close the file. We want to keep the generated histograms; //we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser();; t1->StartViewer();; // in the browser, click on ""ROOT Files"", then on ""tree1.root"".; // you can clic",MatchSource.WIKI,doc/master/tree1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree1_8C.html
https://root.cern/doc/master/tree1_8C.html:550,Integrability,interface,interface,550,". ROOT: tutorials/tree/tree1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree1.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; It shows:; how to fill a Tree with a few simple variables.; how to read this Tree; how to browse and analyze the Tree via the TBrowser and TTreeViewer This example can be run in many different ways:. Using the Cling interpreter .x tree1.C. Using the automatic compiler interface .x tree1.C++. .L tree1.C or .L tree1.C++; tree1(); One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree1.C; tree1r();; ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; ; void tree1w(); {; //create a Tree file tree1.root; ; //create the file, the Tree and a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""random"",&random,""random/D"");; t1.Branch(""ev"",&ev,""ev/I"");; ; //fill the tree; for (Int_t i=0;i<10000;i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t1.Write();; }; ; void tree1r(); {; //read the Tree generated by tree1w and fill two histograms; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddr",MatchSource.WIKI,doc/master/tree1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree1_8C.html
https://root.cern/doc/master/tree1_8C.html:329,Modifiability,variab,variables,329,". ROOT: tutorials/tree/tree1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree1.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; It shows:; how to fill a Tree with a few simple variables.; how to read this Tree; how to browse and analyze the Tree via the TBrowser and TTreeViewer This example can be run in many different ways:. Using the Cling interpreter .x tree1.C. Using the automatic compiler interface .x tree1.C++. .L tree1.C or .L tree1.C++; tree1(); One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree1.C; tree1r();; ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; ; void tree1w(); {; //create a Tree file tree1.root; ; //create the file, the Tree and a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""random"",&random,""random/D"");; t1.Branch(""ev"",&ev,""ev/I"");; ; //fill the tree; for (Int_t i=0;i<10000;i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t1.Write();; }; ; void tree1r(); {; //read the Tree generated by tree1w and fill two histograms; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddr",MatchSource.WIKI,doc/master/tree1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree1_8C.html
https://root.cern/doc/master/tree1_8C.html:1082,Modifiability,variab,variables,1082,".  . Loading...; Searching...; No Matches. tree1.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; It shows:; how to fill a Tree with a few simple variables.; how to read this Tree; how to browse and analyze the Tree via the TBrowser and TTreeViewer This example can be run in many different ways:. Using the Cling interpreter .x tree1.C. Using the automatic compiler interface .x tree1.C++. .L tree1.C or .L tree1.C++; tree1(); One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree1.C; tree1r();; ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; ; void tree1w(); {; //create a Tree file tree1.root; ; //create the file, the Tree and a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""random"",&random,""random/D"");; t1.Branch(""ev"",&ev,""ev/I"");; ; //fill the tree; for (Int_t i=0;i<10000;i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t1.Write();; }; ; void tree1r(); {; //read the Tree generated by tree1w and fill two histograms; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddress(""pz"",&pz);; t1->SetBranchAddress(""random"",&random);; t1->SetBranchAddress(""ev"",&",MatchSource.WIKI,doc/master/tree1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree1_8C.html
https://root.cern/doc/master/tree1_8C.html:322,Usability,simpl,simple,322,". ROOT: tutorials/tree/tree1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree1.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; It shows:; how to fill a Tree with a few simple variables.; how to read this Tree; how to browse and analyze the Tree via the TBrowser and TTreeViewer This example can be run in many different ways:. Using the Cling interpreter .x tree1.C. Using the automatic compiler interface .x tree1.C++. .L tree1.C or .L tree1.C++; tree1(); One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree1.C; tree1r();; ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; ; void tree1w(); {; //create a Tree file tree1.root; ; //create the file, the Tree and a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""random"",&random,""random/D"");; t1.Branch(""ev"",&ev,""ev/I"");; ; //fill the tree; for (Int_t i=0;i<10000;i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t1.Write();; }; ; void tree1r(); {; //read the Tree generated by tree1w and fill two histograms; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddr",MatchSource.WIKI,doc/master/tree1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree1_8C.html
https://root.cern/doc/master/tree1_8C.html:1058,Usability,simpl,simple,1058,".  . Loading...; Searching...; No Matches. tree1.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; It shows:; how to fill a Tree with a few simple variables.; how to read this Tree; how to browse and analyze the Tree via the TBrowser and TTreeViewer This example can be run in many different ways:. Using the Cling interpreter .x tree1.C. Using the automatic compiler interface .x tree1.C++. .L tree1.C or .L tree1.C++; tree1(); One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree1.C; tree1r();; ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; ; void tree1w(); {; //create a Tree file tree1.root; ; //create the file, the Tree and a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""random"",&random,""random/D"");; t1.Branch(""ev"",&ev,""ev/I"");; ; //fill the tree; for (Int_t i=0;i<10000;i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t1.Write();; }; ; void tree1r(); {; //read the Tree generated by tree1w and fill two histograms; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddress(""pz"",&pz);; t1->SetBranchAddress(""random"",&random);; t1->SetBranchAddress(""ev"",&",MatchSource.WIKI,doc/master/tree1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree1_8C.html
https://root.cern/doc/master/tree1_8C.html:1075,Usability,simpl,simple,1075,".  . Loading...; Searching...; No Matches. tree1.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; It shows:; how to fill a Tree with a few simple variables.; how to read this Tree; how to browse and analyze the Tree via the TBrowser and TTreeViewer This example can be run in many different ways:. Using the Cling interpreter .x tree1.C. Using the automatic compiler interface .x tree1.C++. .L tree1.C or .L tree1.C++; tree1(); One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree1.C; tree1r();; ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; ; void tree1w(); {; //create a Tree file tree1.root; ; //create the file, the Tree and a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""random"",&random,""random/D"");; t1.Branch(""ev"",&ev,""ev/I"");; ; //fill the tree; for (Int_t i=0;i<10000;i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t1.Write();; }; ; void tree1r(); {; //read the Tree generated by tree1w and fill two histograms; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddress(""pz"",&pz);; t1->SetBranchAddress(""random"",&random);; t1->SetBranchAddress(""ev"",&",MatchSource.WIKI,doc/master/tree1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree1_8C.html
https://root.cern/doc/master/tree2a_8C.html:4754,Availability,alive,alive,4754,"tep->step, gstep->vect, vout); //make one step; ; //apply energy loss; gstep->destep = gstep->step*gRandom->Gaus(0.0002,0.00001);; gstep->gekin -= gstep->destep;; gstep->getot = gstep->gekin + mass;; gstep->vect[6] = charge*TMath::Sqrt(gstep->getot*gstep->getot - mass*mass);; gstep->vect[0] = vout[0];; gstep->vect[1] = vout[1];; gstep->vect[2] = vout[2];; gstep->vect[3] = vout[3];; gstep->vect[4] = vout[4];; gstep->vect[5] = vout[5];; gstep->nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep->nmec;l++) {; gstep->lmec[l] = l;; gstep->namec[l] = l+100;; }; if (gstep->gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep->vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2ar(); {; //read the Tree generated by tree2w and fill one histogram; //we are only interested by the destep branch.; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave; //this function.; TFile *f = new TFile(""tree2.root"");; TTree *t2 = (TTree*)f->Get(""t2"");; Gctrak *gstep = nullptr;; t2->SetBranchAddress(""track"",&gstep);; TBranch *b_destep = t2->GetBranch(""destep"");; ; //create one histogram; TH1F *hdestep = new TH1F(""hdestep"",""destep in Mev"",100,1e-5,3e-5);; ; //read only the destep branch for all entries; Long64_t nentries = t2->GetEntries();; for (Long64_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; hdestep->Fill(gstep->destep);; }; ; //we do not close the file.; //We want to keep the generated histograms; //We fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);; c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");; c1->cd(2);; gPad->SetFillColor(37);; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;; ; // invoke the x3d viewer; gPad->GetView",MatchSource.WIKI,doc/master/tree2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2a_8C.html
https://root.cern/doc/master/tree2a_8C.html:2797,Energy Efficiency,charge,charge,2797,"at_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ; void tree2aw(); {; //create a Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak *gstep = new Gctrak;; t2.Branch(""track"",&gstep,8000,1);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep->lmec = new Int_t[MAXMEC];; gstep->namec = new Int_t[MAXMEC];; gstep->step = 0.1;; gstep->destep = 0;; gstep->nmec = 0;; gstep->pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //",MatchSource.WIKI,doc/master/tree2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2a_8C.html
https://root.cern/doc/master/tree2a_8C.html:3259,Energy Efficiency,charge,charge,3259,"] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ; void tree2aw(); {; //create a Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak *gstep = new Gctrak;; t2.Branch(""track"",&gstep,8000,1);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep->lmec = new Int_t[MAXMEC];; gstep->namec = new Int_t[MAXMEC];; gstep->step = 0.1;; gstep->destep = 0;; gstep->nmec = 0;; gstep->pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //apply energy loss; gstep->destep = gstep->step*gRandom->Gaus(0.0002,0.00001);; gstep->gekin -= gstep->destep;; gstep->getot = gstep->gekin + mass;; gstep->vect[6] = charge*TMath::Sqrt(gstep->getot*gstep->getot - mass*mass);; gstep->vect[0] = vout[0];; gstep->vect[1] = vout[1];; gstep->vect[2] = vout[2];; gstep->vect[3] = vout[3];; gstep->vect[4] = vout[4];; gstep->vect[5] = vout[5];; gstep->nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep->nmec;l++) {; gstep->lmec[l] = l;;",MatchSource.WIKI,doc/master/tree2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2a_8C.html
https://root.cern/doc/master/tree2a_8C.html:3298,Energy Efficiency,charge,charge,3298,"Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak *gstep = new Gctrak;; t2.Branch(""track"",&gstep,8000,1);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep->lmec = new Int_t[MAXMEC];; gstep->namec = new Int_t[MAXMEC];; gstep->step = 0.1;; gstep->destep = 0;; gstep->nmec = 0;; gstep->pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //apply energy loss; gstep->destep = gstep->step*gRandom->Gaus(0.0002,0.00001);; gstep->gekin -= gstep->destep;; gstep->getot = gstep->gekin + mass;; gstep->vect[6] = charge*TMath::Sqrt(gstep->getot*gstep->getot - mass*mass);; gstep->vect[0] = vout[0];; gstep->vect[1] = vout[1];; gstep->vect[2] = vout[2];; gstep->vect[3] = vout[3];; gstep->vect[4] = vout[4];; gstep->vect[5] = vout[5];; gstep->nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep->nmec;l++) {; gstep->lmec[l] = l;; gstep->namec[l] = l+100;; }; if (gstep->gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep->vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going o",MatchSource.WIKI,doc/master/tree2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2a_8C.html
https://root.cern/doc/master/tree2a_8C.html:3484,Energy Efficiency,charge,charge,3484,"Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak *gstep = new Gctrak;; t2.Branch(""track"",&gstep,8000,1);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep->lmec = new Int_t[MAXMEC];; gstep->namec = new Int_t[MAXMEC];; gstep->step = 0.1;; gstep->destep = 0;; gstep->nmec = 0;; gstep->pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //apply energy loss; gstep->destep = gstep->step*gRandom->Gaus(0.0002,0.00001);; gstep->gekin -= gstep->destep;; gstep->getot = gstep->gekin + mass;; gstep->vect[6] = charge*TMath::Sqrt(gstep->getot*gstep->getot - mass*mass);; gstep->vect[0] = vout[0];; gstep->vect[1] = vout[1];; gstep->vect[2] = vout[2];; gstep->vect[3] = vout[3];; gstep->vect[4] = vout[4];; gstep->vect[5] = vout[5];; gstep->nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep->nmec;l++) {; gstep->lmec[l] = l;; gstep->namec[l] = l+100;; }; if (gstep->gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep->vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going o",MatchSource.WIKI,doc/master/tree2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2a_8C.html
https://root.cern/doc/master/tree2a_8C.html:3775,Energy Efficiency,energy,energy,3775,"article parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep->lmec = new Int_t[MAXMEC];; gstep->namec = new Int_t[MAXMEC];; gstep->step = 0.1;; gstep->destep = 0;; gstep->nmec = 0;; gstep->pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //apply energy loss; gstep->destep = gstep->step*gRandom->Gaus(0.0002,0.00001);; gstep->gekin -= gstep->destep;; gstep->getot = gstep->gekin + mass;; gstep->vect[6] = charge*TMath::Sqrt(gstep->getot*gstep->getot - mass*mass);; gstep->vect[0] = vout[0];; gstep->vect[1] = vout[1];; gstep->vect[2] = vout[2];; gstep->vect[3] = vout[3];; gstep->vect[4] = vout[4];; gstep->vect[5] = vout[5];; gstep->nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep->nmec;l++) {; gstep->lmec[l] = l;; gstep->namec[l] = l+100;; }; if (gstep->gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep->vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2ar(); {; //read the Tree generated by tree2w and fill one histogram; //we are only interested by the destep branch.; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep the",MatchSource.WIKI,doc/master/tree2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2a_8C.html
https://root.cern/doc/master/tree2a_8C.html:3934,Energy Efficiency,charge,charge,3934,") {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //apply energy loss; gstep->destep = gstep->step*gRandom->Gaus(0.0002,0.00001);; gstep->gekin -= gstep->destep;; gstep->getot = gstep->gekin + mass;; gstep->vect[6] = charge*TMath::Sqrt(gstep->getot*gstep->getot - mass*mass);; gstep->vect[0] = vout[0];; gstep->vect[1] = vout[1];; gstep->vect[2] = vout[2];; gstep->vect[3] = vout[3];; gstep->vect[4] = vout[4];; gstep->vect[5] = vout[5];; gstep->nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep->nmec;l++) {; gstep->lmec[l] = l;; gstep->namec[l] = l+100;; }; if (gstep->gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep->vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2ar(); {; //read the Tree generated by tree2w and fill one histogram; //we are only interested by the destep branch.; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave; //this function.; TFile *f = new TFile(""tree2.root"");; TTree *t2 = (TTree*)f->Get(""t2"");; Gctrak *gstep = nullptr;; t2->SetBranchAddress(""track"",&gstep);; TBranch *b_destep = t2->GetBranch(""destep"");; ; //create one histogram; TH1F *hdestep = new TH1F(""hdestep"",""destep in Mev"",100,1e-5,3e-5);; ; /",MatchSource.WIKI,doc/master/tree2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2a_8C.html
https://root.cern/doc/master/tree2a_8C.html:521,Integrability,rout,routines,521,". ROOT: tutorials/tree/tree2a.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree2a.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is the same as tree2.C, but uses a class instead of a C-struct. ; In this example, we are mapping a class to one of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do to execute with native compiler: .x tree2a.C+ ; Note that since IO is involved, ACLiC has to be invoked to create the dictionary of class Gctrak. ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TMath.h""; #include ""TRandom.h""; #include ""TCanvas.h""; ; const Int_t MAXMEC = 30;; ; class Gctrak : public TObject {; public:; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7]; //! not persistent; Int_t nmec;; Int_t *lmec; //[nmec]; Int_t *namec; //[nmec]; Int_t nstep; //! not persistent; Int_t pid;; Float_t destep;; Float_t destel; //! not persistent; Float_t safety; //! not persistent; Float_t sleng; //! not persistent; Float_t step; //! not persistent; Float_t snext; //! not persistent; Float_t sfield; //! not persistent; Float_t tofg; //! not persistent; Float_t gekrat; //! not persistent; Float_t upwght; //! not persistent; ; Gctrak() {lmec=nullptr; namec=nullptr;}; ; ClassDefOverride(Gctrak,1); };; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = st",MatchSource.WIKI,doc/master/tree2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2a_8C.html
https://root.cern/doc/master/tree2a_8C.html:1193,Safety,safe,safety,1193,"ne of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do to execute with native compiler: .x tree2a.C+ ; Note that since IO is involved, ACLiC has to be invoked to create the dictionary of class Gctrak. ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TMath.h""; #include ""TRandom.h""; #include ""TCanvas.h""; ; const Int_t MAXMEC = 30;; ; class Gctrak : public TObject {; public:; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7]; //! not persistent; Int_t nmec;; Int_t *lmec; //[nmec]; Int_t *namec; //[nmec]; Int_t nstep; //! not persistent; Int_t pid;; Float_t destep;; Float_t destel; //! not persistent; Float_t safety; //! not persistent; Float_t sleng; //! not persistent; Float_t step; //! not persistent; Float_t snext; //! not persistent; Float_t sfield; //! not persistent; Float_t tofg; //! not persistent; Float_t gekrat; //! not persistent; Float_t upwght; //! not persistent; ; Gctrak() {lmec=nullptr; namec=nullptr;}; ; ClassDefOverride(Gctrak,1); };; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*ve",MatchSource.WIKI,doc/master/tree2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2a_8C.html
https://root.cern/doc/master/tree2_8C.html:4635,Availability,alive,alive,4635," ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6] = charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep.nmec;l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2r(); {; //read the Tree generated by tree2w and fill one histogram; //we are only interested by the destep branch.; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave; //this function.; TFile *f = new TFile(""tree2.root"");; TTree *t2 = (TTree*)f->Get(""t2"");; static Float_t destep;; TBranch *b_destep = t2->GetBranch(""destep"");; b_destep->SetAddress(&destep);; ; //create one histogram; TH1F *hdestep = new TH1F(""hdestep"",""destep in Mev"",100,1e-5,3e-5);; ; //read only the destep branch for all entries; Long64_t nentries = t2->GetEntries();; for (Long64_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; hdestep->Fill(destep);; }; ; //we do not close the file.; //We want to keep the generated histograms; //We fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);; c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");; c1->cd(2);; gPad->SetFillColor(37);; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; ; // Allow to use the TTree after the end of the function.; t2->ResetBranchAddresses();;",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:2817,Energy Efficiency,charge,charge,2817,"oat_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ; void tree2w(); {; //create a Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak_t gstep;; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot);; t2.Branch(""gekin"",&gstep.gekin);; t2.Branch(""nmec"",&gstep.nmec);; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep);; t2.Branch(""pid"",&gstep.pid);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.d",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:3206,Energy Efficiency,charge,charge,3206,");; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ; void tree2w(); {; //create a Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak_t gstep;; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot);; t2.Branch(""gekin"",&gstep.gekin);; t2.Branch(""nmec"",&gstep.nmec);; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep);; t2.Branch(""pid"",&gstep.pid);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6] = charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep.nmec;l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParti",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:3245,Energy Efficiency,charge,charge,3245,"; ; void tree2w(); {; //create a Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak_t gstep;; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot);; t2.Branch(""gekin"",&gstep.gekin);; t2.Branch(""nmec"",&gstep.nmec);; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep);; t2.Branch(""pid"",&gstep.pid);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6] = charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep.nmec;l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) n",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:3423,Energy Efficiency,charge,charge,3423,"e t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak_t gstep;; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot);; t2.Branch(""gekin"",&gstep.gekin);; t2.Branch(""nmec"",&gstep.nmec);; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep);; t2.Branch(""pid"",&gstep.pid);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6] = charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep.nmec;l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2r(); {; //read",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:3709,Energy Efficiency,energy,energy,3709,""",&gstep.destep);; t2.Branch(""pid"",&gstep.pid);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6] = charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep.nmec;l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2r(); {; //read the Tree generated by tree2w and fill one histogram; //we are only interested by the destep branch.; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave; //this function.; TFile *f = new TFile(""tre",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:3861,Energy Efficiency,charge,charge,3861," Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6] = charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep.nmec;l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2r(); {; //read the Tree generated by tree2w and fill one histogram; //we are only interested by the destep branch.; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave; //this function.; TFile *f = new TFile(""tree2.root"");; TTree *t2 = (TTree*)f->Get(""t2"");; static Float_t destep;; TBranch *b_destep = t2->GetBranch(""destep"");; b_destep->SetAddress(&destep);; ; //create one histog",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:8330,Energy Efficiency,allocate,allocate,8330,"d SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; c1return c1Definition legend1.C:41; f1TF1 * f1Definition legend1.C:11; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; lTLine lDefinition textangle.C:4; AuthorRene Brun ; Definition in file tree2.C. tutorialstreetree2.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:727,Integrability,rout,routines,727,". ROOT: tutorials/tree/tree2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree2.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example illustrates how to make a Tree from variables or arrays in a C struct - without a dictionary, by creating the branches for builtin types (int, float, double) and arrays explicitly. ; See tree2a.C for the same example using a class with dictionary instead of a C-struct.; In this example, we are mapping a C struct to one of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do: .x tree2.C to execute with the Cling interpreter; .x tree2.C++ to execute with native compiler; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TMath.h""; ; const Int_t MAXMEC = 30;; ; typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:249,Modifiability,variab,variables,249,". ROOT: tutorials/tree/tree2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree2.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example illustrates how to make a Tree from variables or arrays in a C struct - without a dictionary, by creating the branches for builtin types (int, float, double) and arrays explicitly. ; See tree2a.C for the same example using a class with dictionary instead of a C-struct.; In this example, we are mapping a C struct to one of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do: .x tree2.C to execute with the Cling interpreter; .x tree2.C++ to execute with native compiler; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TMath.h""; ; const Int_t MAXMEC = 30;; ; typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree2_8C.html:1222,Safety,safe,safety,1222,"out a dictionary, by creating the branches for builtin types (int, float, double) and arrays explicitly. ; See tree2a.C for the same example using a class with dictionary instead of a C-struct.; In this example, we are mapping a C struct to one of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do: .x tree2.C to execute with the Cling interpreter; .x tree2.C++ to execute with native compiler; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TMath.h""; ; const Int_t MAXMEC = 30;; ; typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ; void tree2w(); {; //create a Tre",MatchSource.WIKI,doc/master/tree2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree2_8C.html
https://root.cern/doc/master/tree3_8C.html:237,Modifiability,variab,variable,237,". ROOT: tutorials/tree/tree3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree3.C File ReferenceTutorials » Tree tutorials. Detailed Description; Example of a Tree where branches are variable length arrays A second Tree is created and filled in parallel. ; Run this script with .x tree3.C; In the function treer, the first Tree is open. The second Tree is declared friend of the first tree. TTree::Draw is called with variables from both Trees. ; #include ""TFile.h""; #include ""TTree.h""; #include ""TRandom.h""; #include ""TCanvas.h""; ; void tree3w() {; ; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;; ; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");; ; TFile fr(""tree3f.root"",""recreate"");; TTree *t3f = new TTree(""t3f"",""a friend Tree"");; t3f->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3f->Branch(""sumstat"",&sumstat,""sumstat/D"");; t3f->Branch(""pt"",pt,""pt[ntrack]/F"");; ; for (Int_t i=0;i<1000;i++) {; Int_t nt = gRandom->Rndm()*(kMaxTrack-1);; ntrack = nt;; sumstat = 0;; for (Int_t n=0;n<nt;n++) {; stat[n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }; ; void tree3r(); {; TFile *f = new TF",MatchSource.WIKI,doc/master/tree3_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree3_8C.html
https://root.cern/doc/master/tree3_8C.html:472,Modifiability,variab,variables,472,". ROOT: tutorials/tree/tree3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree3.C File ReferenceTutorials » Tree tutorials. Detailed Description; Example of a Tree where branches are variable length arrays A second Tree is created and filled in parallel. ; Run this script with .x tree3.C; In the function treer, the first Tree is open. The second Tree is declared friend of the first tree. TTree::Draw is called with variables from both Trees. ; #include ""TFile.h""; #include ""TTree.h""; #include ""TRandom.h""; #include ""TCanvas.h""; ; void tree3w() {; ; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;; ; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");; ; TFile fr(""tree3f.root"",""recreate"");; TTree *t3f = new TTree(""t3f"",""a friend Tree"");; t3f->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3f->Branch(""sumstat"",&sumstat,""sumstat/D"");; t3f->Branch(""pt"",pt,""pt[ntrack]/F"");; ; for (Int_t i=0;i<1000;i++) {; Int_t nt = gRandom->Rndm()*(kMaxTrack-1);; ntrack = nt;; sumstat = 0;; for (Int_t n=0;n<nt;n++) {; stat[n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }; ; void tree3r(); {; TFile *f = new TF",MatchSource.WIKI,doc/master/tree3_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree3_8C.html
https://root.cern/doc/master/tree4_8C.html:3425,Availability,alive,alive,3425,"Random->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; ; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; ; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; ; // Create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; ; // Fill the tree; t4.Fill();; ; // Clear the event before reloading it; event->Clear();; }; ; // Write the file header; f.Write();; ; // Print the tree contents; t4.Print();; }; ; ; void tree4r(); {; // read the tree generated with tree4w; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");; ; // create a pointer to an event object. This will be used; // to read the branch values.; Event *event = new Event();; ; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);; ; Long64_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Long64_t i=0;i<nevent;i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);; ; //reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;; ; //read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;; ; //print the first accepted event; if (nselected == 1) t4->Show();; ; //clear tracks array; event->Clear();; }; ; if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; ; void ",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:2221,Modifiability,variab,variable,2221," the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; ; // Create a pointer to an Event object; Event *event = new Event();; ; // Create two branches, split one.; t4.Branch(""event_split"", &event,16000,99);; t4.Branch(""event_not_split"", &event,16000,0);; ; // a local variable for the event type; char etype[20];; ; // Fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; ; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; ; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; ; // Create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; ; // Fill the tree; t4.Fill();; ; // Clear the event before reloading it; event->Clear();; }; ; // Write the file header; f.Write();; ; // Print the tree contents; t4.Print();; }; ; ; void tree4r(); {; // read the tree g",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:4429,Modifiability,variab,variables,4429," t < ntrack; t++) event->AddTrack(random);; ; // Fill the tree; t4.Fill();; ; // Clear the event before reloading it; event->Clear();; }; ; // Write the file header; f.Write();; ; // Print the tree contents; t4.Print();; }; ; ; void tree4r(); {; // read the tree generated with tree4w; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");; ; // create a pointer to an event object. This will be used; // to read the branch values.; Event *event = new Event();; ; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);; ; Long64_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Long64_t i=0;i<nevent;i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);; ; //reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;; ; //read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;; ; //print the first accepted event; if (nselected == 1) t4->Show();; ; //clear tracks array; event->Clear();; }; ; if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; ; void tree4() {; Event::Reset(); // Allow for re-run this script by cleaning static variables.; tree4w();; Event::Reset(); // Allow for re-run this script by cleaning static variables.; tree4r();; }; f#define f(i)Definition RSha256.hxx:104; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Long64_tlong long Long64_tDefinition RtypesCore.h:69; R__LOAD_LIBRARY#define R__LOAD_LIBRARY(LIBRARY)Definition Rtypes.h:496; TBrowser.h; TClassTable.h; TH2.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TSystem.h; TTree.h; EventDefinition collection_proxies.C:172; TBranchA TTree is a list of TBranches.Definiti",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:4519,Modifiability,variab,variables,4519,"ree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");; ; // create a pointer to an event object. This will be used; // to read the branch values.; Event *event = new Event();; ; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);; ; Long64_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Long64_t i=0;i<nevent;i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);; ; //reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;; ; //read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;; ; //print the first accepted event; if (nselected == 1) t4->Show();; ; //clear tracks array; event->Clear();; }; ; if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; ; void tree4() {; Event::Reset(); // Allow for re-run this script by cleaning static variables.; tree4w();; Event::Reset(); // Allow for re-run this script by cleaning static variables.; tree4r();; }; f#define f(i)Definition RSha256.hxx:104; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Long64_tlong long Long64_tDefinition RtypesCore.h:69; R__LOAD_LIBRARY#define R__LOAD_LIBRARY(LIBRARY)Definition Rtypes.h:496; TBrowser.h; TClassTable.h; TH2.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TSystem.h; TTree.h; EventDefinition collection_proxies.C:172; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; TBranch::SetAddressvirtual void SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TFileA ROOT file is an on-disk file, usually with extension .root, that stores ",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:301,Testability,test,test,301,". ROOT: tutorials/tree/tree4.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree4.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example writes a tree with objects of the class Event. ; It is a simplified version of $ROOTSYS/test/MainEvent.cxx to write the tree, and $ROOTSYS/test/eventb.C It shows:; how to fill a Tree with an event class containing these data members: char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622. the difference in splitting or not splitting a branch; how to read selected branches of the tree, and print the first entry with less than 587 tracks.; how to browse and analyze the Tree via the TBrowser and TTreeViewer. This example can be run in many different ways:; way1 using the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Even",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:352,Testability,test,test,352,". ROOT: tutorials/tree/tree4.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree4.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example writes a tree with objects of the class Event. ; It is a simplified version of $ROOTSYS/test/MainEvent.cxx to write the tree, and $ROOTSYS/test/eventb.C It shows:; how to fill a Tree with an event class containing these data members: char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622. the difference in splitting or not splitting a branch; how to read selected branches of the tree, and print the first entry with less than 587 tracks.; how to browse and analyze the Tree via the TBrowser and TTreeViewer. This example can be run in many different ways:; way1 using the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Even",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:1409,Testability,test,test,1409," containing these data members: char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622. the difference in splitting or not splitting a branch; how to read selected branches of the tree, and print the first entry with less than 587 tracks.; how to browse and analyze the Tree via the TBrowser and TTreeViewer. This example can be run in many different ways:; way1 using the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; ; // Create a pointer to an Event object; Event *event = new Event();; ; // Create two branches, split one.; t4.Branch(""event_split"", &event,16000,99);; t4.Branch(""event_not_split"", &event,16000,0);; ; // a local variable for the event type; char etype[20];; ; // Fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *si",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:1635,Testability,test,test,1635," fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622. the difference in splitting or not splitting a branch; how to read selected branches of the tree, and print the first entry with less than 587 tracks.; how to browse and analyze the Tree via the TBrowser and TTreeViewer. This example can be run in many different ways:; way1 using the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; ; // Create a pointer to an Event object; Event *event = new Event();; ; // Create two branches, split one.; t4.Branch(""event_split"", &event,16000,99);; t4.Branch(""event_not_split"", &event,16000,0);; ; // a local variable for the event type; char etype[20];; ; // Fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNve",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:1840,Testability,test,test,1840," TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622. the difference in splitting or not splitting a branch; how to read selected branches of the tree, and print the first entry with less than 587 tracks.; how to browse and analyze the Tree via the TBrowser and TTreeViewer. This example can be run in many different ways:; way1 using the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; ; // Create a pointer to an Event object; Event *event = new Event();; ; // Create two branches, split one.; t4.Branch(""event_split"", &event,16000,99);; t4.Branch(""event_not_split"", &event,16000,0);; ; // a local variable for the event type; char etype[20];; ; // Fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; ; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; ; // fill the matrix; ",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:270,Usability,simpl,simplified,270,". ROOT: tutorials/tree/tree4.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree4.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example writes a tree with objects of the class Event. ; It is a simplified version of $ROOTSYS/test/MainEvent.cxx to write the tree, and $ROOTSYS/test/eventb.C It shows:; how to fill a Tree with an event class containing these data members: char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622. the difference in splitting or not splitting a branch; how to read selected branches of the tree, and print the first entry with less than 587 tracks.; how to browse and analyze the Tree via the TBrowser and TTreeViewer. This example can be run in many different ways:; way1 using the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Even",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/tree4_8C.html:4231,Usability,clear,clear,4231," t < ntrack; t++) event->AddTrack(random);; ; // Fill the tree; t4.Fill();; ; // Clear the event before reloading it; event->Clear();; }; ; // Write the file header; f.Write();; ; // Print the tree contents; t4.Print();; }; ; ; void tree4r(); {; // read the tree generated with tree4w; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");; ; // create a pointer to an event object. This will be used; // to read the branch values.; Event *event = new Event();; ; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);; ; Long64_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Long64_t i=0;i<nevent;i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);; ; //reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;; ; //read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;; ; //print the first accepted event; if (nselected == 1) t4->Show();; ; //clear tracks array; event->Clear();; }; ; if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; ; void tree4() {; Event::Reset(); // Allow for re-run this script by cleaning static variables.; tree4w();; Event::Reset(); // Allow for re-run this script by cleaning static variables.; tree4r();; }; f#define f(i)Definition RSha256.hxx:104; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Long64_tlong long Long64_tDefinition RtypesCore.h:69; R__LOAD_LIBRARY#define R__LOAD_LIBRARY(LIBRARY)Definition Rtypes.h:496; TBrowser.h; TClassTable.h; TH2.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TSystem.h; TTree.h; EventDefinition collection_proxies.C:172; TBranchA TTree is a list of TBranches.Definiti",MatchSource.WIKI,doc/master/tree4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree4_8C.html
https://root.cern/doc/master/treefriend_8C.html:385,Modifiability,variab,variable,385,". ROOT: tutorials/tree/treefriend.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treefriend.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to use Tree friends: . create a simple TTree; Copy a subset of this TTree to a new TTree; Create a Tree Index; Make a friend TTree; compare two TTrees; Draw a variable from the first tree versus a variable in the friend Tree. You can run this tutorial with: root > .x treefriend.C (interpreted via Cling); root > .x treefriend.C+ (executed via ACLIC & the native compiler); or, variants like: root > .L treefriend.C+; root > CreateParentTree();; root > CreateFriendTree();; root > CompareTrees();; root > DrawFriend();; ; ******************************************************************************; *Tree :T : test friend trees *; *Entries : 10000 : Total = 203762 bytes File Size = 94821 *; * : : Tree compression factor = 1.69 *; ******************************************************************************; *Br 0 :Run : Run/I *; *Entries : 10000 : Total Size= 40698 bytes File Size = 265 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 120.75 *; *............................................................................*; *Br 1 :Event : Event/I *; *Entries : 10000 : Total Size= 40712 bytes File Size = 11231 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 2.85 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27116 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27035 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 10000 : Total Size= 40684 b",MatchSource.WIKI,doc/master/treefriend_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treefriend_8C.html
https://root.cern/doc/master/treefriend_8C.html:423,Modifiability,variab,variable,423,". ROOT: tutorials/tree/treefriend.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treefriend.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to use Tree friends: . create a simple TTree; Copy a subset of this TTree to a new TTree; Create a Tree Index; Make a friend TTree; compare two TTrees; Draw a variable from the first tree versus a variable in the friend Tree. You can run this tutorial with: root > .x treefriend.C (interpreted via Cling); root > .x treefriend.C+ (executed via ACLIC & the native compiler); or, variants like: root > .L treefriend.C+; root > CreateParentTree();; root > CreateFriendTree();; root > CompareTrees();; root > DrawFriend();; ; ******************************************************************************; *Tree :T : test friend trees *; *Entries : 10000 : Total = 203762 bytes File Size = 94821 *; * : : Tree compression factor = 1.69 *; ******************************************************************************; *Br 0 :Run : Run/I *; *Entries : 10000 : Total Size= 40698 bytes File Size = 265 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 120.75 *; *............................................................................*; *Br 1 :Event : Event/I *; *Entries : 10000 : Total Size= 40712 bytes File Size = 11231 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 2.85 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27116 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27035 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 10000 : Total Size= 40684 b",MatchSource.WIKI,doc/master/treefriend_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treefriend_8C.html
https://root.cern/doc/master/treefriend_8C.html:6152,Modifiability,variab,variable,6152,"""T"");; TFile *ff = new TFile(""treefriend.root"",""recreate"");; TTree *TF = T->CopyTree(""z<10"");; TF->SetName(""TF"");; TF->BuildIndex(""Run"",""Event"");; TF->Write();; TF->Print();; delete ff;; }; ; void CompareTrees() {; // The two TTrees created above are compared.; // The subset of entries in the small TTree must be identical; // to the entries in the original TTree.; ; TFile *f = new TFile(""treeparent.root"");; TTree *T = (TTree*)f->Get(""T"");; TFile *ff = new TFile(""treefriend.root"");; TTree *TF = (TTree*)ff->Get(""TF"");; Int_t fRun,fEvent;; Float_t fx,fy,fz;; T->SetBranchAddress(""Run"",&Run);; T->SetBranchAddress(""Event"",&Event);; T->SetBranchAddress(""x"",&x);; T->SetBranchAddress(""y"",&y);; T->SetBranchAddress(""z"",&z);; TF->SetBranchAddress(""Run"",&fRun);; TF->SetBranchAddress(""Event"",&fEvent);; TF->SetBranchAddress(""x"",&fx);; TF->SetBranchAddress(""y"",&fy);; TF->SetBranchAddress(""z"",&fz);; T->AddFriend(TF);; ; Long64_t nentries = T->GetEntries();; Int_t nok = 0;; for (Long64_t i=0;i<nentries;i++) {; T->GetEntry(i);; if (fRun == Run && fEvent==Event && x==fx && y==fy &&z==fz) {; nok++;; } else {; if (TF->GetEntryWithIndex(Run,Event) > 0) {; if (i <100) printf(""i=%lld, Run=%d, Event=%d, x=%g, y=%g, z=%g, : fRun=%d, fEvent=%d, fx=%g, fy=%g, fz=%g\n"",i,Run,Event,x,y,z,fRun,fEvent,fx,fy,fz);; }; }; }; printf(""nok = %d, fentries=%lld\n"",nok,TF->GetEntries());; ; delete f;; delete ff;; }; ; void DrawFriend() {; // Draw a scatter plot of variable x in the parent TTree versus; // the same variable in the subtree.; // This should produce points along a straight line.; ; TFile *f = TFile::Open(""treeparent.root"");; TTree *T = (TTree*)f->Get(""T"");; T->AddFriend(""TF"",""treefriend.root"");; T->Draw(""x:TF.x"");; }; ; void treefriend() {; CreateParentTree();; CreateFriendTree();; CompareTrees();; DrawFriend();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:",MatchSource.WIKI,doc/master/treefriend_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treefriend_8C.html
https://root.cern/doc/master/treefriend_8C.html:6203,Modifiability,variab,variable,6203,"""T"");; TFile *ff = new TFile(""treefriend.root"",""recreate"");; TTree *TF = T->CopyTree(""z<10"");; TF->SetName(""TF"");; TF->BuildIndex(""Run"",""Event"");; TF->Write();; TF->Print();; delete ff;; }; ; void CompareTrees() {; // The two TTrees created above are compared.; // The subset of entries in the small TTree must be identical; // to the entries in the original TTree.; ; TFile *f = new TFile(""treeparent.root"");; TTree *T = (TTree*)f->Get(""T"");; TFile *ff = new TFile(""treefriend.root"");; TTree *TF = (TTree*)ff->Get(""TF"");; Int_t fRun,fEvent;; Float_t fx,fy,fz;; T->SetBranchAddress(""Run"",&Run);; T->SetBranchAddress(""Event"",&Event);; T->SetBranchAddress(""x"",&x);; T->SetBranchAddress(""y"",&y);; T->SetBranchAddress(""z"",&z);; TF->SetBranchAddress(""Run"",&fRun);; TF->SetBranchAddress(""Event"",&fEvent);; TF->SetBranchAddress(""x"",&fx);; TF->SetBranchAddress(""y"",&fy);; TF->SetBranchAddress(""z"",&fz);; T->AddFriend(TF);; ; Long64_t nentries = T->GetEntries();; Int_t nok = 0;; for (Long64_t i=0;i<nentries;i++) {; T->GetEntry(i);; if (fRun == Run && fEvent==Event && x==fx && y==fy &&z==fz) {; nok++;; } else {; if (TF->GetEntryWithIndex(Run,Event) > 0) {; if (i <100) printf(""i=%lld, Run=%d, Event=%d, x=%g, y=%g, z=%g, : fRun=%d, fEvent=%d, fx=%g, fy=%g, fz=%g\n"",i,Run,Event,x,y,z,fRun,fEvent,fx,fy,fz);; }; }; }; printf(""nok = %d, fentries=%lld\n"",nok,TF->GetEntries());; ; delete f;; delete ff;; }; ; void DrawFriend() {; // Draw a scatter plot of variable x in the parent TTree versus; // the same variable in the subtree.; // This should produce points along a straight line.; ; TFile *f = TFile::Open(""treeparent.root"");; TTree *T = (TTree*)f->Get(""T"");; T->AddFriend(""TF"",""treefriend.root"");; T->Draw(""x:TF.x"");; }; ; void treefriend() {; CreateParentTree();; CreateFriendTree();; CompareTrees();; DrawFriend();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:",MatchSource.WIKI,doc/master/treefriend_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treefriend_8C.html
https://root.cern/doc/master/treefriend_8C.html:839,Testability,test,test,839,". ROOT: tutorials/tree/treefriend.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treefriend.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to use Tree friends: . create a simple TTree; Copy a subset of this TTree to a new TTree; Create a Tree Index; Make a friend TTree; compare two TTrees; Draw a variable from the first tree versus a variable in the friend Tree. You can run this tutorial with: root > .x treefriend.C (interpreted via Cling); root > .x treefriend.C+ (executed via ACLIC & the native compiler); or, variants like: root > .L treefriend.C+; root > CreateParentTree();; root > CreateFriendTree();; root > CompareTrees();; root > DrawFriend();; ; ******************************************************************************; *Tree :T : test friend trees *; *Entries : 10000 : Total = 203762 bytes File Size = 94821 *; * : : Tree compression factor = 1.69 *; ******************************************************************************; *Br 0 :Run : Run/I *; *Entries : 10000 : Total Size= 40698 bytes File Size = 265 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 120.75 *; *............................................................................*; *Br 1 :Event : Event/I *; *Entries : 10000 : Total Size= 40712 bytes File Size = 11231 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 2.85 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27116 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27035 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 10000 : Total Size= 40684 b",MatchSource.WIKI,doc/master/treefriend_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treefriend_8C.html
https://root.cern/doc/master/treefriend_8C.html:2260,Testability,test,test,2260,r 1 :Event : Event/I *; *Entries : 10000 : Total Size= 40712 bytes File Size = 11231 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 2.85 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27116 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27035 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 29174 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.10 *; *............................................................................*; ******************************************************************************; *Tree :TF : test friend trees *; *Entries : 8460 : Total = 375780 bytes File Size = 128536 *; * : : Tree compression factor = 1.69 *; ******************************************************************************; *Br 0 :Run : Run/I *; *Entries : 8460 : Total Size= 34463 bytes File Size = 374 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 90.84 *; *............................................................................*; *Br 1 :Event : Event/I *; *Entries : 8460 : Total Size= 34475 bytes File Size = 12152 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 2.80 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 28849 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 28757 *; *Baskets : 2 : Basket Size= 32000 bytes Compression,MatchSource.WIKI,doc/master/treefriend_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treefriend_8C.html
https://root.cern/doc/master/treefriend_8C.html:3973,Testability,test,test,3973,"...................................................*; *Br 3 :y : y/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 28757 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 30674 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.11 *; *............................................................................*; nok = 8460, fentries=8460; . ; ; #include ""TTree.h""; #include ""TFile.h""; #include ""TRandom.h""; #include ""TTree.h""; #include ""TTree.h""; ; Int_t Run, Event;; Float_t x,y,z;; ; void CreateParentTree() {; // create a simple TTree with 5 branches; // Two branches (""Run"" and ""Event"") will be used to index the Tree; TFile *f = new TFile(""treeparent.root"",""recreate"");; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&Run,""Run/I"");; T->Branch(""Event"",&Event,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) Run = 1;; else Run = 2;; Event = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; T->Print();; T->Write();; delete f;; }; void CreateFriendTree() {; // Open the file created by CreateParentTree; // Copy a subset of the TTree into a new TTree; // (see also tutorials copytree.C, copytree2.C and copytree3.C); // Create an index on the new TTree (""Run"",""Event""); // Write the new TTree (including its index); ; TFile *f = new TFile(""treeparent.root"");; TTree *T = (TTree*)f->Get(""T"");; TFile *ff = new TFile(""treefriend.root"",""recreate"");; TTree *TF = T->CopyTree(""z<10"");; TF->SetName(""TF"");; TF->BuildIndex(""Run"",""Event"");; TF->Write();; TF->Print();; delete ff;; }; ; void CompareTrees() {; // The two TTrees created above are compared.; // The subset of entries in the small TTree must be identical; // to the entries in the original TTree.; ; TFile *f = ",MatchSource.WIKI,doc/master/treefriend_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treefriend_8C.html
https://root.cern/doc/master/treefriend_8C.html:258,Usability,simpl,simple,258,". ROOT: tutorials/tree/treefriend.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treefriend.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to use Tree friends: . create a simple TTree; Copy a subset of this TTree to a new TTree; Create a Tree Index; Make a friend TTree; compare two TTrees; Draw a variable from the first tree versus a variable in the friend Tree. You can run this tutorial with: root > .x treefriend.C (interpreted via Cling); root > .x treefriend.C+ (executed via ACLIC & the native compiler); or, variants like: root > .L treefriend.C+; root > CreateParentTree();; root > CreateFriendTree();; root > CompareTrees();; root > DrawFriend();; ; ******************************************************************************; *Tree :T : test friend trees *; *Entries : 10000 : Total = 203762 bytes File Size = 94821 *; * : : Tree compression factor = 1.69 *; ******************************************************************************; *Br 0 :Run : Run/I *; *Entries : 10000 : Total Size= 40698 bytes File Size = 265 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 120.75 *; *............................................................................*; *Br 1 :Event : Event/I *; *Entries : 10000 : Total Size= 40712 bytes File Size = 11231 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 2.85 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27116 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27035 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 10000 : Total Size= 40684 b",MatchSource.WIKI,doc/master/treefriend_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treefriend_8C.html
https://root.cern/doc/master/treefriend_8C.html:3796,Usability,simpl,simple,3796,"ression= 2.80 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 28849 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 28757 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 30674 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.11 *; *............................................................................*; nok = 8460, fentries=8460; . ; ; #include ""TTree.h""; #include ""TFile.h""; #include ""TRandom.h""; #include ""TTree.h""; #include ""TTree.h""; ; Int_t Run, Event;; Float_t x,y,z;; ; void CreateParentTree() {; // create a simple TTree with 5 branches; // Two branches (""Run"" and ""Event"") will be used to index the Tree; TFile *f = new TFile(""treeparent.root"",""recreate"");; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&Run,""Run/I"");; T->Branch(""Event"",&Event,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) Run = 1;; else Run = 2;; Event = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; T->Print();; T->Write();; delete f;; }; void CreateFriendTree() {; // Open the file created by CreateParentTree; // Copy a subset of the TTree into a new TTree; // (see also tutorials copytree.C, copytree2.C and copytree3.C); // Create an index on the new TTree (""Run"",""Event""); // Write the new TTree (including its index); ; TFile *f = new TFile(""treeparent.root"");; TTree *T = (TTree*)f->Get(""T"");; TFile *ff = new TFile(""treefriend.root"",""recreate"");; TTree *TF = T->CopyTree(""z<10"");; TF->SetName(""TF"");; T",MatchSource.WIKI,doc/master/treefriend_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treefriend_8C.html
https://root.cern/doc/master/treegetval_8C.html:244,Modifiability,variab,variables,244,". ROOT: tutorials/tree/treegetval.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treegetval.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to retrieve TTree variables in arrays. ; This example:; creates a simple TTree,; generates TTree variables thanks to the Draw method with goff option,; retrieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = ne",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/treegetval_8C.html:323,Modifiability,variab,variables,323,". ROOT: tutorials/tree/treegetval.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treegetval.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to retrieve TTree variables in arrays. ; This example:; creates a simple TTree,; generates TTree variables thanks to the Draw method with goff option,; retrieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = ne",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/treegetval_8C.html:654,Modifiability,variab,variables,654,". ROOT: tutorials/tree/treegetval.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treegetval.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to retrieve TTree variables in arrays. ; This example:; creates a simple TTree,; generates TTree variables thanks to the Draw method with goff option,; retrieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = ne",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/treegetval_8C.html:745,Modifiability,variab,variables,745,". ROOT: tutorials/tree/treegetval.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treegetval.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to retrieve TTree variables in arrays. ; This example:; creates a simple TTree,; generates TTree variables thanks to the Draw method with goff option,; retrieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = ne",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/treegetval_8C.html:799,Modifiability,variab,variables,799,". ROOT: tutorials/tree/treegetval.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treegetval.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to retrieve TTree variables in arrays. ; This example:; creates a simple TTree,; generates TTree variables thanks to the Draw method with goff option,; retrieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = ne",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/treegetval_8C.html:1706,Modifiability,variab,variables,1706,"al with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = new TGraph(n,vx,vxs);; TGraph *gc = new TGraph(n,vx,vxc);; gs->Draw(""ap"");; gc->Draw(""p"");; }; ; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gcOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void gcDefinition TGWin32VirtualXProxy.cxx:130; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/treegetval_8C.html:1844,Modifiability,variab,variables,1844,"al with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = new TGraph(n,vx,vxs);; TGraph *gc = new TGraph(n,vx,vxc);; gs->Draw(""ap"");; gc->Draw(""p"");; }; ; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gcOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void gcDefinition TGWin32VirtualXProxy.cxx:130; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/treegetval_8C.html:1327,Testability,test,test,1327,"rieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = new TGraph(n,vx,vxs);; TGraph *gc = new TGraph(n,vx,vxc);; gs->Draw(""ap"");; gc->Draw(""p"");; }; ; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor Get",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/treegetval_8C.html:292,Usability,simpl,simple,292,". ROOT: tutorials/tree/treegetval.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treegetval.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to retrieve TTree variables in arrays. ; This example:; creates a simple TTree,; generates TTree variables thanks to the Draw method with goff option,; retrieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = ne",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/treegetval_8C.html:1238,Usability,simpl,simple,1238,"rieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = new TGraph(n,vx,vxs);; TGraph *gc = new TGraph(n,vx,vxc);; gs->Draw(""ap"");; gc->Draw(""p"");; }; ; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor Get",MatchSource.WIKI,doc/master/treegetval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/treegetval_8C.html
https://root.cern/doc/master/tree_2jets_8C.html:2191,Performance,load,loads,2191,"; T->Print();; T->Write();; }; ; void read() {; //read the JetEvent file; TFile f(""JetEvent.root"");; TTree *T = (TTree*)f.Get(""T"");; JetEvent *event = 0;; T->SetBranchAddress(""event"", &event);; Long64_t nentries = T->GetEntries();; ; for (Long64_t ev=0;ev<nentries;ev++) {; T->GetEntry(ev);; if (ev) continue; //dump first event only; cout << "" Event: ""<< ev; << "" Jets: "" << event->GetNjet(); << "" Tracks: "" << event->GetNtrack(); << "" Hits A: "" << event->GetNhitA(); << "" Hits B: "" << event->GetNhitB() << endl;; }; }; ; void pileup(Int_t nev=200) {; //make nev pileup events, each build with LOOPMAX events selected; //randomly among the nentries; TFile f(""JetEvent.root"");; TTree *T = (TTree*)f.Get(""T"");; // Long64_t nentries = T->GetEntries();; ; const Int_t LOOPMAX=10;; JetEvent *events[LOOPMAX];; Int_t loop;; for (loop=0;loop<LOOPMAX;loop++) events[loop] = 0;; for (Long64_t ev=0;ev<nev;ev++) {; if (ev%10 == 0) printf(""building pileup: %lld\n"",ev);; for (loop=0;loop<LOOPMAX;loop++) {; Int_t rev = gRandom->Uniform(LOOPMAX);; T->SetBranchAddress(""event"", &events[loop]);; T->GetEntry(rev);; }; }; }; ; void jets(Int_t nev=100, Int_t npileup=200, Bool_t secondrun = true) {; // Embedding these loads inside the first run of the script is not yet; // supported in v6; // gROOT->ProcessLine("".L $ROOTSYS/tutorials/tree/JetEvent.cxx+"");; write(nev);; read();; pileup(npileup);; }; ; #else; ; //void jets(Int_t nev=100, Int_t npileup=200, Bool_t secondrun);; void jets(Int_t nev=100, Int_t npileup=200) {; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".L "" + tutdir + ""/tree/JetEvent.cxx+"");; gROOT->ProcessLine(""#define JETS_SECOND_RUN yes"");; gROOT->ProcessLine(""#include \"""" __FILE__ ""\"""");; gROOT->ProcessLine(""jets(100,200,true)"");; }; ; #endif; JetEvent.h; f#define f(i)Definition RSha256.hxx:104; Riostream.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TFile.h; nentriesin",MatchSource.WIKI,doc/master/tree_2jets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree_2jets_8C.html
https://root.cern/doc/master/tree_2parallelcoordtrans_8C.html:5767,Modifiability,variab,variables,5767,"rtualGLProxy.cxx:39; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TNtuple.h; TParallelCoordRange.h; TParallelCoordVar.h; TParallelCoord.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::SetAlphavirtual void SetAlpha(Float_t a)Definition TColor.h:70; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TParallelCoordVarTParallelCoord axes.Definition TParallelCoordVar.h:24; TParallelCoordVar::SetHistogramHeightvoid SetHistogramHeight(Double_t h=0)Set the height of the bar histogram.Definition TParallelCoordVar.cxx:892; TParallelCoordVar::Drawvoid Draw(Option_t *option="""") overrideDraw the axis.Definition TParallelCoordVar.cxx:150; TParallelCoordParallel Coordinates class.Definition TParallelCoord.h:28; TParallelCoord::SetLineColorvoid SetLineColor(Color_t col)Definition TParallelCoord.h:127; TParallelCoord::GetVarListTList * GetVarList()Definition TParallelCoord.h:102; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDef",MatchSource.WIKI,doc/master/tree_2parallelcoordtrans_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree_2parallelcoordtrans_8C.html
https://root.cern/doc/master/tree_2parallelcoordtrans_8C.html:5724,Usability,simpl,simple,5724,"rtualGLProxy.cxx:39; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TNtuple.h; TParallelCoordRange.h; TParallelCoordVar.h; TParallelCoord.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::SetAlphavirtual void SetAlpha(Float_t a)Definition TColor.h:70; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TParallelCoordVarTParallelCoord axes.Definition TParallelCoordVar.h:24; TParallelCoordVar::SetHistogramHeightvoid SetHistogramHeight(Double_t h=0)Set the height of the bar histogram.Definition TParallelCoordVar.cxx:892; TParallelCoordVar::Drawvoid Draw(Option_t *option="""") overrideDraw the axis.Definition TParallelCoordVar.cxx:150; TParallelCoordParallel Coordinates class.Definition TParallelCoord.h:28; TParallelCoord::SetLineColorvoid SetLineColor(Color_t col)Definition TParallelCoord.h:127; TParallelCoord::GetVarListTList * GetVarList()Definition TParallelCoord.h:102; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDef",MatchSource.WIKI,doc/master/tree_2parallelcoordtrans_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree_2parallelcoordtrans_8C.html
https://root.cern/doc/master/tree_8C.html:3246,Modifiability,variab,variable,3246,"leafcolor);; leaf0->Draw();; TPaveLabel* leaf1 = new TPaveLabel(.6,.78,.7,.83,""Leaf 1"");; leaf1->SetFillColor(leafcolor);; leaf1->Draw();; TPaveLabel* leaf2 = new TPaveLabel(.8,.78,.9,.83,""Leaf 2"");; leaf2->SetFillColor(leafcolor);; leaf2->Draw();; TPaveText* firstevent = new TPaveText(.4,.35,.9,.4);; firstevent->AddText(""First event of each basket"");; firstevent->AddText(""Array of fMaxBaskets Integers"");; firstevent->SetFillColor(basketcolor);; firstevent->Draw();; TPaveLabel* basket0 = new TPaveLabel(.4,.25,.5,.3,""Basket 0"");; basket0->SetFillColor(basketcolor);; basket0->Draw();; TPaveLabel* basket1 = new TPaveLabel(.6,.25,.7,.3,""Basket 1"");; basket1->SetFillColor(basketcolor);; basket1->Draw();; TPaveLabel* basket2 = new TPaveLabel(.8,.25,.9,.3,""Basket 2"");; basket2->SetFillColor(basketcolor);; basket2->Draw();; ; TPaveText* offset = new TPaveText(.55,.15,.9,.2);; offset->AddText(""Offset of events in fBuffer"");; offset->AddText(""Array of fEventOffsetLen Integers"");; offset->AddText(""(if variable length structure)"");; offset->SetFillColor(offsetcolor);; offset->Draw();; TPaveText* buffer = new TPaveText(.55,.05,.9,.1);; buffer->AddText(""Basket buffer"");; buffer->AddText(""Array of fBasketSize chars"");; buffer->SetFillColor(offsetcolor);; buffer->Draw();; TPaveText* zipbuffer = new TPaveText(.55,-.05,.75,.0);; zipbuffer->AddText(""Basket compressed buffer"");; zipbuffer->AddText(""(if compression)"");; zipbuffer->SetFillColor(offsetcolor);; zipbuffer->Draw();; TArrow ar1;; ar1.SetLineWidth(2);; ar1.SetLineColor(1);; ar1.SetFillStyle(1001);; ar1.SetFillColor(1);; ar1.DrawArrow(.21,.275,.39,.275,0.015,""|>"");; ar1.DrawArrow(.23,.375,.39,.375,0.015,""|>"");; ar1.DrawArrow(.25,.805,.39,.805,0.015,""|>"");; ar1.DrawArrow(.50,.805,.59,.805,0.015,""|>"");; ar1.DrawArrow(.70,.805,.79,.805,0.015,""|>"");; ar1.DrawArrow(.50,.275,.59,.275,0.015,""|>"");; ar1.DrawArrow(.70,.275,.79,.275,0.015,""|>"");; ar1.DrawArrow(.45,.175,.54,.175,0.015,""|>"");; ar1.DrawArrow(.43,.075,.54,.075,0.015,""|>"");; a",MatchSource.WIKI,doc/master/tree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree_8C.html
https://root.cern/doc/master/tree_8C.html:11593,Usability,simpl,simple,11593,"yle.Definition TAttFill.h:39; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::AddLinevirtual TLine * AddLine(Double_t x1=0, Double_t y1=0, Double_t x2=0, Double_t y2=0)Add a new graphics line to this pavetext.Definition TPaveText.cxx:177; TPaveText::Drawvoi",MatchSource.WIKI,doc/master/tree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tree_8C.html
https://root.cern/doc/master/TRFunctionImport____oprtr_8h_source.html:338,Integrability,interface,interface,338,". ROOT: bindings/r/inc/TRFunctionImport__oprtr.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TRFunctionImport__oprtr.h. Go to the documentation of this file. 1// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; tab-width: 8 -*-; 2//; 3// TRFunctionImport__oprt.h: based in Rcpp R/C++ interface class library -- generated helper code for Function.h; 4//; 5// Copyright (C) 2010 - 2013 Dirk Eddelbuettel and Romain Francois; 6// Modified by Omar Zapata for ROOTR; 7//; 8// This file is based in Rcpp.; 9 ; 10#ifndef ROOT_R_TRFunctionImport_oprtr; 11#define ROOT_R_TRFunctionImport_oprtr; 12 ; 13template <typename T1>; 14TRObject operator()(const T1 &t1) const; 15{; 16 return (*f)(t1) ;; 17}; 18 ; 19template <typename T1, typename T2>; 20TRObject operator()(const T1 &t1, const T2 &t2) const; 21{; 22 return (*f)(t1, t2) ;; 23}; 24 ; 25template <typename T1, typename T2, typename T3>; 26TRObject operator()(const T1 &t1, const T2 &t2, const T3 &t3) const; 27{; 28 return (*f)(t1, t2, t3) ;; 29}; 30 ; 31template <typename T1, typename T2, typename T3, typename T4>; 32TRObject operator()(const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4) const; 33{; 34 return (*f)(t1, t2, t3, t4) ;; 35}; 36 ; 37template <typename T1, typename T2, typename T3, typename T4, typename T5>; 38TRObject operator()(const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4, const T5 &t5) const; 39{; 40 return (*f)(t1, t2, t3, t4, t5) ;; 41}; 42 ; 43template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>; 44TRObject operator()(const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4, const T5 &t5, const T6 &t6) const; 45{; 46 return (*f)(t1, t2, t3, t4, t5, t6) ;; 47}; 48 ; 49template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>; 50TRObject operator()(const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4, const T5 &t5, const T6 &t6, const T7 &t7) const; 51{; 52 return (*f)(t1, ",MatchSource.WIKI,doc/master/TRFunctionImport____oprtr_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRFunctionImport____oprtr_8h_source.html
https://root.cern/doc/master/triangles_8C.html:424,Integrability,message,message,424,". ROOT: tutorials/graphics/triangles.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. triangles.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Create small triangles at random positions on the canvas. ; Assign a unique ID to each triangle, and give each one a random color from the color palette.; root > .x triangles.C; When a triangle is clicked, a message displaying its unique number and color will be printed. ; void triangles(int ntriangles=50); {; auto c1 = new TCanvas(""c1"",""triangles"",10,10,700,700);; gStyle->SetPalette(kCMYK);; TRandom r;; double dx = 0.2; double dy = 0.2;; int ncolors = TColor::GetNumberOfColors();; double x[4],y[4];; for (int i=0;i<ntriangles;i++) {; x[0] = r.Uniform(.05,.95); y[0] = r.Uniform(.05,.95);; x[1] = x[0] + dx*r.Rndm(); y[1] = y[0] + dy*r.Rndm();; x[2] = x[1] - dx*r.Rndm(); y[2] = y[1] - dy*r.Rndm();; x[3] = x[0]; y[3] = y[0];; auto pl = new TPolyLine(4,x,y);; pl->SetUniqueID(i);; int ci = ncolors*r.Rndm();; TColor *c = gROOT->GetColor(TColor::GetColorPalette(ci));; c->SetAlpha(r.Rndm());; pl->SetFillColor(c->GetNumber());; pl->Draw(""f"");; }; c1->AddExec(""ex"",""TriangleClicked()"");; }; ; void TriangleClicked(); {; //this action function is called whenever you move the mouse; //it just prints the id of the picked triangle; //you can add graphics actions instead; int event = gPad->GetEvent();; if (event != 11) return; //may be comment this line; TObject *select = gPad->GetSelected();; if (!select) return;; if (select->InheritsFrom(TPolyLine::Class())) {; TPolyLine *pl = (TPolyLine*)select;; printf(""You have clicked triangle %d, color=%d\n"",; pl->GetUniqueID(),pl->GetFillColor());; }; }; c#define c(i)Definition RSha256.hxx:101; kCMYK@ kCMYKDefinition TColor.h:123; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Fl",MatchSource.WIKI,doc/master/triangles_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/triangles_8C.html
https://root.cern/doc/master/triangles_8C.html:3180,Modifiability,inherit,inherits,3180,"arkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gROOT#define gROOTDefinition TROOT.h:406; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TAttFill::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TCanvasThe Canvas class.Definition TCanvas.h:23; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetColorPalettestatic Int_t GetColorPalette(Int_t i)Static function returning the color number i in current palette.Definition TColor.cxx:1504; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetNumberOfColorsstatic Int_t GetNumberOfColors()Static function returning number of colors in the color palette.Definition TColor.cxx:1524; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TPolyLineDefined by an array on N points in a 2-D space.Definition TPolyLine.h:23; TPolyLine::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; AuthorRene Brun ; Definition in file triangles.C. tutorialsgraphicstriangles.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/triangles_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/triangles_8C.html
https://root.cern/doc/master/TRint_8cxx_source.html:4446,Availability,down,down,4446,"Reset();; 106#ifndef WIN32; 107 if (gException); 108 Throw(GetSignal());; 109#endif; 110 } else {; 111 // Reset input.; 112 Getlinem(kClear, ((TRint*)gApplication)->GetPrompt());; 113 }; 114 ; 115 return kTRUE;; 116}; 117 ; 118//----- Terminal Input file handler --------------------------------------------; 119////////////////////////////////////////////////////////////////////////////////; 120 ; 121class TTermInputHandler : public TFileHandler {; 122public:; 123 TTermInputHandler(Int_t fd) : TFileHandler(fd, 1) { }; 124 Bool_t Notify() override;; 125 Bool_t ReadNotify() override { return Notify(); }; 126};; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// Notify implementation. Call the application interupt handler.; 130 ; 131Bool_t TTermInputHandler::Notify(); 132{; 133 return gApplication->HandleTermInput();; 134}; 135 ; 136 ; 137ClassImp(TRint);; 138 ; 139 ; 140namespace {; 141static int SetExtraClingArgsBeforeTAppCtor(Int_t *argc, char **argv); 142{; 143 bool forcePtrCheck = false;; 144 if (argc != nullptr) {; 145 for (int iarg = 1; iarg < *argc; ++iarg) {; 146 if (!strcmp(argv[iarg], ""--ptrcheck"")) {; 147 // Hide this, by moving all other args one down...; 148 for (int jarg = iarg + 1; jarg < *argc; ++jarg); 149 argv[jarg - 1] = argv[jarg];; 150 // ... and updating argc accordingly.; 151 --*argc;; 152 forcePtrCheck = true;; 153 break;; 154 }; 155 }; 156 }; 157#ifdef R__UNIX; 158 if (forcePtrCheck || isatty(0) || isatty(1)); 159#endif; 160 TROOT::AddExtraInterpreterArgs({""--ptrcheck""});; 161 return 0;; 162}; 163}; 164 ; 165////////////////////////////////////////////////////////////////////////////////; 166/// Create an application environment. The TRint environment provides an; 167/// interface to the WM manager functionality and eventloop via inheritance; 168/// of TApplication and in addition provides interactive access to; 169/// the Cling C++ interpreter via the command line.; 170 ; 171TRint::TRint(const char",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:13369,Availability,error,error,13369,"rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void TRint::Run(Bool_t retrn); 385{; 386 if (!QuitOpt()) {; 387 // Prompt prompt only if we are expecting / allowing input.; 388 Getlinem(kInit, GetPrompt());; 389 }; 390 ; 391 Longptr_t retval = 0;; 392 Int_t error = 0;; 393 volatile Bool_t needGetlinemInit = kFALSE;; 394 ; 395 if (strlen(WorkingDirectory())) {; 396 // if directory specified as argument make it the working directory; 397 gSystem->ChangeDirectory(WorkingDirectory());; 398 TSystemDirectory *workdir = new TSystemDirectory(""workdir"", gSystem->WorkingDirectory());; 399 TObject *w = gROOT->GetListOfBrowsables()->FindObject(""workdir"");; 400 TObjLink *lnk = gROOT->GetListOfBrowsables()->FirstLink();; 401 while (lnk) {; 402 if (lnk->GetObject() == w) {; 403 lnk->SetObject(workdir);; 404 lnk->SetOption(gSystem->WorkingDirectory());; 405 break;; 406 }; 407 lnk = lnk->Next();; 408 }; 409 delete w;; 410 }; 411 ; ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:13412,Availability,error,error,13412,"rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void TRint::Run(Bool_t retrn); 385{; 386 if (!QuitOpt()) {; 387 // Prompt prompt only if we are expecting / allowing input.; 388 Getlinem(kInit, GetPrompt());; 389 }; 390 ; 391 Longptr_t retval = 0;; 392 Int_t error = 0;; 393 volatile Bool_t needGetlinemInit = kFALSE;; 394 ; 395 if (strlen(WorkingDirectory())) {; 396 // if directory specified as argument make it the working directory; 397 gSystem->ChangeDirectory(WorkingDirectory());; 398 TSystemDirectory *workdir = new TSystemDirectory(""workdir"", gSystem->WorkingDirectory());; 399 TObject *w = gROOT->GetListOfBrowsables()->FindObject(""workdir"");; 400 TObjLink *lnk = gROOT->GetListOfBrowsables()->FirstLink();; 401 while (lnk) {; 402 if (lnk->GetObject() == w) {; 403 lnk->SetObject(workdir);; 404 lnk->SetOption(gSystem->WorkingDirectory());; 405 break;; 406 }; 407 lnk = lnk->Next();; 408 }; 409 delete w;; 410 }; 411 ; ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:13708,Availability,error,error,13708,"ation event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void TRint::Run(Bool_t retrn); 385{; 386 if (!QuitOpt()) {; 387 // Prompt prompt only if we are expecting / allowing input.; 388 Getlinem(kInit, GetPrompt());; 389 }; 390 ; 391 Longptr_t retval = 0;; 392 Int_t error = 0;; 393 volatile Bool_t needGetlinemInit = kFALSE;; 394 ; 395 if (strlen(WorkingDirectory())) {; 396 // if directory specified as argument make it the working directory; 397 gSystem->ChangeDirectory(WorkingDirectory());; 398 TSystemDirectory *workdir = new TSystemDirectory(""workdir"", gSystem->WorkingDirectory());; 399 TObject *w = gROOT->GetListOfBrowsables()->FindObject(""workdir"");; 400 TObjLink *lnk = gROOT->GetListOfBrowsables()->FirstLink();; 401 while (lnk) {; 402 if (lnk->GetObject() == w) {; 403 lnk->SetObject(workdir);; 404 lnk->SetOption(gSystem->WorkingDirectory());; 405 break;; 406 }; 407 lnk = lnk->Next();; 408 }; 409 delete w;; 410 }; 411 ; 412 // Process shell command line input files; 413 if (InputFiles()) {; 414 // Make sure that calls into the event loop; 415 // ignore end-of-file on the terminal.; 416 fInputHandler->DeActivate();; 417 TIter next(InputFiles());; 418 RETRY {; 419 retval = 0; error = 0;; 420 Int_t nfile = 0;; 421 while (TObject *fileObj = next()) {; 422 if (dynamic_cast<TNamed*>(fileObj)) {; 423 // A file that TApplication did not find. Note the error.; 424 retval = 1;; 425 continue;; 426 }; 427 TObjString *file = (TObjString *)fileObj;; 428 char cmd[kMAXPATHLEN+50];; 429 if (!fNcmd); 430 printf(""\n"");; 431 Bool_t rootfile = kFALSE;; 432 ; 433 if (file->TestBit(kExpression)) {; 434 snprintf(cmd, kMAXPATHLEN+50, ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:14637,Availability,error,error,14637," 391 Longptr_t retval = 0;; 392 Int_t error = 0;; 393 volatile Bool_t needGetlinemInit = kFALSE;; 394 ; 395 if (strlen(WorkingDirectory())) {; 396 // if directory specified as argument make it the working directory; 397 gSystem->ChangeDirectory(WorkingDirectory());; 398 TSystemDirectory *workdir = new TSystemDirectory(""workdir"", gSystem->WorkingDirectory());; 399 TObject *w = gROOT->GetListOfBrowsables()->FindObject(""workdir"");; 400 TObjLink *lnk = gROOT->GetListOfBrowsables()->FirstLink();; 401 while (lnk) {; 402 if (lnk->GetObject() == w) {; 403 lnk->SetObject(workdir);; 404 lnk->SetOption(gSystem->WorkingDirectory());; 405 break;; 406 }; 407 lnk = lnk->Next();; 408 }; 409 delete w;; 410 }; 411 ; 412 // Process shell command line input files; 413 if (InputFiles()) {; 414 // Make sure that calls into the event loop; 415 // ignore end-of-file on the terminal.; 416 fInputHandler->DeActivate();; 417 TIter next(InputFiles());; 418 RETRY {; 419 retval = 0; error = 0;; 420 Int_t nfile = 0;; 421 while (TObject *fileObj = next()) {; 422 if (dynamic_cast<TNamed*>(fileObj)) {; 423 // A file that TApplication did not find. Note the error.; 424 retval = 1;; 425 continue;; 426 }; 427 TObjString *file = (TObjString *)fileObj;; 428 char cmd[kMAXPATHLEN+50];; 429 if (!fNcmd); 430 printf(""\n"");; 431 Bool_t rootfile = kFALSE;; 432 ; 433 if (file->TestBit(kExpression)) {; 434 snprintf(cmd, kMAXPATHLEN+50, ""%s"", (const char*)file->String());; 435 } else {; 436 if (file->String().EndsWith("".root"") || file->String().BeginsWith(""file:"")) {; 437 rootfile = kTRUE;; 438 } else {; 439 rootfile = gROOT->IsRootFile(file->String());; 440 }; 441 if (rootfile) {; 442 // special trick to be able to open files using UNC path names; 443 if (file->String().BeginsWith(""\\\\"")); 444 file->String().Prepend(""\\\\"");; 445 file->String().ReplaceAll(""\\"",""/"");; 446 const char *rfile = (const char*)file->String();; 447 Printf(""Attaching file %s as _file%d..."", rfile, nfile);; 448 snprintf(cmd, kMAXPATHLEN+50,",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:14810,Availability,error,error,14810,") {; 396 // if directory specified as argument make it the working directory; 397 gSystem->ChangeDirectory(WorkingDirectory());; 398 TSystemDirectory *workdir = new TSystemDirectory(""workdir"", gSystem->WorkingDirectory());; 399 TObject *w = gROOT->GetListOfBrowsables()->FindObject(""workdir"");; 400 TObjLink *lnk = gROOT->GetListOfBrowsables()->FirstLink();; 401 while (lnk) {; 402 if (lnk->GetObject() == w) {; 403 lnk->SetObject(workdir);; 404 lnk->SetOption(gSystem->WorkingDirectory());; 405 break;; 406 }; 407 lnk = lnk->Next();; 408 }; 409 delete w;; 410 }; 411 ; 412 // Process shell command line input files; 413 if (InputFiles()) {; 414 // Make sure that calls into the event loop; 415 // ignore end-of-file on the terminal.; 416 fInputHandler->DeActivate();; 417 TIter next(InputFiles());; 418 RETRY {; 419 retval = 0; error = 0;; 420 Int_t nfile = 0;; 421 while (TObject *fileObj = next()) {; 422 if (dynamic_cast<TNamed*>(fileObj)) {; 423 // A file that TApplication did not find. Note the error.; 424 retval = 1;; 425 continue;; 426 }; 427 TObjString *file = (TObjString *)fileObj;; 428 char cmd[kMAXPATHLEN+50];; 429 if (!fNcmd); 430 printf(""\n"");; 431 Bool_t rootfile = kFALSE;; 432 ; 433 if (file->TestBit(kExpression)) {; 434 snprintf(cmd, kMAXPATHLEN+50, ""%s"", (const char*)file->String());; 435 } else {; 436 if (file->String().EndsWith("".root"") || file->String().BeginsWith(""file:"")) {; 437 rootfile = kTRUE;; 438 } else {; 439 rootfile = gROOT->IsRootFile(file->String());; 440 }; 441 if (rootfile) {; 442 // special trick to be able to open files using UNC path names; 443 if (file->String().BeginsWith(""\\\\"")); 444 file->String().Prepend(""\\\\"");; 445 file->String().ReplaceAll(""\\"",""/"");; 446 const char *rfile = (const char*)file->String();; 447 Printf(""Attaching file %s as _file%d..."", rfile, nfile);; 448 snprintf(cmd, kMAXPATHLEN+50, ""TFile *_file%d = TFile::Open(\""%s\"")"", nfile++, rfile);; 449 } else {; 450 Printf(""Processing %s..."", (const char*)file->String());; 45",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:16240,Availability,error,error,16240,").BeginsWith(""\\\\"")); 444 file->String().Prepend(""\\\\"");; 445 file->String().ReplaceAll(""\\"",""/"");; 446 const char *rfile = (const char*)file->String();; 447 Printf(""Attaching file %s as _file%d..."", rfile, nfile);; 448 snprintf(cmd, kMAXPATHLEN+50, ""TFile *_file%d = TFile::Open(\""%s\"")"", nfile++, rfile);; 449 } else {; 450 Printf(""Processing %s..."", (const char*)file->String());; 451 snprintf(cmd, kMAXPATHLEN+50, "".x %s"", (const char*)file->String());; 452 }; 453 }; 454 Getlinem(kCleanUp, nullptr);; 455 Gl_histadd(cmd);; 456 ; 457 // The ProcessLine might throw an 'exception'. In this case,; 458 // GetLinem(kInit,""Root >"") is called and we are jump back; 459 // to RETRY ... and we have to avoid the Getlinem(kInit, GetPrompt());; 460 needGetlinemInit = kFALSE;; 461 retval = ProcessLineNr(""ROOT_cli_"", cmd, &error);; 462 gCling->EndOfLineAction();; 463 fNcmd++;; 464 ; 465 // The ProcessLine has successfully completed and we need; 466 // to call Getlinem(kInit, GetPrompt());; 467 needGetlinemInit = kTRUE;; 468 ; 469 if (error != 0 || fCaughtSignal != -1) break;; 470 }; 471 } ENDTRY;; 472 ; 473 if (QuitOpt()) {; 474 if (retrn) return;; 475 if (error) {; 476 retval = error;; 477 } else if (fCaughtSignal != -1) {; 478 retval = fCaughtSignal + 128;; 479 }; 480 // Bring retval into sensible range, 0..255.; 481 if (retval < 0 || retval > 255); 482 retval = 255;; 483 Terminate(retval);; 484 }; 485 ; 486 // Allow end-of-file on the terminal to be noticed; 487 // after we finish processing the command line input files.; 488 fInputHandler->Activate();; 489 ; 490 ClearInputFiles();; 491 ; 492 if (needGetlinemInit) Getlinem(kInit, GetPrompt());; 493 }; 494 ; 495 if (QuitOpt()) {; 496 printf(""\n"");; 497 if (retrn) return;; 498 Terminate(fCaughtSignal != -1 ? fCaughtSignal + 128 : 0);; 499 }; 500 ; 501 TApplication::Run(retrn);; 502 ; 503 // Reset to happiness.; 504 fCaughtSignal = -1;; 505 ; 506 Getlinem(kCleanUp, nullptr);; 507}; 508 ; 509////////////////////////////////////////",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:16455,Availability,error,error,16455,").BeginsWith(""\\\\"")); 444 file->String().Prepend(""\\\\"");; 445 file->String().ReplaceAll(""\\"",""/"");; 446 const char *rfile = (const char*)file->String();; 447 Printf(""Attaching file %s as _file%d..."", rfile, nfile);; 448 snprintf(cmd, kMAXPATHLEN+50, ""TFile *_file%d = TFile::Open(\""%s\"")"", nfile++, rfile);; 449 } else {; 450 Printf(""Processing %s..."", (const char*)file->String());; 451 snprintf(cmd, kMAXPATHLEN+50, "".x %s"", (const char*)file->String());; 452 }; 453 }; 454 Getlinem(kCleanUp, nullptr);; 455 Gl_histadd(cmd);; 456 ; 457 // The ProcessLine might throw an 'exception'. In this case,; 458 // GetLinem(kInit,""Root >"") is called and we are jump back; 459 // to RETRY ... and we have to avoid the Getlinem(kInit, GetPrompt());; 460 needGetlinemInit = kFALSE;; 461 retval = ProcessLineNr(""ROOT_cli_"", cmd, &error);; 462 gCling->EndOfLineAction();; 463 fNcmd++;; 464 ; 465 // The ProcessLine has successfully completed and we need; 466 // to call Getlinem(kInit, GetPrompt());; 467 needGetlinemInit = kTRUE;; 468 ; 469 if (error != 0 || fCaughtSignal != -1) break;; 470 }; 471 } ENDTRY;; 472 ; 473 if (QuitOpt()) {; 474 if (retrn) return;; 475 if (error) {; 476 retval = error;; 477 } else if (fCaughtSignal != -1) {; 478 retval = fCaughtSignal + 128;; 479 }; 480 // Bring retval into sensible range, 0..255.; 481 if (retval < 0 || retval > 255); 482 retval = 255;; 483 Terminate(retval);; 484 }; 485 ; 486 // Allow end-of-file on the terminal to be noticed; 487 // after we finish processing the command line input files.; 488 fInputHandler->Activate();; 489 ; 490 ClearInputFiles();; 491 ; 492 if (needGetlinemInit) Getlinem(kInit, GetPrompt());; 493 }; 494 ; 495 if (QuitOpt()) {; 496 printf(""\n"");; 497 if (retrn) return;; 498 Terminate(fCaughtSignal != -1 ? fCaughtSignal + 128 : 0);; 499 }; 500 ; 501 TApplication::Run(retrn);; 502 ; 503 // Reset to happiness.; 504 fCaughtSignal = -1;; 505 ; 506 Getlinem(kCleanUp, nullptr);; 507}; 508 ; 509////////////////////////////////////////",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:16580,Availability,error,error,16580,").BeginsWith(""\\\\"")); 444 file->String().Prepend(""\\\\"");; 445 file->String().ReplaceAll(""\\"",""/"");; 446 const char *rfile = (const char*)file->String();; 447 Printf(""Attaching file %s as _file%d..."", rfile, nfile);; 448 snprintf(cmd, kMAXPATHLEN+50, ""TFile *_file%d = TFile::Open(\""%s\"")"", nfile++, rfile);; 449 } else {; 450 Printf(""Processing %s..."", (const char*)file->String());; 451 snprintf(cmd, kMAXPATHLEN+50, "".x %s"", (const char*)file->String());; 452 }; 453 }; 454 Getlinem(kCleanUp, nullptr);; 455 Gl_histadd(cmd);; 456 ; 457 // The ProcessLine might throw an 'exception'. In this case,; 458 // GetLinem(kInit,""Root >"") is called and we are jump back; 459 // to RETRY ... and we have to avoid the Getlinem(kInit, GetPrompt());; 460 needGetlinemInit = kFALSE;; 461 retval = ProcessLineNr(""ROOT_cli_"", cmd, &error);; 462 gCling->EndOfLineAction();; 463 fNcmd++;; 464 ; 465 // The ProcessLine has successfully completed and we need; 466 // to call Getlinem(kInit, GetPrompt());; 467 needGetlinemInit = kTRUE;; 468 ; 469 if (error != 0 || fCaughtSignal != -1) break;; 470 }; 471 } ENDTRY;; 472 ; 473 if (QuitOpt()) {; 474 if (retrn) return;; 475 if (error) {; 476 retval = error;; 477 } else if (fCaughtSignal != -1) {; 478 retval = fCaughtSignal + 128;; 479 }; 480 // Bring retval into sensible range, 0..255.; 481 if (retval < 0 || retval > 255); 482 retval = 255;; 483 Terminate(retval);; 484 }; 485 ; 486 // Allow end-of-file on the terminal to be noticed; 487 // after we finish processing the command line input files.; 488 fInputHandler->Activate();; 489 ; 490 ClearInputFiles();; 491 ; 492 if (needGetlinemInit) Getlinem(kInit, GetPrompt());; 493 }; 494 ; 495 if (QuitOpt()) {; 496 printf(""\n"");; 497 if (retrn) return;; 498 Terminate(fCaughtSignal != -1 ? fCaughtSignal + 128 : 0);; 499 }; 500 ; 501 TApplication::Run(retrn);; 502 ; 503 // Reset to happiness.; 504 fCaughtSignal = -1;; 505 ; 506 Getlinem(kCleanUp, nullptr);; 507}; 508 ; 509////////////////////////////////////////",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:16603,Availability,error,error,16603,").BeginsWith(""\\\\"")); 444 file->String().Prepend(""\\\\"");; 445 file->String().ReplaceAll(""\\"",""/"");; 446 const char *rfile = (const char*)file->String();; 447 Printf(""Attaching file %s as _file%d..."", rfile, nfile);; 448 snprintf(cmd, kMAXPATHLEN+50, ""TFile *_file%d = TFile::Open(\""%s\"")"", nfile++, rfile);; 449 } else {; 450 Printf(""Processing %s..."", (const char*)file->String());; 451 snprintf(cmd, kMAXPATHLEN+50, "".x %s"", (const char*)file->String());; 452 }; 453 }; 454 Getlinem(kCleanUp, nullptr);; 455 Gl_histadd(cmd);; 456 ; 457 // The ProcessLine might throw an 'exception'. In this case,; 458 // GetLinem(kInit,""Root >"") is called and we are jump back; 459 // to RETRY ... and we have to avoid the Getlinem(kInit, GetPrompt());; 460 needGetlinemInit = kFALSE;; 461 retval = ProcessLineNr(""ROOT_cli_"", cmd, &error);; 462 gCling->EndOfLineAction();; 463 fNcmd++;; 464 ; 465 // The ProcessLine has successfully completed and we need; 466 // to call Getlinem(kInit, GetPrompt());; 467 needGetlinemInit = kTRUE;; 468 ; 469 if (error != 0 || fCaughtSignal != -1) break;; 470 }; 471 } ENDTRY;; 472 ; 473 if (QuitOpt()) {; 474 if (retrn) return;; 475 if (error) {; 476 retval = error;; 477 } else if (fCaughtSignal != -1) {; 478 retval = fCaughtSignal + 128;; 479 }; 480 // Bring retval into sensible range, 0..255.; 481 if (retval < 0 || retval > 255); 482 retval = 255;; 483 Terminate(retval);; 484 }; 485 ; 486 // Allow end-of-file on the terminal to be noticed; 487 // after we finish processing the command line input files.; 488 fInputHandler->Activate();; 489 ; 490 ClearInputFiles();; 491 ; 492 if (needGetlinemInit) Getlinem(kInit, GetPrompt());; 493 }; 494 ; 495 if (QuitOpt()) {; 496 printf(""\n"");; 497 if (retrn) return;; 498 Terminate(fCaughtSignal != -1 ? fCaughtSignal + 128 : 0);; 499 }; 500 ; 501 TApplication::Run(retrn);; 502 ; 503 // Reset to happiness.; 504 fCaughtSignal = -1;; 505 ; 506 Getlinem(kCleanUp, nullptr);; 507}; 508 ; 509////////////////////////////////////////",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:25506,Availability,echo,echo,25506,"///////////////////////////////////////////////////////; 717/// Terminate the application. Reset the terminal to sane mode and call; 718/// the logoff macro defined via Rint.Logoff environment variable.; 719/// @note The function does not return, unless the class has; 720/// been told to return from Run(), by a call to SetReturnFromRun().; 721 ; 722void TRint::Terminate(Int_t status); 723{; 724 Getlinem(kCleanUp, nullptr);; 725 ; 726 if (ReturnFromRun()) {; 727 gSystem->ExitLoop();; 728 } else {; 729 delete gTabCom;; 730 gTabCom = nullptr;; 731 ; 732 //Execute logoff macro; 733 const char *logoff;; 734 logoff = gEnv->GetValue(""Rint.Logoff"", (char*)nullptr);; 735 if (logoff && !NoLogOpt()) {; 736 char *mac = gSystem->Which(TROOT::GetMacroPath(), logoff, kReadPermission);; 737 if (mac); 738 ProcessFile(logoff);; 739 delete [] mac;; 740 }; 741 ; 742 TApplication::Terminate(status);; 743 }; 744}; 745 ; 746////////////////////////////////////////////////////////////////////////////////; 747/// Set console mode:; 748///; 749/// mode = kTRUE - echo input symbols; 750/// mode = kFALSE - noecho input symbols; 751 ; 752void TRint::SetEchoMode(Bool_t mode); 753{; 754 Gl_config(""noecho"", mode ? 0 : 1);; 755}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Process the content of a line starting with "".R"" (already stripped-off); 759/// The format is; 760/// [user@]host[:dir] [-l user] [-d dbg] [script]; 761/// The variable 'dir' is the remote directory to be used as working dir.; 762/// The username can be specified in two ways, ""-l"" having the priority; 763/// (as in ssh).; 764/// A 'dbg' value > 0 gives increasing verbosity.; 765/// The last argument 'script' allows to specify an alternative script to; 766/// be executed remotely to startup the session.; 767 ; 768Longptr_t TRint::ProcessRemote(const char *line, Int_t *); 769{; 770 Longptr_t ret = TApplication::ProcessRemote(line);; 771 ; 772 if (ret == 1) {; 773 if (fAppRemote) ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:27058,Availability,error,error,27058,"rity; 763/// (as in ssh).; 764/// A 'dbg' value > 0 gives increasing verbosity.; 765/// The last argument 'script' allows to specify an alternative script to; 766/// be executed remotely to startup the session.; 767 ; 768Longptr_t TRint::ProcessRemote(const char *line, Int_t *); 769{; 770 Longptr_t ret = TApplication::ProcessRemote(line);; 771 ; 772 if (ret == 1) {; 773 if (fAppRemote) {; 774 TString prompt; prompt.Form(""%s:root [%%d] "", fAppRemote->ApplicationName());; 775 SetPrompt(prompt);; 776 } else {; 777 SetPrompt(""root [%d] "");; 778 }; 779 }; 780 ; 781 return ret;; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Calls TRint::ProcessLine() possibly prepending a `#line` directive for; 787/// better diagnostics.; 788/// The user is responsible for incrementing `fNcmd`, where appropriate, after; 789/// a call to this function.; 790 ; 791Longptr_t TRint::ProcessLineNr(const char* filestem, const char *line, Int_t *error /*= 0*/); 792{; 793 Int_t err;; 794 if (!error); 795 error = &err;; 796 if (line && line[0] != '.') {; 797 TString input;; 798 if (!fBackslashContinue); 799 input += TString::Format(""#line 1 \""%s%d\""\n"", filestem, fNcmd);; 800 input += line;; 801 int res = ProcessLine(input, kFALSE, error);; 802 if (gCling->GetMore()) {; 803 if (!fNonContinuePrompt.Length()); 804 fNonContinuePrompt = fDefaultPrompt;; 805 SetPrompt(""root (cont'ed, cancel with .@) [%d]"");; 806 } else if (fNonContinuePrompt.Length()) {; 807 SetPrompt(fNonContinuePrompt);; 808 fNonContinuePrompt.Clear();; 809 }; 810 std::string_view sv(line);; 811 auto lastNonSpace = sv.find_last_not_of("" \t"");; 812 fBackslashContinue = (lastNonSpace != std::string_view::npos; 813 && sv[lastNonSpace] == '\\');; 814 return res;; 815 }; 816 if (line && line[0] == '.' && line[1] == '@') {; 817 ProcessLine(line, kFALSE, error);; 818 SetPrompt(""root [%d] "");; 819 }; 820 return ProcessLine(line, kFALSE, error);; 821}; 822 ; 823 ; 824/////////////",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:27105,Availability,error,error,27105,"rity; 763/// (as in ssh).; 764/// A 'dbg' value > 0 gives increasing verbosity.; 765/// The last argument 'script' allows to specify an alternative script to; 766/// be executed remotely to startup the session.; 767 ; 768Longptr_t TRint::ProcessRemote(const char *line, Int_t *); 769{; 770 Longptr_t ret = TApplication::ProcessRemote(line);; 771 ; 772 if (ret == 1) {; 773 if (fAppRemote) {; 774 TString prompt; prompt.Form(""%s:root [%%d] "", fAppRemote->ApplicationName());; 775 SetPrompt(prompt);; 776 } else {; 777 SetPrompt(""root [%d] "");; 778 }; 779 }; 780 ; 781 return ret;; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Calls TRint::ProcessLine() possibly prepending a `#line` directive for; 787/// better diagnostics.; 788/// The user is responsible for incrementing `fNcmd`, where appropriate, after; 789/// a call to this function.; 790 ; 791Longptr_t TRint::ProcessLineNr(const char* filestem, const char *line, Int_t *error /*= 0*/); 792{; 793 Int_t err;; 794 if (!error); 795 error = &err;; 796 if (line && line[0] != '.') {; 797 TString input;; 798 if (!fBackslashContinue); 799 input += TString::Format(""#line 1 \""%s%d\""\n"", filestem, fNcmd);; 800 input += line;; 801 int res = ProcessLine(input, kFALSE, error);; 802 if (gCling->GetMore()) {; 803 if (!fNonContinuePrompt.Length()); 804 fNonContinuePrompt = fDefaultPrompt;; 805 SetPrompt(""root (cont'ed, cancel with .@) [%d]"");; 806 } else if (fNonContinuePrompt.Length()) {; 807 SetPrompt(fNonContinuePrompt);; 808 fNonContinuePrompt.Clear();; 809 }; 810 std::string_view sv(line);; 811 auto lastNonSpace = sv.find_last_not_of("" \t"");; 812 fBackslashContinue = (lastNonSpace != std::string_view::npos; 813 && sv[lastNonSpace] == '\\');; 814 return res;; 815 }; 816 if (line && line[0] == '.' && line[1] == '@') {; 817 ProcessLine(line, kFALSE, error);; 818 SetPrompt(""root [%d] "");; 819 }; 820 return ProcessLine(line, kFALSE, error);; 821}; 822 ; 823 ; 824/////////////",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:27117,Availability,error,error,27117,"rity; 763/// (as in ssh).; 764/// A 'dbg' value > 0 gives increasing verbosity.; 765/// The last argument 'script' allows to specify an alternative script to; 766/// be executed remotely to startup the session.; 767 ; 768Longptr_t TRint::ProcessRemote(const char *line, Int_t *); 769{; 770 Longptr_t ret = TApplication::ProcessRemote(line);; 771 ; 772 if (ret == 1) {; 773 if (fAppRemote) {; 774 TString prompt; prompt.Form(""%s:root [%%d] "", fAppRemote->ApplicationName());; 775 SetPrompt(prompt);; 776 } else {; 777 SetPrompt(""root [%d] "");; 778 }; 779 }; 780 ; 781 return ret;; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Calls TRint::ProcessLine() possibly prepending a `#line` directive for; 787/// better diagnostics.; 788/// The user is responsible for incrementing `fNcmd`, where appropriate, after; 789/// a call to this function.; 790 ; 791Longptr_t TRint::ProcessLineNr(const char* filestem, const char *line, Int_t *error /*= 0*/); 792{; 793 Int_t err;; 794 if (!error); 795 error = &err;; 796 if (line && line[0] != '.') {; 797 TString input;; 798 if (!fBackslashContinue); 799 input += TString::Format(""#line 1 \""%s%d\""\n"", filestem, fNcmd);; 800 input += line;; 801 int res = ProcessLine(input, kFALSE, error);; 802 if (gCling->GetMore()) {; 803 if (!fNonContinuePrompt.Length()); 804 fNonContinuePrompt = fDefaultPrompt;; 805 SetPrompt(""root (cont'ed, cancel with .@) [%d]"");; 806 } else if (fNonContinuePrompt.Length()) {; 807 SetPrompt(fNonContinuePrompt);; 808 fNonContinuePrompt.Clear();; 809 }; 810 std::string_view sv(line);; 811 auto lastNonSpace = sv.find_last_not_of("" \t"");; 812 fBackslashContinue = (lastNonSpace != std::string_view::npos; 813 && sv[lastNonSpace] == '\\');; 814 return res;; 815 }; 816 if (line && line[0] == '.' && line[1] == '@') {; 817 ProcessLine(line, kFALSE, error);; 818 SetPrompt(""root [%d] "");; 819 }; 820 return ProcessLine(line, kFALSE, error);; 821}; 822 ; 823 ; 824/////////////",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:27348,Availability,error,error,27348,"ngptr_t TRint::ProcessRemote(const char *line, Int_t *); 769{; 770 Longptr_t ret = TApplication::ProcessRemote(line);; 771 ; 772 if (ret == 1) {; 773 if (fAppRemote) {; 774 TString prompt; prompt.Form(""%s:root [%%d] "", fAppRemote->ApplicationName());; 775 SetPrompt(prompt);; 776 } else {; 777 SetPrompt(""root [%d] "");; 778 }; 779 }; 780 ; 781 return ret;; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Calls TRint::ProcessLine() possibly prepending a `#line` directive for; 787/// better diagnostics.; 788/// The user is responsible for incrementing `fNcmd`, where appropriate, after; 789/// a call to this function.; 790 ; 791Longptr_t TRint::ProcessLineNr(const char* filestem, const char *line, Int_t *error /*= 0*/); 792{; 793 Int_t err;; 794 if (!error); 795 error = &err;; 796 if (line && line[0] != '.') {; 797 TString input;; 798 if (!fBackslashContinue); 799 input += TString::Format(""#line 1 \""%s%d\""\n"", filestem, fNcmd);; 800 input += line;; 801 int res = ProcessLine(input, kFALSE, error);; 802 if (gCling->GetMore()) {; 803 if (!fNonContinuePrompt.Length()); 804 fNonContinuePrompt = fDefaultPrompt;; 805 SetPrompt(""root (cont'ed, cancel with .@) [%d]"");; 806 } else if (fNonContinuePrompt.Length()) {; 807 SetPrompt(fNonContinuePrompt);; 808 fNonContinuePrompt.Clear();; 809 }; 810 std::string_view sv(line);; 811 auto lastNonSpace = sv.find_last_not_of("" \t"");; 812 fBackslashContinue = (lastNonSpace != std::string_view::npos; 813 && sv[lastNonSpace] == '\\');; 814 return res;; 815 }; 816 if (line && line[0] == '.' && line[1] == '@') {; 817 ProcessLine(line, kFALSE, error);; 818 SetPrompt(""root [%d] "");; 819 }; 820 return ProcessLine(line, kFALSE, error);; 821}; 822 ; 823 ; 824////////////////////////////////////////////////////////////////////////////////; 825/// Forward tab completion request to our TTabCom::Hook().; 826 ; 827Int_t TRint::TabCompletionHook(char *buf, int *pLoc, std::ostream& out); 828{; 829",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:27939,Availability,error,error,27939,"har *line, Int_t *error /*= 0*/); 792{; 793 Int_t err;; 794 if (!error); 795 error = &err;; 796 if (line && line[0] != '.') {; 797 TString input;; 798 if (!fBackslashContinue); 799 input += TString::Format(""#line 1 \""%s%d\""\n"", filestem, fNcmd);; 800 input += line;; 801 int res = ProcessLine(input, kFALSE, error);; 802 if (gCling->GetMore()) {; 803 if (!fNonContinuePrompt.Length()); 804 fNonContinuePrompt = fDefaultPrompt;; 805 SetPrompt(""root (cont'ed, cancel with .@) [%d]"");; 806 } else if (fNonContinuePrompt.Length()) {; 807 SetPrompt(fNonContinuePrompt);; 808 fNonContinuePrompt.Clear();; 809 }; 810 std::string_view sv(line);; 811 auto lastNonSpace = sv.find_last_not_of("" \t"");; 812 fBackslashContinue = (lastNonSpace != std::string_view::npos; 813 && sv[lastNonSpace] == '\\');; 814 return res;; 815 }; 816 if (line && line[0] == '.' && line[1] == '@') {; 817 ProcessLine(line, kFALSE, error);; 818 SetPrompt(""root [%d] "");; 819 }; 820 return ProcessLine(line, kFALSE, error);; 821}; 822 ; 823 ; 824////////////////////////////////////////////////////////////////////////////////; 825/// Forward tab completion request to our TTabCom::Hook().; 826 ; 827Int_t TRint::TabCompletionHook(char *buf, int *pLoc, std::ostream& out); 828{; 829 if (gTabCom); 830 return gTabCom->Hook(buf, pLoc, out);; 831 ; 832 return -1;; 833}; e#define e(i)Definition RSha256.hxx:103; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kMAXPATHLEN@ kMAXPATHLENDefinition Rtypes.h:60; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TBenchmark.h; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; TClassEdit.h; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:104; TC",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:28022,Availability,error,error,28022,"har *line, Int_t *error /*= 0*/); 792{; 793 Int_t err;; 794 if (!error); 795 error = &err;; 796 if (line && line[0] != '.') {; 797 TString input;; 798 if (!fBackslashContinue); 799 input += TString::Format(""#line 1 \""%s%d\""\n"", filestem, fNcmd);; 800 input += line;; 801 int res = ProcessLine(input, kFALSE, error);; 802 if (gCling->GetMore()) {; 803 if (!fNonContinuePrompt.Length()); 804 fNonContinuePrompt = fDefaultPrompt;; 805 SetPrompt(""root (cont'ed, cancel with .@) [%d]"");; 806 } else if (fNonContinuePrompt.Length()) {; 807 SetPrompt(fNonContinuePrompt);; 808 fNonContinuePrompt.Clear();; 809 }; 810 std::string_view sv(line);; 811 auto lastNonSpace = sv.find_last_not_of("" \t"");; 812 fBackslashContinue = (lastNonSpace != std::string_view::npos; 813 && sv[lastNonSpace] == '\\');; 814 return res;; 815 }; 816 if (line && line[0] == '.' && line[1] == '@') {; 817 ProcessLine(line, kFALSE, error);; 818 SetPrompt(""root [%d] "");; 819 }; 820 return ProcessLine(line, kFALSE, error);; 821}; 822 ; 823 ; 824////////////////////////////////////////////////////////////////////////////////; 825/// Forward tab completion request to our TTabCom::Hook().; 826 ; 827Int_t TRint::TabCompletionHook(char *buf, int *pLoc, std::ostream& out); 828{; 829 if (gTabCom); 830 return gTabCom->Hook(buf, pLoc, out);; 831 ; 832 return -1;; 833}; e#define e(i)Definition RSha256.hxx:103; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kMAXPATHLEN@ kMAXPATHLENDefinition Rtypes.h:60; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TBenchmark.h; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; TClassEdit.h; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:104; TC",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:29204,Availability,error,error,29204," 826 ; 827Int_t TRint::TabCompletionHook(char *buf, int *pLoc, std::ostream& out); 828{; 829 if (gTabCom); 830 return gTabCom->Hook(buf, pLoc, out);; 831 ; 832 return -1;; 833}; e#define e(i)Definition RSha256.hxx:103; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kMAXPATHLEN@ kMAXPATHLENDefinition Rtypes.h:60; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TBenchmark.h; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; TClassEdit.h; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:104; TClass.h; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; Breakvoid Break(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:207; TException.h; CATCH#define CATCH(n)Definition TException.h:58; ENDTRY#define ENDTRYDefinition TException.h:64; RETRY#define RETRYDefinition TException.h:44; TRY#define TRYDefinition TException.h:51; gExceptionR__EXTERN ExceptionContext_t * gExceptionDefinition TException.h:69; ThrowR__EXTERN void Throw(int code)If an exception context has been set (using the TRY and RETRY macros) jump back to where it was set.Definition TException.cxx:27; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; gInterpreter#define gInterpreterD",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:31708,Availability,error,error,31708," Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TSysEvtHandler.h; kSigInterrupt@ kSigInterruptDefinition TSysEvtHandler.h:115; TSystemDirectory.h; TSystem.h; kReadPermission@ kReadPermissionDefinition TSystem.h:45; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTabCom.h; gTabComR__EXTERN TTabCom * gTabComDefinition TTabCom.h:229; TVirtualX.h; gVirtualX#define gVirtualXDefinition TVirtualX.h:337; ThreadLocalStorage.h; free#define freeDefinition civetweb.c:1539; snprintf#define snprintfDefinition civetweb.c:1540; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::ReturnFromRunBool_t ReturnFromRun() constDefinition TApplication.h:153; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::HandleExceptionvirtual void HandleExceptio",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:33310,Availability,error,error,33310,"ion TApplication.cxx:318; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::ReturnFromRunBool_t ReturnFromRun() constDefinition TApplication.h:153; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::HandleExceptionvirtual void HandleException(Int_t sig)Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingExcepti...Definition TApplication.cxx:590; TApplication::Argvchar ** Argv() constDefinition TApplication.h:141; TApplication::Terminatevirtual void Terminate(Int_t status=0)Terminate the application by call TSystem::Exit() unless application has been told to return from Run...Definition TApplication.cxx:1927; TApplication::ApplicationNamevirtual const char * ApplicationName() constDefinition TApplication.h:128; TApplication::ProcessFilevirtual Longptr_t ProcessFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Process a file containing a C++ macro.Definition TApplication.cxx:1720; TApplication::ReturnPressedvirtual void ReturnPressed(char *text)Emit signal when return key was pressed.Definition TApplication.cxx:1957; TApplication::kExpression@ kExpressionDefinition TApplication.h:49; TApplication::NoLogOptBool_t NoLogOpt() constDefinition TApplication.h:143; TApplication::NoLogoOptBool_t NoLogoOpt() constDefinition TApplication.h:144; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplicat",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:34100,Availability,error,error,34100,"m Run...Definition TApplication.cxx:1927; TApplication::ApplicationNamevirtual const char * ApplicationName() constDefinition TApplication.h:128; TApplication::ProcessFilevirtual Longptr_t ProcessFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Process a file containing a C++ macro.Definition TApplication.cxx:1720; TApplication::ReturnPressedvirtual void ReturnPressed(char *text)Emit signal when return key was pressed.Definition TApplication.cxx:1957; TApplication::kExpression@ kExpressionDefinition TApplication.h:49; TApplication::NoLogOptBool_t NoLogOpt() constDefinition TApplication.h:143; TApplication::NoLogoOptBool_t NoLogoOpt() constDefinition TApplication.h:144; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::SetSignalHandlervoid SetSignalHandler(TSignalHandler *sh)Definition TApplication.h:92; TBenchmarkThis class is a ROOT utility to help benchmarking applications.Definition TBenchmark.h:29; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFileHandlerDefinition TSysEvtHandler.h:65; TFileHandler::Removevoid Remove() overrideRemove file event handler from system file handler list.Definition TSysEvtHandler.cxx:137; TFileHandler::Addvoid Add() overrideAdd file event handler to system f",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:37010,Availability,error,error,37010,"Named.h:29; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::SetOptionvirtual void SetOption(Option_t *)Definition TList.h:150; TObjLink::SetObjectvoid SetObject(TObject *obj)Definition TList.h:147; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TRintDefinition TRint.h:31; TRint::SetEchoModevoid SetEchoMode(Bool_t mode) overrideSet console mode:Definition TRint.cxx:752; TRint::HandleTermInputBool_t HandleTermInput() overrideHandle input coming from terminal.Definition TRint.cxx:611; TRint::fInterruptBool_t fInterruptDefinition TRint.h:38; TRint::Runvoid Run(Bool_t retrn=",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:38171,Availability,error,error,38171,":2762; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TRintDefinition TRint.h:31; TRint::SetEchoModevoid SetEchoMode(Bool_t mode) overrideSet console mode:Definition TRint.cxx:752; TRint::HandleTermInputBool_t HandleTermInput() overrideHandle input coming from terminal.Definition TRint.cxx:611; TRint::fInterruptBool_t fInterruptDefinition TRint.h:38; TRint::Runvoid Run(Bool_t retrn=kFALSE) overrideMain application eventloop.Definition TRint.cxx:384; TRint::ProcessLineNrLongptr_t ProcessLineNr(const char *filestem, const char *line, Int_t *error=nullptr)Calls TRint::ProcessLine() possibly prepending a #line directive for better diagnostics.Definition TRint.cxx:791; TRint::SetPromptvirtual const char * SetPrompt(const char *newPrompt)Set a new default prompt.Definition TRint.cxx:595; TRint::Terminatevirtual void Terminate(int status) overrideTerminate the application.Definition TRint.cxx:722; TRint::fPromptchar fPrompt[64]Definition TRint.h:37; TRint::TabCompletionHookInt_t TabCompletionHook(char *buf, int *pLoc, std::ostream &out) overrideForward tab completion request to our TTabCom::Hook().Definition TRint.cxx:827; TRint::GetPromptvirtual char * GetPrompt()Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"".Definition TRint.cxx:575; TRint::HandleExceptionvoid HandleException(Int_t sig) overrideHandle signals (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException)...Definition TRint.cxx:704; TRint::~TRintvirtual ~TRint()Destructor.Definition TRint.cxx:316; TRint::PrintLogovirtu",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:39423,Availability,error,error,39423," TRint::Terminatevirtual void Terminate(int status) overrideTerminate the application.Definition TRint.cxx:722; TRint::fPromptchar fPrompt[64]Definition TRint.h:37; TRint::TabCompletionHookInt_t TabCompletionHook(char *buf, int *pLoc, std::ostream &out) overrideForward tab completion request to our TTabCom::Hook().Definition TRint.cxx:827; TRint::GetPromptvirtual char * GetPrompt()Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"".Definition TRint.cxx:575; TRint::HandleExceptionvoid HandleException(Int_t sig) overrideHandle signals (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException)...Definition TRint.cxx:704; TRint::~TRintvirtual ~TRint()Destructor.Definition TRint.cxx:316; TRint::PrintLogovirtual void PrintLogo(Bool_t lite=kFALSE)Print the ROOT logo on standard output.Definition TRint.cxx:512; TRint::ExecLogonvoid ExecLogon()Execute logon macro's.Definition TRint.cxx:341; TRint::ProcessRemoteLongptr_t ProcessRemote(const char *line, Int_t *error=nullptr) overrideProcess the content of a line starting with "".R"" (already stripped-off) The format is [user@]host[:di...Definition TRint.cxx:768; TRint::fBackslashContinueBool_t fBackslashContinueDefinition TRint.h:41; TRint::fDefaultPromptTString fDefaultPromptDefinition TRint.h:35; TRint::fNonContinuePromptTString fNonContinuePromptDefinition TRint.h:36; TRint::fCaughtSignalInt_t fCaughtSignalDefinition TRint.h:39; TRint::fNcmdInt_t fNcmdDefinition TRint.h:34; TRint::TRintTRint(const TRint &)=delete; TRint::fInputHandlerTFileHandler * fInputHandlerDefinition TRint.h:40; TSignalHandlerDefinition TSysEvtHandler.h:127; TSignalHandler::Addvoid Add() overrideAdd signal handler to system signal handler list.Definition TSysEvtHandler.cxx:168; TSignalHandler::GetSignalESignals GetSignal() constDefinition TSysEvtHandler.h:141; TSignalHandler::fDelayInt_t fDelayDefinition TSysEvtHandler.h:132; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t r",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:45211,Availability,error,errorCode,45211,"irtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TTabComDefinition TTabCom.h:52; TTabCom::HookInt_t Hook(char *buf, int *pLoc, std::ostream &out)[private]Definition TTabCom.cxx:1567; TTabCom::ClearAllvoid ClearAll()clears all lists except for user names and system include files.Definition TTabCom.cxx:319; TTermInputHandlerDefinition TRint.cxx:121; TTermInputHandler::TTermInputHandlerTTermInputHandler(Int_t fd)Definition TRint.cxx:123; TTermInputHandler::ReadNotifyBool_t ReadNotify() overrideNotify when something can be read from the descriptor associated with this handler.Definition TRint.cxx:125; TTermInputHandler::NotifyBool_t Notify() overrideNotify implementation. Call the application interupt handler.Definition TRint.cxx:131; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::gMmallocDescR__EXTERN void * gMmallocDescDefinition TStorage.h:143; TClassEdit::DemangleTypeIdNamechar * DemangleTypeIdName(const std::type_info &ti, int &errorCode)Demangle in a portable way the type id name.Definition TClassEdit.cxx:2148. corerintsrcTRint.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:18777,Deployability,release,release,18777,"ines;; 518 // Here, %%s results in %s after TString::Format():; 519 lines.emplace_back(TString::Format(""Welcome to ROOT %s%%shttps://root.cern"",; 520 gROOT->GetVersion()));; 521 lines.emplace_back(TString::Format(""(c) 1995-2024, The ROOT Team; conception: R. Brun, F. Rademakers%%s""));; 522 lines.emplace_back(TString::Format(""Built for %s on %s%%s"", gSystem->GetBuildArch(), gROOT->GetGitDate()));; 523 if (!strcmp(gROOT->GetGitBranch(), gROOT->GetGitCommit())) {; 524 static const char *months[] = {""January"",""February"",""March"",""April"",""May"",; 525 ""June"",""July"",""August"",""September"",""October"",; 526 ""November"",""December""};; 527 Int_t idatqq = gROOT->GetVersionDate();; 528 Int_t iday = idatqq%100;; 529 Int_t imonth = (idatqq/100)%100;; 530 Int_t iyear = (idatqq/10000);; 531 ; 532 lines.emplace_back(TString::Format(""From tag %s, %d %s %4d%%s"",; 533 gROOT->GetGitBranch(),; 534 iday,months[imonth-1],iyear));; 535 } else {; 536 // If branch and commit are identical - e.g. ""v5-34-18"" - then we have; 537 // a release build. Else specify the git hash this build was made from.; 538 lines.emplace_back(TString::Format(""From %s@%s %%s"",; 539 gROOT->GetGitBranch(),; 540 gROOT->GetGitCommit()));; 541 }; 542 lines.emplace_back(TString::Format(""With %s %%s"",; 543 gSystem->GetBuildCompilerVersionStr()));; 544 lines.emplace_back(TString(""Try '.help'/'.?', '.demo', '.license', '.credits', '.quit'/'.q'%s""));; 545 ; 546 // Find the longest line and its length:; 547 auto itLongest = std::max_element(lines.begin(), lines.end(),; 548 [](const TString& left, const TString& right) {; 549 return left.Length() < right.Length(); });; 550 Ssiz_t lenLongest = itLongest->Length();; 551 ; 552 ; 553 Printf("" %s"", TString('-', lenLongest).Data());; 554 for (const auto& line: lines) {; 555 // Print the line, expanded with the necessary spaces at %s, and; 556 // surrounded by some ASCII art.; 557 Printf("" | %s |"",; 558 TString::Format(line.Data(),; 559 TString(' ', lenLongest - line.Length()).Data()).Data());",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:37615,Deployability,install,installation,37615,"ct::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TRintDefinition TRint.h:31; TRint::SetEchoModevoid SetEchoMode(Bool_t mode) overrideSet console mode:Definition TRint.cxx:752; TRint::HandleTermInputBool_t HandleTermInput() overrideHandle input coming from terminal.Definition TRint.cxx:611; TRint::fInterruptBool_t fInterruptDefinition TRint.h:38; TRint::Runvoid Run(Bool_t retrn=kFALSE) overrideMain application eventloop.Definition TRint.cxx:384; TRint::ProcessLineNrLongptr_t ProcessLineNr(const char *filestem, const char *line, Int_t *error=nullptr)Calls TRint::ProcessLine() possibly prepending a #line directive for better diagnostics.Definition TRint.cxx:791; TRint::SetPromptvirtual const char * SetPrompt(const char *newPrompt)Set a new default prompt.Definition TRint.cxx:595; TRint::Terminatevirtual void Terminate(int status) overrideTerminate the application.Definition TRint.cxx:722; TRint::fPromptchar fPrompt[64]Definition TRi",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:9550,Energy Efficiency,green,green,9550,"ntf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 // the History versions; 264 int hist_size = gEnv->GetValue(""Rint.HistorySize"", 500);; 265 if (hist_size == 500); 266 hist_size = gEnv->GetValue(""Rint.HistSize"", 500);; 267 int hist_save = gEnv->GetValue(""Rint.HistorySave"", 400);; 268 if (hist_save == 400); 269 hist_save = gEnv->GetValue(""Rint.HistSave"", 400);; 270 const char *envHist = gSystem->Getenv(""ROOT_HIST"");; 271 if (envHist) {; 272 hist_size = atoi(envHist);; 273 envHist = strchr(envHist, ':');; 274 if (envHist); 275 hist_save = atoi(envHist+1);; 276 }; 277 Gl_histsize(hist_size, hist_save);; 278 Gl_histinit((char *)logon);; 279 ; 280 // black on white or white on black?; 281 static const char* defaultColorsBW[] = {; 282 ""bold blue"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 283 };; 284 static const char* defaultColorsWB[] = {; 285 ""yellow"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 286 };; 287 ; 288 const char** defaultColors = defaultColorsBW;; 289 TString revColor = gEnv->GetValue(""Rint.ReverseColor"", ""no"");; 290 if (revColor.Contains(""yes"", TString::kIgnoreCase)) {; 291 defaultColors = defaultColorsWB;; 292 }; 293 TString colorType = gEnv->GetValue(""Rint.TypeColor"", defaultColors[0]);; 294 TString colorTabCom = gEnv->GetValue(""Rint.TabComColor"", defaultColors[1]);; 295 TString colorBracket = gEnv->GetValue(""Rint.BracketColor"", defaultColors[2]);; 296 TString colorBadBracket = gEnv->GetValue(""Rint.BadBracketColor"", defaultColors[3]);; 297 TString colorPrompt = gEnv->GetValue(""Rint.PromptColor"", defaultColors[4]);; 298 Gl_setColors(colorType, colorTabCom, colorBracket, colorBadBracket, colorPrompt);; 299 ; 300 Gl_windowchang",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:9677,Energy Efficiency,green,green,9677,"ntf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 // the History versions; 264 int hist_size = gEnv->GetValue(""Rint.HistorySize"", 500);; 265 if (hist_size == 500); 266 hist_size = gEnv->GetValue(""Rint.HistSize"", 500);; 267 int hist_save = gEnv->GetValue(""Rint.HistorySave"", 400);; 268 if (hist_save == 400); 269 hist_save = gEnv->GetValue(""Rint.HistSave"", 400);; 270 const char *envHist = gSystem->Getenv(""ROOT_HIST"");; 271 if (envHist) {; 272 hist_size = atoi(envHist);; 273 envHist = strchr(envHist, ':');; 274 if (envHist); 275 hist_save = atoi(envHist+1);; 276 }; 277 Gl_histsize(hist_size, hist_save);; 278 Gl_histinit((char *)logon);; 279 ; 280 // black on white or white on black?; 281 static const char* defaultColorsBW[] = {; 282 ""bold blue"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 283 };; 284 static const char* defaultColorsWB[] = {; 285 ""yellow"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 286 };; 287 ; 288 const char** defaultColors = defaultColorsBW;; 289 TString revColor = gEnv->GetValue(""Rint.ReverseColor"", ""no"");; 290 if (revColor.Contains(""yes"", TString::kIgnoreCase)) {; 291 defaultColors = defaultColorsWB;; 292 }; 293 TString colorType = gEnv->GetValue(""Rint.TypeColor"", defaultColors[0]);; 294 TString colorTabCom = gEnv->GetValue(""Rint.TabComColor"", defaultColors[1]);; 295 TString colorBracket = gEnv->GetValue(""Rint.BracketColor"", defaultColors[2]);; 296 TString colorBadBracket = gEnv->GetValue(""Rint.BadBracketColor"", defaultColors[3]);; 297 TString colorPrompt = gEnv->GetValue(""Rint.PromptColor"", defaultColors[4]);; 298 Gl_setColors(colorType, colorTabCom, colorBracket, colorBadBracket, colorPrompt);; 299 ; 300 Gl_windowchang",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:4994,Integrability,interface,interface,4994,"ation->HandleTermInput();; 134}; 135 ; 136 ; 137ClassImp(TRint);; 138 ; 139 ; 140namespace {; 141static int SetExtraClingArgsBeforeTAppCtor(Int_t *argc, char **argv); 142{; 143 bool forcePtrCheck = false;; 144 if (argc != nullptr) {; 145 for (int iarg = 1; iarg < *argc; ++iarg) {; 146 if (!strcmp(argv[iarg], ""--ptrcheck"")) {; 147 // Hide this, by moving all other args one down...; 148 for (int jarg = iarg + 1; jarg < *argc; ++jarg); 149 argv[jarg - 1] = argv[jarg];; 150 // ... and updating argc accordingly.; 151 --*argc;; 152 forcePtrCheck = true;; 153 break;; 154 }; 155 }; 156 }; 157#ifdef R__UNIX; 158 if (forcePtrCheck || isatty(0) || isatty(1)); 159#endif; 160 TROOT::AddExtraInterpreterArgs({""--ptrcheck""});; 161 return 0;; 162}; 163}; 164 ; 165////////////////////////////////////////////////////////////////////////////////; 166/// Create an application environment. The TRint environment provides an; 167/// interface to the WM manager functionality and eventloop via inheritance; 168/// of TApplication and in addition provides interactive access to; 169/// the Cling C++ interpreter via the command line.; 170 ; 171TRint::TRint(const char *appClassName, Int_t *argc, char **argv, void *options, Int_t numOptions, Bool_t noLogo,; 172 Bool_t exitOnUnknownArgs); 173 : TApplication(appClassName, argc, argv, options, numOptions + SetExtraClingArgsBeforeTAppCtor(argc, argv)),; 174 fCaughtSignal(-1); 175{; 176 ; 177 if (exitOnUnknownArgs && argc != nullptr && *argc > 1) {; 178 // Early exit if there are remaining unrecognized options; 179 // This branch supposes that TRint is created as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:31389,Integrability,interface,interfaces,31389,"terminal to non-raw mode.Definition TRint.cxx:74; Key_Pressedstatic Int_t Key_Pressed(Int_t key)Definition TRint.cxx:56; BeepHookstatic Int_t BeepHook()Definition TRint.cxx:64; TRint.h; TStopwatch.h; TStorage.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TSysEvtHandler.h; kSigInterrupt@ kSigInterruptDefinition TSysEvtHandler.h:115; TSystemDirectory.h; TSystem.h; kReadPermission@ kReadPermissionDefinition TSystem.h:45; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTabCom.h; gTabComR__EXTERN TTabCom * gTabComDefinition TTabCom.h:229; TVirtualX.h; gVirtualX#define gVirtualXDefinition TVirtualX.h:337; ThreadLocalStorage.h; free#define freeDefinition civetweb.c:1539; snprintf#define snprintfDefinition civetweb.c:1540; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::kProcessRemotely@ kProcessRemot",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:32587,Integrability,depend,dependent,32587,"n.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::ReturnFromRunBool_t ReturnFromRun() constDefinition TApplication.h:153; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::HandleExceptionvirtual void HandleException(Int_t sig)Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingExcepti...Definition TApplication.cxx:590; TApplication::Argvchar ** Argv() constDefinition TApplication.h:141; TApplication::Terminatevirtual void Terminate(Int_t status=0)Terminate the application by call TSystem::Exit() unless application has been told to return from Run...Definition TApplication.cxx:1927; TApplication::ApplicationNamevirtual const char * ApplicationName() constDefinition TApplication.h:128; TApplication::ProcessFilevirtual Longptr_t ProcessFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Process a file containing a C++ macro.Definition TApplication.cxx:1720; TApplication::ReturnPressedvirtual void ReturnPressed(char *text)Emit signal when return key was pressed.Definition TApplication.cxx:1957; TApplication::kExpression@ kExpressionDef",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:37016,Integrability,message,message,37016,"Named.h:29; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::SetOptionvirtual void SetOption(Option_t *)Definition TList.h:150; TObjLink::SetObjectvoid SetObject(TObject *obj)Definition TList.h:147; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TRintDefinition TRint.h:31; TRint::SetEchoModevoid SetEchoMode(Bool_t mode) overrideSet console mode:Definition TRint.cxx:752; TRint::HandleTermInputBool_t HandleTermInput() overrideHandle input coming from terminal.Definition TRint.cxx:611; TRint::fInterruptBool_t fInterruptDefinition TRint.h:38; TRint::Runvoid Run(Bool_t retrn=",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:5054,Modifiability,inherit,inheritance,5054,"ation->HandleTermInput();; 134}; 135 ; 136 ; 137ClassImp(TRint);; 138 ; 139 ; 140namespace {; 141static int SetExtraClingArgsBeforeTAppCtor(Int_t *argc, char **argv); 142{; 143 bool forcePtrCheck = false;; 144 if (argc != nullptr) {; 145 for (int iarg = 1; iarg < *argc; ++iarg) {; 146 if (!strcmp(argv[iarg], ""--ptrcheck"")) {; 147 // Hide this, by moving all other args one down...; 148 for (int jarg = iarg + 1; jarg < *argc; ++jarg); 149 argv[jarg - 1] = argv[jarg];; 150 // ... and updating argc accordingly.; 151 --*argc;; 152 forcePtrCheck = true;; 153 break;; 154 }; 155 }; 156 }; 157#ifdef R__UNIX; 158 if (forcePtrCheck || isatty(0) || isatty(1)); 159#endif; 160 TROOT::AddExtraInterpreterArgs({""--ptrcheck""});; 161 return 0;; 162}; 163}; 164 ; 165////////////////////////////////////////////////////////////////////////////////; 166/// Create an application environment. The TRint environment provides an; 167/// interface to the WM manager functionality and eventloop via inheritance; 168/// of TApplication and in addition provides interactive access to; 169/// the Cling C++ interpreter via the command line.; 170 ; 171TRint::TRint(const char *appClassName, Int_t *argc, char **argv, void *options, Int_t numOptions, Bool_t noLogo,; 172 Bool_t exitOnUnknownArgs); 173 : TApplication(appClassName, argc, argv, options, numOptions + SetExtraClingArgsBeforeTAppCtor(argc, argv)),; 174 fCaughtSignal(-1); 175{; 176 ; 177 if (exitOnUnknownArgs && argc != nullptr && *argc > 1) {; 178 // Early exit if there are remaining unrecognized options; 179 // This branch supposes that TRint is created as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:6924,Modifiability,variab,variable,6924,"(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",lo",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7037,Modifiability,variab,variable,7037," ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 2",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7226,Modifiability,variab,variable,7226,"ly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TIn",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:24646,Modifiability,variab,variable,24646,"fInputHandler->Activate();; 689 ; 690 if (!sline.BeginsWith("".reset"")); 691 gCling->EndOfLineAction();; 692 ; 693 gTabCom->ClearAll();; 694 Getlinem(kInit, GetPrompt());; 695 }; 696 return kTRUE;; 697}; 698 ; 699////////////////////////////////////////////////////////////////////////////////; 700/// Handle signals (kSigBus, kSigSegmentationViolation,; 701/// kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; 702/// Specific TApplication implementations may want something different here.; 703 ; 704void TRint::HandleException(Int_t sig); 705{; 706 fCaughtSignal = sig;; 707 if (TROOT::Initialized()) {; 708 if (gException) {; 709 Getlinem(kCleanUp, nullptr);; 710 Getlinem(kInit, ""Root > "");; 711 }; 712 }; 713 TApplication::HandleException(sig);; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Terminate the application. Reset the terminal to sane mode and call; 718/// the logoff macro defined via Rint.Logoff environment variable.; 719/// @note The function does not return, unless the class has; 720/// been told to return from Run(), by a call to SetReturnFromRun().; 721 ; 722void TRint::Terminate(Int_t status); 723{; 724 Getlinem(kCleanUp, nullptr);; 725 ; 726 if (ReturnFromRun()) {; 727 gSystem->ExitLoop();; 728 } else {; 729 delete gTabCom;; 730 gTabCom = nullptr;; 731 ; 732 //Execute logoff macro; 733 const char *logoff;; 734 logoff = gEnv->GetValue(""Rint.Logoff"", (char*)nullptr);; 735 if (logoff && !NoLogOpt()) {; 736 char *mac = gSystem->Which(TROOT::GetMacroPath(), logoff, kReadPermission);; 737 if (mac); 738 ProcessFile(logoff);; 739 delete [] mac;; 740 }; 741 ; 742 TApplication::Terminate(status);; 743 }; 744}; 745 ; 746////////////////////////////////////////////////////////////////////////////////; 747/// Set console mode:; 748///; 749/// mode = kTRUE - echo input symbols; 750/// mode = kFALSE - noecho input symbols; 751 ; 752void TRint::SetEchoMode(Bool_t mode); 753{; 754 Gl_config(""no",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:25928,Modifiability,variab,variable,25928,"omRun()) {; 727 gSystem->ExitLoop();; 728 } else {; 729 delete gTabCom;; 730 gTabCom = nullptr;; 731 ; 732 //Execute logoff macro; 733 const char *logoff;; 734 logoff = gEnv->GetValue(""Rint.Logoff"", (char*)nullptr);; 735 if (logoff && !NoLogOpt()) {; 736 char *mac = gSystem->Which(TROOT::GetMacroPath(), logoff, kReadPermission);; 737 if (mac); 738 ProcessFile(logoff);; 739 delete [] mac;; 740 }; 741 ; 742 TApplication::Terminate(status);; 743 }; 744}; 745 ; 746////////////////////////////////////////////////////////////////////////////////; 747/// Set console mode:; 748///; 749/// mode = kTRUE - echo input symbols; 750/// mode = kFALSE - noecho input symbols; 751 ; 752void TRint::SetEchoMode(Bool_t mode); 753{; 754 Gl_config(""noecho"", mode ? 0 : 1);; 755}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Process the content of a line starting with "".R"" (already stripped-off); 759/// The format is; 760/// [user@]host[:dir] [-l user] [-d dbg] [script]; 761/// The variable 'dir' is the remote directory to be used as working dir.; 762/// The username can be specified in two ways, ""-l"" having the priority; 763/// (as in ssh).; 764/// A 'dbg' value > 0 gives increasing verbosity.; 765/// The last argument 'script' allows to specify an alternative script to; 766/// be executed remotely to startup the session.; 767 ; 768Longptr_t TRint::ProcessRemote(const char *line, Int_t *); 769{; 770 Longptr_t ret = TApplication::ProcessRemote(line);; 771 ; 772 if (ret == 1) {; 773 if (fAppRemote) {; 774 TString prompt; prompt.Form(""%s:root [%%d] "", fAppRemote->ApplicationName());; 775 SetPrompt(prompt);; 776 } else {; 777 SetPrompt(""root [%d] "");; 778 }; 779 }; 780 ; 781 return ret;; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Calls TRint::ProcessLine() possibly prepending a `#line` directive for; 787/// better diagnostics.; 788/// The user is responsible for incrementing `",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:42737,Modifiability,variab,variable,42737,"sNullBool_t IsNull() constDefinition TString.h:414; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSysEvtHandler::DeActivatevoid DeActivate()De-activate a system event handler.Definition TSysEvtHandler.cxx:46; TSysEvtHandler::Activatevoid Activate()Activate a system event handler.Definition TSysEvtHandler.cxx:32; TSystemDirectoryDescribes an Operating System directory for the browser.Definition TSystemDirectory.h:32; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::Worki",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:45235,Modifiability,portab,portable,45235,"irtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TTabComDefinition TTabCom.h:52; TTabCom::HookInt_t Hook(char *buf, int *pLoc, std::ostream &out)[private]Definition TTabCom.cxx:1567; TTabCom::ClearAllvoid ClearAll()clears all lists except for user names and system include files.Definition TTabCom.cxx:319; TTermInputHandlerDefinition TRint.cxx:121; TTermInputHandler::TTermInputHandlerTTermInputHandler(Int_t fd)Definition TRint.cxx:123; TTermInputHandler::ReadNotifyBool_t ReadNotify() overrideNotify when something can be read from the descriptor associated with this handler.Definition TRint.cxx:125; TTermInputHandler::NotifyBool_t Notify() overrideNotify implementation. Call the application interupt handler.Definition TRint.cxx:131; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::gMmallocDescR__EXTERN void * gMmallocDescDefinition TStorage.h:143; TClassEdit::DemangleTypeIdNamechar * DemangleTypeIdName(const std::type_info &ti, int &errorCode)Demangle in a portable way the type id name.Definition TClassEdit.cxx:2148. corerintsrcTRint.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:6220,Performance,load,load,6220,"assName, Int_t *argc, char **argv, void *options, Int_t numOptions, Bool_t noLogo,; 172 Bool_t exitOnUnknownArgs); 173 : TApplication(appClassName, argc, argv, options, numOptions + SetExtraClingArgsBeforeTAppCtor(argc, argv)),; 174 fCaughtSignal(-1); 175{; 176 ; 177 if (exitOnUnknownArgs && argc != nullptr && *argc > 1) {; 178 // Early exit if there are remaining unrecognized options; 179 // This branch supposes that TRint is created as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variabl",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:6255,Performance,load,loaded,6255,"assName, Int_t *argc, char **argv, void *options, Int_t numOptions, Bool_t noLogo,; 172 Bool_t exitOnUnknownArgs); 173 : TApplication(appClassName, argc, argv, options, numOptions + SetExtraClingArgsBeforeTAppCtor(argc, argv)),; 174 fCaughtSignal(-1); 175{; 176 ; 177 if (exitOnUnknownArgs && argc != nullptr && *argc > 1) {; 178 // Early exit if there are remaining unrecognized options; 179 // This branch supposes that TRint is created as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variabl",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:6689,Performance,load,load,6689," as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 //",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:6975,Performance,load,loading,6975,"""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // E",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7064,Performance,load,load,7064," ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 2",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7144,Performance,load,load,7144,"ly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TIn",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:12358,Safety,avoid,avoid,12358,"26// TSignalHandler *ih = GetSignalHandler();; 327// ih->Remove();; 328// SetSignalHandler(0);; 329// delete ih;; 330}; 331 ; 332////////////////////////////////////////////////////////////////////////////////; 333/// Execute logon macro's. There are three levels of logon macros that; 334/// will be executed: the system logon etc/system.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which cas",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:16121,Safety,avoid,avoid,16121,").BeginsWith(""\\\\"")); 444 file->String().Prepend(""\\\\"");; 445 file->String().ReplaceAll(""\\"",""/"");; 446 const char *rfile = (const char*)file->String();; 447 Printf(""Attaching file %s as _file%d..."", rfile, nfile);; 448 snprintf(cmd, kMAXPATHLEN+50, ""TFile *_file%d = TFile::Open(\""%s\"")"", nfile++, rfile);; 449 } else {; 450 Printf(""Processing %s..."", (const char*)file->String());; 451 snprintf(cmd, kMAXPATHLEN+50, "".x %s"", (const char*)file->String());; 452 }; 453 }; 454 Getlinem(kCleanUp, nullptr);; 455 Gl_histadd(cmd);; 456 ; 457 // The ProcessLine might throw an 'exception'. In this case,; 458 // GetLinem(kInit,""Root >"") is called and we are jump back; 459 // to RETRY ... and we have to avoid the Getlinem(kInit, GetPrompt());; 460 needGetlinemInit = kFALSE;; 461 retval = ProcessLineNr(""ROOT_cli_"", cmd, &error);; 462 gCling->EndOfLineAction();; 463 fNcmd++;; 464 ; 465 // The ProcessLine has successfully completed and we need; 466 // to call Getlinem(kInit, GetPrompt());; 467 needGetlinemInit = kTRUE;; 468 ; 469 if (error != 0 || fCaughtSignal != -1) break;; 470 }; 471 } ENDTRY;; 472 ; 473 if (QuitOpt()) {; 474 if (retrn) return;; 475 if (error) {; 476 retval = error;; 477 } else if (fCaughtSignal != -1) {; 478 retval = fCaughtSignal + 128;; 479 }; 480 // Bring retval into sensible range, 0..255.; 481 if (retval < 0 || retval > 255); 482 retval = 255;; 483 Terminate(retval);; 484 }; 485 ; 486 // Allow end-of-file on the terminal to be noticed; 487 // after we finish processing the command line input files.; 488 fInputHandler->Activate();; 489 ; 490 ClearInputFiles();; 491 ; 492 if (needGetlinemInit) Getlinem(kInit, GetPrompt());; 493 }; 494 ; 495 if (QuitOpt()) {; 496 printf(""\n"");; 497 if (retrn) return;; 498 Terminate(fCaughtSignal != -1 ? fCaughtSignal + 128 : 0);; 499 }; 500 ; 501 TApplication::Run(retrn);; 502 ; 503 // Reset to happiness.; 504 fCaughtSignal = -1;; 505 ; 506 Getlinem(kCleanUp, nullptr);; 507}; 508 ; 509////////////////////////////////////////",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:789,Security,access,access,789,". ROOT: core/rint/src/TRint.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TRint.cxx. Go to the documentation of this file. 1// @(#)root/rint:$Id$; 2// Author: Rene Brun 17/02/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12//////////////////////////////////////////////////////////////////////////; 13// //; 14// Rint //; 15// //; 16// Rint is the ROOT Interactive Interface. It allows interactive access //; 17// to the ROOT system via the Cling C/C++ interpreter. //; 18// //; 19//////////////////////////////////////////////////////////////////////////; 20 ; 21#include ""TROOT.h""; 22#include ""TClass.h""; 23#include ""TClassEdit.h""; 24#include ""TVirtualX.h""; 25#include ""TObjectTable.h""; 26#include ""TClassTable.h""; 27#include ""TStopwatch.h""; 28#include ""TBenchmark.h""; 29#include ""TRint.h""; 30#include ""TSystem.h""; 31#include ""TEnv.h""; 32#include ""TSysEvtHandler.h""; 33#include ""TSystemDirectory.h""; 34#include ""TError.h""; 35#include ""TException.h""; 36#include ""TInterpreter.h""; 37#include ""TObjString.h""; 38#include ""TObjArray.h""; 39#include ""TStorage.h"" // ROOT::Internal::gMmallocDesc; 40#include ""ThreadLocalStorage.h""; 41#include ""TTabCom.h""; 42#include <cstdlib>; 43#include <algorithm>; 44#include <iostream>; 45#include ""Getline.h""; 46#include ""strlcpy.h""; 47#include ""snprintf.h""; 48 ; 49#ifdef R__UNIX; 50#include <signal.h>; 51#include <unistd.h>; 52#endif; 53 ; 54////////////////////////////////////////////////////////////////////////////////; 55 ; 56static Int_t Key_Pressed(Int_t key); 57{; 58 gApplication->KeyPressed(key);; 59 return 0;; 60}; 61 ; 62////////////////////////////////////////",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:5127,Security,access,access,5127,"ation->HandleTermInput();; 134}; 135 ; 136 ; 137ClassImp(TRint);; 138 ; 139 ; 140namespace {; 141static int SetExtraClingArgsBeforeTAppCtor(Int_t *argc, char **argv); 142{; 143 bool forcePtrCheck = false;; 144 if (argc != nullptr) {; 145 for (int iarg = 1; iarg < *argc; ++iarg) {; 146 if (!strcmp(argv[iarg], ""--ptrcheck"")) {; 147 // Hide this, by moving all other args one down...; 148 for (int jarg = iarg + 1; jarg < *argc; ++jarg); 149 argv[jarg - 1] = argv[jarg];; 150 // ... and updating argc accordingly.; 151 --*argc;; 152 forcePtrCheck = true;; 153 break;; 154 }; 155 }; 156 }; 157#ifdef R__UNIX; 158 if (forcePtrCheck || isatty(0) || isatty(1)); 159#endif; 160 TROOT::AddExtraInterpreterArgs({""--ptrcheck""});; 161 return 0;; 162}; 163}; 164 ; 165////////////////////////////////////////////////////////////////////////////////; 166/// Create an application environment. The TRint environment provides an; 167/// interface to the WM manager functionality and eventloop via inheritance; 168/// of TApplication and in addition provides interactive access to; 169/// the Cling C++ interpreter via the command line.; 170 ; 171TRint::TRint(const char *appClassName, Int_t *argc, char **argv, void *options, Int_t numOptions, Bool_t noLogo,; 172 Bool_t exitOnUnknownArgs); 173 : TApplication(appClassName, argc, argv, options, numOptions + SetExtraClingArgsBeforeTAppCtor(argc, argv)),; 174 fCaughtSignal(-1); 175{; 176 ; 177 if (exitOnUnknownArgs && argc != nullptr && *argc > 1) {; 178 // Early exit if there are remaining unrecognized options; 179 // This branch supposes that TRint is created as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:18813,Security,hash,hash,18813,":Format():; 519 lines.emplace_back(TString::Format(""Welcome to ROOT %s%%shttps://root.cern"",; 520 gROOT->GetVersion()));; 521 lines.emplace_back(TString::Format(""(c) 1995-2024, The ROOT Team; conception: R. Brun, F. Rademakers%%s""));; 522 lines.emplace_back(TString::Format(""Built for %s on %s%%s"", gSystem->GetBuildArch(), gROOT->GetGitDate()));; 523 if (!strcmp(gROOT->GetGitBranch(), gROOT->GetGitCommit())) {; 524 static const char *months[] = {""January"",""February"",""March"",""April"",""May"",; 525 ""June"",""July"",""August"",""September"",""October"",; 526 ""November"",""December""};; 527 Int_t idatqq = gROOT->GetVersionDate();; 528 Int_t iday = idatqq%100;; 529 Int_t imonth = (idatqq/100)%100;; 530 Int_t iyear = (idatqq/10000);; 531 ; 532 lines.emplace_back(TString::Format(""From tag %s, %d %s %4d%%s"",; 533 gROOT->GetGitBranch(),; 534 iday,months[imonth-1],iyear));; 535 } else {; 536 // If branch and commit are identical - e.g. ""v5-34-18"" - then we have; 537 // a release build. Else specify the git hash this build was made from.; 538 lines.emplace_back(TString::Format(""From %s@%s %%s"",; 539 gROOT->GetGitBranch(),; 540 gROOT->GetGitCommit()));; 541 }; 542 lines.emplace_back(TString::Format(""With %s %%s"",; 543 gSystem->GetBuildCompilerVersionStr()));; 544 lines.emplace_back(TString(""Try '.help'/'.?', '.demo', '.license', '.credits', '.quit'/'.q'%s""));; 545 ; 546 // Find the longest line and its length:; 547 auto itLongest = std::max_element(lines.begin(), lines.end(),; 548 [](const TString& left, const TString& right) {; 549 return left.Length() < right.Length(); });; 550 Ssiz_t lenLongest = itLongest->Length();; 551 ; 552 ; 553 Printf("" %s"", TString('-', lenLongest).Data());; 554 for (const auto& line: lines) {; 555 // Print the line, expanded with the necessary spaces at %s, and; 556 // surrounded by some ASCII art.; 557 Printf("" | %s |"",; 558 TString::Format(line.Data(),; 559 TString(' ', lenLongest - line.Length()).Data()).Data());; 560 }; 561 Printf("" %s\n"", TString('-', lenLonges",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:34654,Security,hash,hash,34654,"ssionDefinition TApplication.h:49; TApplication::NoLogOptBool_t NoLogOpt() constDefinition TApplication.h:143; TApplication::NoLogoOptBool_t NoLogoOpt() constDefinition TApplication.h:144; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::SetSignalHandlervoid SetSignalHandler(TSignalHandler *sh)Definition TApplication.h:92; TBenchmarkThis class is a ROOT utility to help benchmarking applications.Definition TBenchmark.h:29; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFileHandlerDefinition TSysEvtHandler.h:65; TFileHandler::Removevoid Remove() overrideRemove file event handler from system file handler list.Definition TSysEvtHandler.cxx:137; TFileHandler::Addvoid Add() overrideAdd file event handler to system file handler list.Definition TSysEvtHandler.cxx:126; TInterpreter::GetPromptvirtual char * GetPrompt()=0; TInterpreter::SaveGlobalsContextvirtual void SaveGlobalsContext()=0; TInterpreter::EndOfLineActionvirtual void EndOfLineAction()=0; TInterpreter::Resetvirtual void Reset()=0; TInterpreter::SetGetlinevirtual void SetGetline(const char *(*getlineFunc)(const char *prompt), void(*histaddFunc)(const char *line))=0; TInterpreter::SaveContextvirtual void SaveContext()=0; TInterpreter::GetMorevirtual Int",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:43234,Security,access,access,43234,"ivatevoid DeActivate()De-activate a system event handler.Definition TSysEvtHandler.cxx:46; TSysEvtHandler::Activatevoid Activate()Activate a system event handler.Definition TSysEvtHandler.cxx:32; TSystemDirectoryDescribes an Operating System directory for the browser.Definition TSystemDirectory.h:32; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:43268,Security,access,access,43268,"ivatevoid DeActivate()De-activate a system event handler.Definition TSysEvtHandler.cxx:46; TSysEvtHandler::Activatevoid Activate()Activate a system event handler.Definition TSysEvtHandler.cxx:32; TSystemDirectoryDescribes an Operating System directory for the browser.Definition TSystemDirectory.h:32; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7710,Testability,log,logon,7710,"1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the co",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7722,Testability,log,logon,7722,"1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the co",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7784,Testability,log,logon,7784,"mory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7848,Testability,log,logon,7848,"mory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7917,Testability,log,logon,7917,"nd setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 // the History versions; 264 int hist_size = gEnv->GetValue(""Rint.HistorySize"", 500);; 265 if (hist_size == 500); 266 hist_size = gEnv->GetValue(""Rint.HistSize"", 500);; 267 int hist_save = gEnv->GetValue(""Rint.HistorySave"", 400);; 268 if (hist_save == 400); 269 hist_save = gEnv->GetValue(""Rint.HistSave"", 400);; 270 const char *envHist = gSystem->Getenv(""ROOT_HIST"");; 271 if (env",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:7982,Testability,log,logon,7982,"nd setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 // the History versions; 264 int hist_size = gEnv->GetValue(""Rint.HistorySize"", 500);; 265 if (hist_size == 500); 266 hist_size = gEnv->GetValue(""Rint.HistSize"", 500);; 267 int hist_save = gEnv->GetValue(""Rint.HistorySave"", 400);; 268 if (hist_save == 400); 269 hist_save = gEnv->GetValue(""Rint.HistSave"", 400);; 270 const char *envHist = gSystem->Getenv(""ROOT_HIST"");; 271 if (env",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:8556,Testability,log,logon,8556,"3 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 // the History versions; 264 int hist_size = gEnv->GetValue(""Rint.HistorySize"", 500);; 265 if (hist_size == 500); 266 hist_size = gEnv->GetValue(""Rint.HistSize"", 500);; 267 int hist_save = gEnv->GetValue(""Rint.HistorySave"", 400);; 268 if (hist_save == 400); 269 hist_save = gEnv->GetValue(""Rint.HistSave"", 400);; 270 const char *envHist = gSystem->Getenv(""ROOT_HIST"");; 271 if (envHist) {; 272 hist_size = atoi(envHist);; 273 envHist = strchr(envHist, ':');; 274 if (envHist); 275 hist_save = atoi(envHist+1);; 276 }; 277 Gl_histsize(hist_size, hist_save);; 278 Gl_histinit((char *)logon);; 279 ; 280 // black on white or white on black?; 281 static const char* defaultColorsBW[] = {; 282 ""bold blue"", ""magenta"", ""bold",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:9413,Testability,log,logon,9413,"ntf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 // the History versions; 264 int hist_size = gEnv->GetValue(""Rint.HistorySize"", 500);; 265 if (hist_size == 500); 266 hist_size = gEnv->GetValue(""Rint.HistSize"", 500);; 267 int hist_save = gEnv->GetValue(""Rint.HistorySave"", 400);; 268 if (hist_save == 400); 269 hist_save = gEnv->GetValue(""Rint.HistSave"", 400);; 270 const char *envHist = gSystem->Getenv(""ROOT_HIST"");; 271 if (envHist) {; 272 hist_size = atoi(envHist);; 273 envHist = strchr(envHist, ':');; 274 if (envHist); 275 hist_save = atoi(envHist+1);; 276 }; 277 Gl_histsize(hist_size, hist_save);; 278 Gl_histinit((char *)logon);; 279 ; 280 // black on white or white on black?; 281 static const char* defaultColorsBW[] = {; 282 ""bold blue"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 283 };; 284 static const char* defaultColorsWB[] = {; 285 ""yellow"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 286 };; 287 ; 288 const char** defaultColors = defaultColorsBW;; 289 TString revColor = gEnv->GetValue(""Rint.ReverseColor"", ""no"");; 290 if (revColor.Contains(""yes"", TString::kIgnoreCase)) {; 291 defaultColors = defaultColorsWB;; 292 }; 293 TString colorType = gEnv->GetValue(""Rint.TypeColor"", defaultColors[0]);; 294 TString colorTabCom = gEnv->GetValue(""Rint.TabComColor"", defaultColors[1]);; 295 TString colorBracket = gEnv->GetValue(""Rint.BracketColor"", defaultColors[2]);; 296 TString colorBadBracket = gEnv->GetValue(""Rint.BadBracketColor"", defaultColors[3]);; 297 TString colorPrompt = gEnv->GetValue(""Rint.PromptColor"", defaultColors[4]);; 298 Gl_setColors(colorType, colorTabCom, colorBracket, colorBadBracket, colorPrompt);; 299 ; 300 Gl_windowchang",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:11392,Testability,log,logon,11392," 297 TString colorPrompt = gEnv->GetValue(""Rint.PromptColor"", defaultColors[4]);; 298 Gl_setColors(colorType, colorTabCom, colorBracket, colorBadBracket, colorPrompt);; 299 ; 300 Gl_windowchanged();; 301 ; 302 atexit(ResetTermAtExit);; 303 ; 304 // Setup for tab completion; 305 gTabCom = new TTabCom;; 306 Gl_in_key = &Key_Pressed;; 307 Gl_beep_hook = &BeepHook;; 308 ; 309 // tell Cling to use our getline; 310 gCling->SetGetline(Getline, Gl_histadd);; 311}; 312 ; 313////////////////////////////////////////////////////////////////////////////////; 314/// Destructor.; 315 ; 316TRint::~TRint(); 317{; 318 delete gTabCom;; 319 gTabCom = nullptr;; 320 Gl_in_key = nullptr;; 321 Gl_beep_hook = nullptr;; 322 fInputHandler->Remove();; 323 delete fInputHandler;; 324 // We can't know where the signal handler was changed since we started ...; 325 // so for now let's not delete it.; 326// TSignalHandler *ih = GetSignalHandler();; 327// ih->Remove();; 328// SetSignalHandler(0);; 329// delete ih;; 330}; 331 ; 332////////////////////////////////////////////////////////////////////////////////; 333/// Execute logon macro's. There are three levels of logon macros that; 334/// will be executed: the system logon etc/system.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, k",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:11433,Testability,log,logon,11433,"9 ; 300 Gl_windowchanged();; 301 ; 302 atexit(ResetTermAtExit);; 303 ; 304 // Setup for tab completion; 305 gTabCom = new TTabCom;; 306 Gl_in_key = &Key_Pressed;; 307 Gl_beep_hook = &BeepHook;; 308 ; 309 // tell Cling to use our getline; 310 gCling->SetGetline(Getline, Gl_histadd);; 311}; 312 ; 313////////////////////////////////////////////////////////////////////////////////; 314/// Destructor.; 315 ; 316TRint::~TRint(); 317{; 318 delete gTabCom;; 319 gTabCom = nullptr;; 320 Gl_in_key = nullptr;; 321 Gl_beep_hook = nullptr;; 322 fInputHandler->Remove();; 323 delete fInputHandler;; 324 // We can't know where the signal handler was changed since we started ...; 325 // so for now let's not delete it.; 326// TSignalHandler *ih = GetSignalHandler();; 327// ih->Remove();; 328// SetSignalHandler(0);; 329// delete ih;; 330}; 331 ; 332////////////////////////////////////////////////////////////////////////////////; 333/// Execute logon macro's. There are three levels of logon macros that; 334/// will be executed: the system logon etc/system.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDir",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:11488,Testability,log,logon,11488,"9 ; 300 Gl_windowchanged();; 301 ; 302 atexit(ResetTermAtExit);; 303 ; 304 // Setup for tab completion; 305 gTabCom = new TTabCom;; 306 Gl_in_key = &Key_Pressed;; 307 Gl_beep_hook = &BeepHook;; 308 ; 309 // tell Cling to use our getline; 310 gCling->SetGetline(Getline, Gl_histadd);; 311}; 312 ; 313////////////////////////////////////////////////////////////////////////////////; 314/// Destructor.; 315 ; 316TRint::~TRint(); 317{; 318 delete gTabCom;; 319 gTabCom = nullptr;; 320 Gl_in_key = nullptr;; 321 Gl_beep_hook = nullptr;; 322 fInputHandler->Remove();; 323 delete fInputHandler;; 324 // We can't know where the signal handler was changed since we started ...; 325 // so for now let's not delete it.; 326// TSignalHandler *ih = GetSignalHandler();; 327// ih->Remove();; 328// SetSignalHandler(0);; 329// delete ih;; 330}; 331 ; 332////////////////////////////////////////////////////////////////////////////////; 333/// Execute logon macro's. There are three levels of logon macros that; 334/// will be executed: the system logon etc/system.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDir",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:11542,Testability,log,logon,11542,"Setup for tab completion; 305 gTabCom = new TTabCom;; 306 Gl_in_key = &Key_Pressed;; 307 Gl_beep_hook = &BeepHook;; 308 ; 309 // tell Cling to use our getline; 310 gCling->SetGetline(Getline, Gl_histadd);; 311}; 312 ; 313////////////////////////////////////////////////////////////////////////////////; 314/// Destructor.; 315 ; 316TRint::~TRint(); 317{; 318 delete gTabCom;; 319 gTabCom = nullptr;; 320 Gl_in_key = nullptr;; 321 Gl_beep_hook = nullptr;; 322 fInputHandler->Remove();; 323 delete fInputHandler;; 324 // We can't know where the signal handler was changed since we started ...; 325 // so for now let's not delete it.; 326// TSignalHandler *ih = GetSignalHandler();; 327// ih->Remove();; 328// SetSignalHandler(0);; 329// delete ih;; 330}; 331 ; 332////////////////////////////////////////////////////////////////////////////////; 333/// Execute logon macro's. There are three levels of logon macros that; 334/// will be executed: the system logon etc/system.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 P",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:11637,Testability,log,logon,11637,"k = &BeepHook;; 308 ; 309 // tell Cling to use our getline; 310 gCling->SetGetline(Getline, Gl_histadd);; 311}; 312 ; 313////////////////////////////////////////////////////////////////////////////////; 314/// Destructor.; 315 ; 316TRint::~TRint(); 317{; 318 delete gTabCom;; 319 gTabCom = nullptr;; 320 Gl_in_key = nullptr;; 321 Gl_beep_hook = nullptr;; 322 fInputHandler->Remove();; 323 delete fInputHandler;; 324 // We can't know where the signal handler was changed since we started ...; 325 // so for now let's not delete it.; 326// TSignalHandler *ih = GetSignalHandler();; 327// ih->Remove();; 328// SetSignalHandler(0);; 329// delete ih;; 330}; 331 ; 332////////////////////////////////////////////////////////////////////////////////; 333/// Execute logon macro's. There are three levels of logon macros that; 334/// will be executed: the system logon etc/system.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 c",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:11764,Testability,log,logon,11764,"//////////////////////////////////; 314/// Destructor.; 315 ; 316TRint::~TRint(); 317{; 318 delete gTabCom;; 319 gTabCom = nullptr;; 320 Gl_in_key = nullptr;; 321 Gl_beep_hook = nullptr;; 322 fInputHandler->Remove();; 323 delete fInputHandler;; 324 // We can't know where the signal handler was changed since we started ...; 325 // so for now let's not delete it.; 326// TSignalHandler *ih = GetSignalHandler();; 327// ih->Remove();; 328// SetSignalHandler(0);; 329// delete ih;; 330}; 331 ; 332////////////////////////////////////////////////////////////////////////////////; 333/// Execute logon macro's. There are three levels of logon macros that; 334/// will be executed: the system logon etc/system.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:12589,Testability,log,logon,12589,"m.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void T",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:12644,Testability,log,logon,12644,"ro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void TRint::Run(Bool_t retrn); 385{; 386 if (!QuitOpt()) {; 387 // Prompt prompt only if we are expecting / allowing input.; 388 Getlinem(kInit, GetP",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:12707,Testability,log,logon,12707," the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void TRint::Run(Bool_t retrn); 385{; 386 if (!QuitOpt()) {; 387 // Prompt prompt only if we are expecting / allowing input.; 388 Getlinem(kInit, GetPrompt());; 389 }; 390 ; 391 Longptr_t retval = 0;; 392 Int_t error = 0;; 393 volatile Bool_t needGetlinemInit = kFALSE;; 394 ; 395 if (strlen(WorkingDirectory())) {; 396 // if directory s",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:12771,Testability,log,logon,12771," the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void TRint::Run(Bool_t retrn); 385{; 386 if (!QuitOpt()) {; 387 // Prompt prompt only if we are expecting / allowing input.; 388 Getlinem(kInit, GetPrompt());; 389 }; 390 ; 391 Longptr_t retval = 0;; 392 Int_t error = 0;; 393 volatile Bool_t needGetlinemInit = kFALSE;; 394 ; 395 if (strlen(WorkingDirectory())) {; 396 // if directory s",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:12827,Testability,log,logon,12827," the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void TRint::Run(Bool_t retrn); 385{; 386 if (!QuitOpt()) {; 387 // Prompt prompt only if we are expecting / allowing input.; 388 Getlinem(kInit, GetPrompt());; 389 }; 390 ; 391 Longptr_t retval = 0;; 392 Int_t error = 0;; 393 volatile Bool_t needGetlinemInit = kFALSE;; 394 ; 395 if (strlen(WorkingDirectory())) {; 396 // if directory s",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:17484,Testability,log,logo,17484,"t());; 467 needGetlinemInit = kTRUE;; 468 ; 469 if (error != 0 || fCaughtSignal != -1) break;; 470 }; 471 } ENDTRY;; 472 ; 473 if (QuitOpt()) {; 474 if (retrn) return;; 475 if (error) {; 476 retval = error;; 477 } else if (fCaughtSignal != -1) {; 478 retval = fCaughtSignal + 128;; 479 }; 480 // Bring retval into sensible range, 0..255.; 481 if (retval < 0 || retval > 255); 482 retval = 255;; 483 Terminate(retval);; 484 }; 485 ; 486 // Allow end-of-file on the terminal to be noticed; 487 // after we finish processing the command line input files.; 488 fInputHandler->Activate();; 489 ; 490 ClearInputFiles();; 491 ; 492 if (needGetlinemInit) Getlinem(kInit, GetPrompt());; 493 }; 494 ; 495 if (QuitOpt()) {; 496 printf(""\n"");; 497 if (retrn) return;; 498 Terminate(fCaughtSignal != -1 ? fCaughtSignal + 128 : 0);; 499 }; 500 ; 501 TApplication::Run(retrn);; 502 ; 503 // Reset to happiness.; 504 fCaughtSignal = -1;; 505 ; 506 Getlinem(kCleanUp, nullptr);; 507}; 508 ; 509////////////////////////////////////////////////////////////////////////////////; 510/// Print the ROOT logo on standard output.; 511 ; 512void TRint::PrintLogo(Bool_t lite); 513{; 514 if (!lite) {; 515 // Fancy formatting: the content of lines are format strings; their %s is; 516 // replaced by spaces needed to make all lines as long as the longest line.; 517 std::vector<TString> lines;; 518 // Here, %%s results in %s after TString::Format():; 519 lines.emplace_back(TString::Format(""Welcome to ROOT %s%%shttps://root.cern"",; 520 gROOT->GetVersion()));; 521 lines.emplace_back(TString::Format(""(c) 1995-2024, The ROOT Team; conception: R. Brun, F. Rademakers%%s""));; 522 lines.emplace_back(TString::Format(""Built for %s on %s%%s"", gSystem->GetBuildArch(), gROOT->GetGitDate()));; 523 if (!strcmp(gROOT->GetGitBranch(), gROOT->GetGitCommit())) {; 524 static const char *months[] = {""January"",""February"",""March"",""April"",""May"",; 525 ""June"",""July"",""August"",""September"",""October"",; 526 ""November"",""December""};; 527 Int_t id",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:19879,Testability,log,logo,19879,"ng::Format(""With %s %%s"",; 543 gSystem->GetBuildCompilerVersionStr()));; 544 lines.emplace_back(TString(""Try '.help'/'.?', '.demo', '.license', '.credits', '.quit'/'.q'%s""));; 545 ; 546 // Find the longest line and its length:; 547 auto itLongest = std::max_element(lines.begin(), lines.end(),; 548 [](const TString& left, const TString& right) {; 549 return left.Length() < right.Length(); });; 550 Ssiz_t lenLongest = itLongest->Length();; 551 ; 552 ; 553 Printf("" %s"", TString('-', lenLongest).Data());; 554 for (const auto& line: lines) {; 555 // Print the line, expanded with the necessary spaces at %s, and; 556 // surrounded by some ASCII art.; 557 Printf("" | %s |"",; 558 TString::Format(line.Data(),; 559 TString(' ', lenLongest - line.Length()).Data()).Data());; 560 }; 561 Printf("" %s\n"", TString('-', lenLongest).Data());; 562 }; 563 ; 564#ifdef R__UNIX; 565 // Popdown X logo, only if started with -splash option; 566 for (int i = 0; i < Argc(); i++); 567 if (!strcmp(Argv(i), ""-splash"")); 568 kill(getppid(), SIGUSR1);; 569#endif; 570}; 571 ; 572////////////////////////////////////////////////////////////////////////////////; 573/// Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"".; 574 ; 575char *TRint::GetPrompt(); 576{; 577 char *s = gCling->GetPrompt();; 578 if (s[0]); 579 strlcpy(fPrompt, s, sizeof(fPrompt));; 580 else; 581 snprintf(fPrompt, sizeof(fPrompt), fDefaultPrompt.Data(), fNcmd);; 582 ; 583 return fPrompt;; 584}; 585 ; 586////////////////////////////////////////////////////////////////////////////////; 587/// Set a new default prompt. It returns the previous prompt.; 588/// The prompt may contain a %d which will be replaced by the commend; 589/// number. The default prompt is ""root [%d] "". The maximum length of; 590/// the prompt is 55 characters. To set the prompt in an interactive; 591/// session do:; 592/// root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); 593/// aap>; 594 ; 595const char *TRint::SetPrompt(const char *newP",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:24597,Testability,log,logoff,24597,"nt(""u"");; 686 ; 687 // enable again intput handler; 688 fInputHandler->Activate();; 689 ; 690 if (!sline.BeginsWith("".reset"")); 691 gCling->EndOfLineAction();; 692 ; 693 gTabCom->ClearAll();; 694 Getlinem(kInit, GetPrompt());; 695 }; 696 return kTRUE;; 697}; 698 ; 699////////////////////////////////////////////////////////////////////////////////; 700/// Handle signals (kSigBus, kSigSegmentationViolation,; 701/// kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; 702/// Specific TApplication implementations may want something different here.; 703 ; 704void TRint::HandleException(Int_t sig); 705{; 706 fCaughtSignal = sig;; 707 if (TROOT::Initialized()) {; 708 if (gException) {; 709 Getlinem(kCleanUp, nullptr);; 710 Getlinem(kInit, ""Root > "");; 711 }; 712 }; 713 TApplication::HandleException(sig);; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Terminate the application. Reset the terminal to sane mode and call; 718/// the logoff macro defined via Rint.Logoff environment variable.; 719/// @note The function does not return, unless the class has; 720/// been told to return from Run(), by a call to SetReturnFromRun().; 721 ; 722void TRint::Terminate(Int_t status); 723{; 724 Getlinem(kCleanUp, nullptr);; 725 ; 726 if (ReturnFromRun()) {; 727 gSystem->ExitLoop();; 728 } else {; 729 delete gTabCom;; 730 gTabCom = nullptr;; 731 ; 732 //Execute logoff macro; 733 const char *logoff;; 734 logoff = gEnv->GetValue(""Rint.Logoff"", (char*)nullptr);; 735 if (logoff && !NoLogOpt()) {; 736 char *mac = gSystem->Which(TROOT::GetMacroPath(), logoff, kReadPermission);; 737 if (mac); 738 ProcessFile(logoff);; 739 delete [] mac;; 740 }; 741 ; 742 TApplication::Terminate(status);; 743 }; 744}; 745 ; 746////////////////////////////////////////////////////////////////////////////////; 747/// Set console mode:; 748///; 749/// mode = kTRUE - echo input symbols; 750/// mode = kFALSE - noecho input symbols; 751 ; 752void ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:25020,Testability,log,logoff,25020,"andle signals (kSigBus, kSigSegmentationViolation,; 701/// kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; 702/// Specific TApplication implementations may want something different here.; 703 ; 704void TRint::HandleException(Int_t sig); 705{; 706 fCaughtSignal = sig;; 707 if (TROOT::Initialized()) {; 708 if (gException) {; 709 Getlinem(kCleanUp, nullptr);; 710 Getlinem(kInit, ""Root > "");; 711 }; 712 }; 713 TApplication::HandleException(sig);; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Terminate the application. Reset the terminal to sane mode and call; 718/// the logoff macro defined via Rint.Logoff environment variable.; 719/// @note The function does not return, unless the class has; 720/// been told to return from Run(), by a call to SetReturnFromRun().; 721 ; 722void TRint::Terminate(Int_t status); 723{; 724 Getlinem(kCleanUp, nullptr);; 725 ; 726 if (ReturnFromRun()) {; 727 gSystem->ExitLoop();; 728 } else {; 729 delete gTabCom;; 730 gTabCom = nullptr;; 731 ; 732 //Execute logoff macro; 733 const char *logoff;; 734 logoff = gEnv->GetValue(""Rint.Logoff"", (char*)nullptr);; 735 if (logoff && !NoLogOpt()) {; 736 char *mac = gSystem->Which(TROOT::GetMacroPath(), logoff, kReadPermission);; 737 if (mac); 738 ProcessFile(logoff);; 739 delete [] mac;; 740 }; 741 ; 742 TApplication::Terminate(status);; 743 }; 744}; 745 ; 746////////////////////////////////////////////////////////////////////////////////; 747/// Set console mode:; 748///; 749/// mode = kTRUE - echo input symbols; 750/// mode = kFALSE - noecho input symbols; 751 ; 752void TRint::SetEchoMode(Bool_t mode); 753{; 754 Gl_config(""noecho"", mode ? 0 : 1);; 755}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Process the content of a line starting with "".R"" (already stripped-off); 759/// The format is; 760/// [user@]host[:dir] [-l user] [-d dbg] [script]; 761/// The variable 'dir' ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
https://root.cern/doc/master/TRint_8cxx_source.html:25050,Testability,log,logoff,25050,"andle signals (kSigBus, kSigSegmentationViolation,; 701/// kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; 702/// Specific TApplication implementations may want something different here.; 703 ; 704void TRint::HandleException(Int_t sig); 705{; 706 fCaughtSignal = sig;; 707 if (TROOT::Initialized()) {; 708 if (gException) {; 709 Getlinem(kCleanUp, nullptr);; 710 Getlinem(kInit, ""Root > "");; 711 }; 712 }; 713 TApplication::HandleException(sig);; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Terminate the application. Reset the terminal to sane mode and call; 718/// the logoff macro defined via Rint.Logoff environment variable.; 719/// @note The function does not return, unless the class has; 720/// been told to return from Run(), by a call to SetReturnFromRun().; 721 ; 722void TRint::Terminate(Int_t status); 723{; 724 Getlinem(kCleanUp, nullptr);; 725 ; 726 if (ReturnFromRun()) {; 727 gSystem->ExitLoop();; 728 } else {; 729 delete gTabCom;; 730 gTabCom = nullptr;; 731 ; 732 //Execute logoff macro; 733 const char *logoff;; 734 logoff = gEnv->GetValue(""Rint.Logoff"", (char*)nullptr);; 735 if (logoff && !NoLogOpt()) {; 736 char *mac = gSystem->Which(TROOT::GetMacroPath(), logoff, kReadPermission);; 737 if (mac); 738 ProcessFile(logoff);; 739 delete [] mac;; 740 }; 741 ; 742 TApplication::Terminate(status);; 743 }; 744}; 745 ; 746////////////////////////////////////////////////////////////////////////////////; 747/// Set console mode:; 748///; 749/// mode = kTRUE - echo input symbols; 750/// mode = kFALSE - noecho input symbols; 751 ; 752void TRint::SetEchoMode(Bool_t mode); 753{; 754 Gl_config(""noecho"", mode ? 0 : 1);; 755}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Process the content of a line starting with "".R"" (already stripped-off); 759/// The format is; 760/// [user@]host[:dir] [-l user] [-d dbg] [script]; 761/// The variable 'dir' ",MatchSource.WIKI,doc/master/TRint_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html
