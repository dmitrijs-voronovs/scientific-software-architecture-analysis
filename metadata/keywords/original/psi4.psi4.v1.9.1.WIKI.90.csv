id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:30800,Energy Efficiency,charge,charge,30800," atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(i) + "")""); text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". print(text); # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); text += """""" zmat? %s\n"""""" % (self.has_zmatrix()); print(text). [docs] def create_psi4_string_from_molecule(self):; """"""Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction.; """"""; text = """"; if self.nallatom():. # append units and any oth",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:31688,Energy Efficiency,charge,charges,31688,"% (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); text += """""" zmat? %s\n"""""" % (self.has_zmatrix()); print(text). [docs] def create_psi4_string_from_molecule(self):; """"""Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction.; """"""; text = """"; if self.nallatom():. # append units and any other non-default molecule keywords; text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += "" no_com\n""; if self.PYfix_orientation:; text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:32087,Energy Efficiency,charge,charge,32087,""""""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); text += """""" zmat? %s\n"""""" % (self.has_zmatrix()); print(text). [docs] def create_psi4_string_from_molecule(self):; """"""Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction.; """"""; text = """"; if self.nallatom():. # append units and any other non-default molecule keywords; text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += "" no_com\n""; if self.PYfix_orientation:; text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s"" % (""Gh("" + self.flabel(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """,MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:33909,Energy Efficiency,charge,charge,33909,"bles.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_po",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:34129,Energy Efficiency,charge,charge,34129,"ue(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Mole",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:34137,Energy Efficiency,charge,charge,34137,"ue(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Mole",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:34403,Energy Efficiency,charge,charge,34403,"TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vst",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:49486,Energy Efficiency,energy,energy,49486,"oint group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; self.set_point_group(self.find_point_group()); self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:49844,Energy Efficiency,energy,energy,49844,"s updated to the new frame; self.set_point_group(self.find_point_group()); self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i) - self.x(j)) * Zi * Zj / temp; entry[1] -= (self.y(i) - self.y(j)) * Zi * Zj / temp; entry[2] -= (self.z(i) - self.z(j)) * Zi * Zj / temp; de.append(entry); return de. [docs] def nuclear_repulsion_energy_deriv2(self):; """""" **NYI** Computes nuclear repulsion energy second derivatives""""""; raise FeatureNotImplemented('Molecule::nuclear_repulsion_energy_deriv2'",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:50712,Energy Efficiency,energy,energy,50712,"yz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i) - self.x(j)) * Zi * Zj / temp; entry[1] -= (self.y(i) - self.y(j)) * Zi * Zj / temp; entry[2] -= (self.z(i) - self.z(j)) * Zi * Zj / temp; de.append(entry); return de. [docs] def nuclear_repulsion_energy_deriv2(self):; """""" **NYI** Computes nuclear repulsion energy second derivatives""""""; raise FeatureNotImplemented('Molecule::nuclear_repulsion_energy_deriv2') # FINAL. [docs] def set_basis_all_atoms(self, name, role=""BASIS""):; """"""Assigns basis *name* to all atoms.""""""; uc = name.upper(); if uc in ['SPECIAL', 'GENERAL', 'CUSTOM']:; # These aren't really basis set specifications, just return.; return; for atom in self.full_atoms:; atom.set_basisset(name, role). [docs] def set_basis_by_symbol(self, symbol, name, role=""BASIS""):; """"""Assigns basis *name* to all *symbol* atoms.""""""; for atom in self.full_atoms:; if symbol.upper() == atom.symbol():; atom.set_basisset(name, role). [docs] def clear_basis_all_atoms(self):; """"""Remove all basis information from atoms.""""""; for atom in self.full_atoms:; atom.PYbasissets = OrderedDict(). [docs] def set_basis_by_number(self, number, name, role=""BASIS""):; """"""Assigns basis *name* to atom number *number* (0-indexed, excludes dummies).""""""; # change from libmints to 0-indexing and to real/ghost numbering, dummies not includ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:38673,Integrability,message,message,38673,"tribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Molecule::get_anchor_atom: Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:47613,Integrability,rout,routine,47613,"multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rath",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:74720,Integrability,depend,dependent,74720,"try_from_input()). if user_specified_direction:; # Assume the user knows what they're doing.; # Make sure user is subgroup of pg; if (pg.bits() & user.bits()) != user.bits():; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s)"" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). else:; similars, count = similar(user.bits()); found = False; for typ in range(count):; # If what the user specified and the similar type; # matches the full point group we've got a match; if (similars[typ] & pg.bits()) == similars[typ]:; found = True; break. if found:; # Construct a point group object using the found similar; user = PointGroup(similars[typ]). else:; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s). If this is because the symmetry increased, try to start the calculation again from the last geometry, after checking any symmetry-dependent input, such as DOCC."" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). # If we make it here, what the user specified is good.; pg = user. return pg. [docs] def reset_point_group(self, pgname):; """"""Override symmetry from outside the molecule string""""""; self.PYsymmetry_from_input = pgname.lower(); self.set_point_group(self.find_point_group()). [docs] def find_highest_point_group(self, tol=DEFAULT_SYM_TOL):; """"""Find the highest D2h point group from Jet and Ed's code: c1; ci c2 cs d2 c2v c2h d2h. Ignore the user-specified subgroup in; this case. """"""; pg_bits = 0. # The order of the next 2 arrays MUST match!; symm_bit = [; SymmOps['C2_z'],; SymmOps['C2_y'],; SymmOps['C2_x'],; SymmOps['i'],; SymmOps['Sigma_xy'],; SymmOps['Sigma_xz'],; SymmOps['Sigma_yz']]. symm_func = [; SymmetryOperation.c2_z,; SymmetryOperation.c2_y,; SymmetryOperation.c2_x,; SymmetryOperation.i,; SymmetryOperation.sigma_xy,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:3698,Modifiability,variab,variables,3698,"s"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False # TODO None?. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule; self.pg = None; # Full point group; self.full_pg = ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:3795,Modifiability,variab,variables,3795,"self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False # TODO None?. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule; self.pg = None; # Full point group; self.full_pg = 'C1'; # n of the highest rotational axis Cn; self.PYfull_pg_n = 1; # Symmetry string from ge",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:15601,Modifiability,variab,variable,15601," for Construction >>>. [docs] def create_molecule_from_string(self, text):; """"""Given a string *text* of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. """"""; comment = re.compile(r'^\s*#'); blank = re.compile(r'^\s*$'); bohr = re.compile(r'^\s*units?[\s=]+(bohr|au|a.u.)\s*$', re.IGNORECASE); ang = re.compile(r'^\s*units?[\s=]+(ang|angstrom)\s*$', re.IGNORECASE); orient = re.compile(r'^\s*(no_reorient|noreorient)\s*$', re.IGNORECASE); com = re.compile(r'^\s*(no_com|nocom)\s*$', re.IGNORECASE); symmetry = re.compile(r'^\s*symmetry[\s=]+(\w+)\s*$', re.IGNORECASE); ATOM = '((([A-Z]{1,3})_\w+)|(([A-Z]{1,3})\d*))' # match 'C', 'al', 'p88', 'p_pass' not 'Ofail', 'h99_text' # good, but unused; atom = re.compile(r'^(?:(?P<gh1>@)|(?P<gh2>Gh\())?(?P<label>(?P<symbol>[A-Z]{1,3})(?:(_\w+)|(\d+))?)(?(gh2)\))(?:@(?P<mass>\d+\.\d+))?$', re.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; self.PYsymmetry_from_input = symmetry.match(line).group(1).lower(). # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vn",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:16367,Modifiability,variab,variables,16367,"e.compile(r'^(?:(?P<gh1>@)|(?P<gh2>Gh\())?(?P<label>(?P<symbol>[A-Z]{1,3})(?:(_\w+)|(\d+))?)(?(gh2)\))(?:@(?P<mass>\d+\.\d+))?$', re.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; self.PYsymmetry_from_input = symmetry.match(line).group(1).lower(). # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line.split()[0].strip()):; glines.append(line); else:; raise ValidationError('Molecule::create_m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:16383,Modifiability,variab,variable,16383,"e.compile(r'^(?:(?P<gh1>@)|(?P<gh2>Gh\())?(?P<label>(?P<symbol>[A-Z]{1,3})(?:(_\w+)|(\d+))?)(?(gh2)\))(?:@(?P<mass>\d+\.\d+))?$', re.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; self.PYsymmetry_from_input = symmetry.match(line).group(1).lower(). # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line.split()[0].strip()):; glines.append(line); else:; raise ValidationError('Molecule::create_m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:16414,Modifiability,variab,variable,16414,"2>Gh\())?(?P<label>(?P<symbol>[A-Z]{1,3})(?:(_\w+)|(\d+))?)(?(gh2)\))(?:@(?P<mass>\d+\.\d+))?$', re.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; self.PYsymmetry_from_input = symmetry.match(line).group(1).lower(). # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line.split()[0].strip()):; glines.append(line); else:; raise ValidationError('Molecule::create_molecule_from_string: Unidentifiab",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:16466,Modifiability,variab,variable,16466,"\d+))?)(?(gh2)\))(?:@(?P<mass>\d+\.\d+))?$', re.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; self.PYsymmetry_from_input = symmetry.match(line).group(1).lower(). # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line.split()[0].strip()):; glines.append(line); else:; raise ValidationError('Molecule::create_molecule_from_string: Unidentifiable line in geometry specification: %s' % (line)). # ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:32833,Modifiability,variab,variables,32833,"keywords; text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += "" no_com\n""; if self.PYfix_orientation:; text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s"" % (""Gh("" + self.flabel(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.ge",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:33155,Modifiability,variab,variable,33155,"iplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s"" % (""Gh("" + self.flabel(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:33380,Modifiability,variab,variable,33380," self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s"" % (""Gh("" + self.flabel(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:33540,Modifiability,variab,variable,33540," %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s"" % (""Gh("" + self.flabel(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationErr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:33741,Modifiability,variab,variable,33741," (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:35286,Modifiability,variab,variable,35286,"mies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geome",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:35656,Modifiability,variab,variable,35656,"om):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(na",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:35898,Modifiability,variab,variable,35898,"r with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute co",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36010,Modifiability,variab,variable,36010,"gstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self._",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36060,Modifiability,variab,variables,36060,"gstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self._",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36226,Modifiability,variab,variable,36226,"n -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self.__dict__['__dict__']:; ## if object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; ## else:; ## #return self.__dict__[name",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36540,Modifiability,variab,variable,36540,"self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self.__dict__['__dict__']:; ## if object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; ## else:; ## #return self.__dict__[name]; ## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__dict__' in self.__dict__ and name in self.__dict__['__dict__']:; ## return self.__dict__['__dict__'][name]; ## elif object.__getattribute__(self, 'is_variable')(name",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36897,Modifiability,variab,variable,36897," raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self.__dict__['__dict__']:; ## if object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; ## else:; ## #return self.__dict__[name]; ## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__dict__' in self.__dict__ and name in self.__dict__['__dict__']:; ## return self.__dict__['__dict__'][name]; ## elif object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; #; # if not name in self.__dict__:; # if object.__getattribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:37935,Modifiability,variab,variable,37935,"le values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self.__dict__['__dict__']:; ## if object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; ## else:; ## #return self.__dict__[name]; ## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__dict__' in self.__dict__ and name in self.__dict__['__dict__']:; ## return self.__dict__['__dict__'][name]; ## elif object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; #; # if not name in self.__dict__:; # if object.__getattribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:38263,Modifiability,variab,variable,38263,"## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__dict__' in self.__dict__ and name in self.__dict__['__dict__']:; ## return self.__dict__['__dict__'][name]; ## elif object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; #; # if not name in self.__dict__:; # if object.__getattribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Molecule::get_anchor_atom: Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 ar",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:47549,Modifiability,variab,variables,47549,"; self.atoms = []; for item in self.full_atoms:; item.invalidate(). temp_charge = self.PYmolecular_charge; temp_multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_fra",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:88907,Modifiability,variab,variables,88907," noise coming in from optking. """"""; #raise FeatureNotImplemented('Molecule::symmetrize') # FINAL SYMM; temp = zero(self.natom(), 3); ct = self.point_group().char_table(). # Obtain atom mapping of atom * symm op to atom; atom_map = compute_atom_map(self). # Symmetrize the molecule to remove any noise; for at in range(self.natom()):; for g in range(ct.order()):; Gatom = atom_map[at][g]; so = ct.symm_operation(g). # Full so must be used if molecule is not in standard orientation; temp[at][0] += so[0][0] * self.x(Gatom) / ct.order(); temp[at][0] += so[0][1] * self.y(Gatom) / ct.order(); temp[at][0] += so[0][2] * self.z(Gatom) / ct.order(); temp[at][1] += so[1][0] * self.x(Gatom) / ct.order(); temp[at][1] += so[1][1] * self.y(Gatom) / ct.order(); temp[at][1] += so[1][2] * self.z(Gatom) / ct.order(); temp[at][2] += so[2][0] * self.x(Gatom) / ct.order(); temp[at][2] += so[2][1] * self.y(Gatom) / ct.order(); temp[at][2] += so[2][2] * self.z(Gatom) / ct.order(). # Set the geometry to ensure z-matrix variables get updated; self.set_geometry(temp). [docs] def schoenflies_symbol(self):; """"""Returns the Schoenflies symbol""""""; return self.point_group().symbol(). [docs] def valid_atom_map(self, tol=0.01):; """"""Check if current geometry fits current point group. """"""; np = [0.0, 0.0, 0.0]; ct = self.point_group().char_table(). # loop over all centers; for at in range(self.natom()):; ac = self.xyz(at). # For each operation in the pointgroup, transform the coordinates of; # center ""at"" and see which atom it maps into; for g in range(ct.order()):; so = ct.symm_operation(g). for ii in range(3):; np[ii] = 0; for jj in range(3):; np[ii] += so[ii][jj] * ac[jj]. if self.atom_at_position(np, tol) < 0:; return False; return True. [docs] def full_point_group_with_n(self):; """"""Return point group name such as Cnv or Sn.""""""; return self.full_pg. [docs] def full_pg_n(self):; """"""Return n in Cnv, etc.; If there is no n (e.g. Td); it's the highest-order rotation axis. """"""; return self.PYfull_pg_n. [docs",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:23059,Safety,detect,detected,23059,"atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Molecule::create_molecule_from_string: Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36395,Safety,safe,safe,36395,"d returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self.__dict__['__dict__']:; ## if object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; ## else:; ## #return self.__dict__[name]; ## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:73961,Safety,detect,detected,73961,"""""""Find computational molecular point group, user can override; this with the ""symmetry"" keyword. Result is highest D2h subgroup; attendant on molecule and allowed by the user. """"""; pg = self.find_highest_point_group(tol) # D2h subgroup; user = self.symmetry_from_input(). if user is not None:; # Need to handle the cases that the user only provides C2, C2v, C2h, Cs.; # These point groups need directionality. # Did the user provide directionality? If they did, the last letter would be x, y, or z; # Directionality given, assume the user is smart enough to know what they're doing.; user_specified_direction = True if user[-1] in ['X', 'x', 'Y', 'y', 'Z', 'z'] else False. if self.symmetry_from_input() != pg.symbol():; user = PointGroup(self.symmetry_from_input()). if user_specified_direction:; # Assume the user knows what they're doing.; # Make sure user is subgroup of pg; if (pg.bits() & user.bits()) != user.bits():; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s)"" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). else:; similars, count = similar(user.bits()); found = False; for typ in range(count):; # If what the user specified and the similar type; # matches the full point group we've got a match; if (similars[typ] & pg.bits()) == similars[typ]:; found = True; break. if found:; # Construct a point group object using the found similar; user = PointGroup(similars[typ]). else:; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s). If this is because the symmetry increased, try to start the calculation again from the last geometry, after checking any symmetry-dependent input, such as DOCC."" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). # If we make it here, what the user specified is good.; pg = user. return pg. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:74563,Safety,detect,detected,74563,"fied_direction = True if user[-1] in ['X', 'x', 'Y', 'y', 'Z', 'z'] else False. if self.symmetry_from_input() != pg.symbol():; user = PointGroup(self.symmetry_from_input()). if user_specified_direction:; # Assume the user knows what they're doing.; # Make sure user is subgroup of pg; if (pg.bits() & user.bits()) != user.bits():; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s)"" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). else:; similars, count = similar(user.bits()); found = False; for typ in range(count):; # If what the user specified and the similar type; # matches the full point group we've got a match; if (similars[typ] & pg.bits()) == similars[typ]:; found = True; break. if found:; # Construct a point group object using the found similar; user = PointGroup(similars[typ]). else:; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s). If this is because the symmetry increased, try to start the calculation again from the last geometry, after checking any symmetry-dependent input, such as DOCC."" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). # If we make it here, what the user specified is good.; pg = user. return pg. [docs] def reset_point_group(self, pgname):; """"""Override symmetry from outside the molecule string""""""; self.PYsymmetry_from_input = pgname.lower(); self.set_point_group(self.find_point_group()). [docs] def find_highest_point_group(self, tol=DEFAULT_SYM_TOL):; """"""Find the highest D2h point group from Jet and Ed's code: c1; ci c2 cs d2 c2v c2h d2h. Ignore the user-specified subgroup in; this case. """"""; pg_bits = 0. # The order of the next 2 arrays MUST match!; symm_bit = [; SymmOps['C2_z'],; SymmOps['C2_y'],; SymmOps['C2_x'],; SymmOps['i'],; SymmOps['Sigma_xy'],; SymmOps['Sigma_xz'],; SymmO",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:75795,Safety,detect,detect,75795,"_to_full_name(pg.bits()))). # If we make it here, what the user specified is good.; pg = user. return pg. [docs] def reset_point_group(self, pgname):; """"""Override symmetry from outside the molecule string""""""; self.PYsymmetry_from_input = pgname.lower(); self.set_point_group(self.find_point_group()). [docs] def find_highest_point_group(self, tol=DEFAULT_SYM_TOL):; """"""Find the highest D2h point group from Jet and Ed's code: c1; ci c2 cs d2 c2v c2h d2h. Ignore the user-specified subgroup in; this case. """"""; pg_bits = 0. # The order of the next 2 arrays MUST match!; symm_bit = [; SymmOps['C2_z'],; SymmOps['C2_y'],; SymmOps['C2_x'],; SymmOps['i'],; SymmOps['Sigma_xy'],; SymmOps['Sigma_xz'],; SymmOps['Sigma_yz']]. symm_func = [; SymmetryOperation.c2_z,; SymmetryOperation.c2_y,; SymmetryOperation.c2_x,; SymmetryOperation.i,; SymmetryOperation.sigma_xy,; SymmetryOperation.sigma_xz,; SymmetryOperation.sigma_yz]. symop = SymmetryOperation(); matching_atom = -1. # Only needs to detect the 8 symmetry operations; for g in range(7):. # Call the function pointer; symm_func[g](symop); found = True. for at in range(self.natom()):; op = [symop[0][0], symop[1][1], symop[2][2]]; pos = naivemult(self.xyz(at), op). matching_atom = self.atom_at_position(pos, tol); if matching_atom >= 0:; if not self.atoms[at].is_equivalent_to(self.atoms[matching_atom]):; found = False; break; else:; found = False; break. if found:; pg_bits |= symm_bit[g]. return PointGroup(pg_bits). [docs] def symmetry_frame(self, tol=DEFAULT_SYM_TOL):; """"""Determine symmetry reference frame. If noreorient is not set,; this is the rotation matrix applied to the geometry in update_geometry. >>> print H2OH2O.symmetry_frame(); [[1.0, -0.0, 0.0], [0.0, 1.0, 0.0], [0.0, -0.0, 1.0]]. """"""; com = self.center_of_mass(); worldxaxis = [1.0, 0.0, 0.0]; worldyaxis = [0.0, 1.0, 0.0]; worldzaxis = [0.0, 0.0, 1.0]. sigma = [0.0, 0.0, 0.0]; sigmav = [0.0, 0.0, 0.0]; c2axis = [0.0, 0.0, 0.0]; c2axisperp = [0.0, 0.0, 0.0]. linear, planar = s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:85138,Safety,detect,detected,85138,"h.fabs(xaxis[2]) < NOISY_ZERO:; xaxis[2] = 0.0. # the y is then -x cross z; yaxis = scale(cross(xaxis, zaxis), -1.0). #print ""xaxis %20.14lf %20.14lf %20.14lf"" % (xaxis[0], xaxis[1], xaxis[2]); #print ""yaxis %20.14lf %20.14lf %20.14lf"" % (yaxis[0], yaxis[1], yaxis[2]); #print ""zaxis %20.14lf %20.14lf %20.14lf"" % (zaxis[0], zaxis[1], zaxis[2]). frame = zero(3, 3); for i in range(3):; frame[i][0] = xaxis[i]; frame[i][1] = yaxis[i]; frame[i][2] = zaxis[i]; return frame. [docs] def release_symmetry_information(self):; """"""Release symmetry information""""""; self.PYnunique = 0; self.nequiv = 0; self.PYatom_to_unique = 0; self.equiv = 0. [docs] def form_symmetry_information(self, tol=DEFAULT_SYM_TOL):; """"""Initialize molecular specific symmetry information.; Uses the point group object obtain by calling point_group(). """"""; if self.equiv:; self.release_symmetry_information(). if self.natom() == 0:; self.PYnunique = 0; self.nequiv = 0; self.PYatom_to_unique = 0; self.equiv = 0; print(""""""No atoms detected, returning\n""""""); return. self.nequiv = []; self.PYatom_to_unique = [0] * self.natom(); self.equiv = []. if self.point_group().symbol() == 'c1':; self.PYnunique = self.natom(); for at in range(self.natom()):; self.nequiv.append(1); self.PYatom_to_unique[at] = at; self.equiv.append([at]); return. # The first atom is always unique; self.PYnunique = 1; self.nequiv.append(1); self.PYatom_to_unique[0] = 0; self.equiv.append([0]). ct = self.point_group().char_table(); so = SymmetryOperation(); np = [0.0, 0.0, 0.0]. # Find the equivalent atoms; for i in range(1, self.natom()):; ac = self.xyz(i); i_is_unique = True; i_equiv = 0. # Apply all symmetry ops in the group to the atom; for g in range(ct.order()):; so = ct.symm_operation(g); for ii in range(3):; np[ii] = 0; for jj in range(3):; np[ii] += so[ii][jj] * ac[jj]. # See if the transformed atom is equivalent to a unique atom; for j in range(self.PYnunique):; unique = self.equiv[j][0]; aj = self.xyz(unique); if distance(np, aj) < tol an",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36837,Security,access,accessing,36837," raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self.__dict__['__dict__']:; ## if object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; ## else:; ## #return self.__dict__[name]; ## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__dict__' in self.__dict__ and name in self.__dict__['__dict__']:; ## return self.__dict__['__dict__'][name]; ## elif object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; #; # if not name in self.__dict__:; # if object.__getattribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:38205,Security,access,accessing,38205,"## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__dict__' in self.__dict__ and name in self.__dict__['__dict__']:; ## return self.__dict__['__dict__'][name]; ## elif object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; #; # if not name in self.__dict__:; # if object.__getattribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Molecule::get_anchor_atom: Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 ar",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:47579,Usability,clear,cleared,47579,"multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rath",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:49314,Usability,clear,clear,49314,"f not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; self.set_point_group(self.find_point_group()); self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:4754,Deployability,configurat,configuration,4754,"PointGroups['C2Y'], PointGroups['C2X']]; d2h = [PointGroups['D2h']]; d2 = [PointGroups['D2']]; ci = [PointGroups['Ci']]; c1 = [PointGroups['C1']]. if bits in cs:; sim = cs; elif bits in c2v:; sim = c2v; elif bits in c2h:; sim = c2h; elif bits in c2:; sim = c2; elif bits in d2h:; sim = d2h; elif bits in ci:; sim = ci; elif bits in c1:; sim = c1; elif bits in d2:; sim = d2; else:; raise ValidationError('PointGroups::similar: Should not have reached here.'). return sim, len(sim). [docs]class SymmetryOperation(object):; """"""The SymmetryOperation class provides a 3 by 3 matrix; representation of a symmetry operation, such as a rotation or reflection. """""". def __init__(self, *args):; """"""Constructor"""""". # matrix representation; self.d = zero(3, 3); # bits representation; self.bits = 0. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 1 and \; isinstance(args[0], SymmetryOperation):; self.constructor_symmetryoperation(*args); else:; raise ValidationError('SymmetryOperation::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_symmetryoperation(self, so):; self.bits = so.bits; self.d = [row[:] for row in so.d]. # <<< Simple Methods for Basic SymmetryOperation Information >>>. [docs] def bit(self):; """"""Get the bit value.""""""; return self.bits. def __getitem__(self, i, j=None):; """"""Returns the (i,j)th element of the transformation matrix; or the i'th row of the transformation matrix if *j* is None. """"""; if j is None:; return self.d[i]; else:; return self.d[i][j]. [docs] def trace(self):; """"""returns the trace of the transformation matrix""""""; return self.d[0][0] + self.d[1][1] + self.d[2][2]. # <<< Methods for Symmetry Operations >>>. [docs] def zero(self):; """"""zero out the symop""""""; self.d = zero(3, 3). [docs] def unit(self):; """"""Set equal to a unit matrix""""""; self.zero(); self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[2][2] = 1.0. [docs] def E(self):; """"""Set equal to E""""""; sel",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:10466,Deployability,configurat,configuration,10466,"; text += ""%10.7f \n"" % (self.d[1][2]); text += "" 3 ""; text += ""%10.7f "" % (self.d[2][0]); text += ""%10.7f "" % (self.d[2][1]); text += ""%10.7f \n"" % (self.d[2][2]); text += ""bits_ = %d\n"" % (self.bits). if out is None:; return text; else:; with open(out, mode='w') as handle:; handle.write(text). [docs]class SymRep(object):; """"""The SymRep class provides an n dimensional matrix representation of a; symmetry operation, such as a rotation or reflection. The trace of a; SymRep can be used as the character for that symmetry operation. d is; hardwired to 5x5 since the H irrep in Ih is 5 dimensional. """""". def __init__(self, *args):; """"""Constructor"""""". # order of representation; self.n = 0; # matrix representation; self.d = zero(5, 5). # Divert to constructor functions; if len(args) == 1 and \; isinstance(args[0], int):; self.constructor_order(*args); elif len(args) == 1 and \; isinstance(args[0], SymmetryOperation):; self.constructor_symmetryoperation(*args); else:; raise ValidationError('SymRep::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_order(self, i):; """"""Initialize order only. """"""; self.n = i; self.zero(). [docs] def constructor_symmetryoperation(self, so):; """"""Initialize from 3x3 SymmetryOperation. """"""; self.n = 3; self.zero(); for i in range(3):; for j in range(3):; self.d[i][j] = so[i][j]. [docs] def SymmetryOperation(self):; """"""Cast SymRep to SymmetryOperation. """"""; if self.n != 3:; raise ValidationError(""SymRep::operator SymmetryOperation(): trying to cast to symop when n != 3""). so = SymmetryOperation(); for i in range(3):; for j in range(3):; so[i][j] = self.d[i][j]; return so. # <<< Simple Methods for Basic SymRep Information >>>. [docs] def set_dim(self, i):; """"""Set the dimension of d""""""; self.n = i. def __getitem__(self, i, j=None):; """"""Returns the (i,j)th element of the transformation matrix; or the i'th row of the transformation matrix if *j* is None. """"""; if j is None:; ret",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:16927,Deployability,configurat,configuration,16927," the irrep. The order of the point group; is also provided (this is equal to the number of characters in an; irrep). """""". def __init__(self, *args):; """"""Constructor"""""". # the order of the group; self.g = 0 # int really self?; # the degeneracy of the irrep; self.degen = 0 # int really self?; # the number of rotations in this irrep; self.PYnrot = 0 # int; # the number of translations in this irrep; self.PYntrans = 0 # int; # true if this irrep has a complex representation; self.PYcomplex = 0; # mulliken symbol for this irrep; self.symb = 0 # str; # mulliken symbol for this irrep w/o special characters; self.csymb = 0 # str; # representation matrices for the symops; self.rep = []. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 4 and \; isinstance(args[0], int) and \; isinstance(args[1], int) and \; isinstance(args[2], basestring) and \; isinstance(args[3], basestring):; self.constructor_order_degen_mulliken(*args); else:; raise ValidationError('IrreducibleRepresentation::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_order_degen_mulliken(self, order, d, lab, clab):; """"""This constructor takes as arguments the *order* of the point; group, the degeneracy *d* of the irrep, and the Mulliken symbol of; the irrep. The Mulliken symbol is copied internally. """"""; self.init(order, d, lab, clab). [docs] def init(self, order, d, lab, clab):; """"""Initialize the order, degeneracy, and Mulliken symbol of the; irrep. """"""; self.g = order; self.degen = d; self.PYntrans = 0; self.PYnrot = 0; self.PYcomplex = 0; self.symb = lab; self.csymb = clab. if order > 0:; for i in range(order):; self.rep.append(SymRep(d)). # IrreducibleRepresentation(const IrreducibleRepresentation&);; # IrreducibleRepresentation& operator=(const IrreducibleRepresentation&);. # <<< Simple Methods for Basic IrreducibleRepresentation Information >>>. [docs] def order(self):; """"""Returns the order of the group",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:21242,Deployability,configurat,configuration,21242,"ions of the same class together. For example, in C3v; there are two distinct C3 rotations and 3 distinct reflections, each; with a separate character. Thus symop has 6 elements rather than the 3; you'll find in most published character tables. """""". def __init__(self, *args):; """"""Constructor"""""". # order of the principal rot axis; self.nt = 0; # the class of the point group; self.pg = PointGroups['C1']; # the number of irreps in this pg; self.PYnirrep = 0; # an array of irreps; self.PYgamma = 0; # the matrices describing sym ops; self.symop = 0; # index of the inverse symop; self.inv = 0; # the Schoenflies symbol for the pg; self.symb = 0; # Bitwise representation of the symmetry operations; self.PYbits = 0. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_schoenflies(self, cpg):; """"""This constructor takes the Schoenflies symbol of a point group; as input. """"""; self.symb = cpg; # Check the symbol coming in; self.PYbits = PointGroup.full_name_to_bits(cpg); if self.PYbits is None:; raise ValidationError('CharacterTable: Invalid point group name: %s\n' % (cpg)); self.common_init(). [docs] def constructor_bits(self, bits):; """"""This constructor takes the bitswise representation of a point; group as input. """"""; self.PYbits = bits; self.symb = PointGroup.bits_to_basic_name(bits); self.common_init(). [docs] def common_init(self):; """"""First parse the point group symbol, this will give us the; order of the point group(g), the type of point group (pg), the; order of the principle rotation axis (nt), and the number of; irreps (nirrep). """"""; if len(self.symb) == 0:; raise ValidationError('CharacterTable::CharacterTable: null p",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:39070,Deployability,configurat,configuration,39070,"formation matrices, and a point of origin. The origin is not; respected by the symmetry operations, so if you want to use a point; group with a nonzero origin, first translate all your coordinates to; the origin and then set the origin to zero. """""". def __init__(self, *args):; """"""Constructor"""""". # Schoenflies symbol; self.symb = 'c1'; # point of origin; self.PYorigin = [0.0, 0.0, 0.0]; # bit representation of point group; self.PYbits = 0. # Divert to constructor functions; # if len(args) == 0:; # self.constructor_zero_ao_basis(); if len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); elif len(args) == 2 and \; isinstance(args[0], basestring) and \; len(args[1]) == 3:; self.constructor_schoenflies_origin(*args); elif len(args) == 2 and \; isinstance(args[0], int) and \; len(args[1]) == 3:; self.constructor_bits_origin(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. # libmints: These 2 constructors do not work right now.; [docs] def constructor_schoenflies(self, s):; """"""This constructor takes a string containing the Schoenflies; symbol of the point group as its only argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = [0.0, 0.0, 0.0]. [docs] def constructor_schoenflies_origin(self, s, origin):; """"""Like the above, but this constructor also takes a point of; origin as an argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = origin. [docs] def constructor_bits(self, bits):; """"""Using the bitwise representation construct",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:46697,Deployability,update,updated,46697,"s)). @staticmethod; [docs] def full_name_to_bits(pg): # altered signature from (pg, bits):; """""". """"""; pgc = pg.capitalize(). if pgc == 'C1':; bits = PointGroups['C1']; elif pgc == 'Ci':; bits = PointGroups['Ci']; elif pgc == 'C2(x)' or pgc == 'C2x' or pgc == 'C2_x':; bits = PointGroups['C2X']; elif pgc == 'C2(y)' or pgc == 'C2y' or pgc == 'C2_y':; bits = PointGroups['C2Y']; elif pgc == 'C2(z)' or pgc == 'C2z' or pgc == 'C2_z':; bits = PointGroups['C2Z']; elif pgc == 'Cs(x)' or pgc == 'Csx' or pgc == 'Cs_x':; bits = PointGroups['CsX']; elif pgc == 'Cs(y)' or pgc == 'Csy' or pgc == 'Cs_y':; bits = PointGroups['CsY']; elif pgc == 'Cs(z)' or pgc == 'Csz' or pgc == 'Cs_z':; bits = PointGroups['CsZ']; elif pgc == 'D2':; bits = PointGroups['D2']; elif pgc == 'C2v(x)' or pgc == 'C2vx' or pgc == 'C2v_x': # changed from C2v(X); bits = PointGroups['C2vX']; elif pgc == 'C2v(y)' or pgc == 'C2vy' or pgc == 'C2v_y': # changed from C2v(Y); bits = PointGroups['C2vY']; elif pgc == 'C2v(z)' or pgc == 'C2vz' or pgc == 'C2v_z': # changed from C2v(Z); bits = PointGroups['C2vZ']; elif pgc == 'C2h(x)' or pgc == 'C2hx' or pgc == 'C2h_x': # changed from C2h(X); bits = PointGroups['C2hX']; elif pgc == 'C2h(y)' or pgc == 'C2hy' or pgc == 'C2h_y': # changed from C2h(Y); bits = PointGroups['C2hY']; elif pgc == 'C2h(z)' or pgc == 'C2hz' or pgc == 'C2h_z': # changed from C2h(Z); bits = PointGroups['C2hZ']; elif pgc == 'D2h':; bits = PointGroups['D2h']. # Ok, the user gave us Cs, C2v, C2h, C2, but no directionality; elif pgc == 'Cs':; bits = PointGroups['CsX']; elif pgc == 'C2v':; bits = PointGroups['C2vZ']; elif pgc == 'C2h':; bits = PointGroups['C2hZ']; elif pgc == 'C2':; bits = PointGroups['C2Z']. else:; bits = None. return bits. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:4754,Modifiability,config,configuration,4754,"PointGroups['C2Y'], PointGroups['C2X']]; d2h = [PointGroups['D2h']]; d2 = [PointGroups['D2']]; ci = [PointGroups['Ci']]; c1 = [PointGroups['C1']]. if bits in cs:; sim = cs; elif bits in c2v:; sim = c2v; elif bits in c2h:; sim = c2h; elif bits in c2:; sim = c2; elif bits in d2h:; sim = d2h; elif bits in ci:; sim = ci; elif bits in c1:; sim = c1; elif bits in d2:; sim = d2; else:; raise ValidationError('PointGroups::similar: Should not have reached here.'). return sim, len(sim). [docs]class SymmetryOperation(object):; """"""The SymmetryOperation class provides a 3 by 3 matrix; representation of a symmetry operation, such as a rotation or reflection. """""". def __init__(self, *args):; """"""Constructor"""""". # matrix representation; self.d = zero(3, 3); # bits representation; self.bits = 0. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 1 and \; isinstance(args[0], SymmetryOperation):; self.constructor_symmetryoperation(*args); else:; raise ValidationError('SymmetryOperation::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_symmetryoperation(self, so):; self.bits = so.bits; self.d = [row[:] for row in so.d]. # <<< Simple Methods for Basic SymmetryOperation Information >>>. [docs] def bit(self):; """"""Get the bit value.""""""; return self.bits. def __getitem__(self, i, j=None):; """"""Returns the (i,j)th element of the transformation matrix; or the i'th row of the transformation matrix if *j* is None. """"""; if j is None:; return self.d[i]; else:; return self.d[i][j]. [docs] def trace(self):; """"""returns the trace of the transformation matrix""""""; return self.d[0][0] + self.d[1][1] + self.d[2][2]. # <<< Methods for Symmetry Operations >>>. [docs] def zero(self):; """"""zero out the symop""""""; self.d = zero(3, 3). [docs] def unit(self):; """"""Set equal to a unit matrix""""""; self.zero(); self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[2][2] = 1.0. [docs] def E(self):; """"""Set equal to E""""""; sel",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:10466,Modifiability,config,configuration,10466,"; text += ""%10.7f \n"" % (self.d[1][2]); text += "" 3 ""; text += ""%10.7f "" % (self.d[2][0]); text += ""%10.7f "" % (self.d[2][1]); text += ""%10.7f \n"" % (self.d[2][2]); text += ""bits_ = %d\n"" % (self.bits). if out is None:; return text; else:; with open(out, mode='w') as handle:; handle.write(text). [docs]class SymRep(object):; """"""The SymRep class provides an n dimensional matrix representation of a; symmetry operation, such as a rotation or reflection. The trace of a; SymRep can be used as the character for that symmetry operation. d is; hardwired to 5x5 since the H irrep in Ih is 5 dimensional. """""". def __init__(self, *args):; """"""Constructor"""""". # order of representation; self.n = 0; # matrix representation; self.d = zero(5, 5). # Divert to constructor functions; if len(args) == 1 and \; isinstance(args[0], int):; self.constructor_order(*args); elif len(args) == 1 and \; isinstance(args[0], SymmetryOperation):; self.constructor_symmetryoperation(*args); else:; raise ValidationError('SymRep::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_order(self, i):; """"""Initialize order only. """"""; self.n = i; self.zero(). [docs] def constructor_symmetryoperation(self, so):; """"""Initialize from 3x3 SymmetryOperation. """"""; self.n = 3; self.zero(); for i in range(3):; for j in range(3):; self.d[i][j] = so[i][j]. [docs] def SymmetryOperation(self):; """"""Cast SymRep to SymmetryOperation. """"""; if self.n != 3:; raise ValidationError(""SymRep::operator SymmetryOperation(): trying to cast to symop when n != 3""). so = SymmetryOperation(); for i in range(3):; for j in range(3):; so[i][j] = self.d[i][j]; return so. # <<< Simple Methods for Basic SymRep Information >>>. [docs] def set_dim(self, i):; """"""Set the dimension of d""""""; self.n = i. def __getitem__(self, i, j=None):; """"""Returns the (i,j)th element of the transformation matrix; or the i'th row of the transformation matrix if *j* is None. """"""; if j is None:; ret",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:16927,Modifiability,config,configuration,16927," the irrep. The order of the point group; is also provided (this is equal to the number of characters in an; irrep). """""". def __init__(self, *args):; """"""Constructor"""""". # the order of the group; self.g = 0 # int really self?; # the degeneracy of the irrep; self.degen = 0 # int really self?; # the number of rotations in this irrep; self.PYnrot = 0 # int; # the number of translations in this irrep; self.PYntrans = 0 # int; # true if this irrep has a complex representation; self.PYcomplex = 0; # mulliken symbol for this irrep; self.symb = 0 # str; # mulliken symbol for this irrep w/o special characters; self.csymb = 0 # str; # representation matrices for the symops; self.rep = []. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 4 and \; isinstance(args[0], int) and \; isinstance(args[1], int) and \; isinstance(args[2], basestring) and \; isinstance(args[3], basestring):; self.constructor_order_degen_mulliken(*args); else:; raise ValidationError('IrreducibleRepresentation::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_order_degen_mulliken(self, order, d, lab, clab):; """"""This constructor takes as arguments the *order* of the point; group, the degeneracy *d* of the irrep, and the Mulliken symbol of; the irrep. The Mulliken symbol is copied internally. """"""; self.init(order, d, lab, clab). [docs] def init(self, order, d, lab, clab):; """"""Initialize the order, degeneracy, and Mulliken symbol of the; irrep. """"""; self.g = order; self.degen = d; self.PYntrans = 0; self.PYnrot = 0; self.PYcomplex = 0; self.symb = lab; self.csymb = clab. if order > 0:; for i in range(order):; self.rep.append(SymRep(d)). # IrreducibleRepresentation(const IrreducibleRepresentation&);; # IrreducibleRepresentation& operator=(const IrreducibleRepresentation&);. # <<< Simple Methods for Basic IrreducibleRepresentation Information >>>. [docs] def order(self):; """"""Returns the order of the group",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:21242,Modifiability,config,configuration,21242,"ions of the same class together. For example, in C3v; there are two distinct C3 rotations and 3 distinct reflections, each; with a separate character. Thus symop has 6 elements rather than the 3; you'll find in most published character tables. """""". def __init__(self, *args):; """"""Constructor"""""". # order of the principal rot axis; self.nt = 0; # the class of the point group; self.pg = PointGroups['C1']; # the number of irreps in this pg; self.PYnirrep = 0; # an array of irreps; self.PYgamma = 0; # the matrices describing sym ops; self.symop = 0; # index of the inverse symop; self.inv = 0; # the Schoenflies symbol for the pg; self.symb = 0; # Bitwise representation of the symmetry operations; self.PYbits = 0. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_schoenflies(self, cpg):; """"""This constructor takes the Schoenflies symbol of a point group; as input. """"""; self.symb = cpg; # Check the symbol coming in; self.PYbits = PointGroup.full_name_to_bits(cpg); if self.PYbits is None:; raise ValidationError('CharacterTable: Invalid point group name: %s\n' % (cpg)); self.common_init(). [docs] def constructor_bits(self, bits):; """"""This constructor takes the bitswise representation of a point; group as input. """"""; self.PYbits = bits; self.symb = PointGroup.bits_to_basic_name(bits); self.common_init(). [docs] def common_init(self):; """"""First parse the point group symbol, this will give us the; order of the point group(g), the type of point group (pg), the; order of the principle rotation axis (nt), and the number of; irreps (nirrep). """"""; if len(self.symb) == 0:; raise ValidationError('CharacterTable::CharacterTable: null p",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:39070,Modifiability,config,configuration,39070,"formation matrices, and a point of origin. The origin is not; respected by the symmetry operations, so if you want to use a point; group with a nonzero origin, first translate all your coordinates to; the origin and then set the origin to zero. """""". def __init__(self, *args):; """"""Constructor"""""". # Schoenflies symbol; self.symb = 'c1'; # point of origin; self.PYorigin = [0.0, 0.0, 0.0]; # bit representation of point group; self.PYbits = 0. # Divert to constructor functions; # if len(args) == 0:; # self.constructor_zero_ao_basis(); if len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); elif len(args) == 2 and \; isinstance(args[0], basestring) and \; len(args[1]) == 3:; self.constructor_schoenflies_origin(*args); elif len(args) == 2 and \; isinstance(args[0], int) and \; len(args[1]) == 3:; self.constructor_bits_origin(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. # libmints: These 2 constructors do not work right now.; [docs] def constructor_schoenflies(self, s):; """"""This constructor takes a string containing the Schoenflies; symbol of the point group as its only argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = [0.0, 0.0, 0.0]. [docs] def constructor_schoenflies_origin(self, s, origin):; """"""Like the above, but this constructor also takes a point of; origin as an argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = origin. [docs] def constructor_bits(self, bits):; """"""Using the bitwise representation construct",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:8053,Performance,perform,performs,8053,"; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([-1.0, 1.0, -1.0])]):; self.bits = SymmOps['C2_y']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([-1.0, -1.0, 1.0])]):; self.bits = SymmOps['C2_z']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([1.0, 1.0, -1.0])]):; self.bits = SymmOps['Sigma_xy']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([1.0, -1.0, 1.0])]):; self.bits = SymmOps['Sigma_xz']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([-1.0, 1.0, 1.0])]):; self.bits = SymmOps['Sigma_yz']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([-1.0, -1.0, -1.0])]):; self.bits = SymmOps['i']. [docs] def operate(self, r):; """"""This operates on this with r (i.e. return r * this)"""""". ret = SymmetryOperation(); for i in range(3):; for j in range(3):; t = 0.0; for k in range(3):; t += r.d[i][k] * self.d[k][j]; ret.d[i][j] = t; ret.analyze_d(); return ret. [docs] def transform(self, r):; """"""This performs the transform r * this * r~"""""". # foo = r * d; foo = SymmetryOperation(); for i in range(3):; for j in range(3):; t = 0.0; for k in range(3):; t += r.d[i][k] * self.d[k][j]; foo.d[i][j] = t. # ret = (r*d)*r~ = foo*r~; ret = SymmetryOperation(); for i in range(3):; for j in range(3):; t = 0.0; for k in range(3):; t += foo.d[i][k] * r.d[j][k]; ret.d[i][j] = t. ret.analyze_d(); return ret. # SymmetryOperation & operator = (SymmetryOperation const & a); // Assignment operator. [docs] def rotation(self, theta):; """"""Set equal to a clockwise rotation by 2pi/n or theta degrees"""""". if isinstance(theta, int):; theta = 2.0 * math.pi if theta == 0 else 2.0 * math.pi / theta; ctheta = math.cos(theta); stheta = math.sin(theta). self.zero(); self.d[0][0] = ctheta; self.d[0][1] = stheta; self.d[1][0] = -stheta; self.d[1][1] = ctheta; self.d[2][2] = 1.0; self.analyze_d(). [docs] def transpose(self):; """"""Transpose matrix operation"""""". for i in range(3):; for j in range(i):; tmp = self.d[i][j]; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:14027,Performance,perform,performs,14027,".n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[4][4] = 1.0. [docs] def c2_y(self):; """"""Set equal to C2 about the y axis. """"""; self.i(); if self.n == 2 or self.n == 3 or self.n == 4:; self.d[1][1] = 1.0; if self.n == 4:; self.d[2][2] = 1.0; elif self.n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[3][3] = 1.0. [docs] def c2_z(self):; """"""Set equal to C2 about the z axis. """"""; self.i(); if self.n == 2 or self.n == 3 or self.n == 4:; self.d[1][1] = 1.0; if self.n == 4:; self.d[2][2] = 1.0; elif self.n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[3][3] = 1.0. # <<< Methods for Operations >>>. [docs] def operate(self, r):; """"""This operates on this with r (i.e. return r * this). """"""; if r.n != self.n:; raise ValidationError(""SymRep::operate(): dimensions don't match""). ret = SymRep(self.n); for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += r[i][k] * self.d[k][j]; ret[i][j] = t; return ret. [docs] def transform(self, r):; """"""This performs the transform r * this * r~. """"""; if r.n != self.n:; raise ValidationError(""SymRep::operate(): dimensions don't match""). foo = SymRep(n); # foo = r * d; for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += r[i][k] * d[k][j]; foo[i][j] = t. ret = SymRep(n); # ret = (r*d)*r~ = foo*r~; for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += foo[i][k] * r[j][k]; ret[i][j] = t. return ret. [docs] def rotation(self, theta):; """"""Set equal to a clockwise rotation by 2pi/n or theta degrees. """"""; if isinstance(theta, int):; theta = 2.0 * math.pi if theta == 0 else 2.0 * math.pi / theta. ctheta = math.cos(theta); stheta = math.sin(theta); c2theta = math.cos(2 * theta); s2theta = math.sin(2 * theta). self.zero(); if self.n == 1:; self.d[0][0] = 1.0. elif self.n == 3:; self.d[0][0] = ctheta; self.d[0][1] = stheta; self.d[1][0] = -stheta; self.d[1][1] = ctheta; self.d[2][2] = 1.0. elif self.n == 2 or self.n == 4:; self.d",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:36761,Safety,abort,abort,36761,"gma_xy(); self.symop[3].sigma_xz(). elif self.PYbits == PointGroups['C2vY']:; self.symop[1].c2_y(); self.symop[2].sigma_xy(); self.symop[3].sigma_yz(). elif self.PYbits == PointGroups['C2vZ']:; self.symop[1].rotation(2); self.symop[2].sigma_xz(); self.symop[3].sigma_yz(). elif self.PYbits == PointGroups['D2']:; self.symop[1].rotation(2); self.symop[2].c2_y(); self.symop[3].c2_x(). elif self.PYbits == PointGroups['D2h']:; self.symop[1].rotation(2); self.symop[2].c2_y(); self.symop[3].c2_x(); self.symop[4].i(); self.symop[5].sigma_xy(); self.symop[6].sigma_xz(); self.symop[7].sigma_yz(). else:; return -1. # now find the inverse of each symop; for gi in range(self.PYnirrep):; for gj in range(self.PYnirrep):; so = self.symop[gi].operate(self.symop[gj]). # is so a unit matrix?; if abs(1.0 - so[0][0]) < 1.0e-8 and \; abs(1.0 - so[1][1]) < 1.0e-8 and \; abs(1.0 - so[2][2]) < 1.0e-8:; break. if gj == self.PYnirrep:; # ExEnv::err0() << indent; # << ""make_table: uh oh, can't find inverse of "" << gi << endl;; # abort();; raise ValidationError(""make_table: uh oh, can't find inverse""). self.inv[gi] = gj. # Check the bits of the operator make sure they make what; # we were given.; sym_bits = 0; for i in range(self.PYnirrep):; sym_bits |= self.symop[i].bit(). if sym_bits != self.PYbits:; raise ValidationError(""make_table: Symmetry operators did not match the point group given.""). return 0. # <<< Methods for Printing >>>. def __str__(self, out=None):; """"""This prints the irrep to the given file, or stdout if none is; given. """"""; text = ''; if not self.PYnirrep:; return. text += ' point group %s\n\n' % (self.symb); for i in range(self.PYnirrep):; text += self.PYgamma[i].__str__(out=None). text += '\n symmetry operation matrices:\n\n'; for i in range(self.PYnirrep):; text += self.symop[i].__str__(out=None). text += '\n inverse symmetry operation matrices:\n\n'; for i in range(self.PYnirrep):; text += self.symop[self.inverse(i)].__str__(out=None). if out is None:; return text; else:; w",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:41835,Usability,simpl,simple,41835,"s point group.""""""; return CharacterTable(self.PYbits). # def equiv(self, grp, tol=1.0e-6):; # """"""Returns 1 if the point groups *self* and *grp* are equivalent,; # 0 otherwise.; #; # """"""; # return 1 if self.symb == grp.symb else 0. #PointGroup::PointGroup(const PointGroup& pg); #{; # *this = pg;; #}; #; #PointGroup::PointGroup(const boost::shared_ptr<PointGroup>& pg); #{; # *this = *pg.get();; #}; #. # """"""The PointGroup KeyVal constructor looks for three keywords:; # symmetry, symmetry_frame, and origin. symmetry is a string; # containing the Schoenflies symbol of the point group. origin is an; # array of doubles which gives the x, y, and z coordinates of the; # origin of the symmetry frame. symmetry_frame is a 3 by 3 array of; # arrays of doubles which specify the principal axes for the; # transformation matrices as a unitary rotation.; #; # For example, a simple input which will use the default origin and; # symmetry_frame ((0,0,0) and the unit matrix, respectively), might; # look like this:; #; # <pre>; # pointgrp<PointGroup>: (; # symmetry = ""c2v""; # ); # </pre>; #; # By default, the principal rotation axis is taken to be the z axis.; # If you already have a set of coordinates which assume that the; # rotation axis is the x axis, then you'll have to rotate your frame; # of reference with symmetry_frame:; #; # <pre>; # pointgrp<PointGroup>: (; # symmetry = ""c2v""; # symmetry_frame = [; # [ 0 0 1 ]; # [ 0 1 0 ]; # [ 1 0 0 ]; # ]; # ); # </pre>; # """"""; # // PointGroup(const Ref<KeyVal>&);; #; # // PointGroup(StateIn&);; # PointGroup(const PointGroup&);; # PointGroup(const boost::shared_ptr<PointGroup>&);; # ~PointGroup();; #; # PointGroup& operator=(const PointGroup&);; #PointGroup& PointGroup::operator=(const PointGroup& pg); #{; # set_symbol(pg.symb);; # origin_ = pg.origin_;; # return *this;; #}; #. # <<< Methods for Printing >>>. def __str__(self, out=None):; text = 'PointGroup: %s\n' % (self.symb). if out is None:; return text; else:; with open(out, mode='w') as ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:44099,Usability,simpl,simple,44099,"[docs] def bits_to_full_name(bits):; """""". """"""; if bits == PointGroups['C1']:; return ""C1""; elif bits == PointGroups['Ci']:; return ""Ci""; elif bits == PointGroups['C2X']:; return ""C2(x)""; elif bits == PointGroups['C2Y']:; return ""C2(y)""; elif bits == PointGroups['C2Z']:; return ""C2(z)""; elif bits == PointGroups['CsZ']:; return ""Cs(Z)""; elif bits == PointGroups['CsY']:; return ""Cs(Y)""; elif bits == PointGroups['CsX']:; return ""Cs(X)""; elif bits == PointGroups['D2']:; return ""D2""; elif bits == PointGroups['C2vX']:; return ""C2v(X)""; elif bits == PointGroups['C2vY']:; return ""C2v(Y)""; elif bits == PointGroups['C2vZ']:; return ""C2v(Z)""; elif bits == PointGroups['C2hX']:; return ""C2h(X)""; elif bits == PointGroups['C2hY']:; return ""C2h(Y)""; elif bits == PointGroups['C2hZ']:; return ""C2h(Z)""; elif bits == PointGroups['D2h']:; return ""D2h""; else:; raise ValidationError(""Unrecognized point group bits: %d\n"" % (bits)). @staticmethod; [docs] def bits_to_basic_name(bits):; """"""From bit representation of point group, returns string of simple; (non-directional) Schoenflies symbol. """"""; if bits == PointGroups['C1']:; return ""c1""; elif bits == PointGroups['Ci']:; return ""ci""; elif bits in [PointGroups['C2X'], PointGroups['C2Y'], PointGroups['C2Z']]:; return ""c2""; elif bits in [PointGroups['CsZ'], PointGroups['CsY'], PointGroups['CsX']]:; return ""cs""; elif bits == PointGroups['D2']:; return ""d2""; elif bits in [PointGroups['C2vX'], PointGroups['C2vY'], PointGroups['C2vZ']]:; return ""c2v""; elif bits in [PointGroups['C2hX'], PointGroups['C2hY'], PointGroups['C2hZ']]:; return ""c2h""; elif bits == PointGroups['D2h']:; return ""d2h""; else:; raise ValidationError('Unrecognized point group bits: %d\n' % (bits)). @staticmethod; [docs] def full_name_to_bits(pg): # altered signature from (pg, bits):; """""". """"""; pgc = pg.capitalize(). if pgc == 'C1':; bits = PointGroups['C1']; elif pgc == 'Ci':; bits = PointGroups['Ci']; elif pgc == 'C2(x)' or pgc == 'C2x' or pgc == 'C2_x':; bits = PointGroups['C2X']",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html:5275,Availability,error,error,5275,"ext += """""" Literature citations:\n""""""; for rol, cit in self.citations.iteritems():; text += """""" %17s: %s\n"""""" (rol, cit.doi); text += """""" Comment: %s\n"""""" % (self.comment); text += """"""\n""""""; return text. [docs]class Method(QCEssential):; """"""Specialization of :py:class:`QCEssential` for quantum chemical methods. """"""; def __init__(self, name, fullname=None, latex=None, citations=None, doi=None, comment=None):; QCEssential.__init__(self, name, fullname, latex, citations, doi, comment); self.name = name.upper(). def __str__(self):; text = ''; text += """""" ==> %s Method <==\n\n"""""" % (self.name); text += """""" Formal name: %s\n"""""" % (self.fullname); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" DOI: %s\n"""""" % (self.doi); text += """""" Literature citations:\n""""""; for rol, cit in self.citations.iteritems():; text += """""" %17s: %s\n"""""" (rol, cit.doi); text += """""" Comment: %s\n"""""" % (self.comment); text += """"""\n""""""; return text. [docs]class Error(QCEssential):; """"""Specialization of :py:class:`QCEssential` for measures of error. """"""; def __init__(self, name, fullname=None, latex=None, citations=None, doi=None, comment=None):; QCEssential.__init__(self, name, fullname, latex, citations, doi, comment); self.name = name.lower(). def __str__(self):; text = ''; text += """""" ==> %s Error Measure <==\n\n"""""" % (self.name); text += """""" Formal name: %s\n"""""" % (self.fullname); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" DOI: %s\n"""""" % (self.doi); text += """""" Literature citations:\n""""""; for rol, cit in self.citations.iteritems():; text += """""" %17s: %s\n"""""" (rol, cit.doi); text += """""" Comment: %s\n"""""" % (self.comment); text += """"""\n""""""; return text. #class Option(QCEssential):; # """"""Specialization of :py:class:`QCEssential` for computation variation.; #; # """"""; # def __init__(self, name, fullname=None, latex=None, citations=None, doi=None, comment=None):; # QCEssential.__init__(self, name, fullname, latex, citations, doi, comment); # self.name = na",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/modelchems.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html:25532,Availability,error,errors,25532,"llname='d(T)', latex=""""""$\delta$(T)""""""), # TODO kill this once non-IE impl in reap-DB; Method('AM1', fullname='AM1'),; Method('GAFF', fullname='GAFF'),; Method('PM6DH2', fullname='PM6-DH2'),; Method('CHARMM', fullname='CHARMM'),; Method('PM3', fullname='PM3'),; Method('PM6', fullname='PM6'),; Method('PDDG', fullname='PDDG'),; Method('FF03', fullname='FF03'),; Method('FF03A', fullname='FF03A'),; Method('FF99SB', fullname='FF99SB'),; Method('FF99SBA', fullname='FF99SBA'),; Method('AM1FS1', fullname='AM1FS1'),; Method('EFP', fullname='EFP'),; ]. methods = {}; for item in _tlist:; methods[item.name] = item. _tlist = [; Error('pexe', fullname='pexE'),; Error('nexe', fullname='nexE'),; Error('maxe', fullname='maxE'),; Error('mine', fullname='minE'),; Error('me', fullname='ME'),; Error('mae', fullname='MAE'),; Error('rmse', fullname='rmsE'),; Error('stde', fullname='stdE'),; Error('pexpe', fullname='pexPE'),; Error('nexpe', fullname='nexPE'),; Error('maxpe', fullname='maxPE'),; Error('minpe', fullname='minPE'),; Error('mpe', fullname='MPE'),; Error('mape', fullname='MAPE', latex=r""""""MA$\%$E""""""), #latex=""""""MA\%E""""""),; Error('rmspe', fullname='rmsPE'),; Error('stdpe', fullname='stdPE'),; Error('pexpbe', fullname='pexPBE'),; Error('nexpbe', fullname='nexPBE'),; Error('maxpbe', fullname='maxPBE'),; Error('minpbe', fullname='minPBE'),; Error('mpbe', fullname='MPBE'),; Error('mapbe', fullname='MAPBE', latex=r""""""MA$\%$BE""""""), #latex=""""""MA\%BE""""""),; Error('rmspbe', fullname='rmsPBE'),; Error('stdpbe', fullname='stdPBE'),; ]; errors = {}; for item in _tlist:; errors[item.name] = item. #_tlist = [; # Option('CP', fullname='CP'),; # Option('unCP', fullname='unCP'),; #]; #options = {item.name: item for item in _tlist}. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/modelchems.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html:25566,Availability,error,errors,25566,"llname='d(T)', latex=""""""$\delta$(T)""""""), # TODO kill this once non-IE impl in reap-DB; Method('AM1', fullname='AM1'),; Method('GAFF', fullname='GAFF'),; Method('PM6DH2', fullname='PM6-DH2'),; Method('CHARMM', fullname='CHARMM'),; Method('PM3', fullname='PM3'),; Method('PM6', fullname='PM6'),; Method('PDDG', fullname='PDDG'),; Method('FF03', fullname='FF03'),; Method('FF03A', fullname='FF03A'),; Method('FF99SB', fullname='FF99SB'),; Method('FF99SBA', fullname='FF99SBA'),; Method('AM1FS1', fullname='AM1FS1'),; Method('EFP', fullname='EFP'),; ]. methods = {}; for item in _tlist:; methods[item.name] = item. _tlist = [; Error('pexe', fullname='pexE'),; Error('nexe', fullname='nexE'),; Error('maxe', fullname='maxE'),; Error('mine', fullname='minE'),; Error('me', fullname='ME'),; Error('mae', fullname='MAE'),; Error('rmse', fullname='rmsE'),; Error('stde', fullname='stdE'),; Error('pexpe', fullname='pexPE'),; Error('nexpe', fullname='nexPE'),; Error('maxpe', fullname='maxPE'),; Error('minpe', fullname='minPE'),; Error('mpe', fullname='MPE'),; Error('mape', fullname='MAPE', latex=r""""""MA$\%$E""""""), #latex=""""""MA\%E""""""),; Error('rmspe', fullname='rmsPE'),; Error('stdpe', fullname='stdPE'),; Error('pexpbe', fullname='pexPBE'),; Error('nexpbe', fullname='nexPBE'),; Error('maxpbe', fullname='maxPBE'),; Error('minpbe', fullname='minPBE'),; Error('mpbe', fullname='MPBE'),; Error('mapbe', fullname='MAPBE', latex=r""""""MA$\%$BE""""""), #latex=""""""MA\%BE""""""),; Error('rmspbe', fullname='rmsPBE'),; Error('stdpbe', fullname='stdPBE'),; ]; errors = {}; for item in _tlist:; errors[item.name] = item. #_tlist = [; # Option('CP', fullname='CP'),; # Option('unCP', fullname='unCP'),; #]; #options = {item.name: item for item in _tlist}. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/modelchems.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html:25922,Deployability,update,updated,25922,"llname='d(T)', latex=""""""$\delta$(T)""""""), # TODO kill this once non-IE impl in reap-DB; Method('AM1', fullname='AM1'),; Method('GAFF', fullname='GAFF'),; Method('PM6DH2', fullname='PM6-DH2'),; Method('CHARMM', fullname='CHARMM'),; Method('PM3', fullname='PM3'),; Method('PM6', fullname='PM6'),; Method('PDDG', fullname='PDDG'),; Method('FF03', fullname='FF03'),; Method('FF03A', fullname='FF03A'),; Method('FF99SB', fullname='FF99SB'),; Method('FF99SBA', fullname='FF99SBA'),; Method('AM1FS1', fullname='AM1FS1'),; Method('EFP', fullname='EFP'),; ]. methods = {}; for item in _tlist:; methods[item.name] = item. _tlist = [; Error('pexe', fullname='pexE'),; Error('nexe', fullname='nexE'),; Error('maxe', fullname='maxE'),; Error('mine', fullname='minE'),; Error('me', fullname='ME'),; Error('mae', fullname='MAE'),; Error('rmse', fullname='rmsE'),; Error('stde', fullname='stdE'),; Error('pexpe', fullname='pexPE'),; Error('nexpe', fullname='nexPE'),; Error('maxpe', fullname='maxPE'),; Error('minpe', fullname='minPE'),; Error('mpe', fullname='MPE'),; Error('mape', fullname='MAPE', latex=r""""""MA$\%$E""""""), #latex=""""""MA\%E""""""),; Error('rmspe', fullname='rmsPE'),; Error('stdpe', fullname='stdPE'),; Error('pexpbe', fullname='pexPBE'),; Error('nexpbe', fullname='nexPBE'),; Error('maxpbe', fullname='maxPBE'),; Error('minpbe', fullname='minPBE'),; Error('mpbe', fullname='MPBE'),; Error('mapbe', fullname='MAPBE', latex=r""""""MA$\%$BE""""""), #latex=""""""MA\%BE""""""),; Error('rmspbe', fullname='rmsPBE'),; Error('stdpbe', fullname='stdPBE'),; ]; errors = {}; for item in _tlist:; errors[item.name] = item. #_tlist = [; # Option('CP', fullname='CP'),; # Option('unCP', fullname='unCP'),; #]; #options = {item.name: item for item in _tlist}. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/modelchems.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:2332,Availability,avail,available,2332,"ctions import defaultdict; from .libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. # def __getstate__(self):; # print 'im being pickled'; # return self.__dict__. # def __setstate__(self, d):; # print 'im being unpickled with these values', d; # self.__dict__ = d. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.I",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:2401,Availability,avail,available,2401,"[docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. # def __getstate__(self):; # print 'im being pickled'; # return self.__dict__. # def __setstate__(self, d):; # print 'im being unpickled with these values', d; # self.__dict__ = d. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:6386,Availability,avail,available,6386,", z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; [docs] def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:6455,Availability,avail,available,6455,"ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; [docs] def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:27598,Availability,fault,faulty,27598,"return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; #'H': 1.001 / 1.5, # JMol; 'HE': 1.012 / 1.5, # JMol; 'LI': 0.825 / 1.5, # JMol; 'BE': 1.408 / 1.5, # JMol; #'B': 1.485 / 1.5, # JMol; #'C': 1.452 / 1.5, # JMol; #'N': 1.397 / 1.5, # JMol; #'O': 1.342 / 1.5, # JMol; #'F': 1.287 / 1.5, # JMol; 'NE': 1.243 / 1.5, # JMol; 'NA': 1.144 / 1.5, # JMol; 'MG': 1.364 / 1.5, # JMol; 'AL': 1.639 / 1.5, # JMol; #'SI': 1.716 / 1.5, # JMol; #'P': 1.705 / 1.5, # JMol; #'S': 1.683 / 1.5, # JMol; #'CL': 1.639 / 1.5, # JMol; 'AR': 1.595 / 1.5, # JMol. 'H': 1.06 / 1.5, # Bondi JPC 68 441 (1964); 'B': 1.65 / 1.5, # Bondi JPC 68 441 (1964); 'C': 1.53 / 1.5, # Bondi JPC 68 441 (1964); 'N': 1.46 / 1.5, # Bondi JPC 68 441 (1964); 'O': 1.42 / 1.5, # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, # Bondi JPC 68 441 (1964); 'P': 1.86 / 1.5, # Bondi JPC 68 441 (1964); 'S': 1.80 / 1.5, # Bondi JPC 68 44",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:38673,Deployability,update,updated,38673,":; for j in range(i + 1, 3):; if degen >= 2:; continue; rabs = math.fabs(rot_const[i] - rot_const[j]); tmp = rot_const[i] if rot_const[i] > rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. [docs] def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. [docs] def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). # Attach methods to qcdb.Molecule class; from .interface_dftd3 import run_dftd3 as _dftd3_qcdb_yo; Molecule.run_dftd3 = _dftd3_qcdb_yo; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol2 = _parker_xyz2mol_yo; from .parker import bond_profile as _parker_bondprofile_yo; Molecule.bond_profile = _parker_bondprofile_yo. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:2446,Energy Efficiency,charge,charge,2446,"n extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. # def __getstate__(self):; # print 'im being pickled'; # return self.__dict__. # def __setstate__(self, d):; # print 'im being unpickled with these values', d; # self.__dict__ = d. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:6500,Energy Efficiency,charge,charge,6500,"tion line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; [docs] def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:7749,Energy Efficiency,charge,charge,7749," False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:7777,Energy Efficiency,charge,chargem,7777," False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:7841,Energy Efficiency,charge,chargem,7841," False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:7865,Energy Efficiency,charge,chargem,7865," False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:7950,Energy Efficiency,charge,charge,7950," False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:15197,Energy Efficiency,charge,charge,15197,"prepare molecule keywords to be set as c-side keywords; options = defaultdict(lambda: defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True. return text, options. [docs] def format_molecule_for_psi4_xyz(self):; """"""not much examined. """"""; text = """"; if self.nallatom():. factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms; # append units and any other non-default molecule keywords; text += ""units Angstrom\n""; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += ""no_com\n""; if self.PYfix_orientation:; text += ""no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s%s%d %d\n"" % (; """" if Pfr == 0 else ""--\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent' or self.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. [docs] def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2ang",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:23985,Energy Efficiency,charge,charge,23985,"at_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). # # append units and any other non-default molecule keywords; # text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); # if not self.PYmove_to_com:; # text += "" no_com\n""; # if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variabl",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:26420,Energy Efficiency,charge,charge,26420,"lue'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i), \; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print(""""""Molecule already fragmented so no further action by auto_fragments().""""""); return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:37658,Energy Efficiency,charge,charge,37658,".0e-6 else 0.0]. # Determine degeneracy of rotational constants.; degen = 0; for i in range(2):; for j in range(i + 1, 3):; if degen >= 2:; continue; rabs = math.fabs(rot_const[i] - rot_const[j]); tmp = rot_const[i] if rot_const[i] > rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. [docs] def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. [docs] def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). # Attach methods to qcdb.Molecule class; from .interface_dftd3 import run_dftd3 as _dftd3_qcdb_yo; Molecule.run_dftd3 = _dftd3_qcdb_yo; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol2 = _parker_xyz2mol_yo; from .parker import bond_profile as _parker_bondprofile_yo; Molecule.bond_profile = _parker_bondprofile_yo. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:37875,Energy Efficiency,charge,charge,37875,":; for j in range(i + 1, 3):; if degen >= 2:; continue; rabs = math.fabs(rot_const[i] - rot_const[j]); tmp = rot_const[i] if rot_const[i] > rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. [docs] def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. [docs] def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). # Attach methods to qcdb.Molecule class; from .interface_dftd3 import run_dftd3 as _dftd3_qcdb_yo; Molecule.run_dftd3 = _dftd3_qcdb_yo; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol2 = _parker_xyz2mol_yo; from .parker import bond_profile as _parker_bondprofile_yo; Molecule.bond_profile = _parker_bondprofile_yo. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:38048,Energy Efficiency,charge,charge,38048,":; for j in range(i + 1, 3):; if degen >= 2:; continue; rabs = math.fabs(rot_const[i] - rot_const[j]); tmp = rot_const[i] if rot_const[i] > rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. [docs] def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. [docs] def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). # Attach methods to qcdb.Molecule class; from .interface_dftd3 import run_dftd3 as _dftd3_qcdb_yo; Molecule.run_dftd3 = _dftd3_qcdb_yo; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol2 = _parker_xyz2mol_yo; from .parker import bond_profile as _parker_bondprofile_yo; Molecule.bond_profile = _parker_bondprofile_yo. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:23150,Modifiability,variab,variables,23150,"2f} {:>17.12f} {:>17.12f}\n"""""".format(; x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = defaultdict(lambda: defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. [docs] def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). # # append units and any other non-default molecule keywords; # text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); # if not self.PYmove_to_com:; # text += "" no_com\n""; # if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continu",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:23227,Modifiability,variab,variables,23227,"2f} {:>17.12f} {:>17.12f}\n"""""".format(; x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = defaultdict(lambda: defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. [docs] def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). # # append units and any other non-default molecule keywords; # text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); # if not self.PYmove_to_com:; # text += "" no_com\n""; # if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continu",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:24917,Modifiability,variab,variables,24917,"ent\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = defaultdict(lambda: defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in ran",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:26363,Modifiability,variab,variable,26363,"elf.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i), \; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print(""""""Molecule already fragmented so no further action by auto_fragments().""""""); return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Mol",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:29843,Performance,queue,queue,29843," 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True, zero=ZERO):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt, zero). [docs] def inertia_tensor_partial(self, part, masswt=True, zero=ZERO):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:2281,Safety,detect,detected,2281,"import shutil; import random; from collections import defaultdict; from .libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. # def __getstate__(self):; # print 'im being pickled'; # return self.__dict__. # def __setstate__(self, d):; # print 'im being unpickled with these values', d; # self.__dict__ = d. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.comp",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:6335,Safety,detect,detected,6335,"e.add_atom(fileAtom, fileX, fileY, fileZ, z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; [docs] def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.rea",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:12572,Deployability,update,updated,12572,"{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt; intermol,ca=\$ca,cb=\$cb,icpks=0}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; # ]; #'dft-sapt-pbe0acalda': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,sapt_level=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,basis_mp2=mp2fit,cfit_scf=3}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # }; #. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:3211,Energy Efficiency,charge,charges,3211,"axz; if self.basis.startswith('heavy-aug-'):; text += """"""set,orbital; default,%s,H=%s\n"""""" % (self.basis[6:], self.unaugbasis); # xz, axz, 6-31g*; else:; text += """"""set,orbital; default,%s\n"""""" % (self.basis). if ('df-' in self.method) or ('f12' in self.method) or (self.method in ['mp2c', 'dft-sapt', 'dft-sapt-pbe0acalda']):; if self.unaugbasis and self.auxbasis:. text += """"""set,jkfit; default,%s/jkfit\n"""""" % (self.auxbasis); text += """"""set,jkfitb; default,%s/jkfit\n"""""" % (self.unaugbasis); text += """"""set,mp2fit; default,%s/mp2fit\n"""""" % (self.auxbasis); text += """"""set,dflhf; default,%s/jkfit\n"""""" % (self.auxbasis); else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)). text += """"""}\n\n""""""; return text. [docs] def format_infile_string(self):; text = ''. # format comment and memory; text += """"""***, %s %s\n"""""" % (self.index, self.molecule.tagline); text += """"""memory,%d,m\n"""""" % (self.memory). # format molecule, incl. charges and dummy atoms; text += self.molecule.format_molecule_for_molpro(). # format global convergence directions; text += self.format_global_parameters(). # format castup directions; if self.castup is True:; text += """"""basis=sto-3g\n""""""; text += """"""rhf\n""""""; text += '\n'. # format basis set; text += self.format_basis(). # format method; for line in qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:3773,Energy Efficiency,energy,energy,3773,"xiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)). text += """"""}\n\n""""""; return text. [docs] def format_infile_string(self):; text = ''. # format comment and memory; text += """"""***, %s %s\n"""""" % (self.index, self.molecule.tagline); text += """"""memory,%d,m\n"""""" % (self.memory). # format molecule, incl. charges and dummy atoms; text += self.molecule.format_molecule_for_molpro(). # format global convergence directions; text += self.format_global_parameters(). # format castup directions; if self.castup is True:; text += """"""basis=sto-3g\n""""""; text += """"""rhf\n""""""; text += '\n'. # format basis set; text += self.format_basis(). # format method; for line in qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_tri",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:3974,Energy Efficiency,energy,energy,3974,"xiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)). text += """"""}\n\n""""""; return text. [docs] def format_infile_string(self):; text = ''. # format comment and memory; text += """"""***, %s %s\n"""""" % (self.index, self.molecule.tagline); text += """"""memory,%d,m\n"""""" % (self.memory). # format molecule, incl. charges and dummy atoms; text += self.molecule.format_molecule_for_molpro(). # format global convergence directions; text += self.format_global_parameters(). # format castup directions; if self.castup is True:; text += """"""basis=sto-3g\n""""""; text += """"""rhf\n""""""; text += '\n'. # format basis set; text += self.format_basis(). # format method; for line in qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_tri",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:4076,Energy Efficiency,energy,energy,4076," (self.memory). # format molecule, incl. charges and dummy atoms; text += self.molecule.format_molecule_for_molpro(). # format global convergence directions; text += self.format_global_parameters(). # format castup directions; if self.castup is True:; text += """"""basis=sto-3g\n""""""; text += """"""rhf\n""""""; text += '\n'. # format basis set; text += self.format_basis(). # format method; for line in qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jk",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:4220,Energy Efficiency,energy,energy,4220," (self.memory). # format molecule, incl. charges and dummy atoms; text += self.molecule.format_molecule_for_molpro(). # format global convergence directions; text += self.format_global_parameters(). # format castup directions; if self.castup is True:; text += """"""basis=sto-3g\n""""""; text += """"""rhf\n""""""; text += '\n'. # format basis set; text += self.format_basis(). # format method; for line in qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jk",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:4330,Energy Efficiency,energy,energy,4330,".format_global_parameters(). # format castup directions; if self.castup is True:; text += """"""basis=sto-3g\n""""""; text += """"""rhf\n""""""; text += '\n'. # format basis set; text += self.format_basis(). # format method; for line in qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirec",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:4546,Energy Efficiency,energy,energy,4546," qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; '",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:4679,Energy Efficiency,energy,energy,4679,".12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:4796,Energy Efficiency,energy,energy,4796,"xch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:4916,Energy Efficiency,energy,energy,4916,"=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:4967,Energy Efficiency,energy,energy,4967,"ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:5114,Energy Efficiency,energy,energy,5114,"gc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:5376,Energy Efficiency,energy,energy,5376,"+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@monoBreal) { print $handle "",$at""; }; # ''; # '{df-hf,basis=jkfit,locorb=0; start,atdens; save,$ga}',; # '{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,$ga; save,$ca}',; # 'eehfa",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:5527,Energy Efficiency,energy,energy,5527,"p'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@monoBreal) { print $handle "",$at""; }; # ''; # '{df-hf,basis=jkfit,locorb=0; start,atdens; save,$ga}',; # '{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,$ga; save,$ca}',; # 'eehfa=energy; sapt; monomerA',; # '',; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:5585,Energy Efficiency,energy,energy,5585,"p2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@monoBreal) { print $handle "",$at""; }; # ''; # '{df-hf,basis=jkfit,locorb=0; start,atdens; save,$ga}',; # '{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,$ga; save,$ca}',; # 'eehfa=energy; sapt; monomerA',; # '',; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at"";",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:5697,Energy Efficiency,energy,energy,5697,"',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@monoBreal) { print $handle "",$at""; }; # ''; # '{df-hf,basis=jkfit,locorb=0; start,atdens; save,$ga}',; # '{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,$ga; save,$ca}',; # 'eehfa=energy; sapt; monomerA',; # '',; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:5787,Energy Efficiency,energy,energy,5787," 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@monoBreal) { print $handle "",$at""; }; # ''; # '{df-hf,basis=jkfit,locorb=0; start,atdens; save,$ga}',; # '{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,$ga; save,$ca}',; # 'eehfa=energy; sapt; monomerA',; # '',; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,\$gb; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:5863,Energy Efficiency,energy,energy,5863," 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@monoBreal) { print $handle "",$at""; }; # ''; # '{df-hf,basis=jkfit,locorb=0; start,atdens; save,$ga}',; # '{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,$ga; save,$ca}',; # 'eehfa=energy; sapt; monomerA',; # '',; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,\$gb; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n""",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:6397,Energy Efficiency,energy,energy,6397,"ect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@monoBreal) { print $handle "",$at""; }; # ''; # '{df-hf,basis=jkfit,locorb=0; start,atdens; save,$ga}',; # '{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,$ga; save,$ca}',; # 'eehfa=energy; sapt; monomerA',; # '',; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,\$gb; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,SAPT_LEVEL=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:6808,Energy Efficiency,energy,energy,6808,"s job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@monoBreal) { print $handle "",$at""; }; # ''; # '{df-hf,basis=jkfit,locorb=0; start,atdens; save,$ga}',; # '{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,$ga; save,$ca}',; # 'eehfa=energy; sapt; monomerA',; # '',; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,\$gb; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,SAPT_LEVEL=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tz",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:7620,Energy Efficiency,charge,charge,7620,"\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,\$gb; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,SAPT_LEVEL=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tzvpp\n"";; # print $handle ""{ks,pbe0; orbprint,0}\n"";; # print $handle ""eeneut=energy\n"";; # $charge += 1;; # $spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdire",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:7708,Energy Efficiency,charge,charge,7708,"\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,\$gb; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,SAPT_LEVEL=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tzvpp\n"";; # print $handle ""{ks,pbe0; orbprint,0}\n"";; # print $handle ""eeneut=energy\n"";; # $charge += 1;; # $spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdire",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:7968,Energy Efficiency,energy,energy,7968,"ac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tzvpp\n"";; # print $handle ""{ks,pbe0; orbprint,0}\n"";; # print $handle ""eeneut=energy\n"";; # $charge += 1;; # $spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdirect\n"";; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:7983,Energy Efficiency,charge,charge,7983,"ac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tzvpp\n"";; # print $handle ""{ks,pbe0; orbprint,0}\n"";; # print $handle ""eeneut=energy\n"";; # $charge += 1;; # $spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdirect\n"";; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:8041,Energy Efficiency,charge,charge,8041,"ac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tzvpp\n"";; # print $handle ""{ks,pbe0; orbprint,0}\n"";; # print $handle ""eeneut=energy\n"";; # $charge += 1;; # $spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdirect\n"";; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:8124,Energy Efficiency,energy,energy,8124,"ac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tzvpp\n"";; # print $handle ""{ks,pbe0; orbprint,0}\n"";; # print $handle ""eeneut=energy\n"";; # $charge += 1;; # $spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdirect\n"";; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:8884,Energy Efficiency,energy,energy,8884,"spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdirect\n"";; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,sapt_level=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,basis_mp2=mp2fit,cfit_scf=3}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # ]; #'dft-sapt-pbe0ac': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # p",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:9238,Energy Efficiency,energy,energy,9238,"$asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdirect\n"";; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,sapt_level=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,basis_mp2=mp2fit,cfit_scf=3}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # ]; #'dft-sapt-pbe0ac': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:10281,Energy Efficiency,energy,energy,10281,"ol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # ]; #'dft-sapt-pbe0ac': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt; intermol,ca=\$ca,cb=\$cb,icpks=0}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; # ]; #'dft-sapt-pbe0acalda': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SP",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:10549,Energy Efficiency,energy,energy,10549,"ol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # ]; #'dft-sapt-pbe0ac': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt; intermol,ca=\$ca,cb=\$cb,icpks=0}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; # ]; #'dft-sapt-pbe0acalda': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SP",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:11468,Energy Efficiency,energy,energy,11468,"n = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt; intermol,ca=\$ca,cb=\$cb,icpks=0}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; # ]; #'dft-sapt-pbe0acalda': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,sapt_level=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,basis_mp2=mp2fit,cfit_scf=3}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # }; #. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesd",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:11736,Energy Efficiency,energy,energy,11736,"n = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt; intermol,ca=\$ca,cb=\$cb,icpks=0}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; # ]; #'dft-sapt-pbe0acalda': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,sapt_level=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,basis_mp2=mp2fit,cfit_scf=3}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # }; #. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesd",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:7357,Modifiability,flexible,flexible,7357,"\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,\$gb; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,SAPT_LEVEL=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tzvpp\n"";; # print $handle ""{ks,pbe0; orbprint,0}\n"";; # print $handle ""eeneut=energy\n"";; # $charge += 1;; # $spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdire",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:2905,Safety,predict,predictable,2905,"-7,GRID=1.e-8\n\n""""""; else:; text += """"""GTHRESH,ZERO=1.e-14,ONEINT=1.e-14,TWOINT=1.e-14,ENERGY=1.e-9\n\n"""""". return text. [docs] def format_basis(self):; text = ''; text += """"""basis={\n"""""". try:; # jaxz, maxz, etc.; for line in molpro_basissets.altbasis[self.basis]:; text += """"""%s\n"""""" % (line); text += '\n'; except KeyError:; # haxz; if self.basis.startswith('heavy-aug-'):; text += """"""set,orbital; default,%s,H=%s\n"""""" % (self.basis[6:], self.unaugbasis); # xz, axz, 6-31g*; else:; text += """"""set,orbital; default,%s\n"""""" % (self.basis). if ('df-' in self.method) or ('f12' in self.method) or (self.method in ['mp2c', 'dft-sapt', 'dft-sapt-pbe0acalda']):; if self.unaugbasis and self.auxbasis:. text += """"""set,jkfit; default,%s/jkfit\n"""""" % (self.auxbasis); text += """"""set,jkfitb; default,%s/jkfit\n"""""" % (self.unaugbasis); text += """"""set,mp2fit; default,%s/mp2fit\n"""""" % (self.auxbasis); text += """"""set,dflhf; default,%s/jkfit\n"""""" % (self.auxbasis); else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)). text += """"""}\n\n""""""; return text. [docs] def format_infile_string(self):; text = ''. # format comment and memory; text += """"""***, %s %s\n"""""" % (self.index, self.molecule.tagline); text += """"""memory,%d,m\n"""""" % (self.memory). # format molecule, incl. charges and dummy atoms; text += self.molecule.format_molecule_for_molpro(). # format global convergence directions; text += self.format_global_parameters(). # format castup directions; if self.castup is True:; text += """"""basis=sto-3g\n""""""; text += """"""rhf\n""""""; text += '\n'. # format basis set; text += self.format_basis(). # format method; for line in qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=em",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:21099,Availability,avail,available,21099,"tions['GTHRESH'].items():; text += """""",%s=%s"""""" % (opt, val['value']); text += '\n\n'. for item in proc:; if len(options[item.upper()]) > 0:; text += """"""{%s%s}\n"""""" % (item, options[item.upper()]['OPTIONS']['value']); else:; text += """"""%s\n"""""" % (item). if text:; text += '\n'. return text. [docs]def muster_modelchem(name, dertype, mol):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)); proc = []. if dertype == 0:; pass; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'mp2':; pass; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'direct'; options['MP2']['MP2_TYPE']['value'] = 'conv'; text += """"""mp2')\n\n"""""". elif lowername == 'ccsd(t)-f12':; proc.append('rhf'); proc.append('ccsd(t)-f12'); options['CCSD(T)-F12']['OPTIONS']['value'] = ',df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb'. elif lowername == 'ccsd(t)-f12c':; proc.append('rhf'); proc.append('ccsd(t)-f12c'); options['CCSD(T)-F12C']['OPTIONS']['value'] = ',df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb'. elif lowername == 'ccsd(t)-f12-optri':; proc.append('rhf'); proc.append('ccsd(t)-f12'); options['CCSD(T)-F12']['OPTIONS']['value'] = ',df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=jkfitc'. elif lowername == 'ccsd(t)-f12-cabsfit':; proc.append('rhf'); proc.append('ccsd(t)-f12'); options['CCSD(T)-F12']['OPTIONS']['value'] = ',df_basis=jkfitc,df_basis_exch=jkfit",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:23233,Availability,avail,available,23233,")); proc.append('df-hf,'); proc.append('df-ks,'); proc.append('sapt; monomerA'); options['DF-HF,']['OPTIONS']['value'] = """"""basis=jkfit,locorb=0; start,atdens; save,1101.2""""""; options['DF-KS,']['OPTIONS']['value'] = """"""lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,1101.2; save,2101.2"""""". proc.append(mol.extract_fragments(2, 1).format_molecule_for_molpro()); proc.append('df-hf'); proc.append('df-ks'); proc.append('sapt; monomerB'); options['DF-HF']['OPTIONS']['value'] = """""",basis=jkfit,locorb=0; start,atdens; save,1102.2""""""; options['DF-KS']['OPTIONS']['value'] = """""",lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,1102.2; save,2102.2"""""". proc.append(mol.format_molecule_for_molpro()); proc.append('sapt; intermol'); options['SAPT; INTERMOL']['OPTIONS']['value'] = """""",saptlevel=3,ca=2101.2,cb=2102.2,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0; dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3"""""". else:; raise ValidationError(""""""Requested Cfour computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options, proc. procedures = {; 'energy': {; 'mp2c' : muster_modelchem,; 'ccsd(t)-f12' : muster_modelchem,; 'ccsd(t)-f12c' : muster_modelchem,; 'ccsd(t)-f12-optri' : muster_modelchem,; 'ccsd(t)-f12-cabsfit' : muster_modelchem,; #'sapt0' : muster_modelchem,; #'sapt2+' : muster_modelchem,; #'sapt2+(3)' : muster_modelchem,; #'sapt2+3(ccd)' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:4204,Deployability,patch,patched,4204,"E2ind\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind-exch\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2disp\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; # r'^\s+' + r'E2disp\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r'\)\s+' + NUMBER + r'\s+' + NUMBER + '\s*',; r'^\s+' + r'E2disp\s+' + NUMBER + r'.*$',; #r'^\s+' + r'E2disp-exch\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2disp-exc\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; outtext, re.MULTILINE); if mobj:; #print('matched sapt-like'); psivar['MP2C DISP20 ENERGY'] = Decimal(mobj.group(1)) / Decimal(1000). # <<< Process SCF-F12 >>>. mobj = re.search(; r'^\s+' + r'CABS-singles contribution of\s+' + NUMBER + r'\s+patched into reference energy.\s*' +; r'^\s+' + r'New reference energy\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched scff12'); psivar['SCF TOTAL ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['HF-CABS TOTAL ENERGY'] = mobj.group(2). # <<< Process MP2-F12 >>>. # DF-MP2-F12 correlation energies:; # --------------------------------; # Approx. Singlet Triplet Ecorr Total Energy; # DF-MP2 -0.261035854033 -0.140514056591 -0.401549910624 -112.843952380305; # DF-MP2-F12/3*C(DX,FIX) -0.367224875485 -0.163178266500 -0.530403141984 -112.972805611666; # DF-MP2-F12/3*C(FIX) -0.358294348708 -0.164988061549 -0.523282410258 -112.965684879939; # DF-MP2-F12/3C(FIX) -0.357375628783 -0.165176490386 -0.522552119169 -112.964954588851; #; # DF-MP2-F12 correlation energies:; # ================================; # Approx. Singlet Triplet Ecorr Total Energy; # DF-MP2 -0.357960885582 -0.185676627667 -0.543637513249 -132.841755020796; # DF-MP2-F1",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:11610,Deployability,release,released,11610,"SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD-F12C OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12C SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12C TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12C CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12C CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12C TOTAL ENERGY'] = psivar['CCSD(T)-F12C CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12C CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12C CORRELATION ENERGY'] = Decimal(mobj.group(2)) + psivar['(T*)-F12C CORRECTION ENERGY']; psivar['CCSD(T*)-F12C TOTAL ENERGY'] = psivar['CCSD(T*)-F12C CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']. # Process Completion; mobj = re.search(; r'^\s*' + r'Variable memory released' + r'\s+$',; outtext, re.MULTILINE); if mobj:; psivar['SUCCESS'] = True. # Process CURRENT energies (TODO: needs better way); if 'HF TOTAL ENERGY' in psivar:; psivar['CURRENT REFERENCE ENERGY'] = psivar['HF TOTAL ENERGY']; psivar['CURRENT ENERGY'] = psivar['HF TOTAL ENERGY']. if 'HF-CABS TOTAL ENERGY' in psivar:; psivar['CURRENT REFERENCE ENERGY'] = psivar['HF-CABS TOTAL ENERGY']; psivar['CURRENT ENERGY'] = psivar['HF-CABS TOTAL ENERGY']. if 'MP2 TOTAL ENERGY' in psivar and 'MP2 CORRELATION ENERGY' in psivar:; psivar['CURRENT CORRELATION ENERGY'] = psivar['MP2 CORRELATION ENERGY']; psivar['CURRENT ENERGY'] = psivar['MP2 TOTAL ENERGY']. if 'MP2-F12 TOTAL ENERGY' in psivar and 'MP2-F12 CORRELATION ENERGY' in psivar:; psivar['CURRENT CORRELATION ENERGY'] = psivar['MP2-F12 CORRELATION ENERGY']; psivar['CURRENT ENERGY'] = psivar['MP2-F12 TOTAL ENERGY']. if 'CCSD TOTAL ENERGY' in psivar and 'CCSD CORRELATION ENERGY' in psivar:; psivar['CURRENT CORRELATION ENERGY'] = psivar['CCSD CO",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:24446,Deployability,update,updated,24446,"ppend(mol.extract_fragments(2, 1).format_molecule_for_molpro()); proc.append('df-hf'); proc.append('df-ks'); proc.append('sapt; monomerB'); options['DF-HF']['OPTIONS']['value'] = """""",basis=jkfit,locorb=0; start,atdens; save,1102.2""""""; options['DF-KS']['OPTIONS']['value'] = """""",lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,1102.2; save,2102.2"""""". proc.append(mol.format_molecule_for_molpro()); proc.append('sapt; intermol'); options['SAPT; INTERMOL']['OPTIONS']['value'] = """""",saptlevel=3,ca=2101.2,cb=2102.2,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0; dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3"""""". else:; raise ValidationError(""""""Requested Cfour computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options, proc. procedures = {; 'energy': {; 'mp2c' : muster_modelchem,; 'ccsd(t)-f12' : muster_modelchem,; 'ccsd(t)-f12c' : muster_modelchem,; 'ccsd(t)-f12-optri' : muster_modelchem,; 'ccsd(t)-f12-cabsfit' : muster_modelchem,; #'sapt0' : muster_modelchem,; #'sapt2+' : muster_modelchem,; #'sapt2+(3)' : muster_modelchem,; #'sapt2+3(ccd)' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return procedures['energy'].keys(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:2135,Energy Efficiency,energy,energy,2135,"port molpro_basissets; from . import options. [docs]def harvest_output(outtext):; """"""Function to read MRCC output file *outtext* and parse important; quantum chemical information from it in. """"""; psivar = PreservingDict(); psivar_coord = None; psivar_grad = None. NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))"". # <<< Process NRE >>>; mobj = re.search(; r'^\s*' + r'(?:NUCLEAR REPULSION ENERGY)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched nrc'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1). # <<< Process SCF >>>. #mobj = re.search(; # r'^\s*' + r'(?:Energy of reference determinant (?:\[au\]|/au/):)' + r'\s+' + NUMBER + r'\s*$',; # outtext, re.MULTILINE); #if mobj:; # print('matched scf'); # psivar['SCF TOTAL ENERGY'] = mobj.group(1). # <<< Process MP2 >>>. mobj = re.search(; r'^\s*' + r'Reference energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 singlet pair energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 triplet pair energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 correlation energy[:]?\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched mp2'); psivar['HF TOTAL ENERGY'] = mobj.group(1); psivar['MP2 CORRELATION ENERGY'] = mobj.group(4); psivar['MP2 TOTAL ENERGY'] = Decimal(mobj.group(1)) + Decimal(mobj.group(4)); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(3)) * \; Decimal(2) / Decimal(3); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(4)) - \; psivar['MP2 SAME-SPIN CORRELATION ENERGY']. # <<< Process SAPT-like >>>. mobj = re.search(; #r'^\s+' + r'E1pol\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E1exch\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E1exch\(S2\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:2200,Energy Efficiency,energy,energy,2200,"port molpro_basissets; from . import options. [docs]def harvest_output(outtext):; """"""Function to read MRCC output file *outtext* and parse important; quantum chemical information from it in. """"""; psivar = PreservingDict(); psivar_coord = None; psivar_grad = None. NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))"". # <<< Process NRE >>>; mobj = re.search(; r'^\s*' + r'(?:NUCLEAR REPULSION ENERGY)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched nrc'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1). # <<< Process SCF >>>. #mobj = re.search(; # r'^\s*' + r'(?:Energy of reference determinant (?:\[au\]|/au/):)' + r'\s+' + NUMBER + r'\s*$',; # outtext, re.MULTILINE); #if mobj:; # print('matched scf'); # psivar['SCF TOTAL ENERGY'] = mobj.group(1). # <<< Process MP2 >>>. mobj = re.search(; r'^\s*' + r'Reference energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 singlet pair energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 triplet pair energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 correlation energy[:]?\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched mp2'); psivar['HF TOTAL ENERGY'] = mobj.group(1); psivar['MP2 CORRELATION ENERGY'] = mobj.group(4); psivar['MP2 TOTAL ENERGY'] = Decimal(mobj.group(1)) + Decimal(mobj.group(4)); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(3)) * \; Decimal(2) / Decimal(3); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(4)) - \; psivar['MP2 SAME-SPIN CORRELATION ENERGY']. # <<< Process SAPT-like >>>. mobj = re.search(; #r'^\s+' + r'E1pol\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E1exch\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E1exch\(S2\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:2265,Energy Efficiency,energy,energy,2265,"port molpro_basissets; from . import options. [docs]def harvest_output(outtext):; """"""Function to read MRCC output file *outtext* and parse important; quantum chemical information from it in. """"""; psivar = PreservingDict(); psivar_coord = None; psivar_grad = None. NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))"". # <<< Process NRE >>>; mobj = re.search(; r'^\s*' + r'(?:NUCLEAR REPULSION ENERGY)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched nrc'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1). # <<< Process SCF >>>. #mobj = re.search(; # r'^\s*' + r'(?:Energy of reference determinant (?:\[au\]|/au/):)' + r'\s+' + NUMBER + r'\s*$',; # outtext, re.MULTILINE); #if mobj:; # print('matched scf'); # psivar['SCF TOTAL ENERGY'] = mobj.group(1). # <<< Process MP2 >>>. mobj = re.search(; r'^\s*' + r'Reference energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 singlet pair energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 triplet pair energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 correlation energy[:]?\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched mp2'); psivar['HF TOTAL ENERGY'] = mobj.group(1); psivar['MP2 CORRELATION ENERGY'] = mobj.group(4); psivar['MP2 TOTAL ENERGY'] = Decimal(mobj.group(1)) + Decimal(mobj.group(4)); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(3)) * \; Decimal(2) / Decimal(3); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(4)) - \; psivar['MP2 SAME-SPIN CORRELATION ENERGY']. # <<< Process SAPT-like >>>. mobj = re.search(; #r'^\s+' + r'E1pol\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E1exch\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E1exch\(S2\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:2329,Energy Efficiency,energy,energy,2329,"port molpro_basissets; from . import options. [docs]def harvest_output(outtext):; """"""Function to read MRCC output file *outtext* and parse important; quantum chemical information from it in. """"""; psivar = PreservingDict(); psivar_coord = None; psivar_grad = None. NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))"". # <<< Process NRE >>>; mobj = re.search(; r'^\s*' + r'(?:NUCLEAR REPULSION ENERGY)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched nrc'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1). # <<< Process SCF >>>. #mobj = re.search(; # r'^\s*' + r'(?:Energy of reference determinant (?:\[au\]|/au/):)' + r'\s+' + NUMBER + r'\s*$',; # outtext, re.MULTILINE); #if mobj:; # print('matched scf'); # psivar['SCF TOTAL ENERGY'] = mobj.group(1). # <<< Process MP2 >>>. mobj = re.search(; r'^\s*' + r'Reference energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 singlet pair energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 triplet pair energy[:]?\s+' + NUMBER + r'\s*' +; r'^\s*' + r'MP2 correlation energy[:]?\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched mp2'); psivar['HF TOTAL ENERGY'] = mobj.group(1); psivar['MP2 CORRELATION ENERGY'] = mobj.group(4); psivar['MP2 TOTAL ENERGY'] = Decimal(mobj.group(1)) + Decimal(mobj.group(4)); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(3)) * \; Decimal(2) / Decimal(3); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(4)) - \; psivar['MP2 SAME-SPIN CORRELATION ENERGY']. # <<< Process SAPT-like >>>. mobj = re.search(; #r'^\s+' + r'E1pol\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E1exch\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E1exch\(S2\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:4227,Energy Efficiency,energy,energy,4227,"E2ind\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind-exch\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2disp\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; # r'^\s+' + r'E2disp\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r'\)\s+' + NUMBER + r'\s+' + NUMBER + '\s*',; r'^\s+' + r'E2disp\s+' + NUMBER + r'.*$',; #r'^\s+' + r'E2disp-exch\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2disp-exc\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; outtext, re.MULTILINE); if mobj:; #print('matched sapt-like'); psivar['MP2C DISP20 ENERGY'] = Decimal(mobj.group(1)) / Decimal(1000). # <<< Process SCF-F12 >>>. mobj = re.search(; r'^\s+' + r'CABS-singles contribution of\s+' + NUMBER + r'\s+patched into reference energy.\s*' +; r'^\s+' + r'New reference energy\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched scff12'); psivar['SCF TOTAL ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['HF-CABS TOTAL ENERGY'] = mobj.group(2). # <<< Process MP2-F12 >>>. # DF-MP2-F12 correlation energies:; # --------------------------------; # Approx. Singlet Triplet Ecorr Total Energy; # DF-MP2 -0.261035854033 -0.140514056591 -0.401549910624 -112.843952380305; # DF-MP2-F12/3*C(DX,FIX) -0.367224875485 -0.163178266500 -0.530403141984 -112.972805611666; # DF-MP2-F12/3*C(FIX) -0.358294348708 -0.164988061549 -0.523282410258 -112.965684879939; # DF-MP2-F12/3C(FIX) -0.357375628783 -0.165176490386 -0.522552119169 -112.964954588851; #; # DF-MP2-F12 correlation energies:; # ================================; # Approx. Singlet Triplet Ecorr Total Energy; # DF-MP2 -0.357960885582 -0.185676627667 -0.543637513249 -132.841755020796; # DF-MP2-F1",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:4268,Energy Efficiency,energy,energy,4268,"\s*'; #r'^\s+' + r'E2ind\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind-exch\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2disp\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; # r'^\s+' + r'E2disp\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r'\)\s+' + NUMBER + r'\s+' + NUMBER + '\s*',; r'^\s+' + r'E2disp\s+' + NUMBER + r'.*$',; #r'^\s+' + r'E2disp-exch\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2disp-exc\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; outtext, re.MULTILINE); if mobj:; #print('matched sapt-like'); psivar['MP2C DISP20 ENERGY'] = Decimal(mobj.group(1)) / Decimal(1000). # <<< Process SCF-F12 >>>. mobj = re.search(; r'^\s+' + r'CABS-singles contribution of\s+' + NUMBER + r'\s+patched into reference energy.\s*' +; r'^\s+' + r'New reference energy\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched scff12'); psivar['SCF TOTAL ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['HF-CABS TOTAL ENERGY'] = mobj.group(2). # <<< Process MP2-F12 >>>. # DF-MP2-F12 correlation energies:; # --------------------------------; # Approx. Singlet Triplet Ecorr Total Energy; # DF-MP2 -0.261035854033 -0.140514056591 -0.401549910624 -112.843952380305; # DF-MP2-F12/3*C(DX,FIX) -0.367224875485 -0.163178266500 -0.530403141984 -112.972805611666; # DF-MP2-F12/3*C(FIX) -0.358294348708 -0.164988061549 -0.523282410258 -112.965684879939; # DF-MP2-F12/3C(FIX) -0.357375628783 -0.165176490386 -0.522552119169 -112.964954588851; #; # DF-MP2-F12 correlation energies:; # ================================; # Approx. Singlet Triplet Ecorr Total Energy; # DF-MP2 -0.357960885582 -0.185676627667 -0.543637513249 -132.841755020796; # DF-MP2-F12/3*C(DX,FIX) -0.381816069559 -0.188149510095 -0.569965579654 -132.868083087202; # DF-MP2",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:6830,Energy Efficiency,energy,energy,6830,"\s+' + NUMBER + r'\s+' + NUMBER + r'\s*' +; r'^\s+' + r'DF-MP2-F12/3C\(FIX\)\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched mp2f12'); psivar['MP2 CORRELATION ENERGY'] = mobj.group(3); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) * \; Decimal(2) / Decimal(3); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(3)) - \; psivar['MP2 SAME-SPIN CORRELATION ENERGY']; psivar['MP2 TOTAL ENERGY'] = mobj.group(4); psivar['MP2-F12 CORRELATION ENERGY'] = mobj.group(15); psivar['MP2-F12 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(14)) * \; Decimal(2) / Decimal(3); psivar['MP2-F12 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(15)) - \; psivar['MP2-F12 SAME-SPIN CORRELATION ENERGY']; psivar['MP2-F12 TOTAL ENERGY'] = mobj.group(16). # <<< Process CC >>>. mobj = re.search(; r'^\s*' + r'CCSD triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)'); psivar['CCSD CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD SAME-SPIN CORRELATION ENERGY']; psivar['CCSD TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF TOTAL ENERGY']; psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T) TOTAL ENERGY'] = psivar['CCSD(T) CORRELATION ENERGY'] + psivar['HF TOTAL ENERGY']. # <<< Process CC-F12 >>>. mobj = re.search(; r'^\s*' + r'CCSD-F12a triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12a correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILI",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:6890,Energy Efficiency,energy,energy,6890,"\s+' + NUMBER + r'\s+' + NUMBER + r'\s*' +; r'^\s+' + r'DF-MP2-F12/3C\(FIX\)\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched mp2f12'); psivar['MP2 CORRELATION ENERGY'] = mobj.group(3); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) * \; Decimal(2) / Decimal(3); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(3)) - \; psivar['MP2 SAME-SPIN CORRELATION ENERGY']; psivar['MP2 TOTAL ENERGY'] = mobj.group(4); psivar['MP2-F12 CORRELATION ENERGY'] = mobj.group(15); psivar['MP2-F12 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(14)) * \; Decimal(2) / Decimal(3); psivar['MP2-F12 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(15)) - \; psivar['MP2-F12 SAME-SPIN CORRELATION ENERGY']; psivar['MP2-F12 TOTAL ENERGY'] = mobj.group(16). # <<< Process CC >>>. mobj = re.search(; r'^\s*' + r'CCSD triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)'); psivar['CCSD CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD SAME-SPIN CORRELATION ENERGY']; psivar['CCSD TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF TOTAL ENERGY']; psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T) TOTAL ENERGY'] = psivar['CCSD(T) CORRELATION ENERGY'] + psivar['HF TOTAL ENERGY']. # <<< Process CC-F12 >>>. mobj = re.search(; r'^\s*' + r'CCSD-F12a triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12a correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILI",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:7716,Energy Efficiency,energy,energy,7716,". mobj = re.search(; r'^\s*' + r'CCSD triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)'); psivar['CCSD CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD SAME-SPIN CORRELATION ENERGY']; psivar['CCSD TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF TOTAL ENERGY']; psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T) TOTAL ENERGY'] = psivar['CCSD(T) CORRELATION ENERGY'] + psivar['HF TOTAL ENERGY']. # <<< Process CC-F12 >>>. mobj = re.search(; r'^\s*' + r'CCSD-F12a triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12a correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)-f12a'); psivar['CCSD-F12A CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD-F12A SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD-F12A OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12A SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12A TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12A CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12A TOTAL ENERGY'] = psivar['CCSD(T)-F12A CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12A CORRELATION ENERGY'] = Decim",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:7781,Energy Efficiency,energy,energy,7781,". mobj = re.search(; r'^\s*' + r'CCSD triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)'); psivar['CCSD CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD SAME-SPIN CORRELATION ENERGY']; psivar['CCSD TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF TOTAL ENERGY']; psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T) TOTAL ENERGY'] = psivar['CCSD(T) CORRELATION ENERGY'] + psivar['HF TOTAL ENERGY']. # <<< Process CC-F12 >>>. mobj = re.search(; r'^\s*' + r'CCSD-F12a triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12a correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)-f12a'); psivar['CCSD-F12A CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD-F12A SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD-F12A OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12A SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12A TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12A CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12A TOTAL ENERGY'] = psivar['CCSD(T)-F12A CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12A CORRELATION ENERGY'] = Decim",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:9010,Energy Efficiency,energy,energy,9010,"\; Decimal(2) / Decimal(3); psivar['CCSD-F12A OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12A SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12A TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12A CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12A TOTAL ENERGY'] = psivar['CCSD(T)-F12A CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12A CORRELATION ENERGY'] = Decimal(mobj.group(2)) + psivar['(T*)-F12AB CORRECTION ENERGY']; psivar['CCSD(T*)-F12A TOTAL ENERGY'] = psivar['CCSD(T*)-F12A CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']. mobj = re.search(; r'^\s*' + r'CCSD-F12b triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12b correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)-f12b'); psivar['CCSD-F12B CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD-F12B SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD-F12B OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12B SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12B TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12B CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12B TOTAL ENERGY'] = psivar['CCSD(T)-F12B CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12B CORRELATION ENERGY'] = Decim",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:9075,Energy Efficiency,energy,energy,9075,"\; Decimal(2) / Decimal(3); psivar['CCSD-F12A OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12A SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12A TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12A CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12A TOTAL ENERGY'] = psivar['CCSD(T)-F12A CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12A CORRELATION ENERGY'] = Decimal(mobj.group(2)) + psivar['(T*)-F12AB CORRECTION ENERGY']; psivar['CCSD(T*)-F12A TOTAL ENERGY'] = psivar['CCSD(T*)-F12A CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']. mobj = re.search(; r'^\s*' + r'CCSD-F12b triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12b correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)-f12b'); psivar['CCSD-F12B CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD-F12B SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD-F12B OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12B SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12B TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12B CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12B TOTAL ENERGY'] = psivar['CCSD(T)-F12B CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12B CORRELATION ENERGY'] = Decim",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:10304,Energy Efficiency,energy,energy,10304,"\; Decimal(2) / Decimal(3); psivar['CCSD-F12B OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12B SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12B TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12B CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12B TOTAL ENERGY'] = psivar['CCSD(T)-F12B CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12B CORRELATION ENERGY'] = Decimal(mobj.group(2)) + psivar['(T*)-F12AB CORRECTION ENERGY']; psivar['CCSD(T*)-F12B TOTAL ENERGY'] = psivar['CCSD(T*)-F12B CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']. mobj = re.search(; r'^\s*' + r'CCSD-F12c triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12c correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)-f12c'); psivar['CCSD-F12C CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD-F12C SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD-F12C OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12C SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12C TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12C CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12C CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12C TOTAL ENERGY'] = psivar['CCSD(T)-F12C CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12C CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12C CORRELATION ENERGY'] = Decimal",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:10369,Energy Efficiency,energy,energy,10369,"\; Decimal(2) / Decimal(3); psivar['CCSD-F12B OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12B SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12B TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12B CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12B TOTAL ENERGY'] = psivar['CCSD(T)-F12B CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12B CORRELATION ENERGY'] = Decimal(mobj.group(2)) + psivar['(T*)-F12AB CORRECTION ENERGY']; psivar['CCSD(T*)-F12B TOTAL ENERGY'] = psivar['CCSD(T*)-F12B CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']. mobj = re.search(; r'^\s*' + r'CCSD-F12c triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12c correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)-f12c'); psivar['CCSD-F12C CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD-F12C SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD-F12C OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12C SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12C TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12C CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12C CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12C TOTAL ENERGY'] = psivar['CCSD(T)-F12C CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12C CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12C CORRELATION ENERGY'] = Decimal",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:17619,Energy Efficiency,energy,energy,17619,"#print opt, val['value']; #print molpro_basissets.altbasis.keys(); if not text:; text += """"""basis={\n""""""; try:; # jaxz, maxz, etc.; for line in molpro_basissets.altbasis[val['value']]:; text += """"""%s\n"""""" % (line); text += '\n'; except KeyError:; # haxz; if val['value'].startswith('heavy-aug-'):; text += """"""set,%s; default,%s,H=%s\n"""""" % (opt.lower(), self.augbasis, self.unaugbasis); # xz, axz, 6-31g*; else:; text += """"""set,%s; default,%s\n"""""" % (opt.lower(), val['value']); ; if text:; text += """"""}\n\n"""""". return text. [docs] def format_infile_string(self):; """""". """"""; # Handle memory and comment; memcmd, _memkw = """"""***, %s\nmemory,%d,m\n"""""" % (self.molecule.tagline, int(math.ceil(self.memory / 8.0))), {}. # Handle molecule and basis set; molcmd, _molkw = self.molecule.format_molecule_for_molpro(), {}. # format global convergence directions; # text += self.format_global_parameters(); _cdscmd, cdskw = muster_cdsgroup_options(self.method). # Handle calc type and quantum chemical method; mdccmd, mdckw, mdcls = procedures['energy'][self.method](self.method, self.dertype, self.molecule); _bascmd, baskw = self.muster_basis_options(). # # format options; # optcmd = qcdb.options.prepare_options_for_psi4(mdckw). # make options from imdb only user options (currently non-existent). set basis and castup from here.; # Handle driver vs input/default keyword reconciliation; userkw = self.options; # userkw = p4util.prepare_options_for_modules(); #userkw = qcdb.options.reconcile_options(userkw, memkw); #userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = options.reconcile_options2(userkw, cdskw); userkw = options.reconcile_options2(userkw, baskw); #userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = options.reconcile_options2(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; #optcmdB = options.prepare_options_for_psi4(userkw); optcmd = prepare_options_for_molpro(userkw, mdcls); bascmd, _baskw = self.prepare_basis_for_molpro(),",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:23770,Energy Efficiency,energy,energy,23770,"ppend(mol.extract_fragments(2, 1).format_molecule_for_molpro()); proc.append('df-hf'); proc.append('df-ks'); proc.append('sapt; monomerB'); options['DF-HF']['OPTIONS']['value'] = """""",basis=jkfit,locorb=0; start,atdens; save,1102.2""""""; options['DF-KS']['OPTIONS']['value'] = """""",lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,1102.2; save,2102.2"""""". proc.append(mol.format_molecule_for_molpro()); proc.append('sapt; intermol'); options['SAPT; INTERMOL']['OPTIONS']['value'] = """""",saptlevel=3,ca=2101.2,cb=2102.2,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0; dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3"""""". else:; raise ValidationError(""""""Requested Cfour computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options, proc. procedures = {; 'energy': {; 'mp2c' : muster_modelchem,; 'ccsd(t)-f12' : muster_modelchem,; 'ccsd(t)-f12c' : muster_modelchem,; 'ccsd(t)-f12-optri' : muster_modelchem,; 'ccsd(t)-f12-cabsfit' : muster_modelchem,; #'sapt0' : muster_modelchem,; #'sapt2+' : muster_modelchem,; #'sapt2+(3)' : muster_modelchem,; #'sapt2+3(ccd)' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return procedures['energy'].keys(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:24125,Energy Efficiency,energy,energy,24125,"ppend(mol.extract_fragments(2, 1).format_molecule_for_molpro()); proc.append('df-hf'); proc.append('df-ks'); proc.append('sapt; monomerB'); options['DF-HF']['OPTIONS']['value'] = """""",basis=jkfit,locorb=0; start,atdens; save,1102.2""""""; options['DF-KS']['OPTIONS']['value'] = """""",lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,1102.2; save,2102.2"""""". proc.append(mol.format_molecule_for_molpro()); proc.append('sapt; intermol'); options['SAPT; INTERMOL']['OPTIONS']['value'] = """""",saptlevel=3,ca=2101.2,cb=2102.2,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0; dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3"""""". else:; raise ValidationError(""""""Requested Cfour computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options, proc. procedures = {; 'energy': {; 'mp2c' : muster_modelchem,; 'ccsd(t)-f12' : muster_modelchem,; 'ccsd(t)-f12c' : muster_modelchem,; 'ccsd(t)-f12-optri' : muster_modelchem,; 'ccsd(t)-f12-cabsfit' : muster_modelchem,; #'sapt0' : muster_modelchem,; #'sapt2+' : muster_modelchem,; #'sapt2+(3)' : muster_modelchem,; #'sapt2+3(ccd)' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return procedures['energy'].keys(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:24233,Energy Efficiency,energy,energy,24233,"ppend(mol.extract_fragments(2, 1).format_molecule_for_molpro()); proc.append('df-hf'); proc.append('df-ks'); proc.append('sapt; monomerB'); options['DF-HF']['OPTIONS']['value'] = """""",basis=jkfit,locorb=0; start,atdens; save,1102.2""""""; options['DF-KS']['OPTIONS']['value'] = """""",lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,1102.2; save,2102.2"""""". proc.append(mol.format_molecule_for_molpro()); proc.append('sapt; intermol'); options['SAPT; INTERMOL']['OPTIONS']['value'] = """""",saptlevel=3,ca=2101.2,cb=2102.2,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0; dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3"""""". else:; raise ValidationError(""""""Requested Cfour computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options, proc. procedures = {; 'energy': {; 'mp2c' : muster_modelchem,; 'ccsd(t)-f12' : muster_modelchem,; 'ccsd(t)-f12c' : muster_modelchem,; 'ccsd(t)-f12-optri' : muster_modelchem,; 'ccsd(t)-f12-cabsfit' : muster_modelchem,; #'sapt0' : muster_modelchem,; #'sapt2+' : muster_modelchem,; #'sapt2+(3)' : muster_modelchem,; #'sapt2+3(ccd)' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return procedures['energy'].keys(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:15877,Safety,predict,predictable,15877,"is sets; [self.unaugbasis, self.augbasis, self.auxbasis] = self.corresponding_aux_basis(). [docs] def muster_basis_options(self):; text = ''; lowername = self.method.lower(); options = defaultdict(lambda: defaultdict(dict)); ; options['BASIS']['ORBITAL']['value'] = self.basis; ; # this f12 basis setting may be totally messed up; if self.method in ['ccsd(t)-f12-optri']:; if self.basis == 'cc-pvdz-f12':; options['BASIS']['JKFIT']['value'] = 'aug-cc-pvtz/jkfit'; options['BASIS']['JKFITC']['value'] = self.basis + '/optri'; options['BASIS']['MP2FIT']['value'] = 'aug-cc-pvtz/mp2fit'; elif self.method in ['ccsd(t)-f12-cabsfit']:; if self.unaugbasis and self.auxbasis:; #options['BASIS']['JKFIT']['value'] = self.auxbasis + '/jkfit'; #options['BASIS']['JKFITB']['value'] = self.unaugbasis + '/jkfit'; #options['BASIS']['MP2FIT']['value'] = self.auxbasis + '/mp2fit'; #options['BASIS']['DFLHF']['value'] = self.auxbasis + '/jkfit'; options['BASIS']['JKFITC']['value'] = 'aug-cc-pv5z/mp2fit'; else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)); elif ('df-' in self.method) or ('f12' in self.method) or (self.method in ['mp2c', 'dft-sapt', 'dft-sapt-pbe0acalda']):; if self.unaugbasis and self.auxbasis:; options['BASIS']['JKFIT']['value'] = self.auxbasis + '/jkfit'; options['BASIS']['JKFITB']['value'] = self.unaugbasis + '/jkfit'; options['BASIS']['MP2FIT']['value'] = self.auxbasis + '/mp2fit'; options['BASIS']['DFLHF']['value'] = self.auxbasis + '/jkfit'; else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)); return text, options. [docs] def prepare_basis_for_molpro(self):; text = ''; ; for opt, val in self.options['BASIS'].items():; #print opt, val['value']; #print molpro_basissets.altbasis.keys(); if not text:; text += """"""basis={\n""""""; try:; # jaxz, maxz, etc.; for line in molpro_basissets.altbasis[val['value']]:; text += """"""%s\n"""""" % (line); text += '\n'; except KeyError:; # h",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:16401,Safety,predict,predictable,16401,"alue'] = 'aug-cc-pvtz/mp2fit'; elif self.method in ['ccsd(t)-f12-cabsfit']:; if self.unaugbasis and self.auxbasis:; #options['BASIS']['JKFIT']['value'] = self.auxbasis + '/jkfit'; #options['BASIS']['JKFITB']['value'] = self.unaugbasis + '/jkfit'; #options['BASIS']['MP2FIT']['value'] = self.auxbasis + '/mp2fit'; #options['BASIS']['DFLHF']['value'] = self.auxbasis + '/jkfit'; options['BASIS']['JKFITC']['value'] = 'aug-cc-pv5z/mp2fit'; else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)); elif ('df-' in self.method) or ('f12' in self.method) or (self.method in ['mp2c', 'dft-sapt', 'dft-sapt-pbe0acalda']):; if self.unaugbasis and self.auxbasis:; options['BASIS']['JKFIT']['value'] = self.auxbasis + '/jkfit'; options['BASIS']['JKFITB']['value'] = self.unaugbasis + '/jkfit'; options['BASIS']['MP2FIT']['value'] = self.auxbasis + '/mp2fit'; options['BASIS']['DFLHF']['value'] = self.auxbasis + '/jkfit'; else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)); return text, options. [docs] def prepare_basis_for_molpro(self):; text = ''; ; for opt, val in self.options['BASIS'].items():; #print opt, val['value']; #print molpro_basissets.altbasis.keys(); if not text:; text += """"""basis={\n""""""; try:; # jaxz, maxz, etc.; for line in molpro_basissets.altbasis[val['value']]:; text += """"""%s\n"""""" % (line); text += '\n'; except KeyError:; # haxz; if val['value'].startswith('heavy-aug-'):; text += """"""set,%s; default,%s,H=%s\n"""""" % (opt.lower(), self.augbasis, self.unaugbasis); # xz, axz, 6-31g*; else:; text += """"""set,%s; default,%s\n"""""" % (opt.lower(), val['value']); ; if text:; text += """"""}\n\n"""""". return text. [docs] def format_infile_string(self):; """""". """"""; # Handle memory and comment; memcmd, _memkw = """"""***, %s\nmemory,%d,m\n"""""" % (self.molecule.tagline, int(math.ceil(self.memory / 8.0))), {}. # Handle molecule and basis set; molcmd, _molkw = self.molecule.format_molecule_for_molp",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/molpro2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:1588,Availability,avail,availibility,1588,"refix='', relpath=False):; """"""Analyzes string *saveas* to see if it contains information on; path to save file, name to save file, both or neither (*saveas*; ends in '/' to indicate directory only) (able to expand '.'). A full; absolute filename is returned, lacking only file extension. Based on; analysis of missing parts of *saveas*, path information from *def_path*; and/or filename information from *def_prefix* + *def_filename* is; inserted. *def_prefix* is intended to be something like ``mplthread_``; to identify the type of figure. """"""; defname = def_prefix + def_filename.replace(' ', '_'); if saveas is None:; pth = def_path; fil = defname; else:; pth, fil = os.path.split(saveas); pth = pth if pth != '' else def_path; fil = fil if fil != '' else defname. abspathfile = os.path.join(os.path.abspath(pth), fil); if relpath:; return os.path.relpath(abspathfile, os.getcwd()); else:; return abspathfile. [docs]def segment_color(argcolor, saptcolor):; """"""Find appropriate color expression between overall color directive; *argcolor* and particular color availibility *rxncolor*. """"""; import matplotlib. # validate any sapt color; if saptcolor is not None:; if saptcolor < 0.0 or saptcolor > 1.0:; saptcolor = None. if argcolor is None:; # no color argument, so take from rxn; if rxncolor is None:; clr = 'grey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:1985,Availability,avail,available,1985,"rted. *def_prefix* is intended to be something like ``mplthread_``; to identify the type of figure. """"""; defname = def_prefix + def_filename.replace(' ', '_'); if saveas is None:; pth = def_path; fil = defname; else:; pth, fil = os.path.split(saveas); pth = pth if pth != '' else def_path; fil = fil if fil != '' else defname. abspathfile = os.path.join(os.path.abspath(pth), fil); if relpath:; return os.path.relpath(abspathfile, os.getcwd()); else:; return abspathfile. [docs]def segment_color(argcolor, saptcolor):; """"""Find appropriate color expression between overall color directive; *argcolor* and particular color availibility *rxncolor*. """"""; import matplotlib. # validate any sapt color; if saptcolor is not None:; if saptcolor < 0.0 or saptcolor > 1.0:; saptcolor = None. if argcolor is None:; # no color argument, so take from rxn; if rxncolor is None:; clr = 'grey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries with error; statistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in argument; *data*. The plot is labeled with *title* and each bar with *mc* key and; plotted at a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:2139,Availability,avail,available,2139,"', '_'); if saveas is None:; pth = def_path; fil = defname; else:; pth, fil = os.path.split(saveas); pth = pth if pth != '' else def_path; fil = fil if fil != '' else defname. abspathfile = os.path.join(os.path.abspath(pth), fil); if relpath:; return os.path.relpath(abspathfile, os.getcwd()); else:; return abspathfile. [docs]def segment_color(argcolor, saptcolor):; """"""Find appropriate color expression between overall color directive; *argcolor* and particular color availibility *rxncolor*. """"""; import matplotlib. # validate any sapt color; if saptcolor is not None:; if saptcolor < 0.0 or saptcolor > 1.0:; saptcolor = None. if argcolor is None:; # no color argument, so take from rxn; if rxncolor is None:; clr = 'grey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries with error; statistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in argument; *data*. The plot is labeled with *title* and each bar with *mc* key and; plotted at a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(figsize=(12, 7)); plt.ylim([0, 4.86]); plt.xlim([0, 6]); plt.xticks([]). # label plot and tiers; ax.text(0.4, 4.6, title,; verticalalignment='bottom', ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:2531,Availability,error,error,2531,"en overall color directive; *argcolor* and particular color availibility *rxncolor*. """"""; import matplotlib. # validate any sapt color; if saptcolor is not None:; if saptcolor < 0.0 or saptcolor > 1.0:; saptcolor = None. if argcolor is None:; # no color argument, so take from rxn; if rxncolor is None:; clr = 'grey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries with error; statistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in argument; *data*. The plot is labeled with *title* and each bar with *mc* key and; plotted at a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(figsize=(12, 7)); plt.ylim([0, 4.86]); plt.xlim([0, 6]); plt.xticks([]). # label plot and tiers; ax.text(0.4, 4.6, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12). widths = [0.15, 0.02, 0.02, 0.02] # TT, HB, MX, DD; xval = 0.1 # starting posn along x-axis. # plot bar sets; for bar in data:; if bar is not None:; lefts = [xval, xval + 0.025, xval + 0.065, xval + 0.105]. rect = ax.bar(lefts, bar['data'], widths, linewidth=0); rect[0].set_color('grey'); rect[1].set_color('red'); rect[2].se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:4425,Availability,error,errors,4425,"r['data'], widths, linewidth=0); rect[0].set_color('grey'); rect[1].set_color('red'); rect[2].set_color('green'); rect[3].set_color('blue'). ax.text(xval + .08, 4.3, bar['mc'],; verticalalignment='center', horizontalalignment='right', rotation='vertical',; family='Times New Roman', fontsize=8); xval += 0.20. # save and show; pltuid = title + '_' + hashlib.sha1(title + repr([bar['mc'] for bar in data if bar is not None])).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='bar_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. [docs]def flat(data, color=None, title='', xlimit=4.0, xlines=[0.0, 0.3, 1.0], mae=None, mape=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a slat diagram between model chemistries with errors in; single-item list *data*, which is supplied as part of the dictionary; for each participating reaction, along with *dbse* and *rxn* keys in; argument *data*. Limits of plot are *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from; sapt_colors module. Summary statistic *mae* is plotted on the; overbound side and relative statistic *mape* on the underbound side.; Saves a file with name *title* and plots to screen if *view*. """"""; import matplotlib.pyplot as plt. Nweft = 1; positions = range(-1, -1 * Nweft - 1, -1). # initialize plot; fig, ax = plt.subplots(figsize=(12, 0.33)); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); plt.xticks([]); # fig.patch.set_visible(False); # ax.patch.set_visible(False); ax.axis('off'). for xl in xlines:; plt.axvline(xl, color='grey', linewidth=4); if xl != 0.0:; plt.axvline(-1 * xl, color='grey', linewidth=4). # plot reaction errors and threads; for rxn in data:; xvals = rxn['data']",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:5377,Availability,error,errors,5377,"in; single-item list *data*, which is supplied as part of the dictionary; for each participating reaction, along with *dbse* and *rxn* keys in; argument *data*. Limits of plot are *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from; sapt_colors module. Summary statistic *mae* is plotted on the; overbound side and relative statistic *mape* on the underbound side.; Saves a file with name *title* and plots to screen if *view*. """"""; import matplotlib.pyplot as plt. Nweft = 1; positions = range(-1, -1 * Nweft - 1, -1). # initialize plot; fig, ax = plt.subplots(figsize=(12, 0.33)); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); plt.xticks([]); # fig.patch.set_visible(False); # ax.patch.set_visible(False); ax.axis('off'). for xl in xlines:; plt.axvline(xl, color='grey', linewidth=4); if xl != 0.0:; plt.axvline(-1 * xl, color='grey', linewidth=4). # plot reaction errors and threads; for rxn in data:; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None). ax.plot(xvals, positions, '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. #def mpl_distslat_multiplot_files(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with basename *pltfile* with a sl",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:6472,Availability,error,errors,6472,"threads; for rxn in data:; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None). ax.plot(xvals, positions, '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. #def mpl_distslat_multiplot_files(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with basename *pltfile* with a slat representation; # of the modelchems errors in *mcdat*. Plot is in PNG, PDF, & EPS; # and suitable for download, no mouseover properties. Both labeled; # and labelless (for pub) figures are constructed.; #; # """"""; # import matplotlib as mpl; # from matplotlib.axes import Subplot; # import sapt_colors; # from matplotlib.figure import Figure; #; # nplots = len(mcdats); # fht = nplots * 0.8; # fig, axt = plt.subplots(figsize=(12.0, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); #; # axt.set_xticks([]); # axt.set_yticks([]); # plt.axis('off'); #; # for item in range(nplots):; # mcdat = mcdats[item]; # label = labels[item]; # title = titles[item]; #; # erdat = np.array(mcdat); # yvals = np.ones(len(mcdat)); # y = np.array([sapt_colors.sapt_colors[dbname][i] for i in label]); #; # ax = Subplot(fig, nplots, 1, item + 1); # fig.add_subplot(ax); # sc = ax.scatter(erdat, yvals, c=y, s=3000, marker=""|"", cmap=mpl.cm.jet, vmin=0, vmax",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:6538,Availability,down,download,6538," '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. #def mpl_distslat_multiplot_files(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with basename *pltfile* with a slat representation; # of the modelchems errors in *mcdat*. Plot is in PNG, PDF, & EPS; # and suitable for download, no mouseover properties. Both labeled; # and labelless (for pub) figures are constructed.; #; # """"""; # import matplotlib as mpl; # from matplotlib.axes import Subplot; # import sapt_colors; # from matplotlib.figure import Figure; #; # nplots = len(mcdats); # fht = nplots * 0.8; # fig, axt = plt.subplots(figsize=(12.0, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); #; # axt.set_xticks([]); # axt.set_yticks([]); # plt.axis('off'); #; # for item in range(nplots):; # mcdat = mcdats[item]; # label = labels[item]; # title = titles[item]; #; # erdat = np.array(mcdat); # yvals = np.ones(len(mcdat)); # y = np.array([sapt_colors.sapt_colors[dbname][i] for i in label]); #; # ax = Subplot(fig, nplots, 1, item + 1); # fig.add_subplot(ax); # sc = ax.scatter(erdat, yvals, c=y, s=3000, marker=""|"", cmap=mpl.cm.jet, vmin=0, vmax=1); #; # ax.set_yticks([]); # ax.set_xticks([]); # ax.set_frame_on(False); # ax.set_xlim([xmin, xmax]); #; # # Write files with only slats; # ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:9477,Availability,error,errors,9477,"_params(axis='both', which='major', labelbottom='on', bottom='off'); #; # plt.savefig('scratch/' + pltfile + '_trimd' + '.png', transparent=True, format='PNG'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.pdf', transparent=True, format='PDF'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.eps', transparent=True, format='EPS'). [docs]def valerr(data, color=None, title='', xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; import hashlib; from itertools import cycle; import matplotlib.pyplot as plt. fig, ax = plt.subplots(figsize=(4, 6)); ax1 = fig.add_subplot(211); plt.axhline(0.0, axes=ax1, color='black'); ax1.set_ylabel('Reaction Energy'); plt.title(title). ax2 = plt.subplot(212, sharex=ax1); plt.axhline(0.0, axes=ax2, color='#cccc00'); ax2.set_ylabel('Energy Error'); ax2.set_xlabel(xtitle). xmin = 500.0; xmax = -500.0; vmin = 1.0; vmax = -1.0; emin = 1.0; emax = -1.0; linecycler = cycle(['-', '--', '-.', ':']); # plot reaction errors and threads; for trace, tracedata in data.iteritems():; vaxis = []; vmcdata = []; verror = []; for rxn in tracedata:; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); xmin = min(xmin, rxn['axis']); xmax = max(xmax, rxn['axis']). ax1.plot(rxn['axis'], rxn['mcdata'], '^', color=clr, markersize=6.0, mew=0, zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.plot(rxn['axis'], rxn['bmdata'], 'o', color='black', markersize=6.0, zorder=1); vmin = min(0, vmin, rxn['bmdata']); vmax = max(0, vmax, rxn['bmdata']). if rxn['error'][0] is not None:; ax2.plot(rxn['axis'], rxn['error'][0], 's', color=clr, mew=0, zorder=8); emin = min(0, emin, rxn['error'][0]); emax = max(0, emax, rxn['error'][0]); verror.append(rxn['error'][0]). ls = next(linecycler); ax1.plot(vaxis, vmcdata, ls, color='grey', label=trace, zorder=3); ax2.plot(vaxis, verror, ls, color='grey', labe",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:10147,Availability,error,error,10147,"label('Reaction Energy'); plt.title(title). ax2 = plt.subplot(212, sharex=ax1); plt.axhline(0.0, axes=ax2, color='#cccc00'); ax2.set_ylabel('Energy Error'); ax2.set_xlabel(xtitle). xmin = 500.0; xmax = -500.0; vmin = 1.0; vmax = -1.0; emin = 1.0; emax = -1.0; linecycler = cycle(['-', '--', '-.', ':']); # plot reaction errors and threads; for trace, tracedata in data.iteritems():; vaxis = []; vmcdata = []; verror = []; for rxn in tracedata:; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); xmin = min(xmin, rxn['axis']); xmax = max(xmax, rxn['axis']). ax1.plot(rxn['axis'], rxn['mcdata'], '^', color=clr, markersize=6.0, mew=0, zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.plot(rxn['axis'], rxn['bmdata'], 'o', color='black', markersize=6.0, zorder=1); vmin = min(0, vmin, rxn['bmdata']); vmax = max(0, vmax, rxn['bmdata']). if rxn['error'][0] is not None:; ax2.plot(rxn['axis'], rxn['error'][0], 's', color=clr, mew=0, zorder=8); emin = min(0, emin, rxn['error'][0]); emax = max(0, emax, rxn['error'][0]); verror.append(rxn['error'][0]). ls = next(linecycler); ax1.plot(vaxis, vmcdata, ls, color='grey', label=trace, zorder=3); ax2.plot(vaxis, verror, ls, color='grey', label=trace, zorder=4). xbuf = max(0.05, abs(0.02 * xmax)); vbuf = max(0.1, abs(0.02 * vmax)); ebuf = max(0.01, abs(0.02 * emax)); plt.xlim([xmin - xbuf, xmax + xbuf]); ax1.set_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:10199,Availability,error,error,10199,", axes=ax2, color='#cccc00'); ax2.set_ylabel('Energy Error'); ax2.set_xlabel(xtitle). xmin = 500.0; xmax = -500.0; vmin = 1.0; vmax = -1.0; emin = 1.0; emax = -1.0; linecycler = cycle(['-', '--', '-.', ':']); # plot reaction errors and threads; for trace, tracedata in data.iteritems():; vaxis = []; vmcdata = []; verror = []; for rxn in tracedata:; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); xmin = min(xmin, rxn['axis']); xmax = max(xmax, rxn['axis']). ax1.plot(rxn['axis'], rxn['mcdata'], '^', color=clr, markersize=6.0, mew=0, zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.plot(rxn['axis'], rxn['bmdata'], 'o', color='black', markersize=6.0, zorder=1); vmin = min(0, vmin, rxn['bmdata']); vmax = max(0, vmax, rxn['bmdata']). if rxn['error'][0] is not None:; ax2.plot(rxn['axis'], rxn['error'][0], 's', color=clr, mew=0, zorder=8); emin = min(0, emin, rxn['error'][0]); emax = max(0, emax, rxn['error'][0]); verror.append(rxn['error'][0]). ls = next(linecycler); ax1.plot(vaxis, vmcdata, ls, color='grey', label=trace, zorder=3); ax2.plot(vaxis, verror, ls, color='grey', label=trace, zorder=4). xbuf = max(0.05, abs(0.02 * xmax)); vbuf = max(0.1, abs(0.02 * vmax)); ebuf = max(0.01, abs(0.02 * emax)); plt.xlim([xmin - xbuf, xmax + xbuf]); ax1.set_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. [docs]def disthist(data, title='', xtitle=''",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:10270,Availability,error,error,10270,", axes=ax2, color='#cccc00'); ax2.set_ylabel('Energy Error'); ax2.set_xlabel(xtitle). xmin = 500.0; xmax = -500.0; vmin = 1.0; vmax = -1.0; emin = 1.0; emax = -1.0; linecycler = cycle(['-', '--', '-.', ':']); # plot reaction errors and threads; for trace, tracedata in data.iteritems():; vaxis = []; vmcdata = []; verror = []; for rxn in tracedata:; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); xmin = min(xmin, rxn['axis']); xmax = max(xmax, rxn['axis']). ax1.plot(rxn['axis'], rxn['mcdata'], '^', color=clr, markersize=6.0, mew=0, zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.plot(rxn['axis'], rxn['bmdata'], 'o', color='black', markersize=6.0, zorder=1); vmin = min(0, vmin, rxn['bmdata']); vmax = max(0, vmax, rxn['bmdata']). if rxn['error'][0] is not None:; ax2.plot(rxn['axis'], rxn['error'][0], 's', color=clr, mew=0, zorder=8); emin = min(0, emin, rxn['error'][0]); emax = max(0, emax, rxn['error'][0]); verror.append(rxn['error'][0]). ls = next(linecycler); ax1.plot(vaxis, vmcdata, ls, color='grey', label=trace, zorder=3); ax2.plot(vaxis, verror, ls, color='grey', label=trace, zorder=4). xbuf = max(0.05, abs(0.02 * xmax)); vbuf = max(0.1, abs(0.02 * vmax)); ebuf = max(0.01, abs(0.02 * emax)); plt.xlim([xmin - xbuf, xmax + xbuf]); ax1.set_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. [docs]def disthist(data, title='', xtitle=''",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:10308,Availability,error,error,10308,", axes=ax2, color='#cccc00'); ax2.set_ylabel('Energy Error'); ax2.set_xlabel(xtitle). xmin = 500.0; xmax = -500.0; vmin = 1.0; vmax = -1.0; emin = 1.0; emax = -1.0; linecycler = cycle(['-', '--', '-.', ':']); # plot reaction errors and threads; for trace, tracedata in data.iteritems():; vaxis = []; vmcdata = []; verror = []; for rxn in tracedata:; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); xmin = min(xmin, rxn['axis']); xmax = max(xmax, rxn['axis']). ax1.plot(rxn['axis'], rxn['mcdata'], '^', color=clr, markersize=6.0, mew=0, zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.plot(rxn['axis'], rxn['bmdata'], 'o', color='black', markersize=6.0, zorder=1); vmin = min(0, vmin, rxn['bmdata']); vmax = max(0, vmax, rxn['bmdata']). if rxn['error'][0] is not None:; ax2.plot(rxn['axis'], rxn['error'][0], 's', color=clr, mew=0, zorder=8); emin = min(0, emin, rxn['error'][0]); emax = max(0, emax, rxn['error'][0]); verror.append(rxn['error'][0]). ls = next(linecycler); ax1.plot(vaxis, vmcdata, ls, color='grey', label=trace, zorder=3); ax2.plot(vaxis, verror, ls, color='grey', label=trace, zorder=4). xbuf = max(0.05, abs(0.02 * xmax)); vbuf = max(0.1, abs(0.02 * vmax)); ebuf = max(0.01, abs(0.02 * emax)); plt.xlim([xmin - xbuf, xmax + xbuf]); ax1.set_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. [docs]def disthist(data, title='', xtitle=''",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:10340,Availability,error,error,10340,"in = 500.0; xmax = -500.0; vmin = 1.0; vmax = -1.0; emin = 1.0; emax = -1.0; linecycler = cycle(['-', '--', '-.', ':']); # plot reaction errors and threads; for trace, tracedata in data.iteritems():; vaxis = []; vmcdata = []; verror = []; for rxn in tracedata:; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); xmin = min(xmin, rxn['axis']); xmax = max(xmax, rxn['axis']). ax1.plot(rxn['axis'], rxn['mcdata'], '^', color=clr, markersize=6.0, mew=0, zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.plot(rxn['axis'], rxn['bmdata'], 'o', color='black', markersize=6.0, zorder=1); vmin = min(0, vmin, rxn['bmdata']); vmax = max(0, vmax, rxn['bmdata']). if rxn['error'][0] is not None:; ax2.plot(rxn['axis'], rxn['error'][0], 's', color=clr, mew=0, zorder=8); emin = min(0, emin, rxn['error'][0]); emax = max(0, emax, rxn['error'][0]); verror.append(rxn['error'][0]). ls = next(linecycler); ax1.plot(vaxis, vmcdata, ls, color='grey', label=trace, zorder=3); ax2.plot(vaxis, verror, ls, color='grey', label=trace, zorder=4). xbuf = max(0.05, abs(0.02 * xmax)); vbuf = max(0.1, abs(0.02 * vmax)); ebuf = max(0.01, abs(0.02 * emax)); plt.xlim([xmin - xbuf, xmax + xbuf]); ax1.set_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. [docs]def disthist(data, title='', xtitle='', xmin=None, xmax=None,; me=None, stde=None, view=True,; saveas=None, relpath=False, gra",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:11447,Availability,error,errors,11447,"rxn['error'][0]). ls = next(linecycler); ax1.plot(vaxis, vmcdata, ls, color='grey', label=trace, zorder=3); ax2.plot(vaxis, verror, ls, color='grey', label=trace, zorder=4). xbuf = max(0.05, abs(0.02 * xmax)); vbuf = max(0.1, abs(0.02 * vmax)); ebuf = max(0.01, abs(0.02 * emax)); plt.xlim([xmin - xbuf, xmax + xbuf]); ax1.set_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. [docs]def disthist(data, title='', xtitle='', xmin=None, xmax=None,; me=None, stde=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with name *saveas* with a histogram representation; of the reaction errors in *data*. Also plots a gaussian distribution; with mean *me* and standard deviation *stde*. Plot has x-range; *xmin* to *xmax*, x-axis label *xtitle* and overall title *title*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt. def gaussianpdf(u, v, x):; """"""*u* is mean, *v* is variance, *x* is value, returns probability""""""; return 1.0 / np.sqrt(2.0 * np.pi * v) * np.exp(-pow(x - u, 2) / 2.0 / v). me = me if me is not None else np.mean(data); stde = stde if stde is not None else np.std(data, ddof=1); evenerr = max(abs(me - 4.0 * stde), abs(me + 4.0 * stde)); xmin = xmin if xmin is not None else -1 * evenerr; xmax = xmax if xmax is not None else evenerr. dx = (xmax - xmin) / 40.; nx = int(round((xmax - xmin) / dx)) + 1; pdfx = []; pdfy = []; for i in xrange(nx):; ix = xmin + i * dx; pdfx.append(ix); pdfy.append(gaussianpdf(me, pow(stde, 2), ix)). f",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:13287,Availability,error,errors,13287,", ix)). fig, ax1 = plt.subplots(figsize=(16, 6)); plt.axvline(0.0, color='#cccc00'); ax1.set_xlim(xmin, xmax); ax1.hist(data, bins=30, range=(xmin, xmax), color='#2d4065', alpha=0.7); ax1.set_xlabel(xtitle); ax1.set_ylabel('Count'). ax2 = ax1.twinx(); ax2.fill(pdfx, pdfy, color='k', alpha=0.2); ax2.set_ylabel('Probability Density'). plt.title(title). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(me) + str(stde) + str(xmin) + str(xmax)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='disthist_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. #def thread(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None):; # """"""Generates a tiered slat diagram between model chemistries with; # errors (or simply values) in list *data*, which is supplied as part of the; # dictionary for each participating reaction, along with *dbse* and *rxn* keys; # in argument *data*. The plot is labeled with *title* and each tier with; # an element of *labels* and plotted at *xlimit* from the zero-line. If; # *color* is None, slats are black, if 'sapt', colors are taken from *color*; # key in *data* [0, 1]. Summary statistics *mae* are plotted on the; # overbound side and relative statistics *mape* on the underbound side.; #; # """"""; # from random import random; # import matplotlib.pyplot as plt; #; # # initialize tiers/wefts; # Nweft = len(labels); # lenS = 0.2; # gapT = 0.04; # positions = range(-1, -1 * Nweft - 1, -1); # posnS = []; # for weft in range(Nweft):; # posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); # posnT = []; # for weft in range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:14901,Availability,error,errors,14901,"= len(labels); # lenS = 0.2; # gapT = 0.04; # positions = range(-1, -1 * Nweft - 1, -1); # posnS = []; # for weft in range(Nweft):; # posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); # posnT = []; # for weft in range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.subplots(figsize=(12, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); # plt.xlim([-xlimit, xlimit]); # plt.ylim([-1 * Nweft - 1, 0]); # plt.yticks([]); #; # # label plot and tiers; # ax.text(-0.9 * xlimit, -0.25, title,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=12); # for weft in labels:; # ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=18); #; # # plot reaction errors and threads; # for rxn in data:; #; # # preparation; # xvals = rxn['data']; # clr = segment_color(color, rxn['color'] if 'color' in rxn else None); # slat = []; # for weft in range(Nweft):; # slat.extend([xvals[weft], xvals[weft], None]); # thread = []; # for weft in range(Nweft - 1):; # thread.extend([xvals[weft], xvals[weft + 1], None]); #; # # plotting; # ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); # ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round',; # alpha=0.3); #; # # labeling; # try:; # toplblposn = next(item for item in xvals if item is not None); # botlblposn = next(item for item in reversed(xvals) if item is not None); # except StopIteration:; # pass; # else:; # ax.text(toplblposn, -0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); # ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='cen",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:16579,Availability,error,errors,16579,"t(item for item in reversed(xvals) if item is not None); # except StopIteration:; # pass; # else:; # ax.text(toplblposn, -0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); # ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); #; # # plot trimmings; # if mae is not None:; # ax.plot([-x for x in mae], positions, 's', color='black'); # if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; # ax.plot([0.025 * x for x in mape], positions, 'o', color='black'); #; # plt.axvline(0, color='black'); # plt.show(). [docs]def threads(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a tiered slat diagram between model chemistries with; errors (or simply values) in list *data*, which is supplied as part of the; dictionary for each participating reaction, along with *dbse* and *rxn* keys; in argument *data*. The plot is labeled with *title* and each tier with; an element of *labels* and plotted at *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from *color*; key in *data* [0, 1]. Summary statistics *mae* are plotted on the; overbound side and relative statistics *mape* on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. """"""; import random; import hashlib; import matplotlib.pyplot as plt; import numpy as np # only needed for missing data with mouseiness. # initialize tiers/wefts; Nweft = len(labels); lenS = 0.2; gapT = 0.04; positions = range(-1, -1 * Nweft - 1, -1",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:18700,Availability,error,errors,18700,"sitions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); posnM = []. # initialize plot; fht = Nweft * 0.8; #fig, ax = plt.subplots(figsize=(12, fht)); fig, ax = plt.subplots(figsize=(11, fht)); plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); ax.set_frame_on(False); if labeled:; ax.set_xticks([-0.5 * xlimit, -0.25 * xlimit, 0.0, 0.25 * xlimit, 0.5 * xlimit]); else:; ax.set_xticks([]); for tick in ax.xaxis.get_major_ticks():; tick.tick1line.set_markersize(0); tick.tick2line.set_markersize(0). # label plot and tiers; if labeled:; ax.text(-0.9 * xlimit, -0.25, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12); for weft in labels:; ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=18). # plot reaction errors and threads; for rxn in data:. # preparation; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); slat = []; for weft in range(Nweft):; slat.extend([xvals[weft], xvals[weft], None]); thread = []; for weft in range(Nweft - 1):; thread.extend([xvals[weft], xvals[weft + 1], None]). # plotting; if Nweft == 1:; ax.plot(slat, posnS, '|', color=clr, markersize=20.0, mew=1.5, solid_capstyle='round'); else:; ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round', alpha=0.3). # converting into screen coordinates for image map; npxvals = [np.nan if val is None else val for val in xvals]; xyscreen = ax.transData.transform(zip(npxvals, positions)); xscreen, yscreen = zip(*xyscreen); posnM.extend(zip([rxn['db']] * Nweft, [rxn['sys']] * Nweft,; npxvals, [rxn['show']] * Nweft, xscreen, yscreen)). # labeling; if not(mousetext or mouselink or mouseimag):; if labeled and len(data) ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:26546,Availability,error,errors,26546,"disp, '', xdot, ydot, cdot. xvals.append(xdot); yvals.append(ydot); cvals.append(cdot). sc = ax.scatter(xvals, yvals, c=cvals, s=15, marker=""o"", \; cmap=mpl.cm.jet, edgecolor='none', vmin=0, vmax=1, zorder=10). # remove figure outline; ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['bottom'].set_visible(False); ax.spines['left'].set_visible(False). # save and show; pltuid = title + '_' + ('lbld' if labeled else 'bare') + '_' + hashlib.sha1(title + repr(sapt)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='tern_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, dpi=450, edgecolor='none', pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. #def thread_mouseover_web(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with name *pltfile* with a slat representation of; # the modelchems errors in *mcdat*. Mouseover shows geometry and error; # from *labels* based on recipe of Andrew Dalke from; # http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html; #; # """"""; # from matplotlib.backends.backend_agg import FigureCanvasAgg; # import matplotlib; # import sapt_colors; #; # cmpd_width = 200; # cmpd_height = 160; #; # nplots = len(mcdats); # fht = nplots * 0.8; # fht = nplots * 0.8 * 1.4; # fig = matplotlib.figure.Figure(figsize=(12.0, fht)); # fig.subplots_adjust(left=0.01, right=0.99, hspace=0.3, top=0.8, bottom=0.2); # img_width = fig.get_figwidth() * 80; # img_height = fig.get_figheight() * 80; #; # htmlcode = """"""; #<SCRIPT>; #function mouseandshow(name, id, db, dbname) {; # var cid = document.getElementById(""cid"");; # cid.innerHTML = name;; # cid.href = ""fragmentviewer.py?name="" + id + ""&dataset="" + db;; # var cmpd_img = document.getElementById(""cmpd_img"");; # ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:26594,Availability,error,error,26594,"cmap=mpl.cm.jet, edgecolor='none', vmin=0, vmax=1, zorder=10). # remove figure outline; ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['bottom'].set_visible(False); ax.spines['left'].set_visible(False). # save and show; pltuid = title + '_' + ('lbld' if labeled else 'bare') + '_' + hashlib.sha1(title + repr(sapt)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='tern_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, dpi=450, edgecolor='none', pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. #def thread_mouseover_web(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with name *pltfile* with a slat representation of; # the modelchems errors in *mcdat*. Mouseover shows geometry and error; # from *labels* based on recipe of Andrew Dalke from; # http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html; #; # """"""; # from matplotlib.backends.backend_agg import FigureCanvasAgg; # import matplotlib; # import sapt_colors; #; # cmpd_width = 200; # cmpd_height = 160; #; # nplots = len(mcdats); # fht = nplots * 0.8; # fht = nplots * 0.8 * 1.4; # fig = matplotlib.figure.Figure(figsize=(12.0, fht)); # fig.subplots_adjust(left=0.01, right=0.99, hspace=0.3, top=0.8, bottom=0.2); # img_width = fig.get_figwidth() * 80; # img_height = fig.get_figheight() * 80; #; # htmlcode = """"""; #<SCRIPT>; #function mouseandshow(name, id, db, dbname) {; # var cid = document.getElementById(""cid"");; # cid.innerHTML = name;; # cid.href = ""fragmentviewer.py?name="" + id + ""&dataset="" + db;; # var cmpd_img = document.getElementById(""cmpd_img"");; # cmpd_img.src = dbname + ""/dimers/"" + id + "".png"";; #}; #</SCRIPT>; #; #Distribution of Fragment Errors in Interaction Energy (kcal/mol)<BR>; #Mouseo",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:28112,Availability,mask,mask,28112,"; # img_width = fig.get_figwidth() * 80; # img_height = fig.get_figheight() * 80; #; # htmlcode = """"""; #<SCRIPT>; #function mouseandshow(name, id, db, dbname) {; # var cid = document.getElementById(""cid"");; # cid.innerHTML = name;; # cid.href = ""fragmentviewer.py?name="" + id + ""&dataset="" + db;; # var cmpd_img = document.getElementById(""cmpd_img"");; # cmpd_img.src = dbname + ""/dimers/"" + id + "".png"";; #}; #</SCRIPT>; #; #Distribution of Fragment Errors in Interaction Energy (kcal/mol)<BR>; #Mouseover:<BR><a id=""cid""></a><br>; #<IMG SRC=""scratch/%s"" ismap usemap=""#points"" WIDTH=""%d"" HEIGHT=""%d"">; #<IMG ID=""cmpd_img"" WIDTH=""%d"" HEIGHT=""%d"">; #<MAP name=""points"">; #"""""" % (pltfile, img_width, img_height, cmpd_width, cmpd_height); #; # for item in range(nplots):; # print '<br><br><br><br><br><br>'; # mcdat = mcdats[item]; # label = labels[item]; # tttle = titles[item]; #; # erdat = np.array(mcdat); # # No masked_array because interferes with html map; # #erdat = np.ma.masked_array(mcdat, mask=mask); # yvals = np.ones(len(mcdat)); # y = np.array([sapt_colors.sapt_colors[dbname][i] for i in label]); #; # ax = fig.add_subplot(nplots, 1, item + 1); # sc = ax.scatter(erdat, yvals, c=y, s=3000, marker=""|"", cmap=matplotlib.cm.jet, vmin=0, vmax=1); # ax.set_title(tttle, fontsize=8); # ax.set_yticks([]); # lp = ax.plot([0, 0], [0.9, 1.1], color='#cccc00', lw=2); # ax.set_ylim([0.95, 1.05]); # ax.text(xmin + 0.3, 1.0, stats(erdat), fontsize=7, family='monospace', verticalalignment='center'); # if item + 1 == nplots:; # ax.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # for tick in ax.xaxis.get_major_ticks():; # tick.tick1line.set_markersize(0); # tick.tick2line.set_markersize(0); # else:; # ax.set_xticks([]); # ax.set_frame_on(False); # ax.set_xlim([xmin, xmax]); #; # # Convert the data set points into screen space coordinates; # #xyscreencoords = ax.transData.transform(zip(erdat, yvals)); # xyscreencoords = ax.transData.transform(zip(erdat, yvals)); #",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:28117,Availability,mask,mask,28117,"; # img_width = fig.get_figwidth() * 80; # img_height = fig.get_figheight() * 80; #; # htmlcode = """"""; #<SCRIPT>; #function mouseandshow(name, id, db, dbname) {; # var cid = document.getElementById(""cid"");; # cid.innerHTML = name;; # cid.href = ""fragmentviewer.py?name="" + id + ""&dataset="" + db;; # var cmpd_img = document.getElementById(""cmpd_img"");; # cmpd_img.src = dbname + ""/dimers/"" + id + "".png"";; #}; #</SCRIPT>; #; #Distribution of Fragment Errors in Interaction Energy (kcal/mol)<BR>; #Mouseover:<BR><a id=""cid""></a><br>; #<IMG SRC=""scratch/%s"" ismap usemap=""#points"" WIDTH=""%d"" HEIGHT=""%d"">; #<IMG ID=""cmpd_img"" WIDTH=""%d"" HEIGHT=""%d"">; #<MAP name=""points"">; #"""""" % (pltfile, img_width, img_height, cmpd_width, cmpd_height); #; # for item in range(nplots):; # print '<br><br><br><br><br><br>'; # mcdat = mcdats[item]; # label = labels[item]; # tttle = titles[item]; #; # erdat = np.array(mcdat); # # No masked_array because interferes with html map; # #erdat = np.ma.masked_array(mcdat, mask=mask); # yvals = np.ones(len(mcdat)); # y = np.array([sapt_colors.sapt_colors[dbname][i] for i in label]); #; # ax = fig.add_subplot(nplots, 1, item + 1); # sc = ax.scatter(erdat, yvals, c=y, s=3000, marker=""|"", cmap=matplotlib.cm.jet, vmin=0, vmax=1); # ax.set_title(tttle, fontsize=8); # ax.set_yticks([]); # lp = ax.plot([0, 0], [0.9, 1.1], color='#cccc00', lw=2); # ax.set_ylim([0.95, 1.05]); # ax.text(xmin + 0.3, 1.0, stats(erdat), fontsize=7, family='monospace', verticalalignment='center'); # if item + 1 == nplots:; # ax.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # for tick in ax.xaxis.get_major_ticks():; # tick.tick1line.set_markersize(0); # tick.tick2line.set_markersize(0); # else:; # ax.set_xticks([]); # ax.set_frame_on(False); # ax.set_xlim([xmin, xmax]); #; # # Convert the data set points into screen space coordinates; # #xyscreencoords = ax.transData.transform(zip(erdat, yvals)); # xyscreencoords = ax.transData.transform(zip(erdat, yvals)); #",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:30024,Availability,error,error,30024,"; # xyscreencoords = ax.transData.transform(zip(erdat, yvals)); # xcoords, ycoords = zip(*xyscreencoords); #; # # HTML image coordinates have y=0 on the top. Matplotlib; # # has y=0 on the bottom. We'll need to flip the numbers; # for cid, x, y, er in zip(label, xcoords, ycoords, erdat):; # htmlcode += """"""<AREA shape=""rect"" coords=""%d,%d,%d,%d"" onmouseover=""javascript:mouseandshow('%s %+.2f', '%s', %s, '%s');"">\n"""""" % \; # (x - 2, img_height - y - 20, x + 2, img_height - y + 20, cid, er, cid, dbid, dbname); #; # htmlcode += ""</MAP>\n""; # canvas = FigureCanvasAgg(fig); # canvas.print_figure('scratch/' + title, dpi=80, transparent=True); #; # #plt.savefig('mplflat_' + title + '.pdf', bbox_inches='tight', transparent=True, format='PDF'); # #plt.savefig(os.environ['HOME'] + os.sep + 'mplflat_' + title + '.pdf', bbox_inches='tight', transparent=T rue, format='PDF'); #; # return htmlcode. [docs]def composition_tile(db, aa1, aa2):; """"""Takes dictionary *db* of label, error pairs and amino acids *aa1*; and *aa2* and returns a square array of all errors for that amino; acid pair, buffered by zeros. """"""; import re; import numpy as np; bfdbpattern = re.compile(""\d\d\d([A-Z][A-Z][A-Z])-\d\d\d([A-Z][A-Z][A-Z])-\d""). tiles = []; for key, val in db.items():; bfdbname = bfdbpattern.match(key); if (bfdbname.group(1) == aa1 and bfdbname.group(2) == aa2) or \; (bfdbname.group(2) == aa1 and bfdbname.group(1) == aa2):; tiles.append(val). if not tiles:; # fill in background when no data. only sensible for neutral center colormaps; tiles = [0]; dim = int(np.ceil(np.sqrt(len(tiles)))); pad = dim * dim - len(tiles); tiles += [0] * pad. return np.reshape(np.array(tiles), (dim, dim)). [docs]def iowa(mcdat, mclbl, title='', xtitle='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with (extensionless) name *pltfile* with an Iowa; representation of the modelchems errors in *mcdat* for BBI/SSI-style; *labels*. """"""; import numpy as np; import hashlib;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:30103,Availability,error,errors,30103,"; # xyscreencoords = ax.transData.transform(zip(erdat, yvals)); # xcoords, ycoords = zip(*xyscreencoords); #; # # HTML image coordinates have y=0 on the top. Matplotlib; # # has y=0 on the bottom. We'll need to flip the numbers; # for cid, x, y, er in zip(label, xcoords, ycoords, erdat):; # htmlcode += """"""<AREA shape=""rect"" coords=""%d,%d,%d,%d"" onmouseover=""javascript:mouseandshow('%s %+.2f', '%s', %s, '%s');"">\n"""""" % \; # (x - 2, img_height - y - 20, x + 2, img_height - y + 20, cid, er, cid, dbid, dbname); #; # htmlcode += ""</MAP>\n""; # canvas = FigureCanvasAgg(fig); # canvas.print_figure('scratch/' + title, dpi=80, transparent=True); #; # #plt.savefig('mplflat_' + title + '.pdf', bbox_inches='tight', transparent=True, format='PDF'); # #plt.savefig(os.environ['HOME'] + os.sep + 'mplflat_' + title + '.pdf', bbox_inches='tight', transparent=T rue, format='PDF'); #; # return htmlcode. [docs]def composition_tile(db, aa1, aa2):; """"""Takes dictionary *db* of label, error pairs and amino acids *aa1*; and *aa2* and returns a square array of all errors for that amino; acid pair, buffered by zeros. """"""; import re; import numpy as np; bfdbpattern = re.compile(""\d\d\d([A-Z][A-Z][A-Z])-\d\d\d([A-Z][A-Z][A-Z])-\d""). tiles = []; for key, val in db.items():; bfdbname = bfdbpattern.match(key); if (bfdbname.group(1) == aa1 and bfdbname.group(2) == aa2) or \; (bfdbname.group(2) == aa1 and bfdbname.group(1) == aa2):; tiles.append(val). if not tiles:; # fill in background when no data. only sensible for neutral center colormaps; tiles = [0]; dim = int(np.ceil(np.sqrt(len(tiles)))); pad = dim * dim - len(tiles); tiles += [0] * pad. return np.reshape(np.array(tiles), (dim, dim)). [docs]def iowa(mcdat, mclbl, title='', xtitle='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with (extensionless) name *pltfile* with an Iowa; representation of the modelchems errors in *mcdat* for BBI/SSI-style; *labels*. """"""; import numpy as np; import hashlib;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:30963,Availability,error,errors,30963,"T rue, format='PDF'); #; # return htmlcode. [docs]def composition_tile(db, aa1, aa2):; """"""Takes dictionary *db* of label, error pairs and amino acids *aa1*; and *aa2* and returns a square array of all errors for that amino; acid pair, buffered by zeros. """"""; import re; import numpy as np; bfdbpattern = re.compile(""\d\d\d([A-Z][A-Z][A-Z])-\d\d\d([A-Z][A-Z][A-Z])-\d""). tiles = []; for key, val in db.items():; bfdbname = bfdbpattern.match(key); if (bfdbname.group(1) == aa1 and bfdbname.group(2) == aa2) or \; (bfdbname.group(2) == aa1 and bfdbname.group(1) == aa2):; tiles.append(val). if not tiles:; # fill in background when no data. only sensible for neutral center colormaps; tiles = [0]; dim = int(np.ceil(np.sqrt(len(tiles)))); pad = dim * dim - len(tiles); tiles += [0] * pad. return np.reshape(np.array(tiles), (dim, dim)). [docs]def iowa(mcdat, mclbl, title='', xtitle='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with (extensionless) name *pltfile* with an Iowa; representation of the modelchems errors in *mcdat* for BBI/SSI-style; *labels*. """"""; import numpy as np; import hashlib; import matplotlib; import matplotlib.pyplot as plt. aa = ['ARG', 'HIE', 'LYS', 'ASP', 'GLU', 'SER', 'THR', 'ASN', 'GLN', 'CYS', 'MET', 'GLY', 'ALA', 'VAL', 'ILE', 'LEU', 'PRO', 'PHE', 'TYR', 'TRP']; #aa = ['ILE', 'LEU', 'ASP', 'GLU', 'PHE']; err = dict(zip(mclbl, mcdat)). # handle for frame, overall axis; fig, axt = plt.subplots(figsize=(6, 6)). #axt.set_xticks([]) # for quick nolabel, whiteback; #axt.set_yticks([]) # for quick nolabel, whiteback; axt.set_xticks(np.arange(len(aa)) + 0.3, minor=False); axt.set_yticks(np.arange(len(aa)) + 0.3, minor=False); axt.invert_yaxis(); axt.xaxis.tick_top() # comment for quick nolabel, whiteback; axt.set_xticklabels(aa, minor=False, rotation=60, size='small') # comment for quick nolabel, whiteback; axt.set_yticklabels(aa, minor=False, size='small') # comment for quick nolabel, whiteback; axt.xaxis.set",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:46114,Availability,error,error,46114,"3, 'data': [0.0696000000000001]}, {'sys': '17', 'color': 0.19082151944747366, 'data': [0.11159999999999992]}, {'sys': '18', 'color': 0.2886200282444196, 'data': [0.4114]}, {'sys': '19', 'color': 0.23560171133945224, 'data': [-0.1392]}, {'sys': '20', 'color': 0.3268270751294533, 'data': [0.5593]}, {'sys': '21', 'color': 0.7324460869158442, 'data': [0.6806000000000001]}],; color='sapt', title='MP2-CP-adz', mae=1.21356003247, mape=24.6665886087, xlimit=4.0). lin_dats = [-0.5, -0.4, -0.3, 0, .5, .8, 5]; lin_labs = ['008ILE-012LEU-1', '012LEU-085ASP-1', '004GLU-063LEU-2',; '011ILE-014PHE-1', '027GLU-031LEU-1', '038PHE-041ILE-1', '199LEU-202GLU-1']; iowa(lin_dats, lin_labs, title='ttl', xlimit=0.5). figs = [0.22, 0.41, 0.14, 0.08, 0.47,; 0, 0.38, 0.22, 0.10, 0.20,; 0, 0, 0.13, 0.07, 0.25,; 0, 0, 0, 0.06, 0.22,; 0, 0, 0, 0, 0.69]; liliowa(figs, saveas='SSI-default-MP2-CP-aqz', xlimit=1.0). disthist(lin_dats). valerrdata = [{'color': 0.14255710779686612, 'db': 'NBC1', 'sys': 'BzBz_S-3.6', 'error': [0.027999999999999803], 'mcdata': -1.231, 'bmdata': -1.259, 'axis': 3.6}, {'color': 0.08862098445220466, 'db': 'NBC1', 'sys': 'BzBz_S-3.7', 'error': [0.02300000000000013], 'mcdata': -1.535, 'bmdata': -1.558, 'axis': 3.7}, {'color': 0.246634626511043, 'db': 'NBC1', 'sys': 'BzBz_S-3.4', 'error': [0.04200000000000001], 'mcdata': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'N",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:46263,Availability,error,error,46263,"96, 'data': [0.4114]}, {'sys': '19', 'color': 0.23560171133945224, 'data': [-0.1392]}, {'sys': '20', 'color': 0.3268270751294533, 'data': [0.5593]}, {'sys': '21', 'color': 0.7324460869158442, 'data': [0.6806000000000001]}],; color='sapt', title='MP2-CP-adz', mae=1.21356003247, mape=24.6665886087, xlimit=4.0). lin_dats = [-0.5, -0.4, -0.3, 0, .5, .8, 5]; lin_labs = ['008ILE-012LEU-1', '012LEU-085ASP-1', '004GLU-063LEU-2',; '011ILE-014PHE-1', '027GLU-031LEU-1', '038PHE-041ILE-1', '199LEU-202GLU-1']; iowa(lin_dats, lin_labs, title='ttl', xlimit=0.5). figs = [0.22, 0.41, 0.14, 0.08, 0.47,; 0, 0.38, 0.22, 0.10, 0.20,; 0, 0, 0.13, 0.07, 0.25,; 0, 0, 0, 0.06, 0.22,; 0, 0, 0, 0, 0.69]; liliowa(figs, saveas='SSI-default-MP2-CP-aqz', xlimit=1.0). disthist(lin_dats). valerrdata = [{'color': 0.14255710779686612, 'db': 'NBC1', 'sys': 'BzBz_S-3.6', 'error': [0.027999999999999803], 'mcdata': -1.231, 'bmdata': -1.259, 'axis': 3.6}, {'color': 0.08862098445220466, 'db': 'NBC1', 'sys': 'BzBz_S-3.7', 'error': [0.02300000000000013], 'mcdata': -1.535, 'bmdata': -1.558, 'axis': 3.7}, {'color': 0.246634626511043, 'db': 'NBC1', 'sys': 'BzBz_S-3.4', 'error': [0.04200000000000001], 'mcdata': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'N",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:46409,Availability,error,error,46409,"}, {'sys': '21', 'color': 0.7324460869158442, 'data': [0.6806000000000001]}],; color='sapt', title='MP2-CP-adz', mae=1.21356003247, mape=24.6665886087, xlimit=4.0). lin_dats = [-0.5, -0.4, -0.3, 0, .5, .8, 5]; lin_labs = ['008ILE-012LEU-1', '012LEU-085ASP-1', '004GLU-063LEU-2',; '011ILE-014PHE-1', '027GLU-031LEU-1', '038PHE-041ILE-1', '199LEU-202GLU-1']; iowa(lin_dats, lin_labs, title='ttl', xlimit=0.5). figs = [0.22, 0.41, 0.14, 0.08, 0.47,; 0, 0.38, 0.22, 0.10, 0.20,; 0, 0, 0.13, 0.07, 0.25,; 0, 0, 0, 0.06, 0.22,; 0, 0, 0, 0, 0.69]; liliowa(figs, saveas='SSI-default-MP2-CP-aqz', xlimit=1.0). disthist(lin_dats). valerrdata = [{'color': 0.14255710779686612, 'db': 'NBC1', 'sys': 'BzBz_S-3.6', 'error': [0.027999999999999803], 'mcdata': -1.231, 'bmdata': -1.259, 'axis': 3.6}, {'color': 0.08862098445220466, 'db': 'NBC1', 'sys': 'BzBz_S-3.7', 'error': [0.02300000000000013], 'mcdata': -1.535, 'bmdata': -1.558, 'axis': 3.7}, {'color': 0.246634626511043, 'db': 'NBC1', 'sys': 'BzBz_S-3.4', 'error': [0.04200000000000001], 'mcdata': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db':",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:46555,Availability,error,error,46555,"6087, xlimit=4.0). lin_dats = [-0.5, -0.4, -0.3, 0, .5, .8, 5]; lin_labs = ['008ILE-012LEU-1', '012LEU-085ASP-1', '004GLU-063LEU-2',; '011ILE-014PHE-1', '027GLU-031LEU-1', '038PHE-041ILE-1', '199LEU-202GLU-1']; iowa(lin_dats, lin_labs, title='ttl', xlimit=0.5). figs = [0.22, 0.41, 0.14, 0.08, 0.47,; 0, 0.38, 0.22, 0.10, 0.20,; 0, 0, 0.13, 0.07, 0.25,; 0, 0, 0, 0.06, 0.22,; 0, 0, 0, 0, 0.69]; liliowa(figs, saveas='SSI-default-MP2-CP-aqz', xlimit=1.0). disthist(lin_dats). valerrdata = [{'color': 0.14255710779686612, 'db': 'NBC1', 'sys': 'BzBz_S-3.6', 'error': [0.027999999999999803], 'mcdata': -1.231, 'bmdata': -1.259, 'axis': 3.6}, {'color': 0.08862098445220466, 'db': 'NBC1', 'sys': 'BzBz_S-3.7', 'error': [0.02300000000000013], 'mcdata': -1.535, 'bmdata': -1.558, 'axis': 3.7}, {'color': 0.246634626511043, 'db': 'NBC1', 'sys': 'BzBz_S-3.4', 'error': [0.04200000000000001], 'mcdata': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, '",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:46702,Availability,error,error,46702,"E-1', '027GLU-031LEU-1', '038PHE-041ILE-1', '199LEU-202GLU-1']; iowa(lin_dats, lin_labs, title='ttl', xlimit=0.5). figs = [0.22, 0.41, 0.14, 0.08, 0.47,; 0, 0.38, 0.22, 0.10, 0.20,; 0, 0, 0.13, 0.07, 0.25,; 0, 0, 0, 0.06, 0.22,; 0, 0, 0, 0, 0.69]; liliowa(figs, saveas='SSI-default-MP2-CP-aqz', xlimit=1.0). disthist(lin_dats). valerrdata = [{'color': 0.14255710779686612, 'db': 'NBC1', 'sys': 'BzBz_S-3.6', 'error': [0.027999999999999803], 'mcdata': -1.231, 'bmdata': -1.259, 'axis': 3.6}, {'color': 0.08862098445220466, 'db': 'NBC1', 'sys': 'BzBz_S-3.7', 'error': [0.02300000000000013], 'mcdata': -1.535, 'bmdata': -1.558, 'axis': 3.7}, {'color': 0.246634626511043, 'db': 'NBC1', 'sys': 'BzBz_S-3.4', 'error': [0.04200000000000001], 'mcdata': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:46848,Availability,error,error,46848," 0.47,; 0, 0.38, 0.22, 0.10, 0.20,; 0, 0, 0.13, 0.07, 0.25,; 0, 0, 0, 0.06, 0.22,; 0, 0, 0, 0, 0.69]; liliowa(figs, saveas='SSI-default-MP2-CP-aqz', xlimit=1.0). disthist(lin_dats). valerrdata = [{'color': 0.14255710779686612, 'db': 'NBC1', 'sys': 'BzBz_S-3.6', 'error': [0.027999999999999803], 'mcdata': -1.231, 'bmdata': -1.259, 'axis': 3.6}, {'color': 0.08862098445220466, 'db': 'NBC1', 'sys': 'BzBz_S-3.7', 'error': [0.02300000000000013], 'mcdata': -1.535, 'bmdata': -1.558, 'axis': 3.7}, {'color': 0.246634626511043, 'db': 'NBC1', 'sys': 'BzBz_S-3.4', 'error': [0.04200000000000001], 'mcdata': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.108841350315320",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:46995,Availability,error,error,46995,", xlimit=1.0). disthist(lin_dats). valerrdata = [{'color': 0.14255710779686612, 'db': 'NBC1', 'sys': 'BzBz_S-3.6', 'error': [0.027999999999999803], 'mcdata': -1.231, 'bmdata': -1.259, 'axis': 3.6}, {'color': 0.08862098445220466, 'db': 'NBC1', 'sys': 'BzBz_S-3.7', 'error': [0.02300000000000013], 'mcdata': -1.535, 'bmdata': -1.558, 'axis': 3.7}, {'color': 0.246634626511043, 'db': 'NBC1', 'sys': 'BzBz_S-3.4', 'error': [0.04200000000000001], 'mcdata': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:47145,Availability,error,error,47145,"cdata': -1.231, 'bmdata': -1.259, 'axis': 3.6}, {'color': 0.08862098445220466, 'db': 'NBC1', 'sys': 'BzBz_S-3.7', 'error': [0.02300000000000013], 'mcdata': -1.535, 'bmdata': -1.558, 'axis': 3.7}, {'color': 0.246634626511043, 'db': 'NBC1', 'sys': 'BzBz_S-3.4', 'error': [0.04200000000000001], 'mcdata': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.142752183732890",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:47294,Availability,error,error,47294,"data': -1.535, 'bmdata': -1.558, 'axis': 3.7}, {'color': 0.246634626511043, 'db': 'NBC1', 'sys': 'BzBz_S-3.4', 'error': [0.04200000000000001], 'mcdata': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:47443,Availability,error,error,47443,"a': 0.189, 'bmdata': 0.147, 'axis': 3.4}, {'color': 0.19526236766857613, 'db': 'NBC1', 'sys': 'BzBz_S-3.5', 'error': [0.03500000000000003], 'mcdata': -0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638, 'db': 'NBC1', 'sys': 'BzBz_S-6.5', 'error': [0.0010000000000000009], 'mcdata': -0.028, 'bmdata': -0.029, 'axis': 6.5}, {'color': 0.6672504378283713",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:47593,Availability,error,error,47593,"-0.689, 'bmdata': -0.724, 'axis': 3.5}, {'color': 0.3443039102164425, 'db': 'NBC1', 'sys': 'BzBz_S-3.2', 'error': [0.05999999999999961], 'mcdata': 3.522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638, 'db': 'NBC1', 'sys': 'BzBz_S-6.5', 'error': [0.0010000000000000009], 'mcdata': -0.028, 'bmdata': -0.029, 'axis': 6.5}, {'color': 0.6672504378283713, 'db': 'NBC1', 'sys': 'BzBz_S-10.0', 'error': [0.0], 'mcdata': 0.018, 'bmdata': 0.018, 'axis': 10.0}]; valerr({'cat': valerrdata},; color='sapt', xti",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:47742,Availability,error,error,47742,"522, 'bmdata': 3.462, 'axis': 3.2}, {'color': 0.29638827303466814, 'db': 'NBC1', 'sys': 'BzBz_S-3.3', 'error': [0.050999999999999934], 'mcdata': 1.535, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638, 'db': 'NBC1', 'sys': 'BzBz_S-6.5', 'error': [0.0010000000000000009], 'mcdata': -0.028, 'bmdata': -0.029, 'axis': 6.5}, {'color': 0.6672504378283713, 'db': 'NBC1', 'sys': 'BzBz_S-10.0', 'error': [0.0], 'mcdata': 0.018, 'bmdata': 0.018, 'axis': 10.0}]; valerr({'cat': valerrdata},; color='sapt', xtitle='Rang', title='aggh', graphicsformat=['png']). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. module",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:47891,Availability,error,error,47891,"5, 'bmdata': 1.484, 'axis': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638, 'db': 'NBC1', 'sys': 'BzBz_S-6.5', 'error': [0.0010000000000000009], 'mcdata': -0.028, 'bmdata': -0.029, 'axis': 6.5}, {'color': 0.6672504378283713, 'db': 'NBC1', 'sys': 'BzBz_S-10.0', 'error': [0.0], 'mcdata': 0.018, 'bmdata': 0.018, 'axis': 10.0}]; valerr({'cat': valerrdata},; color='sapt', xtitle='Rang', title='aggh', graphicsformat=['png']). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:48039,Availability,error,error,48039,"is': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638, 'db': 'NBC1', 'sys': 'BzBz_S-6.5', 'error': [0.0010000000000000009], 'mcdata': -0.028, 'bmdata': -0.029, 'axis': 6.5}, {'color': 0.6672504378283713, 'db': 'NBC1', 'sys': 'BzBz_S-10.0', 'error': [0.0], 'mcdata': 0.018, 'bmdata': 0.018, 'axis': 10.0}]; valerr({'cat': valerrdata},; color='sapt', xtitle='Rang', title='aggh', graphicsformat=['png']). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:48188,Availability,error,error,48188,"is': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638, 'db': 'NBC1', 'sys': 'BzBz_S-6.5', 'error': [0.0010000000000000009], 'mcdata': -0.028, 'bmdata': -0.029, 'axis': 6.5}, {'color': 0.6672504378283713, 'db': 'NBC1', 'sys': 'BzBz_S-10.0', 'error': [0.0], 'mcdata': 0.018, 'bmdata': 0.018, 'axis': 10.0}]; valerr({'cat': valerrdata},; color='sapt', xtitle='Rang', title='aggh', graphicsformat=['png']). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:48335,Availability,error,error,48335,"is': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638, 'db': 'NBC1', 'sys': 'BzBz_S-6.5', 'error': [0.0010000000000000009], 'mcdata': -0.028, 'bmdata': -0.029, 'axis': 6.5}, {'color': 0.6672504378283713, 'db': 'NBC1', 'sys': 'BzBz_S-10.0', 'error': [0.0], 'mcdata': 0.018, 'bmdata': 0.018, 'axis': 10.0}]; valerr({'cat': valerrdata},; color='sapt', xtitle='Rang', title='aggh', graphicsformat=['png']). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:48485,Availability,error,error,48485,"is': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638, 'db': 'NBC1', 'sys': 'BzBz_S-6.5', 'error': [0.0010000000000000009], 'mcdata': -0.028, 'bmdata': -0.029, 'axis': 6.5}, {'color': 0.6672504378283713, 'db': 'NBC1', 'sys': 'BzBz_S-10.0', 'error': [0.0], 'mcdata': 0.018, 'bmdata': 0.018, 'axis': 10.0}]; valerr({'cat': valerrdata},; color='sapt', xtitle='Rang', title='aggh', graphicsformat=['png']). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:5161,Deployability,patch,patch,5161,"); plt.close(); return files_saved. [docs]def flat(data, color=None, title='', xlimit=4.0, xlines=[0.0, 0.3, 1.0], mae=None, mape=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a slat diagram between model chemistries with errors in; single-item list *data*, which is supplied as part of the dictionary; for each participating reaction, along with *dbse* and *rxn* keys in; argument *data*. Limits of plot are *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from; sapt_colors module. Summary statistic *mae* is plotted on the; overbound side and relative statistic *mape* on the underbound side.; Saves a file with name *title* and plots to screen if *view*. """"""; import matplotlib.pyplot as plt. Nweft = 1; positions = range(-1, -1 * Nweft - 1, -1). # initialize plot; fig, ax = plt.subplots(figsize=(12, 0.33)); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); plt.xticks([]); # fig.patch.set_visible(False); # ax.patch.set_visible(False); ax.axis('off'). for xl in xlines:; plt.axvline(xl, color='grey', linewidth=4); if xl != 0.0:; plt.axvline(-1 * xl, color='grey', linewidth=4). # plot reaction errors and threads; for rxn in data:; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None). ax.plot(xvals, positions, '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:5192,Deployability,patch,patch,5192,"ved. [docs]def flat(data, color=None, title='', xlimit=4.0, xlines=[0.0, 0.3, 1.0], mae=None, mape=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a slat diagram between model chemistries with errors in; single-item list *data*, which is supplied as part of the dictionary; for each participating reaction, along with *dbse* and *rxn* keys in; argument *data*. Limits of plot are *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from; sapt_colors module. Summary statistic *mae* is plotted on the; overbound side and relative statistic *mape* on the underbound side.; Saves a file with name *title* and plots to screen if *view*. """"""; import matplotlib.pyplot as plt. Nweft = 1; positions = range(-1, -1 * Nweft - 1, -1). # initialize plot; fig, ax = plt.subplots(figsize=(12, 0.33)); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); plt.xticks([]); # fig.patch.set_visible(False); # ax.patch.set_visible(False); ax.axis('off'). for xl in xlines:; plt.axvline(xl, color='grey', linewidth=4); if xl != 0.0:; plt.axvline(-1 * xl, color='grey', linewidth=4). # plot reaction errors and threads; for rxn in data:; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None). ax.plot(xvals, positions, '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lo",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:5894,Deployability,integrat,integration,5894,"plot as plt. Nweft = 1; positions = range(-1, -1 * Nweft - 1, -1). # initialize plot; fig, ax = plt.subplots(figsize=(12, 0.33)); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); plt.xticks([]); # fig.patch.set_visible(False); # ax.patch.set_visible(False); ax.axis('off'). for xl in xlines:; plt.axvline(xl, color='grey', linewidth=4); if xl != 0.0:; plt.axvline(-1 * xl, color='grey', linewidth=4). # plot reaction errors and threads; for rxn in data:; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None). ax.plot(xvals, positions, '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. #def mpl_distslat_multiplot_files(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with basename *pltfile* with a slat representation; # of the modelchems errors in *mcdat*. Plot is in PNG, PDF, & EPS; # and suitable for download, no mouseover properties. Both labeled; # and labelless (for pub) figures are constructed.; #; # """"""; # import matplotlib as mpl; # from matplotlib.axes import Subplot; # import sapt_colors; # from matplotlib.figure import Figure; #; # nplots = len(mcdats); # fht = nplots * 0.8; # fig, axt = plt.subplots(figsize=(12.0, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); #",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:23563,Deployability,patch,patches,23563," (0, 0); for dbse, rxn, val, show, x, y in posnM:; if val is None or val is np.nan:; continue. now = (int(x), int(y)); if now == last:; htmlcode += """"""<!-- map overlap! %s-%s %+.2f skipped -->\n"""""" % (dbse, rxn, val); else:; htmlcode += """"""<AREA shape=""rect"" coords=""%d,%d,%d,%d"" onmouseover=""javascript:mouseshow('%s', '%s', '%+.2f', '%s');"">\n"""""" % \; (x - 2, img_height - y - 20,; x + 2, img_height - y + 20,; dbse, rxn, val, show); last = now. htmlcode += """"""</MAP>\n"""""". plt.close(); return files_saved, htmlcode. [docs]def ternary(sapt, title='', labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Takes array of arrays *sapt* in form [elst, indc, disp] and builds formatted; two-triangle ternary diagrams. Either fully-readable or dotsonly depending; on *labeled*. Saves in formats *graphicsformat*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib.path import Path; import matplotlib.patches as patches. # initialize plot; fig, ax = plt.subplots(figsize=(6, 3.6)); plt.xlim([-0.75, 1.25]); plt.ylim([-0.18, 1.02]); plt.xticks([]); plt.yticks([]); ax.set_aspect('equal'). if labeled:; # form and color ternary triangles; codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]; pathPos = Path([(0., 0.), (1., 0.), (0.5, 0.866), (0., 0.)], codes); pathNeg = Path([(0., 0.), (-0.5, 0.866), (0.5, 0.866), (0., 0.)], codes); ax.add_patch(patches.PathPatch(pathPos, facecolor='white', lw=2)); ax.add_patch(patches.PathPatch(pathNeg, facecolor='#fff5ee', lw=2)). # form and color HB/MX/DD dividing lines; ax.plot([0.667, 0.5], [0., 0.866], color='#eeb4b4', lw=0.5); ax.plot([-0.333, 0.5], [0.577, 0.866], color='#eeb4b4', lw=0.5); ax.plot([0.333, 0.5], [0., 0.866], color='#7ec0ee', lw=0.5); ax.plot([-0.167, 0.5], [0.289, 0.866], color='#7ec0ee', lw=0.5). # label corners; ax.text(1.0, -0.15, u'Elst (\u2212)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Rom",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:23574,Deployability,patch,patches,23574," (0, 0); for dbse, rxn, val, show, x, y in posnM:; if val is None or val is np.nan:; continue. now = (int(x), int(y)); if now == last:; htmlcode += """"""<!-- map overlap! %s-%s %+.2f skipped -->\n"""""" % (dbse, rxn, val); else:; htmlcode += """"""<AREA shape=""rect"" coords=""%d,%d,%d,%d"" onmouseover=""javascript:mouseshow('%s', '%s', '%+.2f', '%s');"">\n"""""" % \; (x - 2, img_height - y - 20,; x + 2, img_height - y + 20,; dbse, rxn, val, show); last = now. htmlcode += """"""</MAP>\n"""""". plt.close(); return files_saved, htmlcode. [docs]def ternary(sapt, title='', labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Takes array of arrays *sapt* in form [elst, indc, disp] and builds formatted; two-triangle ternary diagrams. Either fully-readable or dotsonly depending; on *labeled*. Saves in formats *graphicsformat*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib.path import Path; import matplotlib.patches as patches. # initialize plot; fig, ax = plt.subplots(figsize=(6, 3.6)); plt.xlim([-0.75, 1.25]); plt.ylim([-0.18, 1.02]); plt.xticks([]); plt.yticks([]); ax.set_aspect('equal'). if labeled:; # form and color ternary triangles; codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]; pathPos = Path([(0., 0.), (1., 0.), (0.5, 0.866), (0., 0.)], codes); pathNeg = Path([(0., 0.), (-0.5, 0.866), (0.5, 0.866), (0., 0.)], codes); ax.add_patch(patches.PathPatch(pathPos, facecolor='white', lw=2)); ax.add_patch(patches.PathPatch(pathNeg, facecolor='#fff5ee', lw=2)). # form and color HB/MX/DD dividing lines; ax.plot([0.667, 0.5], [0., 0.866], color='#eeb4b4', lw=0.5); ax.plot([-0.333, 0.5], [0.577, 0.866], color='#eeb4b4', lw=0.5); ax.plot([0.333, 0.5], [0., 0.866], color='#7ec0ee', lw=0.5); ax.plot([-0.167, 0.5], [0.289, 0.866], color='#7ec0ee', lw=0.5). # label corners; ax.text(1.0, -0.15, u'Elst (\u2212)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Rom",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:24020,Deployability,patch,patches,24020," htmlcode += """"""</MAP>\n"""""". plt.close(); return files_saved, htmlcode. [docs]def ternary(sapt, title='', labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Takes array of arrays *sapt* in form [elst, indc, disp] and builds formatted; two-triangle ternary diagrams. Either fully-readable or dotsonly depending; on *labeled*. Saves in formats *graphicsformat*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib.path import Path; import matplotlib.patches as patches. # initialize plot; fig, ax = plt.subplots(figsize=(6, 3.6)); plt.xlim([-0.75, 1.25]); plt.ylim([-0.18, 1.02]); plt.xticks([]); plt.yticks([]); ax.set_aspect('equal'). if labeled:; # form and color ternary triangles; codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]; pathPos = Path([(0., 0.), (1., 0.), (0.5, 0.866), (0., 0.)], codes); pathNeg = Path([(0., 0.), (-0.5, 0.866), (0.5, 0.866), (0., 0.)], codes); ax.add_patch(patches.PathPatch(pathPos, facecolor='white', lw=2)); ax.add_patch(patches.PathPatch(pathNeg, facecolor='#fff5ee', lw=2)). # form and color HB/MX/DD dividing lines; ax.plot([0.667, 0.5], [0., 0.866], color='#eeb4b4', lw=0.5); ax.plot([-0.333, 0.5], [0.577, 0.866], color='#eeb4b4', lw=0.5); ax.plot([0.333, 0.5], [0., 0.866], color='#7ec0ee', lw=0.5); ax.plot([-0.167, 0.5], [0.289, 0.866], color='#7ec0ee', lw=0.5). # label corners; ax.text(1.0, -0.15, u'Elst (\u2212)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', weight='bold', fontsize=18); ax.text(0.5, 0.9, u'Ind (\u2212)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', weight='bold', fontsize=18); ax.text(0.0, -0.15, u'Disp (\u2212)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', weight='bold', fontsize=18); ax.text(-0.5, 0.9, u'Elst (+)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:24087,Deployability,patch,patches,24087,"ode. [docs]def ternary(sapt, title='', labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Takes array of arrays *sapt* in form [elst, indc, disp] and builds formatted; two-triangle ternary diagrams. Either fully-readable or dotsonly depending; on *labeled*. Saves in formats *graphicsformat*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib.path import Path; import matplotlib.patches as patches. # initialize plot; fig, ax = plt.subplots(figsize=(6, 3.6)); plt.xlim([-0.75, 1.25]); plt.ylim([-0.18, 1.02]); plt.xticks([]); plt.yticks([]); ax.set_aspect('equal'). if labeled:; # form and color ternary triangles; codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]; pathPos = Path([(0., 0.), (1., 0.), (0.5, 0.866), (0., 0.)], codes); pathNeg = Path([(0., 0.), (-0.5, 0.866), (0.5, 0.866), (0., 0.)], codes); ax.add_patch(patches.PathPatch(pathPos, facecolor='white', lw=2)); ax.add_patch(patches.PathPatch(pathNeg, facecolor='#fff5ee', lw=2)). # form and color HB/MX/DD dividing lines; ax.plot([0.667, 0.5], [0., 0.866], color='#eeb4b4', lw=0.5); ax.plot([-0.333, 0.5], [0.577, 0.866], color='#eeb4b4', lw=0.5); ax.plot([0.333, 0.5], [0., 0.866], color='#7ec0ee', lw=0.5); ax.plot([-0.167, 0.5], [0.289, 0.866], color='#7ec0ee', lw=0.5). # label corners; ax.text(1.0, -0.15, u'Elst (\u2212)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', weight='bold', fontsize=18); ax.text(0.5, 0.9, u'Ind (\u2212)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', weight='bold', fontsize=18); ax.text(0.0, -0.15, u'Disp (\u2212)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', weight='bold', fontsize=18); ax.text(-0.5, 0.9, u'Elst (+)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', weight='bold', fontsize=18). xvals = []; yvals = []; cvals",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:48843,Deployability,update,updated,48843,"is': 3.3}, {'color': 0.42859228971962615, 'db': 'NBC1', 'sys': 'BzBz_S-6.0', 'error': [0.0020000000000000018], 'mcdata': -0.099, 'bmdata': -0.101, 'axis': 6.0}, {'color': 0.30970751839224836, 'db': 'NBC1', 'sys': 'BzBz_S-5.0', 'error': [0.0040000000000000036], 'mcdata': -0.542, 'bmdata': -0.546, 'axis': 5.0}, {'color': 0.3750832778147902, 'db': 'NBC1', 'sys': 'BzBz_S-5.5', 'error': [0.0030000000000000027], 'mcdata': -0.248, 'bmdata': -0.251, 'axis': 5.5}, {'color': 0.0335358832178858, 'db': 'NBC1', 'sys': 'BzBz_S-3.8', 'error': [0.019000000000000128], 'mcdata': -1.674, 'bmdata': -1.693, 'axis': 3.8}, {'color': 0.021704594689389095, 'db': 'NBC1', 'sys': 'BzBz_S-3.9', 'error': [0.016000000000000014], 'mcdata': -1.701, 'bmdata': -1.717, 'axis': 3.9}, {'color': 0.22096255119953187, 'db': 'NBC1', 'sys': 'BzBz_S-4.5', 'error': [0.008000000000000007], 'mcdata': -1.058, 'bmdata': -1.066, 'axis': 4.5}, {'color': 0.10884135031532088, 'db': 'NBC1', 'sys': 'BzBz_S-4.1', 'error': [0.01200000000000001], 'mcdata': -1.565, 'bmdata': -1.577, 'axis': 4.1}, {'color': 0.06911476296747143, 'db': 'NBC1', 'sys': 'BzBz_S-4.0', 'error': [0.014000000000000012], 'mcdata': -1.655, 'bmdata': -1.669, 'axis': 4.0}, {'color': 0.14275218373289067, 'db': 'NBC1', 'sys': 'BzBz_S-4.2', 'error': [0.01100000000000012], 'mcdata': -1.448, 'bmdata': -1.459, 'axis': 4.2}, {'color': 0.4740372133275638, 'db': 'NBC1', 'sys': 'BzBz_S-6.5', 'error': [0.0010000000000000009], 'mcdata': -0.028, 'bmdata': -0.029, 'axis': 6.5}, {'color': 0.6672504378283713, 'db': 'NBC1', 'sys': 'BzBz_S-10.0', 'error': [0.0], 'mcdata': 0.018, 'bmdata': 0.018, 'axis': 10.0}]; valerr({'cat': valerrdata},; color='sapt', xtitle='Rang', title='aggh', graphicsformat=['png']). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:2246,Energy Efficiency,green,green,2246,"abspathfile = os.path.join(os.path.abspath(pth), fil); if relpath:; return os.path.relpath(abspathfile, os.getcwd()); else:; return abspathfile. [docs]def segment_color(argcolor, saptcolor):; """"""Find appropriate color expression between overall color directive; *argcolor* and particular color availibility *rxncolor*. """"""; import matplotlib. # validate any sapt color; if saptcolor is not None:; if saptcolor < 0.0 or saptcolor > 1.0:; saptcolor = None. if argcolor is None:; # no color argument, so take from rxn; if rxncolor is None:; clr = 'grey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries with error; statistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in argument; *data*. The plot is labeled with *title* and each bar with *mc* key and; plotted at a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(figsize=(12, 7)); plt.ylim([0, 4.86]); plt.xlim([0, 6]); plt.xticks([]). # label plot and tiers; ax.text(0.4, 4.6, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12). widths = [0.15, 0.02, 0.02, 0.02] # TT, HB, MX, DD; xval = 0.1 # starting posn along x-axis.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:3538,Energy Efficiency,green,green,3538,"tistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in argument; *data*. The plot is labeled with *title* and each bar with *mc* key and; plotted at a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(figsize=(12, 7)); plt.ylim([0, 4.86]); plt.xlim([0, 6]); plt.xticks([]). # label plot and tiers; ax.text(0.4, 4.6, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12). widths = [0.15, 0.02, 0.02, 0.02] # TT, HB, MX, DD; xval = 0.1 # starting posn along x-axis. # plot bar sets; for bar in data:; if bar is not None:; lefts = [xval, xval + 0.025, xval + 0.065, xval + 0.105]. rect = ax.bar(lefts, bar['data'], widths, linewidth=0); rect[0].set_color('grey'); rect[1].set_color('red'); rect[2].set_color('green'); rect[3].set_color('blue'). ax.text(xval + .08, 4.3, bar['mc'],; verticalalignment='center', horizontalalignment='right', rotation='vertical',; family='Times New Roman', fontsize=8); xval += 0.20. # save and show; pltuid = title + '_' + hashlib.sha1(title + repr([bar['mc'] for bar in data if bar is not None])).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='bar_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. [docs]def flat(data, color=None, title='', xlimit=4.0, xlines=[0.0, 0.3, 1.0], mae=None, mape=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a slat diagram between model chemistries with errors in; single-item list *data*, which is supplied as part of the dictionary; for each participating reaction, al",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:5735,Energy Efficiency,energy,energy,5735," 'sapt', colors are taken from; sapt_colors module. Summary statistic *mae* is plotted on the; overbound side and relative statistic *mape* on the underbound side.; Saves a file with name *title* and plots to screen if *view*. """"""; import matplotlib.pyplot as plt. Nweft = 1; positions = range(-1, -1 * Nweft - 1, -1). # initialize plot; fig, ax = plt.subplots(figsize=(12, 0.33)); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); plt.xticks([]); # fig.patch.set_visible(False); # ax.patch.set_visible(False); ax.axis('off'). for xl in xlines:; plt.axvline(xl, color='grey', linewidth=4); if xl != 0.0:; plt.axvline(-1 * xl, color='grey', linewidth=4). # plot reaction errors and threads; for rxn in data:; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None). ax.plot(xvals, positions, '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. #def mpl_distslat_multiplot_files(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with basename *pltfile* with a slat representation; # of the modelchems errors in *mcdat*. Plot is in PNG, PDF, & EPS; # and suitable for download, no mouseover properties. Both labeled; # and labelless (for pub) figures are constructed.; #; # """"""; # import matplotlib as mpl; # fr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:183,Integrability,rout,routines,183,". qcdb.mpl  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.mpl; """"""Module with matplotlib plotting routines. These are not hooked up to; any particular qcdb data structures but can be called with basic; arguments. """"""; from __future__ import absolute_import; from __future__ import print_function; import os; #import matplotlib; #matplotlib.use('Agg'). [docs]def expand_saveas(saveas, def_filename, def_path=os.path.abspath(os.curdir), def_prefix='', relpath=False):; """"""Analyzes string *saveas* to see if it contains information on; path to save file, name to save file, both or neither (*saveas*; ends in '/' to indicate directory only) (able to expand '.'). A full; absolute filename is returned, lacking only file extension. Based on; analysis of missing parts of *saveas*, path information from *def_path*; and/or filename information from *def_prefix* + *def_filename* is; inserted. *def_prefix* is intended to be something like ``mplthread_``; to identify the type of figure. """"""; defname = def_prefix + def_filename.replace(' ', '_'); if saveas is None:; pth = def_path; fil = defname; else:; pth, fil = os.path.split(saveas); pth = pth if pth != '' else def_path; fil = fil if fil != '' else defname. abspathfile = os.path.join(os.path.abspath(pth), fil); if relpath:; return os.path.relpath(abspathfile, os.getcwd()); else:; return abspathfile. [docs]def segment_color(argcolor, saptcolor):; """"""Find appropriate color expression between overall color directive; *argcolor* and particular color availibility *rxncolor*. """"""; import matplotlib. # validate any sapt color; if saptcolor is not None:; if saptcolor < 0.0 or saptcolor > 1.0:; saptcolor = None. if argcolor is None:; # no color argument, so take from rxn; if rxncolor is None:; clr = 'grey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if sa",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:5894,Integrability,integrat,integration,5894,"plot as plt. Nweft = 1; positions = range(-1, -1 * Nweft - 1, -1). # initialize plot; fig, ax = plt.subplots(figsize=(12, 0.33)); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); plt.xticks([]); # fig.patch.set_visible(False); # ax.patch.set_visible(False); ax.axis('off'). for xl in xlines:; plt.axvline(xl, color='grey', linewidth=4); if xl != 0.0:; plt.axvline(-1 * xl, color='grey', linewidth=4). # plot reaction errors and threads; for rxn in data:; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None). ax.plot(xvals, positions, '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. #def mpl_distslat_multiplot_files(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with basename *pltfile* with a slat representation; # of the modelchems errors in *mcdat*. Plot is in PNG, PDF, & EPS; # and suitable for download, no mouseover properties. Both labeled; # and labelless (for pub) figures are constructed.; #; # """"""; # import matplotlib as mpl; # from matplotlib.axes import Subplot; # import sapt_colors; # from matplotlib.figure import Figure; #; # nplots = len(mcdats); # fht = nplots * 0.8; # fig, axt = plt.subplots(figsize=(12.0, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); #",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:23351,Integrability,depend,depending,23351,"e; # points sorted to avoid overlapping map areas that can overwhelm html for SSI; # y=0 on top for html and on bottom for mpl, so flip the numbers; posnM.sort(key=lambda tup: tup[2]); posnM.sort(key=lambda tup: tup[3]); last = (0, 0); for dbse, rxn, val, show, x, y in posnM:; if val is None or val is np.nan:; continue. now = (int(x), int(y)); if now == last:; htmlcode += """"""<!-- map overlap! %s-%s %+.2f skipped -->\n"""""" % (dbse, rxn, val); else:; htmlcode += """"""<AREA shape=""rect"" coords=""%d,%d,%d,%d"" onmouseover=""javascript:mouseshow('%s', '%s', '%+.2f', '%s');"">\n"""""" % \; (x - 2, img_height - y - 20,; x + 2, img_height - y + 20,; dbse, rxn, val, show); last = now. htmlcode += """"""</MAP>\n"""""". plt.close(); return files_saved, htmlcode. [docs]def ternary(sapt, title='', labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Takes array of arrays *sapt* in form [elst, indc, disp] and builds formatted; two-triangle ternary diagrams. Either fully-readable or dotsonly depending; on *labeled*. Saves in formats *graphicsformat*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib.path import Path; import matplotlib.patches as patches. # initialize plot; fig, ax = plt.subplots(figsize=(6, 3.6)); plt.xlim([-0.75, 1.25]); plt.ylim([-0.18, 1.02]); plt.xticks([]); plt.yticks([]); ax.set_aspect('equal'). if labeled:; # form and color ternary triangles; codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]; pathPos = Path([(0., 0.), (1., 0.), (0.5, 0.866), (0., 0.)], codes); pathNeg = Path([(0., 0.), (-0.5, 0.866), (0.5, 0.866), (0., 0.)], codes); ax.add_patch(patches.PathPatch(pathPos, facecolor='white', lw=2)); ax.add_patch(patches.PathPatch(pathNeg, facecolor='#fff5ee', lw=2)). # form and color HB/MX/DD dividing lines; ax.plot([0.667, 0.5], [0., 0.866], color='#eeb4b4', lw=0.5); ax.plot([-0.333, 0.5], [0.577, 0.866], color='#eeb4b4', lw=0.5); ax.plot([0.333, 0.5], [0., 0.866], ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:14064,Modifiability,extend,extend,14064,"es_saved. #def thread(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None):; # """"""Generates a tiered slat diagram between model chemistries with; # errors (or simply values) in list *data*, which is supplied as part of the; # dictionary for each participating reaction, along with *dbse* and *rxn* keys; # in argument *data*. The plot is labeled with *title* and each tier with; # an element of *labels* and plotted at *xlimit* from the zero-line. If; # *color* is None, slats are black, if 'sapt', colors are taken from *color*; # key in *data* [0, 1]. Summary statistics *mae* are plotted on the; # overbound side and relative statistics *mape* on the underbound side.; #; # """"""; # from random import random; # import matplotlib.pyplot as plt; #; # # initialize tiers/wefts; # Nweft = len(labels); # lenS = 0.2; # gapT = 0.04; # positions = range(-1, -1 * Nweft - 1, -1); # posnS = []; # for weft in range(Nweft):; # posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); # posnT = []; # for weft in range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.subplots(figsize=(12, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); # plt.xlim([-xlimit, xlimit]); # plt.ylim([-1 * Nweft - 1, 0]); # plt.yticks([]); #; # # label plot and tiers; # ax.text(-0.9 * xlimit, -0.25, title,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=12); # for weft in labels:; # ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=18); #; # # plot reaction errors and threads; # for rxn in data:; #; # # preparation; # xvals = rxn['data']; # clr = segment_color(color, rxn['color'] if 'color' in rxn else None); # slat = []; # for weft in range(Nweft):; # slat.extend([xvals[weft]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:14183,Modifiability,extend,extend,14183,"diagram between model chemistries with; # errors (or simply values) in list *data*, which is supplied as part of the; # dictionary for each participating reaction, along with *dbse* and *rxn* keys; # in argument *data*. The plot is labeled with *title* and each tier with; # an element of *labels* and plotted at *xlimit* from the zero-line. If; # *color* is None, slats are black, if 'sapt', colors are taken from *color*; # key in *data* [0, 1]. Summary statistics *mae* are plotted on the; # overbound side and relative statistics *mape* on the underbound side.; #; # """"""; # from random import random; # import matplotlib.pyplot as plt; #; # # initialize tiers/wefts; # Nweft = len(labels); # lenS = 0.2; # gapT = 0.04; # positions = range(-1, -1 * Nweft - 1, -1); # posnS = []; # for weft in range(Nweft):; # posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); # posnT = []; # for weft in range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.subplots(figsize=(12, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); # plt.xlim([-xlimit, xlimit]); # plt.ylim([-1 * Nweft - 1, 0]); # plt.yticks([]); #; # # label plot and tiers; # ax.text(-0.9 * xlimit, -0.25, title,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=12); # for weft in labels:; # ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=18); #; # # plot reaction errors and threads; # for rxn in data:; #; # # preparation; # xvals = rxn['data']; # clr = segment_color(color, rxn['color'] if 'color' in rxn else None); # slat = []; # for weft in range(Nweft):; # slat.extend([xvals[weft], xvals[weft], None]); # thread = []; # for weft in range(Nweft - 1):; # thread.extend([xvals[weft], xvals[weft + 1], Non",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:15105,Modifiability,extend,extend,15105,"n range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.subplots(figsize=(12, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); # plt.xlim([-xlimit, xlimit]); # plt.ylim([-1 * Nweft - 1, 0]); # plt.yticks([]); #; # # label plot and tiers; # ax.text(-0.9 * xlimit, -0.25, title,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=12); # for weft in labels:; # ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=18); #; # # plot reaction errors and threads; # for rxn in data:; #; # # preparation; # xvals = rxn['data']; # clr = segment_color(color, rxn['color'] if 'color' in rxn else None); # slat = []; # for weft in range(Nweft):; # slat.extend([xvals[weft], xvals[weft], None]); # thread = []; # for weft in range(Nweft - 1):; # thread.extend([xvals[weft], xvals[weft + 1], None]); #; # # plotting; # ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); # ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round',; # alpha=0.3); #; # # labeling; # try:; # toplblposn = next(item for item in xvals if item is not None); # botlblposn = next(item for item in reversed(xvals) if item is not None); # except StopIteration:; # pass; # else:; # ax.text(toplblposn, -0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); # ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); #; # # plot trimmings; # if mae is not None:; # ax.plot([-x for x in mae], positions, 's', color='black'); # if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; # ax.plot([",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:15204,Modifiability,extend,extend,15204," 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.subplots(figsize=(12, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); # plt.xlim([-xlimit, xlimit]); # plt.ylim([-1 * Nweft - 1, 0]); # plt.yticks([]); #; # # label plot and tiers; # ax.text(-0.9 * xlimit, -0.25, title,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=12); # for weft in labels:; # ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=18); #; # # plot reaction errors and threads; # for rxn in data:; #; # # preparation; # xvals = rxn['data']; # clr = segment_color(color, rxn['color'] if 'color' in rxn else None); # slat = []; # for weft in range(Nweft):; # slat.extend([xvals[weft], xvals[weft], None]); # thread = []; # for weft in range(Nweft - 1):; # thread.extend([xvals[weft], xvals[weft + 1], None]); #; # # plotting; # ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); # ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round',; # alpha=0.3); #; # # labeling; # try:; # toplblposn = next(item for item in xvals if item is not None); # botlblposn = next(item for item in reversed(xvals) if item is not None); # except StopIteration:; # pass; # else:; # ax.text(toplblposn, -0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); # ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); #; # # plot trimmings; # if mae is not None:; # ax.plot([-x for x in mae], positions, 's', color='black'); # if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; # ax.plot([0.025 * x for x in mape], positions, 'o', color='black'); #; # plt.axvline(0, color",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:17587,Modifiability,extend,extend,17587,"art of the; dictionary for each participating reaction, along with *dbse* and *rxn* keys; in argument *data*. The plot is labeled with *title* and each tier with; an element of *labels* and plotted at *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from *color*; key in *data* [0, 1]. Summary statistics *mae* are plotted on the; overbound side and relative statistics *mape* on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. """"""; import random; import hashlib; import matplotlib.pyplot as plt; import numpy as np # only needed for missing data with mouseiness. # initialize tiers/wefts; Nweft = len(labels); lenS = 0.2; gapT = 0.04; positions = range(-1, -1 * Nweft - 1, -1); posnS = []; for weft in range(Nweft):; posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); posnT = []; for weft in range(Nweft - 1):; posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); posnM = []. # initialize plot; fht = Nweft * 0.8; #fig, ax = plt.subplots(figsize=(12, fht)); fig, ax = plt.subplots(figsize=(11, fht)); plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); ax.set_frame_on(False); if labeled:; ax.set_xticks([-0.5 * xlimit, -0.25 * xlimit, 0.0, 0.25 * xlimit, 0.5 * xlimit]); else:; ax.set_xticks([]); for tick in ax.xaxis.get_major_ticks():; tick.tick1line.set_markersize(0); tick.tick2line.set_markersize(0). # label plot and tiers; if labeled:; ax.text(-0.9 * xlimit, -0.25, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12); for weft in labels:; ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; verticalalignment='bottom', horizontalalignment='left',; family='Times N",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:17700,Modifiability,extend,extend,17700,"data*. The plot is labeled with *title* and each tier with; an element of *labels* and plotted at *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from *color*; key in *data* [0, 1]. Summary statistics *mae* are plotted on the; overbound side and relative statistics *mape* on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. """"""; import random; import hashlib; import matplotlib.pyplot as plt; import numpy as np # only needed for missing data with mouseiness. # initialize tiers/wefts; Nweft = len(labels); lenS = 0.2; gapT = 0.04; positions = range(-1, -1 * Nweft - 1, -1); posnS = []; for weft in range(Nweft):; posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); posnT = []; for weft in range(Nweft - 1):; posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); posnM = []. # initialize plot; fht = Nweft * 0.8; #fig, ax = plt.subplots(figsize=(12, fht)); fig, ax = plt.subplots(figsize=(11, fht)); plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); ax.set_frame_on(False); if labeled:; ax.set_xticks([-0.5 * xlimit, -0.25 * xlimit, 0.0, 0.25 * xlimit, 0.5 * xlimit]); else:; ax.set_xticks([]); for tick in ax.xaxis.get_major_ticks():; tick.tick1line.set_markersize(0); tick.tick2line.set_markersize(0). # label plot and tiers; if labeled:; ax.text(-0.9 * xlimit, -0.25, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12); for weft in labels:; ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=18). # plot reaction errors and threads; for rxn in data:. # prepara",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:18887,Modifiability,extend,extend,18887,"djust(left=0.01, right=0.99, hspace=0.3); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); ax.set_frame_on(False); if labeled:; ax.set_xticks([-0.5 * xlimit, -0.25 * xlimit, 0.0, 0.25 * xlimit, 0.5 * xlimit]); else:; ax.set_xticks([]); for tick in ax.xaxis.get_major_ticks():; tick.tick1line.set_markersize(0); tick.tick2line.set_markersize(0). # label plot and tiers; if labeled:; ax.text(-0.9 * xlimit, -0.25, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12); for weft in labels:; ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=18). # plot reaction errors and threads; for rxn in data:. # preparation; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); slat = []; for weft in range(Nweft):; slat.extend([xvals[weft], xvals[weft], None]); thread = []; for weft in range(Nweft - 1):; thread.extend([xvals[weft], xvals[weft + 1], None]). # plotting; if Nweft == 1:; ax.plot(slat, posnS, '|', color=clr, markersize=20.0, mew=1.5, solid_capstyle='round'); else:; ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round', alpha=0.3). # converting into screen coordinates for image map; npxvals = [np.nan if val is None else val for val in xvals]; xyscreen = ax.transData.transform(zip(npxvals, positions)); xscreen, yscreen = zip(*xyscreen); posnM.extend(zip([rxn['db']] * Nweft, [rxn['sys']] * Nweft,; npxvals, [rxn['show']] * Nweft, xscreen, yscreen)). # labeling; if not(mousetext or mouselink or mouseimag):; if labeled and len(data) < 200:; try:; toplblposn = next(item for item in xvals if item is not None); botlblposn = next(item for item in reversed(xvals) if item is not None); except StopIteration:; pass; else:; ax.text(toplblposn, -0.75 + 0.6 * rand",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:18980,Modifiability,extend,extend,18980,"; plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); ax.set_frame_on(False); if labeled:; ax.set_xticks([-0.5 * xlimit, -0.25 * xlimit, 0.0, 0.25 * xlimit, 0.5 * xlimit]); else:; ax.set_xticks([]); for tick in ax.xaxis.get_major_ticks():; tick.tick1line.set_markersize(0); tick.tick2line.set_markersize(0). # label plot and tiers; if labeled:; ax.text(-0.9 * xlimit, -0.25, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12); for weft in labels:; ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=18). # plot reaction errors and threads; for rxn in data:. # preparation; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); slat = []; for weft in range(Nweft):; slat.extend([xvals[weft], xvals[weft], None]); thread = []; for weft in range(Nweft - 1):; thread.extend([xvals[weft], xvals[weft + 1], None]). # plotting; if Nweft == 1:; ax.plot(slat, posnS, '|', color=clr, markersize=20.0, mew=1.5, solid_capstyle='round'); else:; ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round', alpha=0.3). # converting into screen coordinates for image map; npxvals = [np.nan if val is None else val for val in xvals]; xyscreen = ax.transData.transform(zip(npxvals, positions)); xscreen, yscreen = zip(*xyscreen); posnM.extend(zip([rxn['db']] * Nweft, [rxn['sys']] * Nweft,; npxvals, [rxn['show']] * Nweft, xscreen, yscreen)). # labeling; if not(mousetext or mouselink or mouseimag):; if labeled and len(data) < 200:; try:; toplblposn = next(item for item in xvals if item is not None); botlblposn = next(item for item in reversed(xvals) if item is not None); except StopIteration:; pass; else:; ax.text(toplblposn, -0.75 + 0.6 * random.random(), rxn['sys'],; verticalalignment='bottom', horizontalalign",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:19520,Modifiability,extend,extend,19520,"erticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=18). # plot reaction errors and threads; for rxn in data:. # preparation; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); slat = []; for weft in range(Nweft):; slat.extend([xvals[weft], xvals[weft], None]); thread = []; for weft in range(Nweft - 1):; thread.extend([xvals[weft], xvals[weft + 1], None]). # plotting; if Nweft == 1:; ax.plot(slat, posnS, '|', color=clr, markersize=20.0, mew=1.5, solid_capstyle='round'); else:; ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round', alpha=0.3). # converting into screen coordinates for image map; npxvals = [np.nan if val is None else val for val in xvals]; xyscreen = ax.transData.transform(zip(npxvals, positions)); xscreen, yscreen = zip(*xyscreen); posnM.extend(zip([rxn['db']] * Nweft, [rxn['sys']] * Nweft,; npxvals, [rxn['show']] * Nweft, xscreen, yscreen)). # labeling; if not(mousetext or mouselink or mouseimag):; if labeled and len(data) < 200:; try:; toplblposn = next(item for item in xvals if item is not None); botlblposn = next(item for item in reversed(xvals) if item is not None); except StopIteration:; pass; else:; ax.text(toplblposn, -0.75 + 0.6 * random.random(), rxn['sys'],; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', fontsize=8); ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random.random(), rxn['sys'],; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', fontsize=8). # plot trimmings; if mae is not None:; ax.plot([-x for x in mae], positions, 's', color='black'); if labeled:; if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; ax.plot([0.025 * x for x in mape], positions, 'o', color='black'); plt.axvline(0, color='#cccc00'). # save and show; pltuid = title + '_' + ('lbld' if labeled else 'ba",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:22367,Safety,avoid,avoid,22367," += """""" cid.href = %s;\n"""""" % (mouselink); if mouseimag:; htmlcode += """""" var cmpd_img = document.getElementById(""cmpd_img"");\n""""""; htmlcode += """""" cmpd_img.src = %s;\n"""""" % (mouseimag); htmlcode += """"""}\n""""""; htmlcode += """"""</SCRIPT>\n"""""". if mousediv:; htmlcode += """"""%s\n"""""" % (mousediv[0]); if mousetitle:; htmlcode += """"""%s <BR>"""""" % (mousetitle); htmlcode += """"""<h4>Mouseover</h4><a id=""cid""></a><br>\n""""""; if mouseimag:; htmlcode += """"""<div class=""text-center"">""""""; htmlcode += """"""<IMG ID=""cmpd_img"" WIDTH=""%d"" HEIGHT=""%d"">\n"""""" % (200, 160); htmlcode += """"""</div>""""""; if mousediv:; htmlcode += """"""%s\n"""""" % (mousediv[1]); #htmlcode += """"""<IMG SRC=""%s"" ismap usemap=""#points"" WIDTH=""%d"" HEIGHT=""%d"">\n"""""" % \; # (pltfile + '.png', img_width, img_height); htmlcode += """"""<IMG SRC=""%s"" ismap usemap=""#points"" WIDTH=""%d"">\n"""""" % \; (pltfile + '.png', img_width); htmlcode += """"""<MAP name=""points"">\n"""""". # generating html image map code; # points sorted to avoid overlapping map areas that can overwhelm html for SSI; # y=0 on top for html and on bottom for mpl, so flip the numbers; posnM.sort(key=lambda tup: tup[2]); posnM.sort(key=lambda tup: tup[3]); last = (0, 0); for dbse, rxn, val, show, x, y in posnM:; if val is None or val is np.nan:; continue. now = (int(x), int(y)); if now == last:; htmlcode += """"""<!-- map overlap! %s-%s %+.2f skipped -->\n"""""" % (dbse, rxn, val); else:; htmlcode += """"""<AREA shape=""rect"" coords=""%d,%d,%d,%d"" onmouseover=""javascript:mouseshow('%s', '%s', '%+.2f', '%s');"">\n"""""" % \; (x - 2, img_height - y - 20,; x + 2, img_height - y + 20,; dbse, rxn, val, show); last = now. htmlcode += """"""</MAP>\n"""""". plt.close(); return files_saved, htmlcode. [docs]def ternary(sapt, title='', labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Takes array of arrays *sapt* in form [elst, indc, disp] and builds formatted; two-triangle ternary diagrams. Either fully-readable or dotsonly depending; on *labeled*. Saves in formats *graphicsforma",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:1639,Security,validat,validate,1639,"(*saveas*; ends in '/' to indicate directory only) (able to expand '.'). A full; absolute filename is returned, lacking only file extension. Based on; analysis of missing parts of *saveas*, path information from *def_path*; and/or filename information from *def_prefix* + *def_filename* is; inserted. *def_prefix* is intended to be something like ``mplthread_``; to identify the type of figure. """"""; defname = def_prefix + def_filename.replace(' ', '_'); if saveas is None:; pth = def_path; fil = defname; else:; pth, fil = os.path.split(saveas); pth = pth if pth != '' else def_path; fil = fil if fil != '' else defname. abspathfile = os.path.join(os.path.abspath(pth), fil); if relpath:; return os.path.relpath(abspathfile, os.getcwd()); else:; return abspathfile. [docs]def segment_color(argcolor, saptcolor):; """"""Find appropriate color expression between overall color directive; *argcolor* and particular color availibility *rxncolor*. """"""; import matplotlib. # validate any sapt color; if saptcolor is not None:; if saptcolor < 0.0 or saptcolor > 1.0:; saptcolor = None. if argcolor is None:; # no color argument, so take from rxn; if rxncolor is None:; clr = 'grey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries with error; statistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:2834,Security,hash,hashlib,2834,"ey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries with error; statistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in argument; *data*. The plot is labeled with *title* and each bar with *mc* key and; plotted at a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(figsize=(12, 7)); plt.ylim([0, 4.86]); plt.xlim([0, 6]); plt.xticks([]). # label plot and tiers; ax.text(0.4, 4.6, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12). widths = [0.15, 0.02, 0.02, 0.02] # TT, HB, MX, DD; xval = 0.1 # starting posn along x-axis. # plot bar sets; for bar in data:; if bar is not None:; lefts = [xval, xval + 0.025, xval + 0.065, xval + 0.105]. rect = ax.bar(lefts, bar['data'], widths, linewidth=0); rect[0].set_color('grey'); rect[1].set_color('red'); rect[2].set_color('green'); rect[3].set_color('blue'). ax.text(xval + .08, 4.3, bar['mc'],; verticalalignment='center', horizontalalignment='right', rotation='vertical',; family='Times New Roman', fontsize=8); xval += 0.20. # save and show; pltuid = title + '_' + hashlib.sha1(title + repr([bar['mc'] for bar in data if ba",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:3783,Security,hash,hashlib,3783,"a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(figsize=(12, 7)); plt.ylim([0, 4.86]); plt.xlim([0, 6]); plt.xticks([]). # label plot and tiers; ax.text(0.4, 4.6, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12). widths = [0.15, 0.02, 0.02, 0.02] # TT, HB, MX, DD; xval = 0.1 # starting posn along x-axis. # plot bar sets; for bar in data:; if bar is not None:; lefts = [xval, xval + 0.025, xval + 0.065, xval + 0.105]. rect = ax.bar(lefts, bar['data'], widths, linewidth=0); rect[0].set_color('grey'); rect[1].set_color('red'); rect[2].set_color('green'); rect[3].set_color('blue'). ax.text(xval + .08, 4.3, bar['mc'],; verticalalignment='center', horizontalalignment='right', rotation='vertical',; family='Times New Roman', fontsize=8); xval += 0.20. # save and show; pltuid = title + '_' + hashlib.sha1(title + repr([bar['mc'] for bar in data if bar is not None])).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='bar_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. [docs]def flat(data, color=None, title='', xlimit=4.0, xlines=[0.0, 0.3, 1.0], mae=None, mape=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a slat diagram between model chemistries with errors in; single-item list *data*, which is supplied as part of the dictionary; for each participating reaction, along with *dbse* and *rxn* keys in; argument *data*. Limits of plot are *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from; sapt_colors module. Summary statistic *mae* is plotted",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:8966,Security,hash,hashlib,8966,"min + 0.3, 1.0, stats(np.array(mcdats[item])), fontsize=7, family='monospace', verticalalignment='center'); # ax_again.plot([0, 0], [0.9, 1.1], color='#cccc00', lw=2); # ax_again.set_frame_on(False); # ax_again.set_yticks([]); # ax_again.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # ax_again.tick_params(axis='both', which='major', labelbottom='off', bottom='off'); # ax_again.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # ax_again.tick_params(axis='both', which='major', labelbottom='on', bottom='off'); #; # plt.savefig('scratch/' + pltfile + '_trimd' + '.png', transparent=True, format='PNG'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.pdf', transparent=True, format='PDF'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.eps', transparent=True, format='EPS'). [docs]def valerr(data, color=None, title='', xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; import hashlib; from itertools import cycle; import matplotlib.pyplot as plt. fig, ax = plt.subplots(figsize=(4, 6)); ax1 = fig.add_subplot(211); plt.axhline(0.0, axes=ax1, color='black'); ax1.set_ylabel('Reaction Energy'); plt.title(title). ax2 = plt.subplot(212, sharex=ax1); plt.axhline(0.0, axes=ax2, color='#cccc00'); ax2.set_ylabel('Energy Error'); ax2.set_xlabel(xtitle). xmin = 500.0; xmax = -500.0; vmin = 1.0; vmax = -1.0; emin = 1.0; emax = -1.0; linecycler = cycle(['-', '--', '-.', ':']); # plot reaction errors and threads; for trace, tracedata in data.iteritems():; vaxis = []; vmcdata = []; verror = []; for rxn in tracedata:; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); xmin = min(xmin, rxn['axis']); xmax = max(xmax, rxn['axis']). ax1.plot(rxn['axis'], rxn['mcdata'], '^', color=clr, markersize=6.0, mew=0, zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.p",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:10825,Security,hash,hashlib,10825,", zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.plot(rxn['axis'], rxn['bmdata'], 'o', color='black', markersize=6.0, zorder=1); vmin = min(0, vmin, rxn['bmdata']); vmax = max(0, vmax, rxn['bmdata']). if rxn['error'][0] is not None:; ax2.plot(rxn['axis'], rxn['error'][0], 's', color=clr, mew=0, zorder=8); emin = min(0, emin, rxn['error'][0]); emax = max(0, emax, rxn['error'][0]); verror.append(rxn['error'][0]). ls = next(linecycler); ax1.plot(vaxis, vmcdata, ls, color='grey', label=trace, zorder=3); ax2.plot(vaxis, verror, ls, color='grey', label=trace, zorder=4). xbuf = max(0.05, abs(0.02 * xmax)); vbuf = max(0.1, abs(0.02 * vmax)); ebuf = max(0.01, abs(0.02 * emax)); plt.xlim([xmin - xbuf, xmax + xbuf]); ax1.set_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. [docs]def disthist(data, title='', xtitle='', xmin=None, xmax=None,; me=None, stde=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with name *saveas* with a histogram representation; of the reaction errors in *data*. Also plots a gaussian distribution; with mean *me* and standard deviation *stde*. Plot has x-range; *xmin* to *xmax*, x-axis label *xtitle* and overall title *title*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt. def gaussianpdf(u, v, x):; """"""*u* is mean, *v* is variance, *x* is value, returns probability""""""; retur",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:11644,Security,hash,hashlib,11644,"_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. [docs]def disthist(data, title='', xtitle='', xmin=None, xmax=None,; me=None, stde=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with name *saveas* with a histogram representation; of the reaction errors in *data*. Also plots a gaussian distribution; with mean *me* and standard deviation *stde*. Plot has x-range; *xmin* to *xmax*, x-axis label *xtitle* and overall title *title*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt. def gaussianpdf(u, v, x):; """"""*u* is mean, *v* is variance, *x* is value, returns probability""""""; return 1.0 / np.sqrt(2.0 * np.pi * v) * np.exp(-pow(x - u, 2) / 2.0 / v). me = me if me is not None else np.mean(data); stde = stde if stde is not None else np.std(data, ddof=1); evenerr = max(abs(me - 4.0 * stde), abs(me + 4.0 * stde)); xmin = xmin if xmin is not None else -1 * evenerr; xmax = xmax if xmax is not None else evenerr. dx = (xmax - xmin) / 40.; nx = int(round((xmax - xmin) / dx)) + 1; pdfx = []; pdfy = []; for i in xrange(nx):; ix = xmin + i * dx; pdfx.append(ix); pdfy.append(gaussianpdf(me, pow(stde, 2), ix)). fig, ax1 = plt.subplots(figsize=(16, 6)); plt.axvline(0.0, color='#cccc00'); ax1.set_xlim(xmin, xmax); ax1.hist(data, bins=30, range=(xmin, xmax), color='#2d4065', alpha=0.7); ax1.set_xlabel(xtitle); ax1.set_ylabel('Count'). ax2 = ax1.twinx(); ax2.fill(pdfx, pdfy, color='k', alpha=0.2); ax2.set_ylabel('Probability Density').",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:12720,Security,hash,hashlib,12720,"t. def gaussianpdf(u, v, x):; """"""*u* is mean, *v* is variance, *x* is value, returns probability""""""; return 1.0 / np.sqrt(2.0 * np.pi * v) * np.exp(-pow(x - u, 2) / 2.0 / v). me = me if me is not None else np.mean(data); stde = stde if stde is not None else np.std(data, ddof=1); evenerr = max(abs(me - 4.0 * stde), abs(me + 4.0 * stde)); xmin = xmin if xmin is not None else -1 * evenerr; xmax = xmax if xmax is not None else evenerr. dx = (xmax - xmin) / 40.; nx = int(round((xmax - xmin) / dx)) + 1; pdfx = []; pdfy = []; for i in xrange(nx):; ix = xmin + i * dx; pdfx.append(ix); pdfy.append(gaussianpdf(me, pow(stde, 2), ix)). fig, ax1 = plt.subplots(figsize=(16, 6)); plt.axvline(0.0, color='#cccc00'); ax1.set_xlim(xmin, xmax); ax1.hist(data, bins=30, range=(xmin, xmax), color='#2d4065', alpha=0.7); ax1.set_xlabel(xtitle); ax1.set_ylabel('Count'). ax2 = ax1.twinx(); ax2.fill(pdfx, pdfy, color='k', alpha=0.2); ax2.set_ylabel('Probability Density'). plt.title(title). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(me) + str(stde) + str(xmin) + str(xmax)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='disthist_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. #def thread(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None):; # """"""Generates a tiered slat diagram between model chemistries with; # errors (or simply values) in list *data*, which is supplied as part of the; # dictionary for each participating reaction, along with *dbse* and *rxn* keys; # in argument *data*. The plot is labeled with *title* and each tier with; # an element of *labels* and plotted at *xlimit* from the zero-line. If; # *color* is None, slats are black, if 'sapt', colors are taken from *color*; # key in *data* [0, 1]. Summary sta",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:17318,Security,hash,hashlib,17318,"xlimit=4.0, mae=None, mape=None,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a tiered slat diagram between model chemistries with; errors (or simply values) in list *data*, which is supplied as part of the; dictionary for each participating reaction, along with *dbse* and *rxn* keys; in argument *data*. The plot is labeled with *title* and each tier with; an element of *labels* and plotted at *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from *color*; key in *data* [0, 1]. Summary statistics *mae* are plotted on the; overbound side and relative statistics *mape* on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. """"""; import random; import hashlib; import matplotlib.pyplot as plt; import numpy as np # only needed for missing data with mouseiness. # initialize tiers/wefts; Nweft = len(labels); lenS = 0.2; gapT = 0.04; positions = range(-1, -1 * Nweft - 1, -1); posnS = []; for weft in range(Nweft):; posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); posnT = []; for weft in range(Nweft - 1):; posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); posnM = []. # initialize plot; fht = Nweft * 0.8; #fig, ax = plt.subplots(figsize=(12, fht)); fig, ax = plt.subplots(figsize=(11, fht)); plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); ax.set_frame_on(False); if labeled:; ax.set_xticks([-0.5 * xlimit, -0.25 * xlimit, 0.0, 0.25 * xlimit, 0.5 * xlimit]); else:; ax.set_xticks([]); for tick in ax.xaxis.get_major_ticks():; tick.tick1line.set_markersize(0); tick.tick2line.set_markersize(0). # label plot ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:20586,Security,hash,hashlib,20586,"t, [rxn['sys']] * Nweft,; npxvals, [rxn['show']] * Nweft, xscreen, yscreen)). # labeling; if not(mousetext or mouselink or mouseimag):; if labeled and len(data) < 200:; try:; toplblposn = next(item for item in xvals if item is not None); botlblposn = next(item for item in reversed(xvals) if item is not None); except StopIteration:; pass; else:; ax.text(toplblposn, -0.75 + 0.6 * random.random(), rxn['sys'],; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', fontsize=8); ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random.random(), rxn['sys'],; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', fontsize=8). # plot trimmings; if mae is not None:; ax.plot([-x for x in mae], positions, 's', color='black'); if labeled:; if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; ax.plot([0.025 * x for x in mape], positions, 'o', color='black'); plt.axvline(0, color='#cccc00'). # save and show; pltuid = title + '_' + ('lbld' if labeled else 'bare') + '_' + hashlib.sha1(title + repr(labels) + repr(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='thread_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(). if not (mousetext or mouselink or mouseimag):; plt.close(); return files_saved, None; else:; dpi = 80; img_width = fig.get_figwidth() * dpi; img_height = fig.get_figheight() * dpi. htmlcode = """"""<SCRIPT>\n""""""; htmlcode += """"""function mouseshow(db, rxn, val, show) {\n""""""; if mousetext or mouselink:; htmlcode += """""" var cid = document.getElementById(""cid"");\n""""""; if mousetext:; htmlcode += """""" cid.innerHTML = %s;\n"""""" % (mousetext); if mouselink:; htmlcode += """""" cid.href = %s;\n"""""" % (mouselink); if mouseimag:; htmlcode += """""" var cmpd_img = document.getElementById(""cmpd_img"");\n""""""; htmlcode += ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:23423,Security,hash,hashlib,23423," for html and on bottom for mpl, so flip the numbers; posnM.sort(key=lambda tup: tup[2]); posnM.sort(key=lambda tup: tup[3]); last = (0, 0); for dbse, rxn, val, show, x, y in posnM:; if val is None or val is np.nan:; continue. now = (int(x), int(y)); if now == last:; htmlcode += """"""<!-- map overlap! %s-%s %+.2f skipped -->\n"""""" % (dbse, rxn, val); else:; htmlcode += """"""<AREA shape=""rect"" coords=""%d,%d,%d,%d"" onmouseover=""javascript:mouseshow('%s', '%s', '%+.2f', '%s');"">\n"""""" % \; (x - 2, img_height - y - 20,; x + 2, img_height - y + 20,; dbse, rxn, val, show); last = now. htmlcode += """"""</MAP>\n"""""". plt.close(); return files_saved, htmlcode. [docs]def ternary(sapt, title='', labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Takes array of arrays *sapt* in form [elst, indc, disp] and builds formatted; two-triangle ternary diagrams. Either fully-readable or dotsonly depending; on *labeled*. Saves in formats *graphicsformat*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib.path import Path; import matplotlib.patches as patches. # initialize plot; fig, ax = plt.subplots(figsize=(6, 3.6)); plt.xlim([-0.75, 1.25]); plt.ylim([-0.18, 1.02]); plt.xticks([]); plt.yticks([]); ax.set_aspect('equal'). if labeled:; # form and color ternary triangles; codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]; pathPos = Path([(0., 0.), (1., 0.), (0.5, 0.866), (0., 0.)], codes); pathNeg = Path([(0., 0.), (-0.5, 0.866), (0.5, 0.866), (0., 0.)], codes); ax.add_patch(patches.PathPatch(pathPos, facecolor='white', lw=2)); ax.add_patch(patches.PathPatch(pathNeg, facecolor='#fff5ee', lw=2)). # form and color HB/MX/DD dividing lines; ax.plot([0.667, 0.5], [0., 0.866], color='#eeb4b4', lw=0.5); ax.plot([-0.333, 0.5], [0.577, 0.866], color='#eeb4b4', lw=0.5); ax.plot([0.333, 0.5], [0., 0.866], color='#7ec0ee', lw=0.5); ax.plot([-0.167, 0.5], [0.289, 0.866], color='#7ec0ee', lw=0.5). # l",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:25938,Security,hash,hashlib,25938,"ize=18); ax.text(-0.5, 0.9, u'Elst (+)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', weight='bold', fontsize=18). xvals = []; yvals = []; cvals = []; for sys in sapt:; [elst, indc, disp] = sys. # calc ternary posn and color; Ftop = abs(indc) / (abs(elst) + abs(indc) + abs(disp)); Fright = abs(elst) / (abs(elst) + abs(indc) + abs(disp)); xdot = 0.5 * Ftop + Fright; ydot = 0.866 * Ftop; cdot = 0.5 + (xdot - 0.5) / (1. - Ftop); if elst > 0.:; xdot = 0.5 * (Ftop - Fright); ydot = 0.866 * (Ftop + Fright); #print elst, indc, disp, '', xdot, ydot, cdot. xvals.append(xdot); yvals.append(ydot); cvals.append(cdot). sc = ax.scatter(xvals, yvals, c=cvals, s=15, marker=""o"", \; cmap=mpl.cm.jet, edgecolor='none', vmin=0, vmax=1, zorder=10). # remove figure outline; ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['bottom'].set_visible(False); ax.spines['left'].set_visible(False). # save and show; pltuid = title + '_' + ('lbld' if labeled else 'bare') + '_' + hashlib.sha1(title + repr(sapt)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='tern_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, dpi=450, edgecolor='none', pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. #def thread_mouseover_web(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with name *pltfile* with a slat representation of; # the modelchems errors in *mcdat*. Mouseover shows geometry and error; # from *labels* based on recipe of Andrew Dalke from; # http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html; #; # """"""; # from matplotlib.backends.backend_agg import FigureCanvasAgg; # import matplotlib; # import sapt_colors; #; # cmpd_width = 200; # cmpd_height = 16",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:31042,Security,hash,hashlib,31042,"ids *aa1*; and *aa2* and returns a square array of all errors for that amino; acid pair, buffered by zeros. """"""; import re; import numpy as np; bfdbpattern = re.compile(""\d\d\d([A-Z][A-Z][A-Z])-\d\d\d([A-Z][A-Z][A-Z])-\d""). tiles = []; for key, val in db.items():; bfdbname = bfdbpattern.match(key); if (bfdbname.group(1) == aa1 and bfdbname.group(2) == aa2) or \; (bfdbname.group(2) == aa1 and bfdbname.group(1) == aa2):; tiles.append(val). if not tiles:; # fill in background when no data. only sensible for neutral center colormaps; tiles = [0]; dim = int(np.ceil(np.sqrt(len(tiles)))); pad = dim * dim - len(tiles); tiles += [0] * pad. return np.reshape(np.array(tiles), (dim, dim)). [docs]def iowa(mcdat, mclbl, title='', xtitle='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with (extensionless) name *pltfile* with an Iowa; representation of the modelchems errors in *mcdat* for BBI/SSI-style; *labels*. """"""; import numpy as np; import hashlib; import matplotlib; import matplotlib.pyplot as plt. aa = ['ARG', 'HIE', 'LYS', 'ASP', 'GLU', 'SER', 'THR', 'ASN', 'GLN', 'CYS', 'MET', 'GLY', 'ALA', 'VAL', 'ILE', 'LEU', 'PRO', 'PHE', 'TYR', 'TRP']; #aa = ['ILE', 'LEU', 'ASP', 'GLU', 'PHE']; err = dict(zip(mclbl, mcdat)). # handle for frame, overall axis; fig, axt = plt.subplots(figsize=(6, 6)). #axt.set_xticks([]) # for quick nolabel, whiteback; #axt.set_yticks([]) # for quick nolabel, whiteback; axt.set_xticks(np.arange(len(aa)) + 0.3, minor=False); axt.set_yticks(np.arange(len(aa)) + 0.3, minor=False); axt.invert_yaxis(); axt.xaxis.tick_top() # comment for quick nolabel, whiteback; axt.set_xticklabels(aa, minor=False, rotation=60, size='small') # comment for quick nolabel, whiteback; axt.set_yticklabels(aa, minor=False, size='small') # comment for quick nolabel, whiteback; axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); #axt.set_title('%s' % (title), fontsize=16, verticalalignment='botto",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:32845,Security,hash,hashlib,32845,"False, size='small') # comment for quick nolabel, whiteback; axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); #axt.set_title('%s' % (title), fontsize=16, verticalalignment='bottom'); #axt.text(10.0, -1.5, title, horizontalalignment='center', fontsize=16). # nill spacing between 20x20 heatmaps; plt.subplots_adjust(hspace=0.001, wspace=0.001). index = 1; for aa1 in aa:; for aa2 in aa:; cb = composition_tile(err, aa1, aa2). ax = matplotlib.axes.Subplot(fig, len(aa), len(aa), index); fig.add_subplot(ax); heatmap = ax.pcolor(cb, vmin=-xlimit, vmax=xlimit, cmap=plt.cm.PRGn); ax.set_xticks([]); ax.set_yticks([]); index += 1. #plt.title(title); axt.axvline(x=4.8, linewidth=5, color='k'); axt.axvline(x=8.75, linewidth=5, color='k'); axt.axvline(x=11.6, linewidth=5, color='k'); axt.axhline(y=4.8, linewidth=5, color='k'); axt.axhline(y=8.75, linewidth=5, color='k'); axt.axhline(y=11.6, linewidth=5, color='k'); axt.set_zorder(100). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='iowa_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); #plt.savefig(savefile, transparent=False, format=ext, bbox_inches='tight') # for quick nolabel, whiteback; files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. [docs]def liliowa(mcdat, title='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with a heatmap representation of *mcdat*. """"""; import numpy as np; import hashlib; import matplotlib; import matplotlib.pyplot as plt. # handle for frame, overall axis; fig, axt = plt.subplots(figsize=(1, 1)). axt.set_xticks([]); axt.set_yticks([]); axt.invert_yaxis(); axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); axt.set_a",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:33532,Security,hash,hashlib,33532,"ewidth=5, color='k'); axt.axvline(x=8.75, linewidth=5, color='k'); axt.axvline(x=11.6, linewidth=5, color='k'); axt.axhline(y=4.8, linewidth=5, color='k'); axt.axhline(y=8.75, linewidth=5, color='k'); axt.axhline(y=11.6, linewidth=5, color='k'); axt.set_zorder(100). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='iowa_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); #plt.savefig(savefile, transparent=False, format=ext, bbox_inches='tight') # for quick nolabel, whiteback; files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. [docs]def liliowa(mcdat, title='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with a heatmap representation of *mcdat*. """"""; import numpy as np; import hashlib; import matplotlib; import matplotlib.pyplot as plt. # handle for frame, overall axis; fig, axt = plt.subplots(figsize=(1, 1)). axt.set_xticks([]); axt.set_yticks([]); axt.invert_yaxis(); axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); axt.set_aspect('equal'). # remove figure outline; axt.spines['top'].set_visible(False); axt.spines['right'].set_visible(False); axt.spines['bottom'].set_visible(False); axt.spines['left'].set_visible(False). tiles = mcdat; dim = int(np.ceil(np.sqrt(len(tiles)))); pad = dim * dim - len(tiles); tiles += [0] * pad; cb = np.reshape(np.array(tiles), (dim, dim)). heatmap = axt.pcolor(cb, vmin=-xlimit, vmax=xlimit, cmap=plt.cm.PRGn). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='liliowa_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:34291,Security,hash,hashlib,34291,"if view:; plt.show(); plt.close(); return files_saved. [docs]def liliowa(mcdat, title='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with a heatmap representation of *mcdat*. """"""; import numpy as np; import hashlib; import matplotlib; import matplotlib.pyplot as plt. # handle for frame, overall axis; fig, axt = plt.subplots(figsize=(1, 1)). axt.set_xticks([]); axt.set_yticks([]); axt.invert_yaxis(); axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); axt.set_aspect('equal'). # remove figure outline; axt.spines['top'].set_visible(False); axt.spines['right'].set_visible(False); axt.spines['bottom'].set_visible(False); axt.spines['left'].set_visible(False). tiles = mcdat; dim = int(np.ceil(np.sqrt(len(tiles)))); pad = dim * dim - len(tiles); tiles += [0] * pad; cb = np.reshape(np.array(tiles), (dim, dim)). heatmap = axt.pcolor(cb, vmin=-xlimit, vmax=xlimit, cmap=plt.cm.PRGn). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='liliowa_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. if __name__ == ""__main__"":. merge_dats = [; {'show':'a', 'db':'HSG', 'sys':'1', 'data':[0.3508, 0.1234, 0.0364, 0.0731, 0.0388]},; {'show':'b', 'db':'HSG', 'sys':'3', 'data':[0.2036, -0.0736, -0.1650, -0.1380, -0.1806]},; #{'show':'', 'db':'S22', 'sys':'14', 'data':[np.nan, -3.2144, np.nan, np.nan, np.nan]},; {'show':'c', 'db':'S22', 'sys':'14', 'data':[None, -3.2144, None, None, None]},; {'show':'d', 'db':'S22', 'sys':'15', 'data':[-1.5090, -2.5263, -2.9452, -2.8633, -3.1059]},; {'show':'e', 'db':'S22', 'sys':'22', 'data':[0.3046, -0.2632, -0.5070, -0.4925, -0.6359",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:5848,Usability,simpl,simple,5848,"plot as plt. Nweft = 1; positions = range(-1, -1 * Nweft - 1, -1). # initialize plot; fig, ax = plt.subplots(figsize=(12, 0.33)); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); plt.xticks([]); # fig.patch.set_visible(False); # ax.patch.set_visible(False); ax.axis('off'). for xl in xlines:; plt.axvline(xl, color='grey', linewidth=4); if xl != 0.0:; plt.axvline(-1 * xl, color='grey', linewidth=4). # plot reaction errors and threads; for rxn in data:; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None). ax.plot(xvals, positions, '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. #def mpl_distslat_multiplot_files(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with basename *pltfile* with a slat representation; # of the modelchems errors in *mcdat*. Plot is in PNG, PDF, & EPS; # and suitable for download, no mouseover properties. Both labeled; # and labelless (for pub) figures are constructed.; #; # """"""; # import matplotlib as mpl; # from matplotlib.axes import Subplot; # import sapt_colors; # from matplotlib.figure import Figure; #; # nplots = len(mcdats); # fht = nplots * 0.8; # fig, axt = plt.subplots(figsize=(12.0, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); #",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:7822,Usability,guid,guides,7822,"0.8; # fig, axt = plt.subplots(figsize=(12.0, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); #; # axt.set_xticks([]); # axt.set_yticks([]); # plt.axis('off'); #; # for item in range(nplots):; # mcdat = mcdats[item]; # label = labels[item]; # title = titles[item]; #; # erdat = np.array(mcdat); # yvals = np.ones(len(mcdat)); # y = np.array([sapt_colors.sapt_colors[dbname][i] for i in label]); #; # ax = Subplot(fig, nplots, 1, item + 1); # fig.add_subplot(ax); # sc = ax.scatter(erdat, yvals, c=y, s=3000, marker=""|"", cmap=mpl.cm.jet, vmin=0, vmax=1); #; # ax.set_yticks([]); # ax.set_xticks([]); # ax.set_frame_on(False); # ax.set_xlim([xmin, xmax]); #; # # Write files with only slats; # plt.savefig('scratch/' + pltfile + '_plain' + '.png', transparent=True, format='PNG'); # plt.savefig('scratch/' + pltfile + '_plain' + '.pdf', transparent=True, format='PDF'); # plt.savefig('scratch/' + pltfile + '_plain' + '.eps', transparent=True, format='EPS'); #; # # Rewrite files with guides and labels; # for item in range(nplots):; # ax_again = fig.add_subplot(nplots, 1, item + 1); # ax_again.set_title(titles[item], fontsize=8); # ax_again.text(xmin + 0.3, 1.0, stats(np.array(mcdats[item])), fontsize=7, family='monospace', verticalalignment='center'); # ax_again.plot([0, 0], [0.9, 1.1], color='#cccc00', lw=2); # ax_again.set_frame_on(False); # ax_again.set_yticks([]); # ax_again.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # ax_again.tick_params(axis='both', which='major', labelbottom='off', bottom='off'); # ax_again.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # ax_again.tick_params(axis='both', which='major', labelbottom='on', bottom='off'); #; # plt.savefig('scratch/' + pltfile + '_trimd' + '.png', transparent=True, format='PNG'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.pdf', transparent=True, format='PDF'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.eps', transparent=True, format='EPS",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:13298,Usability,simpl,simply,13298,", ix)). fig, ax1 = plt.subplots(figsize=(16, 6)); plt.axvline(0.0, color='#cccc00'); ax1.set_xlim(xmin, xmax); ax1.hist(data, bins=30, range=(xmin, xmax), color='#2d4065', alpha=0.7); ax1.set_xlabel(xtitle); ax1.set_ylabel('Count'). ax2 = ax1.twinx(); ax2.fill(pdfx, pdfy, color='k', alpha=0.2); ax2.set_ylabel('Probability Density'). plt.title(title). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(me) + str(stde) + str(xmin) + str(xmax)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='disthist_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. #def thread(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None):; # """"""Generates a tiered slat diagram between model chemistries with; # errors (or simply values) in list *data*, which is supplied as part of the; # dictionary for each participating reaction, along with *dbse* and *rxn* keys; # in argument *data*. The plot is labeled with *title* and each tier with; # an element of *labels* and plotted at *xlimit* from the zero-line. If; # *color* is None, slats are black, if 'sapt', colors are taken from *color*; # key in *data* [0, 1]. Summary statistics *mae* are plotted on the; # overbound side and relative statistics *mape* on the underbound side.; #; # """"""; # from random import random; # import matplotlib.pyplot as plt; #; # # initialize tiers/wefts; # Nweft = len(labels); # lenS = 0.2; # gapT = 0.04; # positions = range(-1, -1 * Nweft - 1, -1); # posnS = []; # for weft in range(Nweft):; # posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); # posnT = []; # for weft in range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:16590,Usability,simpl,simply,16590,"t(item for item in reversed(xvals) if item is not None); # except StopIteration:; # pass; # else:; # ax.text(toplblposn, -0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); # ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); #; # # plot trimmings; # if mae is not None:; # ax.plot([-x for x in mae], positions, 's', color='black'); # if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; # ax.plot([0.025 * x for x in mape], positions, 'o', color='black'); #; # plt.axvline(0, color='black'); # plt.show(). [docs]def threads(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a tiered slat diagram between model chemistries with; errors (or simply values) in list *data*, which is supplied as part of the; dictionary for each participating reaction, along with *dbse* and *rxn* keys; in argument *data*. The plot is labeled with *title* and each tier with; an element of *labels* and plotted at *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from *color*; key in *data* [0, 1]. Summary statistics *mae* are plotted on the; overbound side and relative statistics *mape* on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. """"""; import random; import hashlib; import matplotlib.pyplot as plt; import numpy as np # only needed for missing data with mouseiness. # initialize tiers/wefts; Nweft = len(labels); lenS = 0.2; gapT = 0.04; positions = range(-1, -1 * Nweft - 1, -1",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/mpl.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:390,Deployability,update,updates,390,". qcdb.oldpymodules  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.oldpymodules; # Obtained from http://code.activestate.com/recipes/576693/ on 15 Nov 2014. # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.; # Passes Python2.7's test suite and incorporates all the latest updates. from __future__ import absolute_import; from __future__ import print_function; try:; from thread import get_ident as _get_ident; except ImportError:; from dummy_thread import get_ident as _get_ident. try:; from _abcoll import KeysView, ValuesView, ItemsView; except ImportError:; pass. [docs]class OrderedDict(dict):; 'Dictionary that remembers insertion order'; # An inherited dict maps keys to values.; # The inherited dict provides __getitem__, __len__, __contains__, and get.; # The remaining methods are order-aware.; # Big-O running times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated wi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:1991,Deployability,update,updated,1991,"ing times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated with the new key/value pair.; if key not in self:; root = self.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:4333,Deployability,update,update,4333,".__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. [docs] def items(self):; 'od.items() -> list of (key, value) pairs in od'; return [(key, self[key]) for key in self]. [docs] def iterkeys(self):; 'od.iterkeys() -> an iterator over the keys in od'; return iter(self). [docs] def itervalues(self):; 'od.itervalues -> an iterator over the values in od'; for k in self:; yield self[k]. [docs] def iteritems(self):; 'od.iteritems -> an iterator over the (key, value) items in od'; for k in self:; yield (k, self[k]). [docs] def update(*args, **kwds):; '''od.update(E, **F) -> None. Update od from dict/iterable E and F. If E is a dict instance, does: for k in E: od[k] = E[k]; If E has a .keys() method, does: for k in E.keys(): od[k] = E[k]; Or if E is an iterable of items, does: for k, v in E: od[k] = v; In either case, this is followed by: for k, v in F.items(): od[k] = v. '''; if len(args) > 2:; raise TypeError('update() takes at most 2 positional '; 'arguments (%d given)' % (len(args),)); elif not args:; raise TypeError('update() takes at least 1 argument (0 given)'); self = args[0]; # Make progressively weaker assumptions about ""other""; other = (); if len(args) == 2:; other = args[1]; if isinstance(other, dict):; for key in other:; self[key] = other[key]; elif hasattr(other, 'keys'):; for key in other.keys():; self[key] = other[key]; else:; for key, value in other:; self[key] = value; for key, value in kwds.items():; self[key] = value. __update = update # let subclasses override update without breaking __init__. __m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:4363,Deployability,update,update,4363,"]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. [docs] def items(self):; 'od.items() -> list of (key, value) pairs in od'; return [(key, self[key]) for key in self]. [docs] def iterkeys(self):; 'od.iterkeys() -> an iterator over the keys in od'; return iter(self). [docs] def itervalues(self):; 'od.itervalues -> an iterator over the values in od'; for k in self:; yield self[k]. [docs] def iteritems(self):; 'od.iteritems -> an iterator over the (key, value) items in od'; for k in self:; yield (k, self[k]). [docs] def update(*args, **kwds):; '''od.update(E, **F) -> None. Update od from dict/iterable E and F. If E is a dict instance, does: for k in E: od[k] = E[k]; If E has a .keys() method, does: for k in E.keys(): od[k] = E[k]; Or if E is an iterable of items, does: for k, v in E: od[k] = v; In either case, this is followed by: for k, v in F.items(): od[k] = v. '''; if len(args) > 2:; raise TypeError('update() takes at most 2 positional '; 'arguments (%d given)' % (len(args),)); elif not args:; raise TypeError('update() takes at least 1 argument (0 given)'); self = args[0]; # Make progressively weaker assumptions about ""other""; other = (); if len(args) == 2:; other = args[1]; if isinstance(other, dict):; for key in other:; self[key] = other[key]; elif hasattr(other, 'keys'):; for key in other.keys():; self[key] = other[key]; else:; for key, value in other:; self[key] = value; for key, value in kwds.items():; self[key] = value. __update = update # let subclasses override update without breaking __init__. __marker = object(). [docs] def pop(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:4725,Deployability,update,update,4725,"t of (key, value) pairs in od'; return [(key, self[key]) for key in self]. [docs] def iterkeys(self):; 'od.iterkeys() -> an iterator over the keys in od'; return iter(self). [docs] def itervalues(self):; 'od.itervalues -> an iterator over the values in od'; for k in self:; yield self[k]. [docs] def iteritems(self):; 'od.iteritems -> an iterator over the (key, value) items in od'; for k in self:; yield (k, self[k]). [docs] def update(*args, **kwds):; '''od.update(E, **F) -> None. Update od from dict/iterable E and F. If E is a dict instance, does: for k in E: od[k] = E[k]; If E has a .keys() method, does: for k in E.keys(): od[k] = E[k]; Or if E is an iterable of items, does: for k, v in E: od[k] = v; In either case, this is followed by: for k, v in F.items(): od[k] = v. '''; if len(args) > 2:; raise TypeError('update() takes at most 2 positional '; 'arguments (%d given)' % (len(args),)); elif not args:; raise TypeError('update() takes at least 1 argument (0 given)'); self = args[0]; # Make progressively weaker assumptions about ""other""; other = (); if len(args) == 2:; other = args[1]; if isinstance(other, dict):; for key in other:; self[key] = other[key]; elif hasattr(other, 'keys'):; for key in other.keys():; self[key] = other[key]; else:; for key, value in other:; self[key] = value; for key, value in kwds.items():; self[key] = value. __update = update # let subclasses override update without breaking __init__. __marker = object(). [docs] def pop(self, key, default=__marker):; '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.; If key is not found, d is returned if given, otherwise KeyError is raised. '''; if key in self:; result = self[key]; del self[key]; return result; if default is self.__marker:; raise KeyError(key); return default. [docs] def setdefault(self, key, default=None):; 'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'; if key in self:; return self[key]; self[key] = default; return default. def __repr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:4837,Deployability,update,update,4837,"t of (key, value) pairs in od'; return [(key, self[key]) for key in self]. [docs] def iterkeys(self):; 'od.iterkeys() -> an iterator over the keys in od'; return iter(self). [docs] def itervalues(self):; 'od.itervalues -> an iterator over the values in od'; for k in self:; yield self[k]. [docs] def iteritems(self):; 'od.iteritems -> an iterator over the (key, value) items in od'; for k in self:; yield (k, self[k]). [docs] def update(*args, **kwds):; '''od.update(E, **F) -> None. Update od from dict/iterable E and F. If E is a dict instance, does: for k in E: od[k] = E[k]; If E has a .keys() method, does: for k in E.keys(): od[k] = E[k]; Or if E is an iterable of items, does: for k, v in E: od[k] = v; In either case, this is followed by: for k, v in F.items(): od[k] = v. '''; if len(args) > 2:; raise TypeError('update() takes at most 2 positional '; 'arguments (%d given)' % (len(args),)); elif not args:; raise TypeError('update() takes at least 1 argument (0 given)'); self = args[0]; # Make progressively weaker assumptions about ""other""; other = (); if len(args) == 2:; other = args[1]; if isinstance(other, dict):; for key in other:; self[key] = other[key]; elif hasattr(other, 'keys'):; for key in other.keys():; self[key] = other[key]; else:; for key, value in other:; self[key] = value; for key, value in kwds.items():; self[key] = value. __update = update # let subclasses override update without breaking __init__. __marker = object(). [docs] def pop(self, key, default=__marker):; '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.; If key is not found, d is returned if given, otherwise KeyError is raised. '''; if key in self:; result = self[key]; del self[key]; return result; if default is self.__marker:; raise KeyError(key); return default. [docs] def setdefault(self, key, default=None):; 'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'; if key in self:; return self[key]; self[key] = default; return default. def __repr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:5272,Deployability,update,update,5272,":; yield (k, self[k]). [docs] def update(*args, **kwds):; '''od.update(E, **F) -> None. Update od from dict/iterable E and F. If E is a dict instance, does: for k in E: od[k] = E[k]; If E has a .keys() method, does: for k in E.keys(): od[k] = E[k]; Or if E is an iterable of items, does: for k, v in E: od[k] = v; In either case, this is followed by: for k, v in F.items(): od[k] = v. '''; if len(args) > 2:; raise TypeError('update() takes at most 2 positional '; 'arguments (%d given)' % (len(args),)); elif not args:; raise TypeError('update() takes at least 1 argument (0 given)'); self = args[0]; # Make progressively weaker assumptions about ""other""; other = (); if len(args) == 2:; other = args[1]; if isinstance(other, dict):; for key in other:; self[key] = other[key]; elif hasattr(other, 'keys'):; for key in other.keys():; self[key] = other[key]; else:; for key, value in other:; self[key] = value; for key, value in kwds.items():; self[key] = value. __update = update # let subclasses override update without breaking __init__. __marker = object(). [docs] def pop(self, key, default=__marker):; '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.; If key is not found, d is returned if given, otherwise KeyError is raised. '''; if key in self:; result = self[key]; del self[key]; return result; if default is self.__marker:; raise KeyError(key); return default. [docs] def setdefault(self, key, default=None):; 'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'; if key in self:; return self[key]; self[key] = default; return default. def __repr__(self, _repr_running={}):; 'od.__repr__() <==> repr(od)'; call_key = id(self), _get_ident(); if call_key in _repr_running:; return '...'; _repr_running[call_key] = 1; try:; if not self:; return '%s()' % (self.__class__.__name__,); return '%s(%r)' % (self.__class__.__name__, self.items()); finally:; del _repr_running[call_key]. def __reduce__(self):; 'Return state information for pickling'; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:5305,Deployability,update,update,5305,":; yield (k, self[k]). [docs] def update(*args, **kwds):; '''od.update(E, **F) -> None. Update od from dict/iterable E and F. If E is a dict instance, does: for k in E: od[k] = E[k]; If E has a .keys() method, does: for k in E.keys(): od[k] = E[k]; Or if E is an iterable of items, does: for k, v in E: od[k] = v; In either case, this is followed by: for k, v in F.items(): od[k] = v. '''; if len(args) > 2:; raise TypeError('update() takes at most 2 positional '; 'arguments (%d given)' % (len(args),)); elif not args:; raise TypeError('update() takes at least 1 argument (0 given)'); self = args[0]; # Make progressively weaker assumptions about ""other""; other = (); if len(args) == 2:; other = args[1]; if isinstance(other, dict):; for key in other:; self[key] = other[key]; elif hasattr(other, 'keys'):; for key in other.keys():; self[key] = other[key]; else:; for key, value in other:; self[key] = value; for key, value in kwds.items():; self[key] = value. __update = update # let subclasses override update without breaking __init__. __marker = object(). [docs] def pop(self, key, default=__marker):; '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.; If key is not found, d is returned if given, otherwise KeyError is raised. '''; if key in self:; result = self[key]; del self[key]; return result; if default is self.__marker:; raise KeyError(key); return default. [docs] def setdefault(self, key, default=None):; 'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'; if key in self:; return self[key]; self[key] = default; return default. def __repr__(self, _repr_running={}):; 'od.__repr__() <==> repr(od)'; call_key = id(self), _get_ident(); if call_key in _repr_running:; return '...'; _repr_running[call_key] = 1; try:; if not self:; return '%s()' % (self.__class__.__name__,); return '%s(%r)' % (self.__class__.__name__, self.items()); finally:; del _repr_running[call_key]. def __reduce__(self):; 'Return state information for pickling'; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:7814,Deployability,update,updated,7814,"ault. def __repr__(self, _repr_running={}):; 'od.__repr__() <==> repr(od)'; call_key = id(self), _get_ident(); if call_key in _repr_running:; return '...'; _repr_running[call_key] = 1; try:; if not self:; return '%s()' % (self.__class__.__name__,); return '%s(%r)' % (self.__class__.__name__, self.items()); finally:; del _repr_running[call_key]. def __reduce__(self):; 'Return state information for pickling'; items = [[k, self[k]] for k in self]; inst_dict = vars(self).copy(); for k in vars(OrderedDict()):; inst_dict.pop(k, None); if inst_dict:; return (self.__class__, (items,), inst_dict); return self.__class__, (items,). [docs] def copy(self):; 'od.copy() -> a shallow copy of od'; return self.__class__(self). @classmethod; [docs] def fromkeys(cls, iterable, value=None):; '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S; and values equal to v (which defaults to None). '''; d = cls(); for key in iterable:; d[key] = value; return d. def __eq__(self, other):; '''od.__eq__(y) <==> od==y. Comparison to another OD is order-sensitive; while comparison to a regular mapping is order-insensitive. '''; if isinstance(other, OrderedDict):; return len(self)==len(other) and self.items() == other.items(); return dict.__eq__(self, other). def __ne__(self, other):; return not self == other. # -- the following methods are only used in Python 2.7 --. [docs] def viewkeys(self):; ""od.viewkeys() -> a set-like object providing a view on od's keys""; return KeysView(self). [docs] def viewvalues(self):; ""od.viewvalues() -> an object providing a view on od's values""; return ValuesView(self). [docs] def viewitems(self):; ""od.viewitems() -> a set-like object providing a view on od's items""; return ItemsView(self). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:3644,Integrability,depend,depend,3644," is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node in self.__map.itervalues():; del node[:]; root = self.__root; root[:] = [root, root, None]; self.__map.clear(); except AttributeError:; pass; dict.clear(self). [docs] def popitem(self, last=True):; '''od.popitem() -> (k, v), return and remove a (key, value) pair.; Pairs are returned in LIFO order if last is true or FIFO order if false. '''; if not self:; raise KeyError('dictionary is empty'); root = self.__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. [docs] def items(self):; 'od.items() -> list of (key, value) pairs in od'; return [(key, self[key]) for key in self]. [docs] def iterkeys(self):; 'od.iterkeys() -> an iterator over the keys in od'; return iter(self). [docs] def itervalues(self):; 'od.itervalues -> an iterator over the values in od'; for k in self:; yield self[k]. [docs] def iteritems(self):; 'od.iteritems -> an iterator over the (key, value) items in od'; for k in self:; yield (k, self[k]). [docs] def update(*args, **kwds):; '''od.update(E, **F) -> None. Update od from dict/iterable E and F. If E is a dict instance, does: for k in E: od[k] = E[k]; If E has a .keys() method, does: for k in E.keys(): od[k] = E[k]; Or if E is an iterable of items, does: for k, v in E: od[k] = v; In either case, this is followed",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:767,Modifiability,inherit,inherited,767,". qcdb.oldpymodules  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.oldpymodules; # Obtained from http://code.activestate.com/recipes/576693/ on 15 Nov 2014. # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.; # Passes Python2.7's test suite and incorporates all the latest updates. from __future__ import absolute_import; from __future__ import print_function; try:; from thread import get_ident as _get_ident; except ImportError:; from dummy_thread import get_ident as _get_ident. try:; from _abcoll import KeysView, ValuesView, ItemsView; except ImportError:; pass. [docs]class OrderedDict(dict):; 'Dictionary that remembers insertion order'; # An inherited dict maps keys to values.; # The inherited dict provides __getitem__, __len__, __contains__, and get.; # The remaining methods are order-aware.; # Big-O running times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated wi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:810,Modifiability,inherit,inherited,810,". qcdb.oldpymodules  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.oldpymodules; # Obtained from http://code.activestate.com/recipes/576693/ on 15 Nov 2014. # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.; # Passes Python2.7's test suite and incorporates all the latest updates. from __future__ import absolute_import; from __future__ import print_function; try:; from thread import get_ident as _get_ident; except ImportError:; from dummy_thread import get_ident as _get_ident. try:; from _abcoll import KeysView, ValuesView, ItemsView; except ImportError:; pass. [docs]class OrderedDict(dict):; 'Dictionary that remembers insertion order'; # An inherited dict maps keys to values.; # The inherited dict provides __getitem__, __len__, __contains__, and get.; # The remaining methods are order-aware.; # Big-O running times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated wi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:1967,Modifiability,inherit,inherited,1967,"ing times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated with the new key/value pair.; if key not in self:; root = self.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:347,Testability,test,test,347,". qcdb.oldpymodules  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.oldpymodules; # Obtained from http://code.activestate.com/recipes/576693/ on 15 Nov 2014. # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.; # Passes Python2.7's test suite and incorporates all the latest updates. from __future__ import absolute_import; from __future__ import print_function; try:; from thread import get_ident as _get_ident; except ImportError:; from dummy_thread import get_ident as _get_ident. try:; from _abcoll import KeysView, ValuesView, ItemsView; except ImportError:; pass. [docs]class OrderedDict(dict):; 'Dictionary that remembers insertion order'; # An inherited dict maps keys to values.; # The inherited dict provides __getitem__, __len__, __contains__, and get.; # The remaining methods are order-aware.; # Big-O running times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated wi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:1208,Usability,simpl,simplifies,1208,"tivestate.com/recipes/576693/ on 15 Nov 2014. # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.; # Passes Python2.7's test suite and incorporates all the latest updates. from __future__ import absolute_import; from __future__ import print_function; try:; from thread import get_ident as _get_ident; except ImportError:; from dummy_thread import get_ident as _get_ident. try:; from _abcoll import KeysView, ValuesView, ItemsView; except ImportError:; pass. [docs]class OrderedDict(dict):; 'Dictionary that remembers insertion order'; # An inherited dict maps keys to values.; # The inherited dict provides __getitem__, __len__, __contains__, and get.; # The remaining methods are order-aware.; # Big-O running times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated with the new key/value pair.; if key not in self:; root = self.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:2857,Usability,clear,clear,2857,"==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated with the new key/value pair.; if key not in self:; root = self.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node in self.__map.itervalues():; del node[:]; root = self.__root; root[:] = [root, root, None]; self.__map.clear(); except AttributeError:; pass; dict.clear(self). [docs] def popitem(self, last=True):; '''od.popitem() -> (k, v), return and remove a (key, value) pair.; Pairs are returned in LIFO order if last is true or FIFO order if false. '''; if not self:; raise KeyError('dictionary is empty'); root = self.__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:2875,Usability,clear,clear,2875," a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated with the new key/value pair.; if key not in self:; root = self.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node in self.__map.itervalues():; del node[:]; root = self.__root; root[:] = [root, root, None]; self.__map.clear(); except AttributeError:; pass; dict.clear(self). [docs] def popitem(self, last=True):; '''od.popitem() -> (k, v), return and remove a (key, value) pair.; Pairs are returned in LIFO order if last is true or FIFO order if false. '''; if not self:; raise KeyError('dictionary is empty'); root = self.__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. [docs] def items(self):",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:3038,Usability,clear,clear,3038,"f.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node in self.__map.itervalues():; del node[:]; root = self.__root; root[:] = [root, root, None]; self.__map.clear(); except AttributeError:; pass; dict.clear(self). [docs] def popitem(self, last=True):; '''od.popitem() -> (k, v), return and remove a (key, value) pair.; Pairs are returned in LIFO order if last is true or FIFO order if false. '''; if not self:; raise KeyError('dictionary is empty'); root = self.__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. [docs] def items(self):; 'od.items() -> list of (key, value) pairs in od'; return [(key, self[key]) for key in self]. [docs] def iterkeys(self):; 'od.iterkeys() -> an iterator over the keys in od'; re",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:3082,Usability,clear,clear,3082,"st[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node in self.__map.itervalues():; del node[:]; root = self.__root; root[:] = [root, root, None]; self.__map.clear(); except AttributeError:; pass; dict.clear(self). [docs] def popitem(self, last=True):; '''od.popitem() -> (k, v), return and remove a (key, value) pair.; Pairs are returned in LIFO order if last is true or FIFO order if false. '''; if not self:; raise KeyError('dictionary is empty'); root = self.__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. [docs] def items(self):; 'od.items() -> list of (key, value) pairs in od'; return [(key, self[key]) for key in self]. [docs] def iterkeys(self):; 'od.iterkeys() -> an iterator over the keys in od'; return iter(self). [docs] def ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html:8834,Deployability,update,updated,8834,"y and lacking in has_changed keys; so presence is enough to satisfy has_changed. consider merging; once mature. """"""; try:; for module, modopts in partial.items():; for kw, kwprop in modopts.items():; #if full[module][kw]['has_changed']:; if full[module][kw]:; if full[module][kw]['value'] != kwprop['value']:; if 'clobber' in kwprop and kwprop['clobber']:; if 'superclobber' in kwprop and kwprop['superclobber']:; # kw in full is touched, conflicts with value in partial,; # but value in partial is paramount, overwrite full with; # value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']); else:; raise ValidationError(""""""; Option %s value `%s` set by options block incompatible with; value `%s` in memory/molecule/command/psi4options block."""""" %; (kw, full[module][kw]['value'], kwprop['value'])); else:; # kw in full is touched, conflicts with value in partial,; # but value in partial is recommended, not required, no change; pass; else:; # kw in full is touched, but in agreement with value in partial, no change; pass; else:; # If kw in full is absent, overwrite it with value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']). except KeyError as e: # not expected but want to trap; raise ValidationError(""""""Unexpected KeyError reconciling keywords: %s."""""" % (repr(e))). return full. [docs]def conv_float2negexp(val):; """"""Returns the least restrictive negative exponent of the power 10; that would achieve the floating point convergence criterium *val*. """"""; return -1 * int(math.floor(math.log(val, 10))). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html:8508,Energy Efficiency,power,power,8508,"y and lacking in has_changed keys; so presence is enough to satisfy has_changed. consider merging; once mature. """"""; try:; for module, modopts in partial.items():; for kw, kwprop in modopts.items():; #if full[module][kw]['has_changed']:; if full[module][kw]:; if full[module][kw]['value'] != kwprop['value']:; if 'clobber' in kwprop and kwprop['clobber']:; if 'superclobber' in kwprop and kwprop['superclobber']:; # kw in full is touched, conflicts with value in partial,; # but value in partial is paramount, overwrite full with; # value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']); else:; raise ValidationError(""""""; Option %s value `%s` set by options block incompatible with; value `%s` in memory/molecule/command/psi4options block."""""" %; (kw, full[module][kw]['value'], kwprop['value'])); else:; # kw in full is touched, conflicts with value in partial,; # but value in partial is recommended, not required, no change; pass; else:; # kw in full is touched, but in agreement with value in partial, no change; pass; else:; # If kw in full is absent, overwrite it with value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']). except KeyError as e: # not expected but want to trap; raise ValidationError(""""""Unexpected KeyError reconciling keywords: %s."""""" % (repr(e))). return full. [docs]def conv_float2negexp(val):; """"""Returns the least restrictive negative exponent of the power 10; that would achieve the floating point convergence criterium *val*. """"""; return -1 * int(math.floor(math.log(val, 10))). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html:8622,Testability,log,log,8622,"y and lacking in has_changed keys; so presence is enough to satisfy has_changed. consider merging; once mature. """"""; try:; for module, modopts in partial.items():; for kw, kwprop in modopts.items():; #if full[module][kw]['has_changed']:; if full[module][kw]:; if full[module][kw]['value'] != kwprop['value']:; if 'clobber' in kwprop and kwprop['clobber']:; if 'superclobber' in kwprop and kwprop['superclobber']:; # kw in full is touched, conflicts with value in partial,; # but value in partial is paramount, overwrite full with; # value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']); else:; raise ValidationError(""""""; Option %s value `%s` set by options block incompatible with; value `%s` in memory/molecule/command/psi4options block."""""" %; (kw, full[module][kw]['value'], kwprop['value'])); else:; # kw in full is touched, conflicts with value in partial,; # but value in partial is recommended, not required, no change; pass; else:; # kw in full is touched, but in agreement with value in partial, no change; pass; else:; # If kw in full is absent, overwrite it with value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']). except KeyError as e: # not expected but want to trap; raise ValidationError(""""""Unexpected KeyError reconciling keywords: %s."""""" % (repr(e))). return full. [docs]def conv_float2negexp(val):; """"""Returns the least restrictive negative exponent of the power 10; that would achieve the floating point convergence criterium *val*. """"""; return -1 * int(math.floor(math.log(val, 10))). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:2194,Availability,avail,available,2194," c-side keywords; options = defaultdict(lambda: defaultdict(dict)); options['ORCA']['ORCA_MAXCORE']['value'] = int(mem); text = ""%MaxCore {}\n"".format(options['ORCA']['ORCA_MAXCORE']['value']). for item in options['ORCA']:; options['ORCA'][item]['clobber'] = True. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for orca. While deliberately requested pieces,; generally orca__orca_deriv_level and orca__orca_calc_level,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, can be countermanded by keywords in input file; ('clobber' set to False). Occasionally, we want these pieces to actually; overcome keywords in input file ('superclobber' set to True).; """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; options['ORCA']['ORCA_RUNTYP']['value'] = 'ENERGY'; elif dertype == 1:; options['ORCA']['ORCA_RUNTYP']['value'] = 'ENGRAD'; else:; raise ValidationError(""Requested Orca dertype {} is not available.""; .format(dertype)). if lowername == 'orca':; pass; elif lowername == 'orca-b3lyp':; options['ORCA']['ORCA_FUNCTIONAL']['value'] = 'B3LYP_G'; elif lowername == 'orca-mp2':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'MP2'; elif lowername == 'orca-ccsd':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD'; elif lowername == 'orca-ccsd(t)':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD(T)'; else:; raise ValidationError(""Requested Orca computational methods {} is not ""; ""available."" .format(lowername)). # Set clobbering; if 'ORCA_RUNTYP' in options['ORCA']:; options['ORCA']['ORCA_RUNTYP']['clobber'] = True; options['ORCA']['ORCA_RUNTYP']['superclobber'] = True; if 'ORCA_FUNCTIONAL' in options['ORCA']:; options['ORCA']['ORCA_FUNCTIONAL']['clobber'] = True; options['ORCA']['ORCA_FUNCTIONAL']['superclobber'] = True. return text, options. [docs]def orca_list():; """"""Return a",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:2690,Availability,avail,available,2690,"me* and derivative level *dertype*; into options for orca. While deliberately requested pieces,; generally orca__orca_deriv_level and orca__orca_calc_level,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, can be countermanded by keywords in input file; ('clobber' set to False). Occasionally, we want these pieces to actually; overcome keywords in input file ('superclobber' set to True).; """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; options['ORCA']['ORCA_RUNTYP']['value'] = 'ENERGY'; elif dertype == 1:; options['ORCA']['ORCA_RUNTYP']['value'] = 'ENGRAD'; else:; raise ValidationError(""Requested Orca dertype {} is not available.""; .format(dertype)). if lowername == 'orca':; pass; elif lowername == 'orca-b3lyp':; options['ORCA']['ORCA_FUNCTIONAL']['value'] = 'B3LYP_G'; elif lowername == 'orca-mp2':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'MP2'; elif lowername == 'orca-ccsd':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD'; elif lowername == 'orca-ccsd(t)':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD(T)'; else:; raise ValidationError(""Requested Orca computational methods {} is not ""; ""available."" .format(lowername)). # Set clobbering; if 'ORCA_RUNTYP' in options['ORCA']:; options['ORCA']['ORCA_RUNTYP']['clobber'] = True; options['ORCA']['ORCA_RUNTYP']['superclobber'] = True; if 'ORCA_FUNCTIONAL' in options['ORCA']:; options['ORCA']['ORCA_FUNCTIONAL']['clobber'] = True; options['ORCA']['ORCA_FUNCTIONAL']['superclobber'] = True. return text, options. [docs]def orca_list():; """"""Return an array of Orca methods with energies. Appended; to procedures['energy']. """"""; val = []; val.append('orca'); val.append('orca-b3lyp'); return val. [docs]def orca_gradient_list():; """"""Return an array of Orca methods with analytical gradients.; Appended to procedures['gradient']. """"""; val = []; val.append('oc-b3lyp'); return val. [docs]def harvest_molecule_from_outfi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:6149,Availability,down,down,6149,"lit()[3]); psivar['NUCLEAR REPULSION ENERGY'] = float(lines[scf_start + 6].split()[3]). [docs]def harvest_dipole(lines, psivar):; """"""Harvest the dipole, and return as a tuple (x, y, z); Multiple different dipole moments can be output if post-HF calculations are; run and their dipoles are requested resulting in highly similar blocks.; It by default collects the last which appears to always be the one requested. TODO: collect all the different types of dipole moments; """"""; """"""Sample dipole moment results block""""""; #-------------; #DIPOLE MOMENT; #-------------; # X Y Z; #Electronic contribution: -0.11359 -0.14669 -0.00000; #Nuclear contribution : 0.61892 0.79867 0.00000; # -----------------------------------------; #Total Dipole Moment : 0.50533 0.65198 -0.00000; # -----------------------------------------; #Magnitude (a.u.) : 0.82489; #Magnitude (Debye) : 2.09670; #; #. dipole_start = find_start(lines, 'DIPOLE MOMENT'). if dipole_start != -1:; # Dipole x, y, z are the last items 6 lines down in the dipole block; dipole_str_list = lines[dipole_start + 6].split()[-3:]; # Convert the dipole to debye; dipole = [float(i)*psi_dipmom_au2debye for i in dipole_str_list]; psivar['CURRENT DIPOLE X'] = dipole[0]; psivar['CURRENT DIPOLE Y'] = dipole[1]; psivar['CURRENT DIPOLE Z'] = dipole[2]. # Dipole magnitude is 8 line down in the dipole block; magnitude = float(lines[dipole_start + 8][-1]). [docs]def harvest_mp2(lines, psivar):; """"""Harvest the MP2 results""""""; """"""Sample MP2 energy line (works for both MP2 and RI-MP2)""""""; #---------------------------------------; #MP2 TOTAL ENERGY: -76.226803665 Eh; #---------------------------------------. """"""Sample MP2 correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # MP2 CORRELATION ENERGY : -0.125436532 Eh; #-----------------------------------------------. """"""Sample RI-MP2 Correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # RI-MP2 CORRELATI",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:6477,Availability,down,down,6477,"collects the last which appears to always be the one requested. TODO: collect all the different types of dipole moments; """"""; """"""Sample dipole moment results block""""""; #-------------; #DIPOLE MOMENT; #-------------; # X Y Z; #Electronic contribution: -0.11359 -0.14669 -0.00000; #Nuclear contribution : 0.61892 0.79867 0.00000; # -----------------------------------------; #Total Dipole Moment : 0.50533 0.65198 -0.00000; # -----------------------------------------; #Magnitude (a.u.) : 0.82489; #Magnitude (Debye) : 2.09670; #; #. dipole_start = find_start(lines, 'DIPOLE MOMENT'). if dipole_start != -1:; # Dipole x, y, z are the last items 6 lines down in the dipole block; dipole_str_list = lines[dipole_start + 6].split()[-3:]; # Convert the dipole to debye; dipole = [float(i)*psi_dipmom_au2debye for i in dipole_str_list]; psivar['CURRENT DIPOLE X'] = dipole[0]; psivar['CURRENT DIPOLE Y'] = dipole[1]; psivar['CURRENT DIPOLE Z'] = dipole[2]. # Dipole magnitude is 8 line down in the dipole block; magnitude = float(lines[dipole_start + 8][-1]). [docs]def harvest_mp2(lines, psivar):; """"""Harvest the MP2 results""""""; """"""Sample MP2 energy line (works for both MP2 and RI-MP2)""""""; #---------------------------------------; #MP2 TOTAL ENERGY: -76.226803665 Eh; #---------------------------------------. """"""Sample MP2 correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # MP2 CORRELATION ENERGY : -0.125436532 Eh; #-----------------------------------------------. """"""Sample RI-MP2 Correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # RI-MP2 CORRELATION ENERGY: -0.125496692 Eh; #-----------------------------------------------. for line in reversed(lines):; if line[:16] == 'MP2 TOTAL ENERGY':; psivar['MP2 TOTAL ENERGY'] = line.split()[-2]; break; for line in reversed(lines):; if line[:23] == ' MP2 CORRELATION ENERGY' or\; line[:26] == ' RI-MP2 CORRELATION ENERGY':; psivar['MP2 CORRELATION ENERGY",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:10381,Deployability,update,updated,10381,"Final correlation energy ... -0.134770265; #E(CCSD) ... -75.709548429; #E(CCSD(T)) ... -75.711092810; #. cc_start = find_start(lines, 'COUPLED CLUSTER ENERGY'); if cc_start == -1:; return. #psivar[""CC REFERENCE""] = float(lines[cc_start + 3].split()[-1]). # CCSD energy block is less than 20 lines; for i, line in enumerate(lines[cc_start:cc_start + 20], start=cc_start):; if line[:6] == ""E(TOT)"":; psivar[""CCSD TOTAL ENERGY""] = line.split()[-1]; psivar[""CCSD CORRELATION ENERGY""] = lines[i-1].split()[-1]; #psivar[""SINGLES NORM""] = lines[i+1].split()[-1]; #psivar[""T1 DIAGNOSTIC""] = lines[i+2].split()[-1]; break. # CCSD(T) energy block; for i, line in enumerate(lines[cc_start:], start=cc_start):; if line[:22] == ""Triples Correction (T)"":; #psivar[""TRIPLES CORRELATION ENERGY""] = line.split()[-1]; psivar[""CCSD(T) CORRELATION ENERGY""] = lines[i+1].split()[-1]; psivar[""CCSD TOTAL ENERGY""] = lines[i+2].split()[-1]; psivar[""CCSD(T) TOTAL ENERGY""] = lines[i+3].split()[-1]; break. [docs]def harvest_engrad(engrad):; """"""Parse the engrad file for the gradient""""""; try:; lines = open(engrad).readlines(); except IOError:; return []; num_atoms = int(lines[3].strip()); energy = lines[7].strip(); grad = []; for i in range(12, 13 + num_atoms*3, 3):; grad.append(list(map(float, lines[i:i + 3]))); return grad. [docs]def find_start(lines, start_str, reverse=True):; """"""Find the start of a block, iterate backwards by default,; Usually the last one is wanted; If not found, return -1; """"""; start = -1; # Iterate backwards until the last value is found; if reverse:; for i, line in reversed(list(enumerate(lines))):; if start_str == line:; return i; else:; for i, line in enumerate(lines):; if start_str == line:; return i; return start. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:3160,Energy Efficiency,energy,energy,3160,"ionError(""Requested Orca dertype {} is not available.""; .format(dertype)). if lowername == 'orca':; pass; elif lowername == 'orca-b3lyp':; options['ORCA']['ORCA_FUNCTIONAL']['value'] = 'B3LYP_G'; elif lowername == 'orca-mp2':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'MP2'; elif lowername == 'orca-ccsd':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD'; elif lowername == 'orca-ccsd(t)':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD(T)'; else:; raise ValidationError(""Requested Orca computational methods {} is not ""; ""available."" .format(lowername)). # Set clobbering; if 'ORCA_RUNTYP' in options['ORCA']:; options['ORCA']['ORCA_RUNTYP']['clobber'] = True; options['ORCA']['ORCA_RUNTYP']['superclobber'] = True; if 'ORCA_FUNCTIONAL' in options['ORCA']:; options['ORCA']['ORCA_FUNCTIONAL']['clobber'] = True; options['ORCA']['ORCA_FUNCTIONAL']['superclobber'] = True. return text, options. [docs]def orca_list():; """"""Return an array of Orca methods with energies. Appended; to procedures['energy']. """"""; val = []; val.append('orca'); val.append('orca-b3lyp'); return val. [docs]def orca_gradient_list():; """"""Return an array of Orca methods with analytical gradients.; Appended to procedures['gradient']. """"""; val = []; val.append('oc-b3lyp'); return val. [docs]def harvest_molecule_from_outfile(lines):; """"""Return a molecule of the last geometry""""""; """"""Sample molecule block""""""; #----------------------------; #CARTESIAN COORDINATES (A.U.); #----------------------------; # NO LB ZA FRAG MASS X Y Z; # 0 O 8.0000 0 15.999 -0.043407801307192 -0.055556028344352 0.000000000000000; # 1 H 1.0000 0 1.008 1.780497256508764 -0.017018089151928 0.000000000000000; # 2 H 1.0000 0 1.008 -0.462170608038134 1.719154625261312 0.000000000000000; #. geom_start = find_start(lines, 'CARTESIAN COORDINATES (A.U.)'); if geom_start == -1:; return Molecule(). # Geometry starts 3 lines after header and ends with a blank line; geom_start += 3; end = ''; mol_str = ''; for i, line in enumerate(lines[g",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:6635,Energy Efficiency,energy,energy,6635,"esults block""""""; #-------------; #DIPOLE MOMENT; #-------------; # X Y Z; #Electronic contribution: -0.11359 -0.14669 -0.00000; #Nuclear contribution : 0.61892 0.79867 0.00000; # -----------------------------------------; #Total Dipole Moment : 0.50533 0.65198 -0.00000; # -----------------------------------------; #Magnitude (a.u.) : 0.82489; #Magnitude (Debye) : 2.09670; #; #. dipole_start = find_start(lines, 'DIPOLE MOMENT'). if dipole_start != -1:; # Dipole x, y, z are the last items 6 lines down in the dipole block; dipole_str_list = lines[dipole_start + 6].split()[-3:]; # Convert the dipole to debye; dipole = [float(i)*psi_dipmom_au2debye for i in dipole_str_list]; psivar['CURRENT DIPOLE X'] = dipole[0]; psivar['CURRENT DIPOLE Y'] = dipole[1]; psivar['CURRENT DIPOLE Z'] = dipole[2]. # Dipole magnitude is 8 line down in the dipole block; magnitude = float(lines[dipole_start + 8][-1]). [docs]def harvest_mp2(lines, psivar):; """"""Harvest the MP2 results""""""; """"""Sample MP2 energy line (works for both MP2 and RI-MP2)""""""; #---------------------------------------; #MP2 TOTAL ENERGY: -76.226803665 Eh; #---------------------------------------. """"""Sample MP2 correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # MP2 CORRELATION ENERGY : -0.125436532 Eh; #-----------------------------------------------. """"""Sample RI-MP2 Correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # RI-MP2 CORRELATION ENERGY: -0.125496692 Eh; #-----------------------------------------------. for line in reversed(lines):; if line[:16] == 'MP2 TOTAL ENERGY':; psivar['MP2 TOTAL ENERGY'] = line.split()[-2]; break; for line in reversed(lines):; if line[:23] == ' MP2 CORRELATION ENERGY' or\; line[:26] == ' RI-MP2 CORRELATION ENERGY':; psivar['MP2 CORRELATION ENERGY'] = line.split()[-2]; break. [docs]def harvest_coupled_cluster(lines, psivar):; """"""Harvest coupled cluster results; WARNING: Canonical and DLPNO prin",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:6830,Energy Efficiency,energy,energy,6830,"l Dipole Moment : 0.50533 0.65198 -0.00000; # -----------------------------------------; #Magnitude (a.u.) : 0.82489; #Magnitude (Debye) : 2.09670; #; #. dipole_start = find_start(lines, 'DIPOLE MOMENT'). if dipole_start != -1:; # Dipole x, y, z are the last items 6 lines down in the dipole block; dipole_str_list = lines[dipole_start + 6].split()[-3:]; # Convert the dipole to debye; dipole = [float(i)*psi_dipmom_au2debye for i in dipole_str_list]; psivar['CURRENT DIPOLE X'] = dipole[0]; psivar['CURRENT DIPOLE Y'] = dipole[1]; psivar['CURRENT DIPOLE Z'] = dipole[2]. # Dipole magnitude is 8 line down in the dipole block; magnitude = float(lines[dipole_start + 8][-1]). [docs]def harvest_mp2(lines, psivar):; """"""Harvest the MP2 results""""""; """"""Sample MP2 energy line (works for both MP2 and RI-MP2)""""""; #---------------------------------------; #MP2 TOTAL ENERGY: -76.226803665 Eh; #---------------------------------------. """"""Sample MP2 correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # MP2 CORRELATION ENERGY : -0.125436532 Eh; #-----------------------------------------------. """"""Sample RI-MP2 Correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # RI-MP2 CORRELATION ENERGY: -0.125496692 Eh; #-----------------------------------------------. for line in reversed(lines):; if line[:16] == 'MP2 TOTAL ENERGY':; psivar['MP2 TOTAL ENERGY'] = line.split()[-2]; break; for line in reversed(lines):; if line[:23] == ' MP2 CORRELATION ENERGY' or\; line[:26] == ' RI-MP2 CORRELATION ENERGY':; psivar['MP2 CORRELATION ENERGY'] = line.split()[-2]; break. [docs]def harvest_coupled_cluster(lines, psivar):; """"""Harvest coupled cluster results; WARNING: Canonical and DLPNO print the coupled cluster results differently; """"""; """"""Sample (canonical) CCSD results block""""""; #----------------------; #COUPLED CLUSTER ENERGY; #----------------------; #; #E(0) ... -76.063720080; #E(CORR) ... -0.288938791; #E(T",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:7042,Energy Efficiency,energy,energy,7042,"ole_start != -1:; # Dipole x, y, z are the last items 6 lines down in the dipole block; dipole_str_list = lines[dipole_start + 6].split()[-3:]; # Convert the dipole to debye; dipole = [float(i)*psi_dipmom_au2debye for i in dipole_str_list]; psivar['CURRENT DIPOLE X'] = dipole[0]; psivar['CURRENT DIPOLE Y'] = dipole[1]; psivar['CURRENT DIPOLE Z'] = dipole[2]. # Dipole magnitude is 8 line down in the dipole block; magnitude = float(lines[dipole_start + 8][-1]). [docs]def harvest_mp2(lines, psivar):; """"""Harvest the MP2 results""""""; """"""Sample MP2 energy line (works for both MP2 and RI-MP2)""""""; #---------------------------------------; #MP2 TOTAL ENERGY: -76.226803665 Eh; #---------------------------------------. """"""Sample MP2 correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # MP2 CORRELATION ENERGY : -0.125436532 Eh; #-----------------------------------------------. """"""Sample RI-MP2 Correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # RI-MP2 CORRELATION ENERGY: -0.125496692 Eh; #-----------------------------------------------. for line in reversed(lines):; if line[:16] == 'MP2 TOTAL ENERGY':; psivar['MP2 TOTAL ENERGY'] = line.split()[-2]; break; for line in reversed(lines):; if line[:23] == ' MP2 CORRELATION ENERGY' or\; line[:26] == ' RI-MP2 CORRELATION ENERGY':; psivar['MP2 CORRELATION ENERGY'] = line.split()[-2]; break. [docs]def harvest_coupled_cluster(lines, psivar):; """"""Harvest coupled cluster results; WARNING: Canonical and DLPNO print the coupled cluster results differently; """"""; """"""Sample (canonical) CCSD results block""""""; #----------------------; #COUPLED CLUSTER ENERGY; #----------------------; #; #E(0) ... -76.063720080; #E(CORR) ... -0.288938791; #E(TOT) ... -76.352658871; #Singles Norm <S|S>**1/2 ... 0.021106262; #T1 diagnostic ... 0.007462191; #. """"""Sample DLPNO coupled cluster block (CCSD)""""""; #----------------------; #COUPLED CLUSTER ENERGY; #------------",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:8473,Energy Efficiency,energy,energy,8473,"RGY':; psivar['MP2 CORRELATION ENERGY'] = line.split()[-2]; break. [docs]def harvest_coupled_cluster(lines, psivar):; """"""Harvest coupled cluster results; WARNING: Canonical and DLPNO print the coupled cluster results differently; """"""; """"""Sample (canonical) CCSD results block""""""; #----------------------; #COUPLED CLUSTER ENERGY; #----------------------; #; #E(0) ... -76.063720080; #E(CORR) ... -0.288938791; #E(TOT) ... -76.352658871; #Singles Norm <S|S>**1/2 ... 0.021106262; #T1 diagnostic ... 0.007462191; #. """"""Sample DLPNO coupled cluster block (CCSD)""""""; #----------------------; #COUPLED CLUSTER ENERGY; #----------------------; #; #E(0) ... -76.026019996; #E(CORR)(strong-pairs) ... -0.211953159; #E(CORR)(weak-pairs) ... -0.000007244; #E(CORR)(corrected) ... -0.211960403; #E(TOT) ... -76.237980399; #Singles Norm <S|S>**1/2 ... 0.014443573; #T1 diagnostic ... 0.005106574; #. """"""Sample CCSD(T) block (same for DLPNO and canonical)""""""; #; #Triples Correction (T) ... -0.001544381; #Final correlation energy ... -0.134770265; #E(CCSD) ... -75.709548429; #E(CCSD(T)) ... -75.711092810; #. cc_start = find_start(lines, 'COUPLED CLUSTER ENERGY'); if cc_start == -1:; return. #psivar[""CC REFERENCE""] = float(lines[cc_start + 3].split()[-1]). # CCSD energy block is less than 20 lines; for i, line in enumerate(lines[cc_start:cc_start + 20], start=cc_start):; if line[:6] == ""E(TOT)"":; psivar[""CCSD TOTAL ENERGY""] = line.split()[-1]; psivar[""CCSD CORRELATION ENERGY""] = lines[i-1].split()[-1]; #psivar[""SINGLES NORM""] = lines[i+1].split()[-1]; #psivar[""T1 DIAGNOSTIC""] = lines[i+2].split()[-1]; break. # CCSD(T) energy block; for i, line in enumerate(lines[cc_start:], start=cc_start):; if line[:22] == ""Triples Correction (T)"":; #psivar[""TRIPLES CORRELATION ENERGY""] = line.split()[-1]; psivar[""CCSD(T) CORRELATION ENERGY""] = lines[i+1].split()[-1]; psivar[""CCSD TOTAL ENERGY""] = lines[i+2].split()[-1]; psivar[""CCSD(T) TOTAL ENERGY""] = lines[i+3].split()[-1]; break. [docs]def harvest_engrad(e",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:8717,Energy Efficiency,energy,energy,8717,"-----------------; #; #E(0) ... -76.063720080; #E(CORR) ... -0.288938791; #E(TOT) ... -76.352658871; #Singles Norm <S|S>**1/2 ... 0.021106262; #T1 diagnostic ... 0.007462191; #. """"""Sample DLPNO coupled cluster block (CCSD)""""""; #----------------------; #COUPLED CLUSTER ENERGY; #----------------------; #; #E(0) ... -76.026019996; #E(CORR)(strong-pairs) ... -0.211953159; #E(CORR)(weak-pairs) ... -0.000007244; #E(CORR)(corrected) ... -0.211960403; #E(TOT) ... -76.237980399; #Singles Norm <S|S>**1/2 ... 0.014443573; #T1 diagnostic ... 0.005106574; #. """"""Sample CCSD(T) block (same for DLPNO and canonical)""""""; #; #Triples Correction (T) ... -0.001544381; #Final correlation energy ... -0.134770265; #E(CCSD) ... -75.709548429; #E(CCSD(T)) ... -75.711092810; #. cc_start = find_start(lines, 'COUPLED CLUSTER ENERGY'); if cc_start == -1:; return. #psivar[""CC REFERENCE""] = float(lines[cc_start + 3].split()[-1]). # CCSD energy block is less than 20 lines; for i, line in enumerate(lines[cc_start:cc_start + 20], start=cc_start):; if line[:6] == ""E(TOT)"":; psivar[""CCSD TOTAL ENERGY""] = line.split()[-1]; psivar[""CCSD CORRELATION ENERGY""] = lines[i-1].split()[-1]; #psivar[""SINGLES NORM""] = lines[i+1].split()[-1]; #psivar[""T1 DIAGNOSTIC""] = lines[i+2].split()[-1]; break. # CCSD(T) energy block; for i, line in enumerate(lines[cc_start:], start=cc_start):; if line[:22] == ""Triples Correction (T)"":; #psivar[""TRIPLES CORRELATION ENERGY""] = line.split()[-1]; psivar[""CCSD(T) CORRELATION ENERGY""] = lines[i+1].split()[-1]; psivar[""CCSD TOTAL ENERGY""] = lines[i+2].split()[-1]; psivar[""CCSD(T) TOTAL ENERGY""] = lines[i+3].split()[-1]; break. [docs]def harvest_engrad(engrad):; """"""Parse the engrad file for the gradient""""""; try:; lines = open(engrad).readlines(); except IOError:; return []; num_atoms = int(lines[3].strip()); energy = lines[7].strip(); grad = []; for i in range(12, 13 + num_atoms*3, 3):; grad.append(list(map(float, lines[i:i + 3]))); return grad. [docs]def find_start(lines, start_str, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:9079,Energy Efficiency,energy,energy,9079,"-0.211953159; #E(CORR)(weak-pairs) ... -0.000007244; #E(CORR)(corrected) ... -0.211960403; #E(TOT) ... -76.237980399; #Singles Norm <S|S>**1/2 ... 0.014443573; #T1 diagnostic ... 0.005106574; #. """"""Sample CCSD(T) block (same for DLPNO and canonical)""""""; #; #Triples Correction (T) ... -0.001544381; #Final correlation energy ... -0.134770265; #E(CCSD) ... -75.709548429; #E(CCSD(T)) ... -75.711092810; #. cc_start = find_start(lines, 'COUPLED CLUSTER ENERGY'); if cc_start == -1:; return. #psivar[""CC REFERENCE""] = float(lines[cc_start + 3].split()[-1]). # CCSD energy block is less than 20 lines; for i, line in enumerate(lines[cc_start:cc_start + 20], start=cc_start):; if line[:6] == ""E(TOT)"":; psivar[""CCSD TOTAL ENERGY""] = line.split()[-1]; psivar[""CCSD CORRELATION ENERGY""] = lines[i-1].split()[-1]; #psivar[""SINGLES NORM""] = lines[i+1].split()[-1]; #psivar[""T1 DIAGNOSTIC""] = lines[i+2].split()[-1]; break. # CCSD(T) energy block; for i, line in enumerate(lines[cc_start:], start=cc_start):; if line[:22] == ""Triples Correction (T)"":; #psivar[""TRIPLES CORRELATION ENERGY""] = line.split()[-1]; psivar[""CCSD(T) CORRELATION ENERGY""] = lines[i+1].split()[-1]; psivar[""CCSD TOTAL ENERGY""] = lines[i+2].split()[-1]; psivar[""CCSD(T) TOTAL ENERGY""] = lines[i+3].split()[-1]; break. [docs]def harvest_engrad(engrad):; """"""Parse the engrad file for the gradient""""""; try:; lines = open(engrad).readlines(); except IOError:; return []; num_atoms = int(lines[3].strip()); energy = lines[7].strip(); grad = []; for i in range(12, 13 + num_atoms*3, 3):; grad.append(list(map(float, lines[i:i + 3]))); return grad. [docs]def find_start(lines, start_str, reverse=True):; """"""Find the start of a block, iterate backwards by default,; Usually the last one is wanted; If not found, return -1; """"""; start = -1; # Iterate backwards until the last value is found; if reverse:; for i, line in reversed(list(enumerate(lines))):; if start_str == line:; return i; else:; for i, line in enumerate(lines):; if start_str == l",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:9620,Energy Efficiency,energy,energy,9620,"Final correlation energy ... -0.134770265; #E(CCSD) ... -75.709548429; #E(CCSD(T)) ... -75.711092810; #. cc_start = find_start(lines, 'COUPLED CLUSTER ENERGY'); if cc_start == -1:; return. #psivar[""CC REFERENCE""] = float(lines[cc_start + 3].split()[-1]). # CCSD energy block is less than 20 lines; for i, line in enumerate(lines[cc_start:cc_start + 20], start=cc_start):; if line[:6] == ""E(TOT)"":; psivar[""CCSD TOTAL ENERGY""] = line.split()[-1]; psivar[""CCSD CORRELATION ENERGY""] = lines[i-1].split()[-1]; #psivar[""SINGLES NORM""] = lines[i+1].split()[-1]; #psivar[""T1 DIAGNOSTIC""] = lines[i+2].split()[-1]; break. # CCSD(T) energy block; for i, line in enumerate(lines[cc_start:], start=cc_start):; if line[:22] == ""Triples Correction (T)"":; #psivar[""TRIPLES CORRELATION ENERGY""] = line.split()[-1]; psivar[""CCSD(T) CORRELATION ENERGY""] = lines[i+1].split()[-1]; psivar[""CCSD TOTAL ENERGY""] = lines[i+2].split()[-1]; psivar[""CCSD(T) TOTAL ENERGY""] = lines[i+3].split()[-1]; break. [docs]def harvest_engrad(engrad):; """"""Parse the engrad file for the gradient""""""; try:; lines = open(engrad).readlines(); except IOError:; return []; num_atoms = int(lines[3].strip()); energy = lines[7].strip(); grad = []; for i in range(12, 13 + num_atoms*3, 3):; grad.append(list(map(float, lines[i:i + 3]))); return grad. [docs]def find_start(lines, start_str, reverse=True):; """"""Find the start of a block, iterate backwards by default,; Usually the last one is wanted; If not found, return -1; """"""; start = -1; # Iterate backwards until the last value is found; if reverse:; for i, line in reversed(list(enumerate(lines))):; if start_str == line:; return i; else:; for i, line in enumerate(lines):; if start_str == line:; return i; return start. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:416,Modifiability,variab,variables,416,". qcdb.orca  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.orca; from __future__ import absolute_import; from __future__ import print_function; from collections import defaultdict; from .pdict import PreservingDict; from .molecule import Molecule; from .physconst import *. [docs]def harvest(p4Mol, orca_out, **largs):; """"""Harvest variables, gradient, and the molecule from the output and other; files; """""". # Split into lines as it is much easier to find what is needed; out_lines = orca_out.split('\n'). mol = harvest_molecule_from_outfile(out_lines). file_name = ""NONE""; grad = harvest_engrad(file_name). # Harvest energies and properties from the output file; psivar = PreservingDict(); harvest_scf_from_outfile(out_lines, psivar); harvest_dipole(out_lines, psivar); harvest_mp2(out_lines, psivar); harvest_coupled_cluster(out_lines, psivar). return psivar, grad, mol. [docs]def muster_memory(mem):; """"""Transform input *mem* in MB into psi4-type options for orca. """"""; # prepare memory keywords to be set as c-side keywords; options = defaultdict(lambda: defaultdict(dict)); options['ORCA']['ORCA_MAXCORE']['value'] = int(mem); text = ""%MaxCore {}\n"".format(options['ORCA']['ORCA_MAXCORE']['value']). for item in options['ORCA']:; options['ORCA'][item]['clobber'] = True. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for orca. While deliberately requested pieces,; generally orca__orca_deriv_level and orca__orca_calc_level,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, can be countermanded by keywords in input file; ('clobber' set to False). Occasionally, we want these pieces to actually; overcome keywords in input file ('superclobber' set to True).; """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype =",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orca.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:1460,Availability,toler,tolerance,1460,"sion.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; #import os; #import re; #import math; #import copy; import itertools; from .molecule import Molecule; #from periodictable import *; #from physconst import *; from .vecutil import *; from .exceptions import *. #LINEAR_A_TOL = 1.0E-2 # When sin(a) is below this, we consider the angle to be linear; #DEFAULT_SYM_TOL = 1.0E-8; #FULL_PG_TOL = 1.0e-8; #ZERO = 1.0E-14; NOISY_ZERO = 1.0E-8; COORD_ZERO = 1.0E-5 # tolerance in coordinate alignment btwn qc programs. [docs]class OrientMols(object):; """"""Class to encode a transformation between two molecular coordinate; systems. After initializing with two qcdb.Molecule objects at the; same geometry in possible different frames and orderings, class; can apply the appropriate transformations to coordinate, gradient,; Hessian, etc. arrays. """""". def __init__(self, molPermanent, molChangeable):; """"""Stores the shift, rotation, axis exchange, axis inversion,; and atom remapping necessary to bring the geometry of; *molChangeable* into coincidence with the geometry of; *molPermanent*. *molPermanent* and *molChangeable* must be; :py:class:`qcdb.Molecule` and represent the same geometry. """"""; # <<< Permanent (Psi4) >>>. # Molecule; self.Pmol = molPermanent; # Vector to shift Pmol to center of mass; self.Pshift = []; # Matrix to rotate Pmol to inertial frame; self.Protate = []. # <<< Changeable (Cfour) >>>. # Molecule; self.Cmol = molChangeable; # Vector to shift Cmol to center of ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:4351,Availability,error,errors,4351,"or(""""""OrientMols must be instantiated with two qcdb.Molecule objects.""""""). def __str__(self):; text = """""" ==> qcdb OrientMols <==\n\n""""""; text += """""" natom: %d\n\n"""""" % (self.Pmol.natom()); text += """""" PNRE: %16.8f\n"""""" % (self.Pmol.nuclear_repulsion_energy()); text += """""" Pshift: %s\n"""""" % (self.Pshift); text += """""" Protate: %s\n"""""" % (self.Protate); text += """"""\n CNRE: %16.8f\n"""""" % (self.Cmol.nuclear_repulsion_energy()); text += """""" Cshift: %s\n"""""" % (self.Cshift); text += """""" Crotate: %s\n"""""" % (self.Crotate); text += """""" Cexchflip: %s\n"""""" % (self.Cexchflip); text += """""" Catommap: %s\n"""""" % (self.Catommap); return text. [docs] def create_orientation_from_molecules(self, Pmol, Cmol):; """"""Finds the shift, rotation, axis exchange, axis inversion,; and atom remapping necessary to bring the geometry of *Cmol*; into coincidence with the geometry of *Pmol*. *Pmol* and *Cmol*; must be :py:class:`qcdb.Molecule` and represent the same; geometry. Presently catches some errors of orientation that; Cfour as *Cmol* should properly fulfill. These are unnecessary; restrictions and can be relaxed later. """"""; p4mol = Pmol.clone(); c4mol = Cmol.clone(); Nat = p4mol.natom(); eye3 = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]. # Find translation to CoM, straightforward; # com = [ x if abs(x) > NOISY_ZERO else 0.0 for x in com]; com = p4mol.center_of_charge() # avoids trouble of ghost atoms w/center_of_mass; p4mol.translate(scale(com, -1.0)); self.Pshift = com. com = c4mol.center_of_charge(); c4mol.translate(scale(com, -1.0)); self.Cshift = com. # Find rotation to MoI frame, straightforward; # frame = [[ x if abs(x) > NOISY_ZERO else 0.0 for x in ax] for ax in frame]; moi, frame = p4mol.inertial_system(masswt=False, zero=NOISY_ZERO) # avoids trouble of ghost atoms w/masswt'd; Psort = sorted(range(3), key=lambda x: moi[x]); p4mol.rotate(frame); self.Protate = frame. moi, frame = c4mol.inertial_system(masswt=False, zero=NOISY_ZERO); Csort = sorted(range(3), key=lambda x: moi[x",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:15259,Deployability,update,updated,15259,")). arr2 = []; for at in range(len(arr)):; arr2.append(arr[self.Catommap[at]]); arr = arr2; # print ""AtomMap""; # for item in arr:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). arr = mult(arr, transpose(self.Protate)); # print ""P4 Rotate""; # for item in arr:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). return arr. [docs] def transform_elementlist(self, elem):; """"""Applies to *elem* the transformation appropriate to bring a; list of atomic numbers in *molChangeable* orientation into; *molPermanent* orientation. In particular, applies a row exchange; to place it in the atom ordering. """"""; elem2 = []; for at in range(self.Pmol.natom()):; elem2.append(elem[self.Catommap[at]]); return elem2. [docs] def transform_vector(self, vec):; """"""Applies to *vec* the transformation appropriate to bring a; vector in *molChangeable* orientation into *molPermanent*; orientation. In particular, applies a rotation to place it; in the inertial frame, a column exchange and phasing to place; it in the axis system, and a rotation to remove it from the; inertial frame. """"""; vec = [vec] # hack since vecutil handles matrices, not vectors. #coord.rotate(self.Crotate); vec2 = mult(vec, self.Crotate); vec = vec2; #print ""Rotate""; #for item in vec:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). #coord.rotate(self.Cexchflip); vec2 = mult(vec, self.Cexchflip); vec = vec2; #print ""ExchFlip""; #for item in vec:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). #coord.rotate(transpose(self.Protate)); vec2 = mult(vec, transpose(self.Protate)); vec = vec2; #print ""P4 Rotate""; #for item in vec:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). return vec[0]. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:4748,Safety,avoid,avoids,4748,"lf.Cmol.nuclear_repulsion_energy()); text += """""" Cshift: %s\n"""""" % (self.Cshift); text += """""" Crotate: %s\n"""""" % (self.Crotate); text += """""" Cexchflip: %s\n"""""" % (self.Cexchflip); text += """""" Catommap: %s\n"""""" % (self.Catommap); return text. [docs] def create_orientation_from_molecules(self, Pmol, Cmol):; """"""Finds the shift, rotation, axis exchange, axis inversion,; and atom remapping necessary to bring the geometry of *Cmol*; into coincidence with the geometry of *Pmol*. *Pmol* and *Cmol*; must be :py:class:`qcdb.Molecule` and represent the same; geometry. Presently catches some errors of orientation that; Cfour as *Cmol* should properly fulfill. These are unnecessary; restrictions and can be relaxed later. """"""; p4mol = Pmol.clone(); c4mol = Cmol.clone(); Nat = p4mol.natom(); eye3 = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]. # Find translation to CoM, straightforward; # com = [ x if abs(x) > NOISY_ZERO else 0.0 for x in com]; com = p4mol.center_of_charge() # avoids trouble of ghost atoms w/center_of_mass; p4mol.translate(scale(com, -1.0)); self.Pshift = com. com = c4mol.center_of_charge(); c4mol.translate(scale(com, -1.0)); self.Cshift = com. # Find rotation to MoI frame, straightforward; # frame = [[ x if abs(x) > NOISY_ZERO else 0.0 for x in ax] for ax in frame]; moi, frame = p4mol.inertial_system(masswt=False, zero=NOISY_ZERO) # avoids trouble of ghost atoms w/masswt'd; Psort = sorted(range(3), key=lambda x: moi[x]); p4mol.rotate(frame); self.Protate = frame. moi, frame = c4mol.inertial_system(masswt=False, zero=NOISY_ZERO); Csort = sorted(range(3), key=lambda x: moi[x]); c4mol.rotate(frame); self.Crotate = frame. # Find degrees of freedom among axis exchanges; rotor = p4mol.rotor_type(); # if rotor != c4mol.rotor_type():; # raise ValidationError(""""""molPermanent (%s) and molChangeable (%s) of different rotor types."""""" % \; # (rotor, c4mol.rotor_type())); # TODO: is this safe? differences in masses of ghost atoms can cause different rotor types; if rotor",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:5129,Safety,avoid,avoids,5129,"necessary to bring the geometry of *Cmol*; into coincidence with the geometry of *Pmol*. *Pmol* and *Cmol*; must be :py:class:`qcdb.Molecule` and represent the same; geometry. Presently catches some errors of orientation that; Cfour as *Cmol* should properly fulfill. These are unnecessary; restrictions and can be relaxed later. """"""; p4mol = Pmol.clone(); c4mol = Cmol.clone(); Nat = p4mol.natom(); eye3 = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]. # Find translation to CoM, straightforward; # com = [ x if abs(x) > NOISY_ZERO else 0.0 for x in com]; com = p4mol.center_of_charge() # avoids trouble of ghost atoms w/center_of_mass; p4mol.translate(scale(com, -1.0)); self.Pshift = com. com = c4mol.center_of_charge(); c4mol.translate(scale(com, -1.0)); self.Cshift = com. # Find rotation to MoI frame, straightforward; # frame = [[ x if abs(x) > NOISY_ZERO else 0.0 for x in ax] for ax in frame]; moi, frame = p4mol.inertial_system(masswt=False, zero=NOISY_ZERO) # avoids trouble of ghost atoms w/masswt'd; Psort = sorted(range(3), key=lambda x: moi[x]); p4mol.rotate(frame); self.Protate = frame. moi, frame = c4mol.inertial_system(masswt=False, zero=NOISY_ZERO); Csort = sorted(range(3), key=lambda x: moi[x]); c4mol.rotate(frame); self.Crotate = frame. # Find degrees of freedom among axis exchanges; rotor = p4mol.rotor_type(); # if rotor != c4mol.rotor_type():; # raise ValidationError(""""""molPermanent (%s) and molChangeable (%s) of different rotor types."""""" % \; # (rotor, c4mol.rotor_type())); # TODO: is this safe? differences in masses of ghost atoms can cause different rotor types; if rotor == 'RT_ATOM':; freebytop = []; elif rotor == 'RT_LINEAR': # 0 < IB == IC inf > B == C; freebytop = [1, 2]; elif rotor == 'RT_SPHERICAL_TOP': # IA == IB == IC A == B == C; freebytop = [0, 1, 2]; elif rotor == 'RT_PROLATE_SYMMETRIC_TOP': # IA < IB == IC A > B == C; freebytop = [1, 2]; elif rotor == 'RT_OBLATE_SYMMETRIC_TOP': # IA == IB < IC A == B > C; freebytop = [0, 1]; elif rotor == ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:5681,Safety,safe,safe,5681,"om. # Find rotation to MoI frame, straightforward; # frame = [[ x if abs(x) > NOISY_ZERO else 0.0 for x in ax] for ax in frame]; moi, frame = p4mol.inertial_system(masswt=False, zero=NOISY_ZERO) # avoids trouble of ghost atoms w/masswt'd; Psort = sorted(range(3), key=lambda x: moi[x]); p4mol.rotate(frame); self.Protate = frame. moi, frame = c4mol.inertial_system(masswt=False, zero=NOISY_ZERO); Csort = sorted(range(3), key=lambda x: moi[x]); c4mol.rotate(frame); self.Crotate = frame. # Find degrees of freedom among axis exchanges; rotor = p4mol.rotor_type(); # if rotor != c4mol.rotor_type():; # raise ValidationError(""""""molPermanent (%s) and molChangeable (%s) of different rotor types."""""" % \; # (rotor, c4mol.rotor_type())); # TODO: is this safe? differences in masses of ghost atoms can cause different rotor types; if rotor == 'RT_ATOM':; freebytop = []; elif rotor == 'RT_LINEAR': # 0 < IB == IC inf > B == C; freebytop = [1, 2]; elif rotor == 'RT_SPHERICAL_TOP': # IA == IB == IC A == B == C; freebytop = [0, 1, 2]; elif rotor == 'RT_PROLATE_SYMMETRIC_TOP': # IA < IB == IC A > B == C; freebytop = [1, 2]; elif rotor == 'RT_OBLATE_SYMMETRIC_TOP': # IA == IB < IC A == B > C; freebytop = [0, 1]; elif rotor == 'RT_ASYMMETRIC_TOP': # IA < IB < IC A > B > C; freebytop = []. # Find possible mappings of axis exchange and flipping that brings Cgeom into coincidence with Pgeom; axExch = [[], [], []]; axPhse = [[], [], []]. Pgeom = p4mol.geometry(); Cgeom = c4mol.geometry(); for Paxs in range(3):; allowed = freebytop if Paxs in freebytop else [Paxs]. for Caxs in allowed:; PcolS = sorted([row[Psort[Paxs]] for row in Pgeom]); CcolS = sorted([row[Csort[Caxs]] for row in Cgeom]); CcolMS = sorted([-row[Csort[Caxs]] for row in Cgeom]). if all([abs(CcolS[at] - PcolS[at]) < COORD_ZERO for at in range(Nat)]):; if all([abs(CcolS[at] - CcolMS[at]) < COORD_ZERO for at in range(Nat)]):; axPhse[Psort[Paxs]] = [1, -1] # Indeterminate when symm P4 col == C4 col; axExch[Psort[Paxs]].append(Csort[Ca",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/orient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/parker.html:4699,Deployability,update,updated,4699,"at2].append(at1). # determine bond order for all bonds from bond tree and element types; n_missing = missing_bonds(bonds, bond_tree, at_types); n_neighbors_missing = missing_neighbors(bond_tree, n_missing). # add double / triple bonds if only one neighbor missing bonds; N_left = math.floor(sum(n_missing) / 2); N_left_previous = N_left + 1; N_iter = 0; while N_left > 0:; N_iter += 1. if N_left == N_left_previous:; neighbor_min += 1; else:; neighbor_min = 1. N_left_previous = N_left. # add a multiple bond to a deficient atom with the fewest number of deficient neighbors; BREAK_LOOP = False; for i in range(N_atoms):; if n_missing[i] > 0 and n_neighbors_missing[i] == neighbor_min:; N_neighbors = len(bond_tree[i]); for a in range(N_neighbors):; j = bond_tree[i][a]; if n_missing[j] > 0:; for p in range(N_bonds):; at1 = bonds[p][0]; at2 = bonds[p][1]; if (at1 == i and at2 == j) or (at1 == j and at2 == i):; bonds[p][2] += 1; n_missing[i] += -1; n_missing[j] += -1; n_neighbors_missing[i] += -1; n_neighbors_missing[j] += -1; N_left = math.floor(sum(n_missing) / 2); BREAK_LOOP = True; if BREAK_LOOP:; break; if BREAK_LOOP:; break. # recalculate incomplete bond topology; n_missing = missing_bonds(bonds, bond_tree, at_types); n_neighbors_missing = missing_neighbors(bond_tree, n_missing). # break cycle if takes more than given number of iterations; max_iter = 100; if N_iter > max_iter:; print(""""""Error: multiple bond determination not complete""""""); print("""""" %i bonds unaccounted for"""""" % (N_left)); break. # bond order is number of bonds between each bonded atom pair; bond_order = []; for p in range(N_bonds):; bond_order.append(bonds[p][2]); for p in range(len(bond_order)):; bonds[p][2] = bond_order[p]. return bonds. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/parker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/parker.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:1482,Availability,error,error,1482,"ublished by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; from decimal import Decimal, ROUND_FLOOR, ROUND_CEILING; from .exceptions import *. [docs]class PreservingDict(dict):; """"""Class to store quantum chemical quantities extracted from output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. """""". def __init__(self, *args, **kwargs):; self.update(*args, **kwargs). def __setitem__(self, key, value):; try:; key = key.upper(); except AttributeError:; raise AttributeError('Keys stored as upper-case strings: %s unsuitable' % (key)); value = Decimal(value); if key in self.keys() and not 'CURRENT' in key:; # Validate choosing more detailed value for variable; existing_exp = self[key].as_tuple().exponent # 0.1111 --> -4; candidate_exp = value.as_tuple().exponent; if existing_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:1617,Deployability,update,update,1617,"HANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; from decimal import Decimal, ROUND_FLOOR, ROUND_CEILING; from .exceptions import *. [docs]class PreservingDict(dict):; """"""Class to store quantum chemical quantities extracted from output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. """""". def __init__(self, *args, **kwargs):; self.update(*args, **kwargs). def __setitem__(self, key, value):; try:; key = key.upper(); except AttributeError:; raise AttributeError('Keys stored as upper-case strings: %s unsuitable' % (key)); value = Decimal(value); if key in self.keys() and not 'CURRENT' in key:; # Validate choosing more detailed value for variable; existing_exp = self[key].as_tuple().exponent # 0.1111 --> -4; candidate_exp = value.as_tuple().exponent; if existing_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILIN",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:3272,Deployability,update,update,3272,"e = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""Output file yielded both %s and %s as values for quantity %s."""""" %; (self[key].to_eng_string(), value.to_eng_string(), key)); #print 'Resetting variable %s to %s' % (key, best_value.to_eng_string()); else:; best_value = value; #print 'Setting variable %s to %s' % (key, best_value.to_eng_string()); super(PreservingDict, self).__setitem__(key, best_value). [docs] def update(self, *args, **kwargs):; if args:; if len(args) > 1:; raise TypeError(""update expected at most 1 arguments, ""; ""got %d"" % len(args)); other = dict(args[0]); for key in other:; self[key] = other[key]; for key in kwargs:; self[key] = kwargs[key]. [docs] def setdefault(self, key, value=None):; if key not in self:; self[key] = value; return self[key]. if __name__ == '__main__':; c4info = PreservingDict(); c4info['scf 4.5e0 total energy'] = '-1.e-4'; c4info['1.3'] = '.4'; c4info['curl'] = '-437.12345678'; c4info['curl'] = '-437.12345677'; c4info['curl'] = '-437.123456'; c4info['curl'] = '-437.123457'; c4info['curl'] = '-437.1234444' # fails; c4info['curl'] = '-437.123456789'; #c4info['curl'] = '-437.1234567779' # fails; print(c4info). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:3350,Deployability,update,update,3350,"e = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""Output file yielded both %s and %s as values for quantity %s."""""" %; (self[key].to_eng_string(), value.to_eng_string(), key)); #print 'Resetting variable %s to %s' % (key, best_value.to_eng_string()); else:; best_value = value; #print 'Setting variable %s to %s' % (key, best_value.to_eng_string()); super(PreservingDict, self).__setitem__(key, best_value). [docs] def update(self, *args, **kwargs):; if args:; if len(args) > 1:; raise TypeError(""update expected at most 1 arguments, ""; ""got %d"" % len(args)); other = dict(args[0]); for key in other:; self[key] = other[key]; for key in kwargs:; self[key] = kwargs[key]. [docs] def setdefault(self, key, value=None):; if key not in self:; self[key] = value; return self[key]. if __name__ == '__main__':; c4info = PreservingDict(); c4info['scf 4.5e0 total energy'] = '-1.e-4'; c4info['1.3'] = '.4'; c4info['curl'] = '-437.12345678'; c4info['curl'] = '-437.12345677'; c4info['curl'] = '-437.123456'; c4info['curl'] = '-437.123457'; c4info['curl'] = '-437.1234444' # fails; c4info['curl'] = '-437.123456789'; #c4info['curl'] = '-437.1234567779' # fails; print(c4info). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:4215,Deployability,update,updated,4215,"e = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""Output file yielded both %s and %s as values for quantity %s."""""" %; (self[key].to_eng_string(), value.to_eng_string(), key)); #print 'Resetting variable %s to %s' % (key, best_value.to_eng_string()); else:; best_value = value; #print 'Setting variable %s to %s' % (key, best_value.to_eng_string()); super(PreservingDict, self).__setitem__(key, best_value). [docs] def update(self, *args, **kwargs):; if args:; if len(args) > 1:; raise TypeError(""update expected at most 1 arguments, ""; ""got %d"" % len(args)); other = dict(args[0]); for key in other:; self[key] = other[key]; for key in kwargs:; self[key] = kwargs[key]. [docs] def setdefault(self, key, value=None):; if key not in self:; self[key] = value; return self[key]. if __name__ == '__main__':; c4info = PreservingDict(); c4info['scf 4.5e0 total energy'] = '-1.e-4'; c4info['1.3'] = '.4'; c4info['curl'] = '-437.12345678'; c4info['curl'] = '-437.12345677'; c4info['curl'] = '-437.123456'; c4info['curl'] = '-437.123457'; c4info['curl'] = '-437.1234444' # fails; c4info['curl'] = '-437.123456789'; #c4info['curl'] = '-437.1234567779' # fails; print(c4info). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:3708,Energy Efficiency,energy,energy,3708,"e = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""Output file yielded both %s and %s as values for quantity %s."""""" %; (self[key].to_eng_string(), value.to_eng_string(), key)); #print 'Resetting variable %s to %s' % (key, best_value.to_eng_string()); else:; best_value = value; #print 'Setting variable %s to %s' % (key, best_value.to_eng_string()); super(PreservingDict, self).__setitem__(key, best_value). [docs] def update(self, *args, **kwargs):; if args:; if len(args) > 1:; raise TypeError(""update expected at most 1 arguments, ""; ""got %d"" % len(args)); other = dict(args[0]); for key in other:; self[key] = other[key]; for key in kwargs:; self[key] = kwargs[key]. [docs] def setdefault(self, key, value=None):; if key not in self:; self[key] = value; return self[key]. if __name__ == '__main__':; c4info = PreservingDict(); c4info['scf 4.5e0 total energy'] = '-1.e-4'; c4info['1.3'] = '.4'; c4info['curl'] = '-437.12345678'; c4info['curl'] = '-437.12345677'; c4info['curl'] = '-437.123456'; c4info['curl'] = '-437.123457'; c4info['curl'] = '-437.1234444' # fails; c4info['curl'] = '-437.123456789'; #c4info['curl'] = '-437.1234567779' # fails; print(c4info). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:1926,Modifiability,variab,variable,1926,"reet, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; from decimal import Decimal, ROUND_FLOOR, ROUND_CEILING; from .exceptions import *. [docs]class PreservingDict(dict):; """"""Class to store quantum chemical quantities extracted from output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. """""". def __init__(self, *args, **kwargs):; self.update(*args, **kwargs). def __setitem__(self, key, value):; try:; key = key.upper(); except AttributeError:; raise AttributeError('Keys stored as upper-case strings: %s unsuitable' % (key)); value = Decimal(value); if key in self.keys() and not 'CURRENT' in key:; # Validate choosing more detailed value for variable; existing_exp = self[key].as_tuple().exponent # 0.1111 --> -4; candidate_exp = value.as_tuple().exponent; if existing_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""O",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:3048,Modifiability,variab,variable,3048,"isting_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""Output file yielded both %s and %s as values for quantity %s."""""" %; (self[key].to_eng_string(), value.to_eng_string(), key)); #print 'Resetting variable %s to %s' % (key, best_value.to_eng_string()); else:; best_value = value; #print 'Setting variable %s to %s' % (key, best_value.to_eng_string()); super(PreservingDict, self).__setitem__(key, best_value). [docs] def update(self, *args, **kwargs):; if args:; if len(args) > 1:; raise TypeError(""update expected at most 1 arguments, ""; ""got %d"" % len(args)); other = dict(args[0]); for key in other:; self[key] = other[key]; for key in kwargs:; self[key] = kwargs[key]. [docs] def setdefault(self, key, value=None):; if key not in self:; self[key] = value; return self[key]. if __name__ == '__main__':; c4info = PreservingDict(); c4info['scf 4.5e0 total energy'] = '-1.e-4'; c4info['1.3'] = '.4'; c4info['curl'] = '-437.12345678'; c4info['curl'] = '-437.12345677'; c4info['curl'] = '-437.123456'; c4info['curl'] = '-437.123457'; c4info['curl'] = '-437.1234444' # fails; c4info['curl'] = '-437.123456789'; #c4info['curl'] = '-437.1234567779' # fails; print(c4info). Quick search. Enter search ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:3147,Modifiability,variab,variable,3147,"g_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""Output file yielded both %s and %s as values for quantity %s."""""" %; (self[key].to_eng_string(), value.to_eng_string(), key)); #print 'Resetting variable %s to %s' % (key, best_value.to_eng_string()); else:; best_value = value; #print 'Setting variable %s to %s' % (key, best_value.to_eng_string()); super(PreservingDict, self).__setitem__(key, best_value). [docs] def update(self, *args, **kwargs):; if args:; if len(args) > 1:; raise TypeError(""update expected at most 1 arguments, ""; ""got %d"" % len(args)); other = dict(args[0]); for key in other:; self[key] = other[key]; for key in kwargs:; self[key] = kwargs[key]. [docs] def setdefault(self, key, value=None):; if key not in self:; self[key] = value; return self[key]. if __name__ == '__main__':; c4info = PreservingDict(); c4info['scf 4.5e0 total energy'] = '-1.e-4'; c4info['1.3'] = '.4'; c4info['curl'] = '-437.12345678'; c4info['curl'] = '-437.12345677'; c4info['curl'] = '-437.123456'; c4info['curl'] = '-437.123457'; c4info['curl'] = '-437.1234444' # fails; c4info['curl'] = '-437.123456789'; #c4info['curl'] = '-437.1234567779' # fails; print(c4info). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:1332,Security,validat,validate,1332,"ublished by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; from decimal import Decimal, ROUND_FLOOR, ROUND_CEILING; from .exceptions import *. [docs]class PreservingDict(dict):; """"""Class to store quantum chemical quantities extracted from output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. """""". def __init__(self, *args, **kwargs):; self.update(*args, **kwargs). def __setitem__(self, key, value):; try:; key = key.upper(); except AttributeError:; raise AttributeError('Keys stored as upper-case strings: %s unsuitable' % (key)); value = Decimal(value); if key in self.keys() and not 'CURRENT' in key:; # Validate choosing more detailed value for variable; existing_exp = self[key].as_tuple().exponent # 0.1111 --> -4; candidate_exp = value.as_tuple().exponent; if existing_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:1389,Testability,test,testing,1389,"ublished by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; from decimal import Decimal, ROUND_FLOOR, ROUND_CEILING; from .exceptions import *. [docs]class PreservingDict(dict):; """"""Class to store quantum chemical quantities extracted from output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. """""". def __init__(self, *args, **kwargs):; self.update(*args, **kwargs). def __setitem__(self, key, value):; try:; key = key.upper(); except AttributeError:; raise AttributeError('Keys stored as upper-case strings: %s unsuitable' % (key)); value = Decimal(value); if key in self.keys() and not 'CURRENT' in key:; # Validate choosing more detailed value for variable; existing_exp = self[key].as_tuple().exponent # 0.1111 --> -4; candidate_exp = value.as_tuple().exponent; if existing_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/pdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:6199,Availability,avail,available,6199,"f-b3lyp-d'; #'df-b3lyp-d3'; #'df-wb97x-d'. [docs]def muster_cdsgroup_options():; text = ''; options = defaultdict(lambda: defaultdict(dict)); options['GLOBALS']['E_CONVERGENCE']['value'] = 8; options['SCF']['GUESS']['value'] = 'sad'; options['SCF']['MAXITER']['value'] = 200. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; text += """"""energy('""""""; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'mp2':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'direct'; options['MP2']['MP2_TYPE']['value'] = 'conv'; text += """"""mp2')\n\n"""""". elif lowername == 'df-mp2':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; options['MP2']['MP2_TYPE']['value'] = 'df'; text += """"""mp2')\n\n"""""". elif lowername == 'sapt0':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; text += """"""sapt0')\n\n"""""". elif lowername == 'sapt2+':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SAPT']['NAT_ORBS_T2']['value'] = True; options['SAPT']['NAT_ORBS_T3']['value'] = True; options['SAPT']['NAT_ORBS_V4']['value'] = True; options['SAPT']['OCC_TOLERANCE']['value'] = 1.0e-6; text += """"""sapt2+')\n\n"""""". elif lowername == 'sapt2+(3)':; option",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psi4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:10007,Availability,avail,available,10007,"]['DFT_RADIAL_POINTS']['value'] = 100; text += """"""wpbe')\n\n"""""". elif lowername == 'ccsd-polarizability':; options['GLOBALS']['FREEZE_CORE']['value'] = True; text = """"""property('ccsd', properties=['polarizability'])\n\n"""""". elif lowername == 'mrccsdt(q)':; options['SCF']['SCF_TYPE']['value'] = 'pk'; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['GLOBALS']['NAT_ORBS']['value'] = True # needed by mrcc but not recognized by mrcc; options['FNOCC']['OCC_TOLERANCE']['value'] = 6; text += """"""mrccsdt(q)')\n\n"""""". elif lowername == 'c4-ccsdt(q)':; options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; text += """"""c4-ccsdt(q)')\n\n"""""". elif lowername == 'df-m05-2x':; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'df-b97-d3' : muster_modelchem,; 'df-wb97x-d' : muster_modelchem,; 'df-b3lyp-d3' : muster_modelchem,; 'mp2' : muster_modelchem,; 'df-mp2' : muster_modelchem,; 'sapt0' : muster_modelchem,; 'sapt2+' : muster_modelchem,; 'sapt2+(3)' : muster_modelchem,; 'sapt2+3(ccd)' : muster_modelchem,; 'mrccsdt(q)' : muster_modelchem,; 'c4-ccsdt(q)' : muster_modelchem,; 'ccsd-polarizability' : muster_modelchem,; 'dfdf-b2plyp-d3': muste",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psi4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:11407,Deployability,update,updated,11407,"t(q)')\n\n"""""". elif lowername == 'c4-ccsdt(q)':; options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; text += """"""c4-ccsdt(q)')\n\n"""""". elif lowername == 'df-m05-2x':; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'df-b97-d3' : muster_modelchem,; 'df-wb97x-d' : muster_modelchem,; 'df-b3lyp-d3' : muster_modelchem,; 'mp2' : muster_modelchem,; 'df-mp2' : muster_modelchem,; 'sapt0' : muster_modelchem,; 'sapt2+' : muster_modelchem,; 'sapt2+(3)' : muster_modelchem,; 'sapt2+3(ccd)' : muster_modelchem,; 'mrccsdt(q)' : muster_modelchem,; 'c4-ccsdt(q)' : muster_modelchem,; 'ccsd-polarizability' : muster_modelchem,; 'dfdf-b2plyp-d3': muster_modelchem,; 'df-wpbe' : muster_modelchem,; 'df-m05-2x' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return sorted(procedures['energy'].keys()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psi4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:3981,Energy Efficiency,energy,energy,3981,"ass Infile(qcformat.InputFormat2):. def __init__(self, mem, mol, mtd, der, opt):; qcformat.InputFormat2.__init__(self, mem, mol, mtd, der, opt). #print self.method, self.molecule.nactive_fragments(); if 'sapt' in self.method and self.molecule.nactive_fragments() != 2:; raise FragmentCountError(""""""Requested molecule has %d, not 2, fragments."""""" % (self.molecule.nactive_fragments())). # # memory in MB --> MW; # self.memory = int(math.ceil(mem / 8.0)); # # auxiliary basis sets; # [self.unaugbasis, self.augbasis, self.auxbasis] = self.corresponding_aux_basis(). [docs] def format_infile_string(self):; """""". """"""; # Handle memory and comment; memcmd, memkw = """"""# %s\n\nmemory %d mb\n\n"""""" % (self.molecule.tagline, self.memory), {}. # Handle molecule and basis set; molcmd, molkw = self.molecule.format_molecule_for_psi4(), {}. # format global convergence directions; # text += self.format_global_parameters(); _cdscmd, cdskw = muster_cdsgroup_options(). # Handle calc type and quantum chemical method; mdccmd, mdckw = procedures['energy'][self.method](self.method, self.dertype). # # format options; # optcmd = qcdb.options.prepare_options_for_psi4(mdckw). # make options from imdb only user options (currently non-existent). set basis and castup from here.; # Handle driver vs input/default keyword reconciliation; userkw = self.options; # userkw = p4util.prepare_options_for_modules(); #userkw = qcdb.options.reconcile_options(userkw, memkw); #userkw = qcdb.options.reconcile_options(userkw, molkw); #userkw = qcdb.options.reconcile_options(userkw, baskw); #userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = options.reconcile_options2(userkw, cdskw); userkw = options.reconcile_options2(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = options.prepare_options_for_psi4(userkw). # Handle text to be passed untouched to psi4; litcmd = """"""\nprint_variables()\n\n"""""". # Assemble infile pieces; return memcmd + molcmd + optcmd + mdccmd + litcmd. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psi4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:6121,Energy Efficiency,energy,energy,6121,"f-b3lyp-d'; #'df-b3lyp-d3'; #'df-wb97x-d'. [docs]def muster_cdsgroup_options():; text = ''; options = defaultdict(lambda: defaultdict(dict)); options['GLOBALS']['E_CONVERGENCE']['value'] = 8; options['SCF']['GUESS']['value'] = 'sad'; options['SCF']['MAXITER']['value'] = 200. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; text += """"""energy('""""""; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'mp2':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'direct'; options['MP2']['MP2_TYPE']['value'] = 'conv'; text += """"""mp2')\n\n"""""". elif lowername == 'df-mp2':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; options['MP2']['MP2_TYPE']['value'] = 'df'; text += """"""mp2')\n\n"""""". elif lowername == 'sapt0':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; text += """"""sapt0')\n\n"""""". elif lowername == 'sapt2+':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SAPT']['NAT_ORBS_T2']['value'] = True; options['SAPT']['NAT_ORBS_T3']['value'] = True; options['SAPT']['NAT_ORBS_V4']['value'] = True; options['SAPT']['OCC_TOLERANCE']['value'] = 1.0e-6; text += """"""sapt2+')\n\n"""""". elif lowername == 'sapt2+(3)':; option",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psi4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:10538,Energy Efficiency,energy,energy,10538,"t(q)')\n\n"""""". elif lowername == 'c4-ccsdt(q)':; options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; text += """"""c4-ccsdt(q)')\n\n"""""". elif lowername == 'df-m05-2x':; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'df-b97-d3' : muster_modelchem,; 'df-wb97x-d' : muster_modelchem,; 'df-b3lyp-d3' : muster_modelchem,; 'mp2' : muster_modelchem,; 'df-mp2' : muster_modelchem,; 'sapt0' : muster_modelchem,; 'sapt2+' : muster_modelchem,; 'sapt2+(3)' : muster_modelchem,; 'sapt2+3(ccd)' : muster_modelchem,; 'mrccsdt(q)' : muster_modelchem,; 'c4-ccsdt(q)' : muster_modelchem,; 'ccsd-polarizability' : muster_modelchem,; 'dfdf-b2plyp-d3': muster_modelchem,; 'df-wpbe' : muster_modelchem,; 'df-m05-2x' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return sorted(procedures['energy'].keys()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psi4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:11078,Energy Efficiency,energy,energy,11078,"t(q)')\n\n"""""". elif lowername == 'c4-ccsdt(q)':; options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; text += """"""c4-ccsdt(q)')\n\n"""""". elif lowername == 'df-m05-2x':; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'df-b97-d3' : muster_modelchem,; 'df-wb97x-d' : muster_modelchem,; 'df-b3lyp-d3' : muster_modelchem,; 'mp2' : muster_modelchem,; 'df-mp2' : muster_modelchem,; 'sapt0' : muster_modelchem,; 'sapt2+' : muster_modelchem,; 'sapt2+(3)' : muster_modelchem,; 'sapt2+3(ccd)' : muster_modelchem,; 'mrccsdt(q)' : muster_modelchem,; 'c4-ccsdt(q)' : muster_modelchem,; 'ccsd-polarizability' : muster_modelchem,; 'dfdf-b2plyp-d3': muster_modelchem,; 'df-wpbe' : muster_modelchem,; 'df-m05-2x' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return sorted(procedures['energy'].keys()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psi4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:11193,Energy Efficiency,energy,energy,11193,"t(q)')\n\n"""""". elif lowername == 'c4-ccsdt(q)':; options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; text += """"""c4-ccsdt(q)')\n\n"""""". elif lowername == 'df-m05-2x':; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'df-b97-d3' : muster_modelchem,; 'df-wb97x-d' : muster_modelchem,; 'df-b3lyp-d3' : muster_modelchem,; 'mp2' : muster_modelchem,; 'df-mp2' : muster_modelchem,; 'sapt0' : muster_modelchem,; 'sapt2+' : muster_modelchem,; 'sapt2+(3)' : muster_modelchem,; 'sapt2+3(ccd)' : muster_modelchem,; 'mrccsdt(q)' : muster_modelchem,; 'c4-ccsdt(q)' : muster_modelchem,; 'ccsd-polarizability' : muster_modelchem,; 'dfdf-b2plyp-d3': muster_modelchem,; 'df-wpbe' : muster_modelchem,; 'df-m05-2x' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return sorted(procedures['energy'].keys()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psi4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:1770,Availability,failure,failure,1770,"al Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; from __future__ import absolute_import; from __future__ import print_function; import sys; import math; import re; import os; import string; from .vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label, exitonfail=True):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* > 1 e.g. digits=0.04). Performs; a system exit on failure unless *exitonfail* False, in which case; returns error message. Used in input files in the test suite. """"""; thresh = 10 ** -digits if digits > 1 else digits; if abs(expected - computed) > thresh:; print(""\t%s: computed value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if exitonfail:; sys.exit(1); else:; return; if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f)\n"" % (label, computed, expected)); print(""\tprobably because the computed value is nan.""); if exitonfail:; sys.exit(1); else:; return; _success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:1828,Availability,error,error,1828,"al Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; from __future__ import absolute_import; from __future__ import print_function; import sys; import math; import re; import os; import string; from .vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label, exitonfail=True):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* > 1 e.g. digits=0.04). Performs; a system exit on failure unless *exitonfail* False, in which case; returns error message. Used in input files in the test suite. """"""; thresh = 10 ** -digits if digits > 1 else digits; if abs(expected - computed) > thresh:; print(""\t%s: computed value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if exitonfail:; sys.exit(1); else:; return; if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f)\n"" % (label, computed, expected)); print(""\tprobably because the computed value is nan.""); if exitonfail:; sys.exit(1); else:; return; _success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:2559,Availability,failure,failure,2559,"Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* > 1 e.g. digits=0.04). Performs; a system exit on failure unless *exitonfail* False, in which case; returns error message. Used in input files in the test suite. """"""; thresh = 10 ** -digits if digits > 1 else digits; if abs(expected - computed) > thresh:; print(""\t%s: computed value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if exitonfail:; sys.exit(1); else:; return; if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f)\n"" % (label, computed, expected)); print(""\tprobably because the computed value is nan.""); if exitonfail:; sys.exit(1); else:; return; _success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:2965,Availability,failure,failure,2965,"computed) > thresh:; print(""\t%s: computed value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if exitonfail:; sys.exit(1); else:; return; if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f)\n"" % (label, computed, expected)); print(""\tprobably because the computed value is nan.""); if exitonfail:; sys.exit(1); else:; return; _success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label).",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:3416,Availability,failure,failure,3416,"e two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:6406,Availability,avail,available,6406,"th.join(path, filename)); else:; return None; ## end of http://code.activestate.com/recipes/52224/ }}}. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; #noDupes = []; #[noDupes.append(i) for i in seq if not noDupes.count(i)]; #return noDupes; noDupes = []; seq2 = sum(seq, []); [noDupes.append(i) for i in seq2 if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield ''; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def findfile_ignorecase(fil, pre='', post=''):; """"""Function to locate a file *pre* + *fil* + *post* in any possible ; lettercase permutation of *fil*. Returns *pre* + *fil* + *post* if ; available, None if not. """"""; afil = None; for per in list(all_casings(fil)):; if os.path.isfile(pre + per + post):; afil = pre + per + post; break; else:; pass. return afil. Quick search. Enter search ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:6478,Availability,avail,available,6478,"docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; #noDupes = []; #[noDupes.append(i) for i in seq if not noDupes.count(i)]; #return noDupes; noDupes = []; seq2 = sum(seq, []); [noDupes.append(i) for i in seq2 if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield ''; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def findfile_ignorecase(fil, pre='', post=''):; """"""Function to locate a file *pre* + *fil* + *post* in any possible ; lettercase permutation of *fil*. Returns *pre* + *fil* + *post* if ; available, None if not. """"""; afil = None; for per in list(all_casings(fil)):; if os.path.isfile(pre + per + post):; afil = pre + per + post; break; else:; pass. return afil. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a7",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:6809,Availability,avail,available,6809,"ee of which duplicate entry is dropped. """"""; #noDupes = []; #[noDupes.append(i) for i in seq if not noDupes.count(i)]; #return noDupes; noDupes = []; seq2 = sum(seq, []); [noDupes.append(i) for i in seq2 if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield ''; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def findfile_ignorecase(fil, pre='', post=''):; """"""Function to locate a file *pre* + *fil* + *post* in any possible ; lettercase permutation of *fil*. Returns *pre* + *fil* + *post* if ; available, None if not. """"""; afil = None; for per in list(all_casings(fil)):; if os.path.isfile(pre + per + post):; afil = pre + per + post; break; else:; pass. return afil. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:7173,Availability,avail,available,7173,"ee of which duplicate entry is dropped. """"""; #noDupes = []; #[noDupes.append(i) for i in seq if not noDupes.count(i)]; #return noDupes; noDupes = []; seq2 = sum(seq, []); [noDupes.append(i) for i in seq2 if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield ''; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def findfile_ignorecase(fil, pre='', post=''):; """"""Function to locate a file *pre* + *fil* + *post* in any possible ; lettercase permutation of *fil*. Returns *pre* + *fil* + *post* if ; available, None if not. """"""; afil = None; for per in list(all_casings(fil)):; if os.path.isfile(pre + per + post):; afil = pre + per + post; break; else:; pass. return afil. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:7543,Deployability,update,updated,7543,"ee of which duplicate entry is dropped. """"""; #noDupes = []; #[noDupes.append(i) for i in seq if not noDupes.count(i)]; #return noDupes; noDupes = []; seq2 = sum(seq, []); [noDupes.append(i) for i in seq2 if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield ''; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def findfile_ignorecase(fil, pre='', post=''):; """"""Function to locate a file *pre* + *fil* + *post* in any possible ; lettercase permutation of *fil*. Returns *pre* + *fil* + *post* if ; available, None if not. """"""; afil = None; for per in list(all_casings(fil)):; if os.path.isfile(pre + per + post):; afil = pre + per + post; break; else:; pass. return afil. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:1834,Integrability,message,message,1834,"al Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; from __future__ import absolute_import; from __future__ import print_function; import sys; import math; import re; import os; import string; from .vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label, exitonfail=True):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* > 1 e.g. digits=0.04). Performs; a system exit on failure unless *exitonfail* False, in which case; returns error message. Used in input files in the test suite. """"""; thresh = 10 ** -digits if digits > 1 else digits; if abs(expected - computed) > thresh:; print(""\t%s: computed value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if exitonfail:; sys.exit(1); else:; return; if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f)\n"" % (label, computed, expected)); print(""\tprobably because the computed value is nan.""); if exitonfail:; sys.exit(1); else:; return; _success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:1870,Testability,test,test,1870,"ee Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; from __future__ import absolute_import; from __future__ import print_function; import sys; import math; import re; import os; import string; from .vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label, exitonfail=True):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* > 1 e.g. digits=0.04). Performs; a system exit on failure unless *exitonfail* False, in which case; returns error message. Used in input files in the test suite. """"""; thresh = 10 ** -digits if digits > 1 else digits; if abs(expected - computed) > thresh:; print(""\t%s: computed value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if exitonfail:; sys.exit(1); else:; return; if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f)\n"" % (label, computed, expected)); print(""\tprobably because the computed value is nan.""); if exitonfail:; sys.exit(1); else:; return; _success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:fun",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:2595,Testability,test,test,2595,"s :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* > 1 e.g. digits=0.04). Performs; a system exit on failure unless *exitonfail* False, in which case; returns error message. Used in input files in the test suite. """"""; thresh = 10 ** -digits if digits > 1 else digits; if abs(expected - computed) > thresh:; print(""\t%s: computed value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if exitonfail:; sys.exit(1); else:; return; if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f)\n"" % (label, computed, expected)); print(""\tprobably because the computed value is nan.""); if exitonfail:; sys.exit(1); else:; return; _success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:3001,Testability,test,test,3001,"puted value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if exitonfail:; sys.exit(1); else:; return; if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f)\n"" % (label, computed, expected)); print(""\tprobably because the computed value is nan.""); if exitonfail:; sys.exit(1); else:; return; _success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, defa",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html:3512,Testability,test,test,3512,"d* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). if default == None:; prompt = "" [y/n] ""; elif default == True:; pro",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psivardefs.html:12665,Deployability,update,updated,12665,"['SAPT2+3(CCD) ELST ENERGY'] = {'func': sum, 'args': ['SAPT2+3 ELST ENERGY']}; pv1['SAPT2+3(CCD) EXCH ENERGY'] = {'func': sum, 'args': ['SAPT2+3 EXCH ENERGY']}; pv1['SAPT2+3(CCD) IND ENERGY'] = {'func': sum, 'args': ['SAPT2+3 IND ENERGY']}; pv1['SAPT2+3(CCD) DISP ENERGY'] = {'func': lambda x: x[1] + x[2] + x[0] * x[3] + x[4] + x[0] * x[5],; 'args': ['SAPT EXCHSCAL', 'SAPT CCD DISP', 'SAPT DISP30 ENERGY', 'SAPT EXCH-DISP30 ENERGY',; 'SAPT IND-DISP30 ENERGY', 'SAPT EXCH-IND-DISP30 ENERGY']}; pv1['SAPT2+3(CCD) TOTAL ENERGY'] = {'func': sum, 'args': ['SAPT2+3(CCD) ELST ENERGY', 'SAPT2+3(CCD) EXCH ENERGY', 'SAPT2+3(CCD) IND ENERGY', 'SAPT2+3(CCD) DISP ENERGY']}; pv1['SAPT2+3DMP2 ELST ENERGY'] = {'func': sum, 'args': ['SAPT2+3 ELST ENERGY']}; pv1['SAPT2+3DMP2 EXCH ENERGY'] = {'func': sum, 'args': ['SAPT2+3 EXCH ENERGY']}; pv1['SAPT2+3DMP2 IND ENERGY'] = {'func': sum, 'args': ['SAPT2+3 IND ENERGY', 'SAPT MP2(3) ENERGY']}; pv1['SAPT2+3DMP2 DISP ENERGY'] = {'func': sum, 'args': ['SAPT2+3 DISP ENERGY']}; pv1['SAPT2+3DMP2 TOTAL ENERGY'] = {'func': sum, 'args': ['SAPT2+3DMP2 ELST ENERGY', 'SAPT2+3DMP2 EXCH ENERGY', 'SAPT2+3DMP2 IND ENERGY', 'SAPT2+3DMP2 DISP ENERGY']}; pv1['SAPT2+3(CCD)DMP2 ELST ENERGY'] = {'func': sum, 'args': ['SAPT2+3 ELST ENERGY']}; pv1['SAPT2+3(CCD)DMP2 EXCH ENERGY'] = {'func': sum, 'args': ['SAPT2+3 EXCH ENERGY']}; pv1['SAPT2+3(CCD)DMP2 IND ENERGY'] = {'func': sum, 'args': ['SAPT2+3DMP2 IND ENERGY']}; pv1['SAPT2+3(CCD)DMP2 DISP ENERGY'] = {'func': sum, 'args': ['SAPT2+3(CCD) DISP ENERGY']}; pv1['SAPT2+3(CCD)DMP2 TOTAL ENERGY'] = {'func': sum, 'args': ['SAPT2+3(CCD)DMP2 ELST ENERGY', 'SAPT2+3(CCD)DMP2 EXCH ENERGY', 'SAPT2+3(CCD)DMP2 IND ENERGY', 'SAPT2+3(CCD)DMP2 DISP ENERGY']}. return pv1. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/psivardefs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psivardefs.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qcformat.html:1873,Availability,down,down,1873,",; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Parent classes for quantum chemistry program input and output file; formats.; """"""; from __future__ import absolute_import; from __future__ import print_function; import re. [docs]class InputFormat(object):. def __init__(self, mem, mtd, bas, mol, sys, cast):. # total job memory in MB; self.memory = mem; # computational method; self.method = mtd.lower(); # qcdb.Molecule object; self.molecule = mol; # database member index; self.index = sys; # orbital basis set; self.basis = bas.lower(); # do cast up from sto-3g basis?; self.castup = cast. [docs] def corresponding_aux_basis(self):; """"""For Dunning basis sets, returns strings from which auxiliary; basis sets and heavy-aug can be constructed. Note that; valence/core-valence/etc. is conserved and X-zeta/(X+d)zeta is; not, since this is the usual aux basis pattern.; *augbasis* is round up to the nearest aug-cc-pVXZ; *rootbasis* is round down to the nearest cc-pVXZ; *auxbasis* is round up to the nearest cc-pVXZ or aug-cc-pVXZ; """"""; Dunmatch = re.compile(r'^(.*cc-)(pv|pcv|pwcv).*?([dtq56]).*z$').match(self.basis). if Dunmatch:; rootbas = 'cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; augbas = 'aug-cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; if Dunmatch.group(1) == 'cc-':; auxbas = rootbas; else:; auxbas = augbas; else:; rootbas = None; augbas = None; auxbas = None. return [rootbas, augbas, auxbas]. [docs]class InputFormat2(object):. def __init__(self, mem, mol, mtd, der, opt):. # total job memory in MB; self.memory = mem; # qcdb.Molecule object; self.molecule = mol; # computational method; self.method = mtd.lower(); # computational derivative level; self.dertype = der; # options dictionary; self.options = opt; # orbital basis set; self.basis = opt['GLOBALS']['BASIS']['value'].lower(); # do cast up from sto-3g basis?; self.castup = opt['SCF']['BASIS_GUESS']['value']. [docs] def corresponding_aux_basis(self):; """"""For Dunning ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qcformat.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qcformat.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qcformat.html:3182,Availability,down,down,3182,"rest cc-pVXZ or aug-cc-pVXZ; """"""; Dunmatch = re.compile(r'^(.*cc-)(pv|pcv|pwcv).*?([dtq56]).*z$').match(self.basis). if Dunmatch:; rootbas = 'cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; augbas = 'aug-cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; if Dunmatch.group(1) == 'cc-':; auxbas = rootbas; else:; auxbas = augbas; else:; rootbas = None; augbas = None; auxbas = None. return [rootbas, augbas, auxbas]. [docs]class InputFormat2(object):. def __init__(self, mem, mol, mtd, der, opt):. # total job memory in MB; self.memory = mem; # qcdb.Molecule object; self.molecule = mol; # computational method; self.method = mtd.lower(); # computational derivative level; self.dertype = der; # options dictionary; self.options = opt; # orbital basis set; self.basis = opt['GLOBALS']['BASIS']['value'].lower(); # do cast up from sto-3g basis?; self.castup = opt['SCF']['BASIS_GUESS']['value']. [docs] def corresponding_aux_basis(self):; """"""For Dunning basis sets, returns strings from which auxiliary; basis sets and heavy-aug can be constructed. Note that; valence/core-valence/etc. is conserved and X-zeta/(X+d)zeta is; not, since this is the usual aux basis pattern.; *augbasis* is round up to the nearest aug-cc-pVXZ; *rootbasis* is round down to the nearest cc-pVXZ; *auxbasis* is round up to the nearest cc-pVXZ or aug-cc-pVXZ; """"""; Dunmatch = re.compile(r'^(.*cc-)(pv|pcv|pwcv).*?([dtq56]).*z$').match(self.basis). if Dunmatch:; rootbas = 'cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; augbas = 'aug-cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; if Dunmatch.group(1) == 'cc-':; auxbas = rootbas; else:; auxbas = augbas; else:; rootbas = None; augbas = None; auxbas = None. return [rootbas, augbas, auxbas]. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qcformat.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qcformat.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qcformat.html:3861,Deployability,update,updated,3861,"rest cc-pVXZ or aug-cc-pVXZ; """"""; Dunmatch = re.compile(r'^(.*cc-)(pv|pcv|pwcv).*?([dtq56]).*z$').match(self.basis). if Dunmatch:; rootbas = 'cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; augbas = 'aug-cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; if Dunmatch.group(1) == 'cc-':; auxbas = rootbas; else:; auxbas = augbas; else:; rootbas = None; augbas = None; auxbas = None. return [rootbas, augbas, auxbas]. [docs]class InputFormat2(object):. def __init__(self, mem, mol, mtd, der, opt):. # total job memory in MB; self.memory = mem; # qcdb.Molecule object; self.molecule = mol; # computational method; self.method = mtd.lower(); # computational derivative level; self.dertype = der; # options dictionary; self.options = opt; # orbital basis set; self.basis = opt['GLOBALS']['BASIS']['value'].lower(); # do cast up from sto-3g basis?; self.castup = opt['SCF']['BASIS_GUESS']['value']. [docs] def corresponding_aux_basis(self):; """"""For Dunning basis sets, returns strings from which auxiliary; basis sets and heavy-aug can be constructed. Note that; valence/core-valence/etc. is conserved and X-zeta/(X+d)zeta is; not, since this is the usual aux basis pattern.; *augbasis* is round up to the nearest aug-cc-pVXZ; *rootbasis* is round down to the nearest cc-pVXZ; *auxbasis* is round up to the nearest cc-pVXZ or aug-cc-pVXZ; """"""; Dunmatch = re.compile(r'^(.*cc-)(pv|pcv|pwcv).*?([dtq56]).*z$').match(self.basis). if Dunmatch:; rootbas = 'cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; augbas = 'aug-cc-' + Dunmatch.group(2) + Dunmatch.group(3) + 'z'; if Dunmatch.group(1) == 'cc-':; auxbas = rootbas; else:; auxbas = augbas; else:; rootbas = None; augbas = None; auxbas = None. return [rootbas, augbas, auxbas]. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qcformat.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qcformat.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:12109,Availability,avail,available,12109,"S_BUFFER']['value'] = 512; options['QCHEM']['QCHEM_MAX_SCF_CYCLES']['value'] = 200. options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; options['QCHEM']['QCHEM_SYMMETRY']['value'] = False; options['QCHEM']['QCHEM_INTEGRALS_BUFFER']['value'] = 512. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; options['QCHEM']['QCHEM_JOBTYPE']['value'] = 'SP'; # text += """"""energy('""""""; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'wb97x-v':; options['QCHEM']['QCHEM_EXCHANGE']['value'] = 'omegaB97X-V'. # text += """"""mp2')\n\n""""""; #; # elif lowername == 'df-mp2':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['MP2']['MP2_TYPE']['value'] = 'df'; # text += """"""mp2')\n\n""""""; #; # elif lowername == 'sapt0':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # text += """"""sapt0')\n\n""""""; #; # elif lowername == 'sapt2+':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['SAPT']['NAT_ORBS_T2']['value'] = True; # options['SAPT']['NAT_ORBS_T3']['value'] = True; # options['SAPT']['NAT_ORBS_V4']['value'] = True; # options['SAPT']['OCC_TOLERANCE']['value'] = 1.0e-6; # text += """"""sapt2+')\n\n""""""; #; # elif lowername == 'sapt2+(3)':; # options[",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:16041,Availability,avail,available,16041,"wpbe')\n\n""""""; #; # elif lowername == 'ccsd-polarizability':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # text = """"""property('ccsd', properties=['polarizability'])\n\n""""""; #; # elif lowername == 'mrccsdt(q)':; # options['SCF']['SCF_TYPE']['value'] = 'pk'; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['GLOBALS']['NAT_ORBS']['value'] = True # needed by mrcc but not recognized by mrcc; # options['FNOCC']['OCC_TOLERANCE']['value'] = 6; # text += """"""mrccsdt(q)')\n\n""""""; #; # elif lowername == 'c4-ccsdt(q)':; # options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; # options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; # options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; # text += """"""c4-ccsdt(q)')\n\n""""""; #; # elif lowername == 'df-m05-2x':; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; # options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; # text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'wb97x-v' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return sorted(procedures['energy'].keys()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 0",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:16972,Deployability,update,updated,16972,"csd-polarizability':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # text = """"""property('ccsd', properties=['polarizability'])\n\n""""""; #; # elif lowername == 'mrccsdt(q)':; # options['SCF']['SCF_TYPE']['value'] = 'pk'; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['GLOBALS']['NAT_ORBS']['value'] = True # needed by mrcc but not recognized by mrcc; # options['FNOCC']['OCC_TOLERANCE']['value'] = 6; # text += """"""mrccsdt(q)')\n\n""""""; #; # elif lowername == 'c4-ccsdt(q)':; # options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; # options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; # options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; # text += """"""c4-ccsdt(q)')\n\n""""""; #; # elif lowername == 'df-m05-2x':; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; # options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; # text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'wb97x-v' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return sorted(procedures['energy'].keys()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:4806,Energy Efficiency,energy,energy,4806," +; r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched dft'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); # with negative lookahead; #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(2); #psivar['DFT TOTAL ENERGY'] = mobj.group(3); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(3). # Process DHDFT no-D or internal-D; mobj = re.search(; # negative grimme3 lookahead goes here; #r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; #r'(?:.*?)' +; r'(?:HF-DFT SCF calculation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total (?:RI)?MP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:(?:RI)?MP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched dhdft'); #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); psivar['DOUBLE-HYBRID CORRECTION ENERGY'] = mobj.group(1). # Process MP2; mobj = re.search(; r'(?:Hartree-Fock SCF calculation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total RIMP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:RIMP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched mp2'); #psivar['NUCLEAR REPULSION ENER",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:4896,Energy Efficiency,energy,energy,4896," +; r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched dft'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); # with negative lookahead; #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(2); #psivar['DFT TOTAL ENERGY'] = mobj.group(3); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(3). # Process DHDFT no-D or internal-D; mobj = re.search(; # negative grimme3 lookahead goes here; #r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; #r'(?:.*?)' +; r'(?:HF-DFT SCF calculation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total (?:RI)?MP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:(?:RI)?MP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched dhdft'); #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); psivar['DOUBLE-HYBRID CORRECTION ENERGY'] = mobj.group(1). # Process MP2; mobj = re.search(; r'(?:Hartree-Fock SCF calculation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total RIMP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:RIMP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched mp2'); #psivar['NUCLEAR REPULSION ENER",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:5564,Energy Efficiency,energy,energy,5564,"'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total (?:RI)?MP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:(?:RI)?MP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched dhdft'); #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); psivar['DOUBLE-HYBRID CORRECTION ENERGY'] = mobj.group(1). # Process MP2; mobj = re.search(; r'(?:Hartree-Fock SCF calculation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total RIMP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:RIMP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched mp2'); #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); psivar['MP2 CORRELATION ENERGY'] = mobj.group(1); #psivar['DOUBLE-HYBRID CORRECTION ENERGY'] = mobj.group(1); print(psivar). # TODO: need to split on 'Q-Chem begins' or 'Quantum Leap' or something. # # Process DFT no-D or internal-D WORKS BUT LOOKAHEAD VERY SLOW; # mobj = re.search(; # r'((?!grimme3).)*' + r'\s*' + # severe negative performance impact; # TODO note neg lookahead insufficient since option could be negated; # r'(?:.*?)' +; # r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; # r'(?:.*?)' +; # r'(?:HF-DFT SCF calculation)' +; # r'(?:.*?)' +; # r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMB",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:5649,Energy Efficiency,energy,energy,5649,"'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total (?:RI)?MP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:(?:RI)?MP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched dhdft'); #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); psivar['DOUBLE-HYBRID CORRECTION ENERGY'] = mobj.group(1). # Process MP2; mobj = re.search(; r'(?:Hartree-Fock SCF calculation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total RIMP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:RIMP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched mp2'); #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); psivar['MP2 CORRELATION ENERGY'] = mobj.group(1); #psivar['DOUBLE-HYBRID CORRECTION ENERGY'] = mobj.group(1); print(psivar). # TODO: need to split on 'Q-Chem begins' or 'Quantum Leap' or something. # # Process DFT no-D or internal-D WORKS BUT LOOKAHEAD VERY SLOW; # mobj = re.search(; # r'((?!grimme3).)*' + r'\s*' + # severe negative performance impact; # TODO note neg lookahead insufficient since option could be negated; # r'(?:.*?)' +; # r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; # r'(?:.*?)' +; # r'(?:HF-DFT SCF calculation)' +; # r'(?:.*?)' +; # r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMB",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:9449,Energy Efficiency,energy,energy,9449,"ol, mtd, der, opt). # #print self.method, self.molecule.nactive_fragments(); # if 'sapt' in self.method and self.molecule.nactive_fragments() != 2:; # raise FragmentCountError(""""""Requested molecule has %d, not 2, fragments."""""" % (self.molecule.nactive_fragments())); #; ## # memory in MB --> MW; ## self.memory = int(math.ceil(mem / 8.0)); ## # auxiliary basis sets; ## [self.unaugbasis, self.augbasis, self.auxbasis] = self.corresponding_aux_basis(). [docs] def format_infile_string(self):; """""". """"""; # Handle memory and comment; cmtcmd = """"""$comment\n%s\n$end\n\n"""""" % (self.molecule.tagline); memcmd, memkw = muster_memory(self.memory). # Handle molecule and basis set; molcmd, molkw = self.molecule.format_molecule_for_qchem(mixedbas=False); # TODO mixedbas=True once handling basis sets. # not translating basis at present; _bascmd, baskw = muster_basis(self.basis). # format global convergence directions; _cdscmd, cdskw = muster_cdsgroup_options(). # Handle calc type and quantum chemical method; mdccmd, mdckw = procedures['energy'][self.method](self.method, self.dertype). ## make options from imdb only user options (currently non-existent). set basis and castup from here.; # Handle driver vs input/default keyword reconciliation; userkw = self.options # p4util.prepare_options_for_modules(); userkw = options.reconcile_options2(userkw, memkw); userkw = options.reconcile_options2(userkw, molkw); userkw = options.reconcile_options2(userkw, baskw); #userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = options.reconcile_options2(userkw, cdskw); userkw = options.reconcile_options2(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = options.prepare_options_for_qchem(userkw). # Handle text to be passed untouched to psi4; litcmd = ''. # Assemble infile pieces; return cmtcmd + memcmd + molcmd + optcmd + mdccmd + litcmd. #'hf'; #'df-hf'; #'b3lyp'; #'blyp'; #'bp86'; #'fno-ccsd(t)'; #'df-ccsd(t)'; #'fno-df-ccsd(t)'; #'df-b97-d'; #'df-b97-d",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:12031,Energy Efficiency,energy,energy,12031,"S_BUFFER']['value'] = 512; options['QCHEM']['QCHEM_MAX_SCF_CYCLES']['value'] = 200. options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; options['QCHEM']['QCHEM_SYMMETRY']['value'] = False; options['QCHEM']['QCHEM_INTEGRALS_BUFFER']['value'] = 512. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; options['QCHEM']['QCHEM_JOBTYPE']['value'] = 'SP'; # text += """"""energy('""""""; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'wb97x-v':; options['QCHEM']['QCHEM_EXCHANGE']['value'] = 'omegaB97X-V'. # text += """"""mp2')\n\n""""""; #; # elif lowername == 'df-mp2':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['MP2']['MP2_TYPE']['value'] = 'df'; # text += """"""mp2')\n\n""""""; #; # elif lowername == 'sapt0':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # text += """"""sapt0')\n\n""""""; #; # elif lowername == 'sapt2+':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['SAPT']['NAT_ORBS_T2']['value'] = True; # options['SAPT']['NAT_ORBS_T3']['value'] = True; # options['SAPT']['NAT_ORBS_V4']['value'] = True; # options['SAPT']['OCC_TOLERANCE']['value'] = 1.0e-6; # text += """"""sapt2+')\n\n""""""; #; # elif lowername == 'sapt2+(3)':; # options[",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:16572,Energy Efficiency,energy,energy,16572,"csd-polarizability':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # text = """"""property('ccsd', properties=['polarizability'])\n\n""""""; #; # elif lowername == 'mrccsdt(q)':; # options['SCF']['SCF_TYPE']['value'] = 'pk'; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['GLOBALS']['NAT_ORBS']['value'] = True # needed by mrcc but not recognized by mrcc; # options['FNOCC']['OCC_TOLERANCE']['value'] = 6; # text += """"""mrccsdt(q)')\n\n""""""; #; # elif lowername == 'c4-ccsdt(q)':; # options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; # options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; # options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; # text += """"""c4-ccsdt(q)')\n\n""""""; #; # elif lowername == 'df-m05-2x':; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; # options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; # text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'wb97x-v' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return sorted(procedures['energy'].keys()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:16643,Energy Efficiency,energy,energy,16643,"csd-polarizability':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # text = """"""property('ccsd', properties=['polarizability'])\n\n""""""; #; # elif lowername == 'mrccsdt(q)':; # options['SCF']['SCF_TYPE']['value'] = 'pk'; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['GLOBALS']['NAT_ORBS']['value'] = True # needed by mrcc but not recognized by mrcc; # options['FNOCC']['OCC_TOLERANCE']['value'] = 6; # text += """"""mrccsdt(q)')\n\n""""""; #; # elif lowername == 'c4-ccsdt(q)':; # options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; # options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; # options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; # text += """"""c4-ccsdt(q)')\n\n""""""; #; # elif lowername == 'df-m05-2x':; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; # options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; # text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'wb97x-v' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return sorted(procedures['energy'].keys()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:16758,Energy Efficiency,energy,energy,16758,"csd-polarizability':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # text = """"""property('ccsd', properties=['polarizability'])\n\n""""""; #; # elif lowername == 'mrccsdt(q)':; # options['SCF']['SCF_TYPE']['value'] = 'pk'; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['GLOBALS']['NAT_ORBS']['value'] = True # needed by mrcc but not recognized by mrcc; # options['FNOCC']['OCC_TOLERANCE']['value'] = 6; # text += """"""mrccsdt(q)')\n\n""""""; #; # elif lowername == 'c4-ccsdt(q)':; # options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; # options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; # options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; # text += """"""c4-ccsdt(q)')\n\n""""""; #; # elif lowername == 'df-m05-2x':; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; # options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; # text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'wb97x-v' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with energies. """"""; return sorted(procedures['energy'].keys()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:3643,Performance,perform,performance,3643,"mobj:; # print('matched dft-d2'); # psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); # psivar['DISPERSION CORRECTION ENERGY'] = mobj.group(2); # psivar['DFT TOTAL ENERGY'] = mobj.group(3); # psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(3) - mboj.group(2). # Process DFT-D3 UNTESTED; # mobj = re.search(; # r'(?:grimme3)' + r'\s*' +; # r'(?:.*?)' +; # r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; # r'(?:.*?)' +; # r'(?:HF-DFT SCF calculation)' +; # r'(?:.*?)' +; # r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*$',; # outtext, re.MULTILINE | re.DOTALL); # if mobj:; # print('matched dft-d3'); # psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); # psivar['DISPERSION CORRECTION ENERGY'] = None; # psivar['DFT TOTAL ENERGY'] = mobj.group(2); # psivar['DFT FUNCTIONAL TOTAL ENERGY'] = None. # /^((?!PART).)*$/. # Process DFT no-D or internal-D; mobj = re.search(; # r'((?!grimme3).)*' + r'\s*' + # severe negative performance impact; # r'(?:.*?)' +; r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; r'(?:.*?)' +; r'(?:HF-DFT SCF calculation)' +; r'(?:.*?)' +; r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched dft'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); # with negative lookahead; #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(2); #psivar['DFT TOTAL ENERGY'] = mobj.group(3); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(3). # Process DHDFT no-D or internal-D; mobj = re.search(; # negative grimme3 lookahead goes here; #r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; #r'(?:.*?)' +; r'(?:HF-DFT SCF calculation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergenc",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:6280,Performance,perform,performance,6280,"culation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total RIMP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:RIMP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched mp2'); #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); psivar['MP2 CORRELATION ENERGY'] = mobj.group(1); #psivar['DOUBLE-HYBRID CORRECTION ENERGY'] = mobj.group(1); print(psivar). # TODO: need to split on 'Q-Chem begins' or 'Quantum Leap' or something. # # Process DFT no-D or internal-D WORKS BUT LOOKAHEAD VERY SLOW; # mobj = re.search(; # r'((?!grimme3).)*' + r'\s*' + # severe negative performance impact; # TODO note neg lookahead insufficient since option could be negated; # r'(?:.*?)' +; # r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; # r'(?:.*?)' +; # r'(?:HF-DFT SCF calculation)' +; # r'(?:.*?)' +; # r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*$',; # outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); # if mobj:; # print('matched dft'); # psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(2); # psivar['DFT TOTAL ENERGY'] = mobj.group(3); # psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(3). # # Process PsiVariables; # mobj = re.search(r'^(?: Variable Map:)\s*' +; # r'^\s*(?:-+)\s*' +; # r'^(.*?)' +; # r'^(?:\s*?)$',; # outtext, re.MULTILINE | re.DOTALL); #; # if mobj:; # for pv in mobj.group(1).split('\n'):; # submobj = re.search(r'^\s+' + r'""(.+?)""' + r'\s+=>\s+' + NUMBER + r'\s*$', pv); # if submobj:; # psivar['%s' % (submobj.group(1))] = submobj.group(2). # Process Completion; mobj = re.search(r'Thank you very m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/qchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html:3321,Deployability,update,updated,3321,"t(); return ssA.intersection(ssB). [docs]def genset_DDn5min(dbinstance):; """"""DD-5min; near-equilibrium systems also in dd. """"""; try:; ssA = set(dbinstance.sset['dd'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_MXDDPPn5min(dbinstance):; """"""MXDDPP-5min; near-equilibrium systems also in mxddpp. """"""; try:; ssA = set(dbinstance.sset['mxddpp'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_MXDDNPn5min(dbinstance):; """"""MXDDNP-5min; near-equilibrium systems also in mxddnp. """"""; try:; ssA = set(dbinstance.sset['mxddnp'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_allneutral(dbinstance):; """"""neutral; systems where all components are neutral. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; if all([True if rgt.charge == 0 else False for rgt in orxn.rxnm['default'].keys()]):; eligible.append(rxn); return eligible. [docs]def genset_anyanion(dbinstance):; """"""anion; systems where any component is an anion. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; for rgt in orxn.rxnm['default'].keys():; if rgt.charge < 0:; eligible.append(rxn); break; return eligible. [docs]def genset_anycation(dbinstance):; """"""cation; systems where any component is a cation. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; for rgt in orxn.rxnm['default'].keys():; if rgt.charge > 0:; eligible.append(rxn); break; return eligible. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html:2488,Energy Efficiency,charge,charge,2488,"t(); return ssA.intersection(ssB). [docs]def genset_DDn5min(dbinstance):; """"""DD-5min; near-equilibrium systems also in dd. """"""; try:; ssA = set(dbinstance.sset['dd'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_MXDDPPn5min(dbinstance):; """"""MXDDPP-5min; near-equilibrium systems also in mxddpp. """"""; try:; ssA = set(dbinstance.sset['mxddpp'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_MXDDNPn5min(dbinstance):; """"""MXDDNP-5min; near-equilibrium systems also in mxddnp. """"""; try:; ssA = set(dbinstance.sset['mxddnp'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_allneutral(dbinstance):; """"""neutral; systems where all components are neutral. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; if all([True if rgt.charge == 0 else False for rgt in orxn.rxnm['default'].keys()]):; eligible.append(rxn); return eligible. [docs]def genset_anyanion(dbinstance):; """"""anion; systems where any component is an anion. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; for rgt in orxn.rxnm['default'].keys():; if rgt.charge < 0:; eligible.append(rxn); break; return eligible. [docs]def genset_anycation(dbinstance):; """"""cation; systems where any component is a cation. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; for rgt in orxn.rxnm['default'].keys():; if rgt.charge > 0:; eligible.append(rxn); break; return eligible. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html:2799,Energy Efficiency,charge,charge,2799,"t(); return ssA.intersection(ssB). [docs]def genset_DDn5min(dbinstance):; """"""DD-5min; near-equilibrium systems also in dd. """"""; try:; ssA = set(dbinstance.sset['dd'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_MXDDPPn5min(dbinstance):; """"""MXDDPP-5min; near-equilibrium systems also in mxddpp. """"""; try:; ssA = set(dbinstance.sset['mxddpp'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_MXDDNPn5min(dbinstance):; """"""MXDDNP-5min; near-equilibrium systems also in mxddnp. """"""; try:; ssA = set(dbinstance.sset['mxddnp'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_allneutral(dbinstance):; """"""neutral; systems where all components are neutral. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; if all([True if rgt.charge == 0 else False for rgt in orxn.rxnm['default'].keys()]):; eligible.append(rxn); return eligible. [docs]def genset_anyanion(dbinstance):; """"""anion; systems where any component is an anion. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; for rgt in orxn.rxnm['default'].keys():; if rgt.charge < 0:; eligible.append(rxn); break; return eligible. [docs]def genset_anycation(dbinstance):; """"""cation; systems where any component is a cation. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; for rgt in orxn.rxnm['default'].keys():; if rgt.charge > 0:; eligible.append(rxn); break; return eligible. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html:3066,Energy Efficiency,charge,charge,3066,"t(); return ssA.intersection(ssB). [docs]def genset_DDn5min(dbinstance):; """"""DD-5min; near-equilibrium systems also in dd. """"""; try:; ssA = set(dbinstance.sset['dd'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_MXDDPPn5min(dbinstance):; """"""MXDDPP-5min; near-equilibrium systems also in mxddpp. """"""; try:; ssA = set(dbinstance.sset['mxddpp'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_MXDDNPn5min(dbinstance):; """"""MXDDNP-5min; near-equilibrium systems also in mxddnp. """"""; try:; ssA = set(dbinstance.sset['mxddnp'].keys()); except KeyError:; ssA = set(); try:; ssB = set(dbinstance.sset['5min'].keys()); except KeyError:; ssB = set(); return ssA.intersection(ssB). [docs]def genset_allneutral(dbinstance):; """"""neutral; systems where all components are neutral. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; if all([True if rgt.charge == 0 else False for rgt in orxn.rxnm['default'].keys()]):; eligible.append(rxn); return eligible. [docs]def genset_anyanion(dbinstance):; """"""anion; systems where any component is an anion. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; for rgt in orxn.rxnm['default'].keys():; if rgt.charge < 0:; eligible.append(rxn); break; return eligible. [docs]def genset_anycation(dbinstance):; """"""cation; systems where any component is a cation. """"""; eligible = []; for rxn, orxn in dbinstance.hrxn.iteritems():; for rgt in orxn.rxnm['default'].keys():; if rgt.charge > 0:; eligible.append(rxn); break; return eligible. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/subsetgenerator.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:448,Availability,error,errors,448,". qcdb.textables  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.textables; from __future__ import absolute_import; from __future__ import print_function; import re; import sys; import itertools; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .modelchems import Method, BasisSet, Error, methods, bases, errors. try:; dict.iteritems; except AttributeError:; # Python 3; def itervalues(d):; return iter(d.values()); def iteritems(d):; return iter(d.items()); else:; # Python 2; [docs] def itervalues(d):; return d.itervalues(); [docs] def iteritems(d):; return d.iteritems(). mc_archive = {'mtd': methods, 'bas': bases, 'err': errors}; fancy_mc_archive = {}; for tier in [methods, bases, errors]:; for k, v in iteritems(tier):; fancy_mc_archive[k] = v.latex. # define helper functions for formatting table cells; [docs]def val(kw):; return r""""""%s%s"""""" % (kw['matelem'], kw['footnote']). [docs]def graphics(kw):; mc = '-'.join([kw[bit] for bit in ['mtd', 'opt', 'bas']]); return r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (kw['plotpath'], mc). [docs]def flat(kw):; if kw['matelem'].strip():; dbssmc = '-'.join([kw[bit] for bit in ['dbse', 'sset', 'mtd', 'opt', 'bas']]); return r""""""\includegraphics[width=6.67cm,height=3.5mm]{%sflat_%s.pdf}"""""" % (kw['plotpath'], dbssmc); else:; return ''. [docs]def liliowa(kw):; if kw['matelem'].strip():; dbssmc = '-'.join([kw[bit] for bit in ['dbse', 'sset', 'mtd', 'opt', 'bas']]); return r""""""\includegraphics[height=3.5mm]{%sliliowa_%s.pdf}"""""" % (kw['plotpath'], dbssmc); else:; return ''. [docs]def lmtdbas(kw):; return """"""%-25s"""""" % (methods[kw['mtd']].latex + '/' + bases[kw['bas']].latex). [docs]def label(kw):; kwt = kw['target']; return """""" %-25s"""""" % (mc_archive[kwt][kw[kwt]].latex if kwt in mc_archive else kw[kwt]). [docs]def label2(kw):; """"""This and fancy_mc_archive are experimental alter",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/textables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:770,Availability,error,errors,770,". qcdb.textables  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.textables; from __future__ import absolute_import; from __future__ import print_function; import re; import sys; import itertools; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .modelchems import Method, BasisSet, Error, methods, bases, errors. try:; dict.iteritems; except AttributeError:; # Python 3; def itervalues(d):; return iter(d.values()); def iteritems(d):; return iter(d.items()); else:; # Python 2; [docs] def itervalues(d):; return d.itervalues(); [docs] def iteritems(d):; return d.iteritems(). mc_archive = {'mtd': methods, 'bas': bases, 'err': errors}; fancy_mc_archive = {}; for tier in [methods, bases, errors]:; for k, v in iteritems(tier):; fancy_mc_archive[k] = v.latex. # define helper functions for formatting table cells; [docs]def val(kw):; return r""""""%s%s"""""" % (kw['matelem'], kw['footnote']). [docs]def graphics(kw):; mc = '-'.join([kw[bit] for bit in ['mtd', 'opt', 'bas']]); return r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (kw['plotpath'], mc). [docs]def flat(kw):; if kw['matelem'].strip():; dbssmc = '-'.join([kw[bit] for bit in ['dbse', 'sset', 'mtd', 'opt', 'bas']]); return r""""""\includegraphics[width=6.67cm,height=3.5mm]{%sflat_%s.pdf}"""""" % (kw['plotpath'], dbssmc); else:; return ''. [docs]def liliowa(kw):; if kw['matelem'].strip():; dbssmc = '-'.join([kw[bit] for bit in ['dbse', 'sset', 'mtd', 'opt', 'bas']]); return r""""""\includegraphics[height=3.5mm]{%sliliowa_%s.pdf}"""""" % (kw['plotpath'], dbssmc); else:; return ''. [docs]def lmtdbas(kw):; return """"""%-25s"""""" % (methods[kw['mtd']].latex + '/' + bases[kw['bas']].latex). [docs]def label(kw):; kwt = kw['target']; return """""" %-25s"""""" % (mc_archive[kwt][kw[kwt]].latex if kwt in mc_archive else kw[kwt]). [docs]def label2(kw):; """"""This and fancy_mc_archive are experimental alter",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/textables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:831,Availability,error,errors,831,". qcdb.textables  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.textables; from __future__ import absolute_import; from __future__ import print_function; import re; import sys; import itertools; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .modelchems import Method, BasisSet, Error, methods, bases, errors. try:; dict.iteritems; except AttributeError:; # Python 3; def itervalues(d):; return iter(d.values()); def iteritems(d):; return iter(d.items()); else:; # Python 2; [docs] def itervalues(d):; return d.itervalues(); [docs] def iteritems(d):; return d.iteritems(). mc_archive = {'mtd': methods, 'bas': bases, 'err': errors}; fancy_mc_archive = {}; for tier in [methods, bases, errors]:; for k, v in iteritems(tier):; fancy_mc_archive[k] = v.latex. # define helper functions for formatting table cells; [docs]def val(kw):; return r""""""%s%s"""""" % (kw['matelem'], kw['footnote']). [docs]def graphics(kw):; mc = '-'.join([kw[bit] for bit in ['mtd', 'opt', 'bas']]); return r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (kw['plotpath'], mc). [docs]def flat(kw):; if kw['matelem'].strip():; dbssmc = '-'.join([kw[bit] for bit in ['dbse', 'sset', 'mtd', 'opt', 'bas']]); return r""""""\includegraphics[width=6.67cm,height=3.5mm]{%sflat_%s.pdf}"""""" % (kw['plotpath'], dbssmc); else:; return ''. [docs]def liliowa(kw):; if kw['matelem'].strip():; dbssmc = '-'.join([kw[bit] for bit in ['dbse', 'sset', 'mtd', 'opt', 'bas']]); return r""""""\includegraphics[height=3.5mm]{%sliliowa_%s.pdf}"""""" % (kw['plotpath'], dbssmc); else:; return ''. [docs]def lmtdbas(kw):; return """"""%-25s"""""" % (methods[kw['mtd']].latex + '/' + bases[kw['bas']].latex). [docs]def label(kw):; kwt = kw['target']; return """""" %-25s"""""" % (mc_archive[kwt][kw[kwt]].latex if kwt in mc_archive else kw[kwt]). [docs]def label2(kw):; """"""This and fancy_mc_archive are experimental alter",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/textables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:5479,Availability,error,error,5479,"+ r""""""\footnotemark["""""" + str(localcounter) + ']' + res.group('cellpost')); changed = True; else:; newcells.append(cell); if changed:; lines2replace[idx] = '&'.join(newcells); for idx, line in iteritems(lines2replace):; text[idx] = line. # search-and-suppress ""blank"" lines; if suppressblanks:; for idx, line in enumerate(text):; if line.strip().endswith('\\'):; innards = ''.join(line.rstrip("""""" \\"""""").split('&')[1:]); if innards.isspace():; text[idx] = '%' + text[idx]. # finish out table; text.append(r""""""\end{tabular}""""""); text.append(r""""""\end{ruledtabular}""""""); for idx, fn in enumerate(footnotes):; text.append(r""""""\footnotetext[%d]{%s}"""""" % (idx + 1, fn)); for fn, idx in iteritems(otffootnotes):; text.append(r""""""\footnotetext[%d]{%s}"""""" % (idx, fn)); text.append(r""""""\end{%s}"""""" % ('sidewaystable' if landscape else 'table')); text.append(r""""""\endgroup""""""); text.append(r""""""\clearpage""""""); text.append(''). def matelem(dict_row, dict_col):; """"""Return merge of index dictionaries *dict_row* and *dict_col* (precedence) with error string from serrors appended at key 'matelem'.""""""; kw = dict(dict_row, **dict_col); errpiece = serrors['-'.join([kw[bit] for bit in ['mtd', 'opt', 'bas']])][kw['sset']][kw['dbse']]; kw['matelem'] = errpiece[kw['err']]; if 'tgtcnt' in errpiece:; kw['count'] = errpiece['tgtcnt']; if 'misscnt' in errpiece and errpiece['misscnt'] != 0 and 'tgtcnt' in errpiece:; kw['footnote'] = r""""""\footnotemark{Missing %d of %d reactions.}"""""" % (errpiece['misscnt'], errpiece['tgtcnt']); else:; kw['footnote'] = ''; return kw. # avoid misunderstandings; keysincolumnplan = set(sum([col[-1].keys() for col in columnplan], [])); for key in ['dbse', 'sset', 'mtd', 'opt', 'bas', 'err']:; if len(locals()[key]) > 1:; if key not in rowplan and key not in keysincolumnplan:; print(""""""Warning: non-first values in argument '{0}' won't """"""; """"""get used. Add '{0}' to rowplan to iterate over """"""; """"""the values or add to columnplan to access""""""; """"""different values."""""".format(key)); sys",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/textables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:15853,Deployability,update,updated,15853,"('mae', ' 0.90'), ('mape', ' 113.9')]), 'HSG': OrderedDict([('mae', ' 0.55'), ('mape', ' 53.3')]), 'DB4': OrderedDict([('mae', ' 0.84'), ('mape', ' 64.3')])}}, 'MP2-CP-adz': {'hb': {'S22': OrderedDict([('mae', ' 1.64'), ('mape', ' 12.2')]), 'HBC1': OrderedDict([('mae', ' 1.41'), ('mape', ' 10.4')]), 'NBC1': None, 'HSG': OrderedDict([('mae', ' 1.42'), ('mape', ' 9.1')]), 'DB4': OrderedDict([('mae', ' 1.49'), ('mape', ' 10.6')])}, 'default': {'S22': OrderedDict([('mae', ' 0.97'), ('mape', ' 16.2')]), 'HBC1': OrderedDict([('mae', ' 1.41'), ('mape', ' 10.4')]), 'NBC1': OrderedDict([('mae', ' 0.70'), ('mape', ' 95.9')]), 'HSG': OrderedDict([('mae', ' 0.46'), ('mape', ' 30.5')]), 'DB4': OrderedDict([('mae', ' 0.88'), ('mape', ' 38.3')])}, 'mxdd': {'S22': OrderedDict([('mae', ' 0.65'), ('mape', ' 18.0')]), 'HBC1': None, 'NBC1': OrderedDict([('mae', ' 0.70'), ('mape', ' 95.9')]), 'HSG': OrderedDict([('mae', ' 0.30'), ('mape', ' 34.1')]), 'DB4': OrderedDict([('mae', ' 0.55'), ('mape', ' 49.3')])}}}; #print serrors['CCSD-CP-adtz']['hb']['HSG']['mape']. columnplan = [; ['l', r""""""Method \& Basis Set"""""", '', label, {}],; ['d', r'S22', 'HB', val, {'sset': 'hb', 'dbse': 'S22'}],; ['d', r'S22', 'MX/DD', val, {'sset': 'mxdd', 'dbse': 'S22'}],; ['d', r'S22', 'TT', val, {'sset': 'default', 'dbse': 'S22'}],; ['d', r'Overall', 'HB', val, {'sset': 'hb', 'dbse': 'DB4'}],; ['d', r'Overall', 'MX/DD', val, {'sset': 'mxdd', 'dbse': 'DB4', 'err': 'mape'}],; ['d', r'Overall', 'TT', val, {'sset': 'default', 'dbse': 'DB4'}]]. tbl, ind = table_generic(columnplan=columnplan, dbse=['DB4'], serrors=serrors,; mtd=['MP2', 'CCSD'], bas=['adz', 'atz'],; opt=['CP'], err=['mae', 'mape'],; theme='test', subjoin=False); print('\n'.join(tbl)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/textables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:5998,Safety,avoid,avoid,5998,"n enumerate(footnotes):; text.append(r""""""\footnotetext[%d]{%s}"""""" % (idx + 1, fn)); for fn, idx in iteritems(otffootnotes):; text.append(r""""""\footnotetext[%d]{%s}"""""" % (idx, fn)); text.append(r""""""\end{%s}"""""" % ('sidewaystable' if landscape else 'table')); text.append(r""""""\endgroup""""""); text.append(r""""""\clearpage""""""); text.append(''). def matelem(dict_row, dict_col):; """"""Return merge of index dictionaries *dict_row* and *dict_col* (precedence) with error string from serrors appended at key 'matelem'.""""""; kw = dict(dict_row, **dict_col); errpiece = serrors['-'.join([kw[bit] for bit in ['mtd', 'opt', 'bas']])][kw['sset']][kw['dbse']]; kw['matelem'] = errpiece[kw['err']]; if 'tgtcnt' in errpiece:; kw['count'] = errpiece['tgtcnt']; if 'misscnt' in errpiece and errpiece['misscnt'] != 0 and 'tgtcnt' in errpiece:; kw['footnote'] = r""""""\footnotemark{Missing %d of %d reactions.}"""""" % (errpiece['misscnt'], errpiece['tgtcnt']); else:; kw['footnote'] = ''; return kw. # avoid misunderstandings; keysincolumnplan = set(sum([col[-1].keys() for col in columnplan], [])); for key in ['dbse', 'sset', 'mtd', 'opt', 'bas', 'err']:; if len(locals()[key]) > 1:; if key not in rowplan and key not in keysincolumnplan:; print(""""""Warning: non-first values in argument '{0}' won't """"""; """"""get used. Add '{0}' to rowplan to iterate over """"""; """"""the values or add to columnplan to access""""""; """"""different values."""""".format(key)); sys.exit(). # form LaTeX reference tag; tag = []; for key in ['dbse', 'sset', 'mtd', 'opt', 'bas', 'err']:; if len(locals()[key]) == 1 or (key == rowplan[0] and not subjoin):; tag.append(key); tag = set(tag); for col in columnplan:; tag -= set(col[4].keys()). # form column headers; start = 1; stop = 1; head0 = ''; for index in range(2, len(columnplan)):; if columnplan[index][1] == columnplan[index - 1][1]:; stop = index; else:; head0 += r""""""\cline{%d-%d}"""""" % (start + 1, stop + 1); start = index; stop = index; if index + 1 == len(columnplan):; head0 += r""""""\cline{%d-%d}"""""" % (",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/textables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:6395,Security,access,access,6395,"elem(dict_row, dict_col):; """"""Return merge of index dictionaries *dict_row* and *dict_col* (precedence) with error string from serrors appended at key 'matelem'.""""""; kw = dict(dict_row, **dict_col); errpiece = serrors['-'.join([kw[bit] for bit in ['mtd', 'opt', 'bas']])][kw['sset']][kw['dbse']]; kw['matelem'] = errpiece[kw['err']]; if 'tgtcnt' in errpiece:; kw['count'] = errpiece['tgtcnt']; if 'misscnt' in errpiece and errpiece['misscnt'] != 0 and 'tgtcnt' in errpiece:; kw['footnote'] = r""""""\footnotemark{Missing %d of %d reactions.}"""""" % (errpiece['misscnt'], errpiece['tgtcnt']); else:; kw['footnote'] = ''; return kw. # avoid misunderstandings; keysincolumnplan = set(sum([col[-1].keys() for col in columnplan], [])); for key in ['dbse', 'sset', 'mtd', 'opt', 'bas', 'err']:; if len(locals()[key]) > 1:; if key not in rowplan and key not in keysincolumnplan:; print(""""""Warning: non-first values in argument '{0}' won't """"""; """"""get used. Add '{0}' to rowplan to iterate over """"""; """"""the values or add to columnplan to access""""""; """"""different values."""""".format(key)); sys.exit(). # form LaTeX reference tag; tag = []; for key in ['dbse', 'sset', 'mtd', 'opt', 'bas', 'err']:; if len(locals()[key]) == 1 or (key == rowplan[0] and not subjoin):; tag.append(key); tag = set(tag); for col in columnplan:; tag -= set(col[4].keys()). # form column headers; start = 1; stop = 1; head0 = ''; for index in range(2, len(columnplan)):; if columnplan[index][1] == columnplan[index - 1][1]:; stop = index; else:; head0 += r""""""\cline{%d-%d}"""""" % (start + 1, stop + 1); start = index; stop = index; if index + 1 == len(columnplan):; head0 += r""""""\cline{%d-%d}"""""" % (start + 1, stop + 1). abbr = ''.join([col[0] for col in columnplan]); h1 = [(k, len(list(g))) for k, g in itertools.groupby([col[1] for col in columnplan])]; head1 = ' & '.join([r""""""\multicolumn{%d}{c}{\textbf{%s}}"""""" % (repeat, label) for (label, repeat) in h1]) + r"""""" \\ """"""; h2 = [(k, len(list(g))) for k, g in itertools.groupby([col[2] fo",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/textables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:15611,Testability,test,test,15611,"('mae', ' 0.90'), ('mape', ' 113.9')]), 'HSG': OrderedDict([('mae', ' 0.55'), ('mape', ' 53.3')]), 'DB4': OrderedDict([('mae', ' 0.84'), ('mape', ' 64.3')])}}, 'MP2-CP-adz': {'hb': {'S22': OrderedDict([('mae', ' 1.64'), ('mape', ' 12.2')]), 'HBC1': OrderedDict([('mae', ' 1.41'), ('mape', ' 10.4')]), 'NBC1': None, 'HSG': OrderedDict([('mae', ' 1.42'), ('mape', ' 9.1')]), 'DB4': OrderedDict([('mae', ' 1.49'), ('mape', ' 10.6')])}, 'default': {'S22': OrderedDict([('mae', ' 0.97'), ('mape', ' 16.2')]), 'HBC1': OrderedDict([('mae', ' 1.41'), ('mape', ' 10.4')]), 'NBC1': OrderedDict([('mae', ' 0.70'), ('mape', ' 95.9')]), 'HSG': OrderedDict([('mae', ' 0.46'), ('mape', ' 30.5')]), 'DB4': OrderedDict([('mae', ' 0.88'), ('mape', ' 38.3')])}, 'mxdd': {'S22': OrderedDict([('mae', ' 0.65'), ('mape', ' 18.0')]), 'HBC1': None, 'NBC1': OrderedDict([('mae', ' 0.70'), ('mape', ' 95.9')]), 'HSG': OrderedDict([('mae', ' 0.30'), ('mape', ' 34.1')]), 'DB4': OrderedDict([('mae', ' 0.55'), ('mape', ' 49.3')])}}}; #print serrors['CCSD-CP-adtz']['hb']['HSG']['mape']. columnplan = [; ['l', r""""""Method \& Basis Set"""""", '', label, {}],; ['d', r'S22', 'HB', val, {'sset': 'hb', 'dbse': 'S22'}],; ['d', r'S22', 'MX/DD', val, {'sset': 'mxdd', 'dbse': 'S22'}],; ['d', r'S22', 'TT', val, {'sset': 'default', 'dbse': 'S22'}],; ['d', r'Overall', 'HB', val, {'sset': 'hb', 'dbse': 'DB4'}],; ['d', r'Overall', 'MX/DD', val, {'sset': 'mxdd', 'dbse': 'DB4', 'err': 'mape'}],; ['d', r'Overall', 'TT', val, {'sset': 'default', 'dbse': 'DB4'}]]. tbl, ind = table_generic(columnplan=columnplan, dbse=['DB4'], serrors=serrors,; mtd=['MP2', 'CCSD'], bas=['adz', 'atz'],; opt=['CP'], err=['mae', 'mape'],; theme='test', subjoin=False); print('\n'.join(tbl)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/textables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:5331,Usability,clear,clearpage,5331,"else:; otfcounter += 1; otffootnotes[res.group('fntext')] = localcounter; newcells.append(res.group('cellpre') + r""""""\footnotemark["""""" + str(localcounter) + ']' + res.group('cellpost')); changed = True; else:; newcells.append(cell); if changed:; lines2replace[idx] = '&'.join(newcells); for idx, line in iteritems(lines2replace):; text[idx] = line. # search-and-suppress ""blank"" lines; if suppressblanks:; for idx, line in enumerate(text):; if line.strip().endswith('\\'):; innards = ''.join(line.rstrip("""""" \\"""""").split('&')[1:]); if innards.isspace():; text[idx] = '%' + text[idx]. # finish out table; text.append(r""""""\end{tabular}""""""); text.append(r""""""\end{ruledtabular}""""""); for idx, fn in enumerate(footnotes):; text.append(r""""""\footnotetext[%d]{%s}"""""" % (idx + 1, fn)); for fn, idx in iteritems(otffootnotes):; text.append(r""""""\footnotetext[%d]{%s}"""""" % (idx, fn)); text.append(r""""""\end{%s}"""""" % ('sidewaystable' if landscape else 'table')); text.append(r""""""\endgroup""""""); text.append(r""""""\clearpage""""""); text.append(''). def matelem(dict_row, dict_col):; """"""Return merge of index dictionaries *dict_row* and *dict_col* (precedence) with error string from serrors appended at key 'matelem'.""""""; kw = dict(dict_row, **dict_col); errpiece = serrors['-'.join([kw[bit] for bit in ['mtd', 'opt', 'bas']])][kw['sset']][kw['dbse']]; kw['matelem'] = errpiece[kw['err']]; if 'tgtcnt' in errpiece:; kw['count'] = errpiece['tgtcnt']; if 'misscnt' in errpiece and errpiece['misscnt'] != 0 and 'tgtcnt' in errpiece:; kw['footnote'] = r""""""\footnotemark{Missing %d of %d reactions.}"""""" % (errpiece['misscnt'], errpiece['tgtcnt']); else:; kw['footnote'] = ''; return kw. # avoid misunderstandings; keysincolumnplan = set(sum([col[-1].keys() for col in columnplan], [])); for key in ['dbse', 'sset', 'mtd', 'opt', 'bas', 'err']:; if len(locals()[key]) > 1:; if key not in rowplan and key not in keysincolumnplan:; print(""""""Warning: non-first values in argument '{0}' won't """"""; """"""get used. Add '{0}' to rowplan",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/textables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:9483,Deployability,update,updated,9483," for row in range(n)] for col in range(m)]; return new_matrix. [docs]def identity(m):; """"""Create identity matrix""""""; new_matrix = zero(m, m); for i in range(m):; new_matrix[i][i] = 1.0; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print(col). [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; try:; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; except TypeError:; new_matrix = zero(len(matrix1), 1); for i in range(len(matrix1)):; for k in range(len(matrix2)):; new_matrix[i][0] += matrix1[i][k] * matrix2[k]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. [docs]def matadd(matrix1, matrix2, fac1=1.0, fac2=1.0):; """"""Matrix addition""""""; if (len(matrix1[0]) != len(matrix2[0])) or (len(matrix1) != len(matrix2)):; raise ValidationError('Matrices must be same dimension to add.'); new_matrix = zero(len(matrix1), len(matrix1[0])); for i in range(len(matrix1)):; for j in range(len(matrix1[0])):; new_matrix[i][j] = fac1 * matrix1[i][j] + fac2 * matrix2[i][j]; return new_matrix. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code .  Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:989,Security,access,accessory,989," qcdb.vecutil  Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules  . toc  ; Psi4 [1.0.0 6a9a71b]  ; Module code . Source code for qcdb.vecutil; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""File for accessory procedures in the chem module.; Credit for the libmints vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. """"""; from __future__ import absolute_import; from __future__ import print_function; import math; import copy; from .exceptions import *. ZERO = 1.0E-14. [docs]def norm(v):; """"""Compute the magnitude of vector *v*.""""""; return math.sqrt(sum(v[i] * v[i] for i in range(len(v)))). [docs]def add(v, u):; """"""Compute sum of vectors *v* and *u*.""""""; return [u[i] + v[i] for i in range(len(v))]. [docs]def sub(v, u):; """"""Compute difference of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def naivemult(v, u):; """"""Compute by-element multiplication of vectors *v* and *u*.""""""; if len(u) != len(v):; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.adc.html:303,Deployability,update,updated,303,". psi4.core.adc. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.adc. psi4.core.adc(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the ADC propagator code, for excited states. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.adc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.adc.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.angularmomentumint.html:570,Deployability,update,updated,570,". psi4.core.AngularMomentumInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.AngularMomentumInt. class psi4.core.AngularMomentumInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.angularmomentumint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.angularmomentumint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.aoshellcombinationsiterator.html:1054,Deployability,update,updated,1054,". psi4.core.AOShellCombinationsIterator. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.AOShellCombinationsIterator. class psi4.core.AOShellCombinationsIterator; Bases: object; Attributes Summary. p; docstring. q; docstring. r; docstring. s; docstring. Methods Summary. first(...); docstring. is_done(...); docstring. next(...); docstring. Attributes Documentation. p; docstring. q; docstring. r; docstring. s; docstring. Methods Documentation. first(self: psi4.core.AOShellCombinationsIterator)  None; docstring. is_done(self: psi4.core.AOShellCombinationsIterator)  bool; docstring. next(self: psi4.core.AOShellCombinationsIterator)  None; docstring. first(self: psi4.core.AOShellCombinationsIterator)  None; docstring. is_done(self: psi4.core.AOShellCombinationsIterator)  bool; docstring. next(self: psi4.core.AOShellCombinationsIterator)  None; docstring. p; docstring. q; docstring. r; docstring. s; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.aoshellcombinationsiterator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.aoshellcombinationsiterator.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.atomic_displacements.html:395,Deployability,update,updated,395,". psi4.core.atomic_displacements. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.atomic_displacements. psi4.core.atomic_displacements(arg0: psi::Molecule)  List[psi::Matrix]; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.atomic_displacements.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.atomic_displacements.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:6966,Deployability,update,updated,6966," docstring. genbas(self: psi4.core.BasisSet)  str; Returns basis set per atom in CFOUR format. has_puream(self: psi4.core.BasisSet)  bool; Spherical harmonics?. make_filename(arg0: str)  str; Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self: psi4.core.BasisSet)  int; Returns maximum angular momentum used. max_function_per_shell(self: psi4.core.BasisSet)  int; docstring. max_nprimitive(self: psi4.core.BasisSet)  int; docstring. molecule(self: psi4.core.BasisSet)  psi4.core.Molecule; docstring. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. print_detail_out(self: psi4.core.BasisSet)  None; docstring. print_out(self: psi4.core.BasisSet)  None; docstring. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, arg0: int) -> psi4.core.GaussianShell. docstring. shell(self: psi4.core.BasisSet, arg0: int, arg1: int) -> psi4.core.GaussianShell. docstring. shell_to_ao_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_basis_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:1329,Integrability,depend,depending,1329,"me] values. build(mol[,key,target,fitrole,other,...]). construct_from_pydict(...); docstring. function_to_center(...); Given a function number, return the number of the center it is on. function_to_shell((self:psi4.core.BasisSet,...); docstring. genbas((self:psi4.core.BasisSet)->str); Returns basis set per atom in CFOUR format. has_puream((self:psi4.core.BasisSet)->bool); Spherical harmonics?. make_filename((arg0:str)->str); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am((self:psi4.core.BasisSet)->int); Returns maximum angular momentum used. max_function_per_shell(...); docstring. max_nprimitive((self:psi4.core.BasisSet)->int); docstring. molecule(...); docstring. name((self:psi4.core.BasisSet)->str); Callback handle, may represent string or function. nao((self:psi4.core.BasisSet)->int); Returns number of atomic orbitals (Cartesian). nbf((self:psi4.core.BasisSet)->int); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive((self:psi4.core.BasisSet)->int); Returns total number of primitives in all contractions. nshell((self:psi4.core.BasisSet)->int); Returns number of shells. nshell_on_center((self:psi4.core.BasisSet,...); docstring. print_detail_out(...); docstring. print_out((self:psi4.core.BasisSet)->None); docstring. shell(*args,**kwargs); Overloaded function. shell_to_ao_function(...); docstring. shell_to_basis_function(...); docstring. shell_to_center((self:psi4.core.BasisSet,...); docstring. zero_ao_basis_set(()->psi4.core.BasisSet); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_at",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:1444,Integrability,contract,contractions,1444,"(...); Given a function number, return the number of the center it is on. function_to_shell((self:psi4.core.BasisSet,...); docstring. genbas((self:psi4.core.BasisSet)->str); Returns basis set per atom in CFOUR format. has_puream((self:psi4.core.BasisSet)->bool); Spherical harmonics?. make_filename((arg0:str)->str); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am((self:psi4.core.BasisSet)->int); Returns maximum angular momentum used. max_function_per_shell(...); docstring. max_nprimitive((self:psi4.core.BasisSet)->int); docstring. molecule(...); docstring. name((self:psi4.core.BasisSet)->str); Callback handle, may represent string or function. nao((self:psi4.core.BasisSet)->int); Returns number of atomic orbitals (Cartesian). nbf((self:psi4.core.BasisSet)->int); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive((self:psi4.core.BasisSet)->int); Returns total number of primitives in all contractions. nshell((self:psi4.core.BasisSet)->int); Returns number of shells. nshell_on_center((self:psi4.core.BasisSet,...); docstring. print_detail_out(...); docstring. print_out((self:psi4.core.BasisSet)->None); docstring. shell(*args,**kwargs); Overloaded function. shell_to_ao_function(...); docstring. shell_to_basis_function(...); docstring. shell_to_center((self:psi4.core.BasisSet,...); docstring. zero_ao_basis_set(()->psi4.core.BasisSet); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, quiet=False). construct_from_pydict(arg0: psi4.core.Molecule, arg1: dict, arg2: int)  psi4.core.Basis",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:2015,Integrability,contract,contraction,2015,"ring. molecule(...); docstring. name((self:psi4.core.BasisSet)->str); Callback handle, may represent string or function. nao((self:psi4.core.BasisSet)->int); Returns number of atomic orbitals (Cartesian). nbf((self:psi4.core.BasisSet)->int); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive((self:psi4.core.BasisSet)->int); Returns total number of primitives in all contractions. nshell((self:psi4.core.BasisSet)->int); Returns number of shells. nshell_on_center((self:psi4.core.BasisSet,...); docstring. print_detail_out(...); docstring. print_out((self:psi4.core.BasisSet)->None); docstring. shell(*args,**kwargs); Overloaded function. shell_to_ao_function(...); docstring. shell_to_basis_function(...); docstring. shell_to_center((self:psi4.core.BasisSet,...); docstring. zero_ao_basis_set(()->psi4.core.BasisSet); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, quiet=False). construct_from_pydict(arg0: psi4.core.Molecule, arg1: dict, arg2: int)  psi4.core.BasisSet; docstring. function_to_center(self: psi4.core.BasisSet, arg0: int)  int; Given a function number, return the number of the center it is on. function_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. genbas(self: psi4.core.BasisSet)  str; Returns basis set per atom in CFOUR format. has_puream(self: psi4.core.BasisSet)  bool; Spherical harmonics?. make_filename(arg0: str)  str; Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self: psi4.core.BasisSet)  int; Returns maximum angular momentum used. max_function_per_sh",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:3470,Integrability,depend,depending,3470,"n_to_center(self: psi4.core.BasisSet, arg0: int)  int; Given a function number, return the number of the center it is on. function_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. genbas(self: psi4.core.BasisSet)  str; Returns basis set per atom in CFOUR format. has_puream(self: psi4.core.BasisSet)  bool; Spherical harmonics?. make_filename(arg0: str)  str; Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self: psi4.core.BasisSet)  int; Returns maximum angular momentum used. max_function_per_shell(self: psi4.core.BasisSet)  int; docstring. max_nprimitive(self: psi4.core.BasisSet)  int; docstring. molecule(self: psi4.core.BasisSet)  psi4.core.Molecule; docstring. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. print_detail_out(self: psi4.core.BasisSet)  None; docstring. print_out(self: psi4.core.BasisSet)  None; docstring. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, arg0: int) -> psi4.core.GaussianShell. docstring. shell(self: psi4.core.BasisSet, arg0: int, arg1: int) -> psi4.core.GaussianShell. docstring. shell_to_ao_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_basis_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent o",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:3583,Integrability,contract,contractions,3583,"t is on. function_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. genbas(self: psi4.core.BasisSet)  str; Returns basis set per atom in CFOUR format. has_puream(self: psi4.core.BasisSet)  bool; Spherical harmonics?. make_filename(arg0: str)  str; Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self: psi4.core.BasisSet)  int; Returns maximum angular momentum used. max_function_per_shell(self: psi4.core.BasisSet)  int; docstring. max_nprimitive(self: psi4.core.BasisSet)  int; docstring. molecule(self: psi4.core.BasisSet)  psi4.core.Molecule; docstring. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. print_detail_out(self: psi4.core.BasisSet)  None; docstring. print_out(self: psi4.core.BasisSet)  None; docstring. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, arg0: int) -> psi4.core.GaussianShell. docstring. shell(self: psi4.core.BasisSet, arg0: int, arg1: int) -> psi4.core.GaussianShell. docstring. shell_to_ao_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_basis_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. ao_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. blend(self: psi4.c",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:4455,Integrability,contract,contraction,4455,"spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. print_detail_out(self: psi4.core.BasisSet)  None; docstring. print_out(self: psi4.core.BasisSet)  None; docstring. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, arg0: int) -> psi4.core.GaussianShell. docstring. shell(self: psi4.core.BasisSet, arg0: int, arg1: int) -> psi4.core.GaussianShell. docstring. shell_to_ao_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_basis_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. ao_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, quiet=False). construct_from_pydict(arg0: psi4.core.Molecule, arg1: dict, arg2: int)  psi4.core.BasisSet; docstring. function_to_center(self: psi4.core.BasisSet, arg0: int)  int; Given a function number, return the number of the center it is on. function_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. genbas(self: psi4.core.BasisSet)  str; Returns basis set per atom in CFOUR format. has_puream(self: psi4.core.BasisSet)  bool; Spherical harmonics?. make_filename(arg0: str)  str; Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self: psi4.core.BasisSet)  int; Returns maximum angular momentum used. max_function_per_shell(self: psi4.core.BasisSet)  i",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:5871,Integrability,depend,depending,5871,"ng. function_to_center(self: psi4.core.BasisSet, arg0: int)  int; Given a function number, return the number of the center it is on. function_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. genbas(self: psi4.core.BasisSet)  str; Returns basis set per atom in CFOUR format. has_puream(self: psi4.core.BasisSet)  bool; Spherical harmonics?. make_filename(arg0: str)  str; Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self: psi4.core.BasisSet)  int; Returns maximum angular momentum used. max_function_per_shell(self: psi4.core.BasisSet)  int; docstring. max_nprimitive(self: psi4.core.BasisSet)  int; docstring. molecule(self: psi4.core.BasisSet)  psi4.core.Molecule; docstring. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. print_detail_out(self: psi4.core.BasisSet)  None; docstring. print_out(self: psi4.core.BasisSet)  None; docstring. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, arg0: int) -> psi4.core.GaussianShell. docstring. shell(self: psi4.core.BasisSet, arg0: int, arg1: int) -> psi4.core.GaussianShell. docstring. shell_to_ao_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_basis_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:5983,Integrability,contract,contractions,5983,"he center it is on. function_to_shell(self: psi4.core.BasisSet, arg0: int)  int; docstring. genbas(self: psi4.core.BasisSet)  str; Returns basis set per atom in CFOUR format. has_puream(self: psi4.core.BasisSet)  bool; Spherical harmonics?. make_filename(arg0: str)  str; Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self: psi4.core.BasisSet)  int; Returns maximum angular momentum used. max_function_per_shell(self: psi4.core.BasisSet)  int; docstring. max_nprimitive(self: psi4.core.BasisSet)  int; docstring. molecule(self: psi4.core.BasisSet)  psi4.core.Molecule; docstring. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. print_detail_out(self: psi4.core.BasisSet)  None; docstring. print_out(self: psi4.core.BasisSet)  None; docstring. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, arg0: int) -> psi4.core.GaussianShell. docstring. shell(self: psi4.core.BasisSet, arg0: int, arg1: int) -> psi4.core.GaussianShell. docstring. shell_to_ao_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_basis_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.;",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html:6846,Integrability,contract,contraction,6846," docstring. genbas(self: psi4.core.BasisSet)  str; Returns basis set per atom in CFOUR format. has_puream(self: psi4.core.BasisSet)  bool; Spherical harmonics?. make_filename(arg0: str)  str; Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self: psi4.core.BasisSet)  int; Returns maximum angular momentum used. max_function_per_shell(self: psi4.core.BasisSet)  int; docstring. max_nprimitive(self: psi4.core.BasisSet)  int; docstring. molecule(self: psi4.core.BasisSet)  psi4.core.Molecule; docstring. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. print_detail_out(self: psi4.core.BasisSet)  None; docstring. print_out(self: psi4.core.BasisSet)  None; docstring. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, arg0: int) -> psi4.core.GaussianShell. docstring. shell(self: psi4.core.BasisSet, arg0: int, arg1: int) -> psi4.core.GaussianShell. docstring. shell_to_ao_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_basis_function(self: psi4.core.BasisSet, arg0: int)  int; docstring. shell_to_center(self: psi4.core.BasisSet, arg0: int)  int; docstring. zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.basissetparser.html:273,Deployability,update,updated,273,". psi4.core.BasisSetParser. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.BasisSetParser. class psi4.core.BasisSetParser; Bases: object; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.basissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.basissetparser.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_blas1.html:286,Deployability,update,updated,286,". psi4.core.benchmark_blas1. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.benchmark_blas1. psi4.core.benchmark_blas1(arg0: int, arg1: float)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_blas2.html:286,Deployability,update,updated,286,". psi4.core.benchmark_blas2. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.benchmark_blas2. psi4.core.benchmark_blas2(arg0: int, arg1: float)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_blas3.html:297,Deployability,update,updated,297,". psi4.core.benchmark_blas3. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.benchmark_blas3. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_disk.html:283,Deployability,update,updated,283,". psi4.core.benchmark_disk. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.benchmark_disk. psi4.core.benchmark_disk(arg0: int, arg1: float)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_integrals.html:298,Deployability,update,updated,298,". psi4.core.benchmark_integrals. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.benchmark_integrals. psi4.core.benchmark_integrals(arg0: int, arg1: float)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_math.html:272,Deployability,update,updated,272,". psi4.core.benchmark_math. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.benchmark_math. psi4.core.benchmark_math(arg0: float)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.be_quiet.html:324,Deployability,update,updated,324,". psi4.core.be_quiet. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.be_quiet. psi4.core.be_quiet()  None; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.be_quiet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.be_quiet.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.boyslocalizer.html:585,Deployability,update,updated,585,". psi4.core.BoysLocalizer. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.BoysLocalizer. class psi4.core.BoysLocalizer; Bases: psi4.core.Localizer; docstring. L; Localized orbital coefficients. U; Orbital rotation matrix. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; docstring. converged; Did the localization procedure converge?. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.boyslocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.boyslocalizer.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html:1560,Availability,error,error,1560,"ve((self:List[psi4.core.ShellInfo],...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.bsvec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html:2456,Availability,error,error,2456," x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.bsvec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html:2588,Deployability,update,updated,2588," x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.bsvec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html:331,Modifiability,extend,extend,331,". psi4.core.BSVec. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.BSVec. class psi4.core.BSVec; Bases: object; Methods Summary. append((self:List[psi4.core.ShellInfo],...); Add an item to the end of the list. count((self:List[psi4.core.ShellInfo],...); Return the number of times x appears in the list. extend((self:List[psi4.core.ShellInfo],...); Extend the list by appending all the items in the given list. insert((self:List[psi4.core.ShellInfo],...); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove((self:List[psi4.core.ShellInfo],...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.bsvec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html:920,Modifiability,extend,extend,920,". psi4.core.BSVec. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.BSVec. class psi4.core.BSVec; Bases: object; Methods Summary. append((self:List[psi4.core.ShellInfo],...); Add an item to the end of the list. count((self:List[psi4.core.ShellInfo],...); Return the number of times x appears in the list. extend((self:List[psi4.core.ShellInfo],...); Extend the list by appending all the items in the given list. insert((self:List[psi4.core.ShellInfo],...); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove((self:List[psi4.core.ShellInfo],...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.bsvec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html:1820,Modifiability,extend,extend,1820," x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo])  None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.bsvec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.bsvec.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ccdensity.html:318,Deployability,update,updated,318,". psi4.core.ccdensity. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ccdensity. psi4.core.ccdensity(arg0: psi::Wavefunction)  float; Runs the code to compute coupled cluster density matrices. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ccdensity.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ccdensity.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ccenergy.html:306,Deployability,update,updated,306,". psi4.core.ccenergy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ccenergy. psi4.core.ccenergy(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the coupled cluster energy code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ccenergy.html:193,Energy Efficiency,energy,energy,193,". psi4.core.ccenergy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ccenergy. psi4.core.ccenergy(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the coupled cluster energy code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cceom.html:317,Deployability,update,updated,317,". psi4.core.cceom. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.cceom. psi4.core.cceom(arg0: psi::Wavefunction)  float; Runs the equation of motion coupled cluster code, for excited states. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cceom.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cceom.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cchbar.html:315,Deployability,update,updated,315,". psi4.core.cchbar. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.cchbar. psi4.core.cchbar(arg0: psi::Wavefunction)  None; Runs the code to generate the similarity transformed Hamiltonian. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cchbar.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cchbar.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cclambda.html:316,Deployability,update,updated,316,". psi4.core.cclambda. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.cclambda. psi4.core.cclambda(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the coupled cluster lambda equations code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cclambda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cclambda.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ccresponse.html:309,Deployability,update,updated,309,". psi4.core.ccresponse. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ccresponse. psi4.core.ccresponse(arg0: psi::Wavefunction)  float; Runs the coupled cluster response theory code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ccresponse.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ccresponse.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cctransort.html:356,Deployability,update,updated,356,". psi4.core.cctransort. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.cctransort. psi4.core.cctransort(arg0: psi::Wavefunction)  None; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cctransort.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cctransort.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cctriples.html:301,Deployability,update,updated,301,". psi4.core.cctriples. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.cctriples. psi4.core.cctriples(arg0: psi::Wavefunction)  float; Runs the coupled cluster (T) energy code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cctriples.html:188,Energy Efficiency,energy,energy,188,". psi4.core.cctriples. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.cctriples. psi4.core.cctriples(arg0: psi::Wavefunction)  float; Runs the coupled cluster (T) energy code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cdsalclist.html:633,Deployability,update,updated,633,". psi4.core.CdSalcList. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.CdSalcList. class psi4.core.CdSalcList; Bases: object; docstring; Methods Summary. matrix(...); docstring. print_out((self:psi4.core.CdSalcList)->None); docstring. Methods Documentation. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; docstring. print_out(self: psi4.core.CdSalcList)  None; docstring. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; docstring. print_out(self: psi4.core.CdSalcList)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cdsalclist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cdsalclist.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.civector.html:4116,Deployability,update,updated,4116," None; docstring. vdot(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  float; docstring. vector_multiply(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: psi4.core.CIVector, arg3: int, arg4: int, arg5: int)  None; docstring. write(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. zero(self: psi4.core.CIVector)  None; docstring. axpy(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int, arg3: int)  None; docstring. close_io_files(self: psi4.core.CIVector, arg0: int)  None; docstring. copy(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  None; docstring. dcalc(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int)  float; docstring. divide(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: float, arg2: int, arg3: int)  None; docstring. init_io_files(self: psi4.core.CIVector, arg0: bool)  None; docstring. norm(self: psi4.core.CIVector, arg0: int)  float; docstring. np; Returns a view of the CIVectors buffer. read(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. scale(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. set_nvec(self: psi4.core.CIVector, arg0: int)  None; docstring. shift(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. symnormalize(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. vdot(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  float; docstring. vector_multiply(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: psi4.core.CIVector, arg3: int, arg4: int, arg5: int)  None; docstring. write(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. zero(self: psi4.core.CIVector)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.civector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.civector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:14706,Deployability,update,updated,14706,"  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix)  None; docstring. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sigma(*args, **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction)  None; docstring. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool)  None; docstring. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:6210,Energy Efficiency,charge,charges,6210,"Beta Density subset. Fa(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Core Matrix (Potential + Kinetic) Integrals. Hd_vector(self: psi4.core.CIWavefunction, arg0: int)  psi::detci::CIvect; docstring. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). ci_nat_orbs(self: psi4.core.CIWavefunction)  None; docstring. cleanup_ci(self: psi4.core.CIWavefunction)  None; docstring. cleanup_dpd(self: psi4.core.CIWavefunction)  None; docstring. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. comput",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:6941,Energy Efficiency,energy,energy,6941,"x; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). ci_nat_orbs(self: psi4.core.CIWavefunction)  None; docstring. cleanup_ci(self: psi4.core.CIWavefunction)  None; docstring. cleanup_dpd(self: psi4.core.CIWavefunction)  None; docstring. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect)  None; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float)  int; docstring. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:7662,Energy Efficiency,energy,energy,7662," basis=None). ci_nat_orbs(self: psi4.core.CIWavefunction)  None; docstring. cleanup_ci(self: psi4.core.CIWavefunction)  None; docstring. cleanup_dpd(self: psi4.core.CIWavefunction)  None; docstring. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect)  None; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float)  int; docstring. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. form_opdm(self: psi4.core.CIWavefunction)  None; docstring. form_tpdm(self: psi4.core.CIWavefunction)  None; docstring. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(se",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:7735,Energy Efficiency,energy,energy,7735,"CIWavefunction)  None; docstring. cleanup_ci(self: psi4.core.CIWavefunction)  None; docstring. cleanup_dpd(self: psi4.core.CIWavefunction)  None; docstring. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect)  None; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float)  int; docstring. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. form_opdm(self: psi4.core.CIWavefunction)  None; docstring. form_tpdm(self: psi4.core.CIWavefunction)  None; docstring. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str)  ps",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:9367,Modifiability,variab,variable,9367,"f: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_dimension(self: psi4.core.CIWavefunction, arg0: str)  psi4.core.Dimension; docstring. get_opdm(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: str, arg3: bool)  psi4.core.Matrix; docstring. get_orbitals(self: psi4.core.CIWavefunction, arg0: str)  psi4.core.Matrix; docstring. get_tpdm(self: psi4.core.CIWavefunction, arg0: str, arg1: bool)  psi4.core.Matrix; docstring. get_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. hamiltonian(self: psi4.core.CIWavefunction, arg0: int)  psi4.core.Matrix; docstring. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. mcscf_object(self: psi4.core.CIWavefunction)  psi4.core.SOMCSCF; docstring. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction)  int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction)  str; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction)  int; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of beta orbitals per irrep. ndet(self: psi4.core.CIWavefunction)  int; docstrin",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:13478,Modifiability,variab,variable,13478,"CIWavefunction, arg0: str)  None; docstring. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix)  None; docstring. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sigma(*args, **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction)  None; docstring. transform_mcscf_integrals(self: ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:14502,Modifiability,variab,variables,14502,"  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix)  None; docstring. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sigma(*args, **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction)  None; docstring. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool)  None; docstring. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:14595,Modifiability,variab,variables,14595,"  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix)  None; docstring. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sigma(*args, **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction)  None; docstring. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool)  None; docstring. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.clean.html:288,Deployability,update,updated,288,". psi4.core.clean. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.clean. psi4.core.clean()  None; Function to remove scratch files. Call between independent jobs. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.clean.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.clean.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.clean_options.html:289,Deployability,update,updated,289,". psi4.core.clean_options. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.clean_options. psi4.core.clean_options()  None; Function to reset options to clean state. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.clean_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.clean_options.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.clean_variables.html:305,Deployability,update,updated,305,". psi4.core.clean_variables. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.clean_variables. psi4.core.clean_variables()  None; Empties all PSI variables that have set internally. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.clean_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.clean_variables.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.clean_variables.html:169,Modifiability,variab,variables,169,". psi4.core.clean_variables. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.clean_variables. psi4.core.clean_variables()  None; Empties all PSI variables that have set internally. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.clean_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.clean_variables.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.close_outfile.html:271,Deployability,update,updated,271,". psi4.core.close_outfile. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.close_outfile. psi4.core.close_outfile()  None; Closes the output file. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.close_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.close_outfile.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.correlationfactor.html:577,Deployability,update,updated,577,". psi4.core.CorrelationFactor. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.CorrelationFactor. class psi4.core.CorrelationFactor; Bases: object; docstring; Methods Summary. set_params(...); docstring. Methods Documentation. set_params(self: psi4.core.CorrelationFactor, arg0: psi4.core.Vector, arg1: psi4.core.Vector)  None; docstring. set_params(self: psi4.core.CorrelationFactor, arg0: psi4.core.Vector, arg1: psi4.core.Vector)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.correlationfactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.correlationfactor.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.correlationtable.html:1896,Deployability,update,updated,1896,". psi4.core.CorrelationTable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.CorrelationTable. class psi4.core.CorrelationTable; Bases: object; docstring; Methods Summary. degen((self:psi4.core.CorrelationTable,...); docstring. group(*args,**kwargs); Overloaded function. n((self:psi4.core.CorrelationTable)->int); docstring. ngamma((self:psi4.core.CorrelationTable,...); docstring. subdegen((self:psi4.core.CorrelationTable,...); docstring. subgroup(...); docstring. subn((self:psi4.core.CorrelationTable)->int); docstring. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; docstring. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. docstring. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. docstring. n(self: psi4.core.CorrelationTable)  int; docstring. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; docstring. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; docstring. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; docstring. subn(self: psi4.core.CorrelationTable)  int; docstring. degen(self: psi4.core.CorrelationTable, arg0: int)  int; docstring. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. docstring. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. docstring. n(self: psi4.core.CorrelationTable)  int; docstring. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; docstring. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; docstring. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; docstring. subn(self: psi4.core.CorrelationTable)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.correlationtable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.correlationtable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cubeproperties.html:490,Deployability,update,updated,490,". psi4.core.CubeProperties. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.CubeProperties. class psi4.core.CubeProperties; Bases: object; docstring; Methods Summary. compute_properties(...); docstring. Methods Documentation. compute_properties(self: psi4.core.CubeProperties)  None; docstring. compute_properties(self: psi4.core.CubeProperties)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cubeproperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cubeproperties.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:9487,Deployability,update,updated,9487,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:2148,Energy Efficiency,charge,charges,2148,"atrix. H(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Core Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of d",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:2691,Energy Efficiency,energy,energy,2691,"gian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:3168,Energy Efficiency,energy,energy,3168,"lf: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the H",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:3241,Energy Efficiency,energy,energy,3241,".Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:3771,Energy Efficiency,energy,energy,3771,"function)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:4839,Modifiability,variab,variable,4839,"ne; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF)  None; Initializes the Wavefunction. iterations(self: psi4.core.HF)  None; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF)  psi4.core.JK; Returns the internal JK object. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction)  int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction)  str; T",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:8927,Modifiability,variab,variable,8927,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:9283,Modifiability,variab,variables,9283,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:9376,Modifiability,variab,variables,9376,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.cuhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dasum.html:285,Deployability,update,updated,285,". psi4.core.DASUM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DASUM. psi4.core.DASUM(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dasum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dasum.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.daxpy.html:327,Deployability,update,updated,327,". psi4.core.DAXPY. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DAXPY. psi4.core.DAXPY(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int, arg5: psi::Vector, arg6: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.daxpy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.daxpy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dcft.html:306,Deployability,update,updated,306,". psi4.core.dcft. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.dcft. psi4.core.dcft(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the density cumulant functional theory code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dcft.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dcft.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dcopy.html:314,Deployability,update,updated,314,". psi4.core.DCOPY. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DCOPY. psi4.core.DCOPY(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dcopy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dcopy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.ddot.html:312,Deployability,update,updated,312,". psi4.core.DDOT. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DDOT. psi4.core.DDOT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  float; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.ddot.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ddot.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.deriv.html:1084,Deployability,update,updated,1084,". psi4.core.Deriv. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Deriv. class psi4.core.Deriv; Bases: object; docstring; Methods Summary. compute(...); docstring. set_deriv_density_backtransformed(...); docstring. set_ignore_reference((self:psi4.core.Deriv,...); docstring. set_tpdm_presorted((self:psi4.core.Deriv,...); docstring. Methods Documentation. compute(self: psi4.core.Deriv)  psi4.core.Matrix; docstring. set_deriv_density_backtransformed(self: psi4.core.Deriv, arg0: bool)  None; docstring. set_ignore_reference(self: psi4.core.Deriv, arg0: bool)  None; docstring. set_tpdm_presorted(self: psi4.core.Deriv, arg0: bool)  None; docstring. compute(self: psi4.core.Deriv)  psi4.core.Matrix; docstring. set_deriv_density_backtransformed(self: psi4.core.Deriv, arg0: bool)  None; docstring. set_ignore_reference(self: psi4.core.Deriv, arg0: bool)  None; docstring. set_tpdm_presorted(self: psi4.core.Deriv, arg0: bool)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.deriv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.deriv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.detci.html:186,Deployability,configurat,configuration,186,". psi4.core.detci. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.detci. psi4.core.detci(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the determinant-based configuration interaction code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.detci.html:318,Deployability,update,updated,318,". psi4.core.detci. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.detci. psi4.core.detci(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the determinant-based configuration interaction code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.detci.html:186,Modifiability,config,configuration,186,". psi4.core.detci. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.detci. psi4.core.detci(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the determinant-based configuration interaction code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfchargefitter.html:1284,Deployability,update,updated,1284,". psi4.core.DFChargeFitter. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DFChargeFitter. class psi4.core.DFChargeFitter; Bases: object; docstring; Methods Summary. d(...); docstring. fit(...); docstring. setAuxiliary(...); docstring. setD((self:psi4.core.DFChargeFitter,...); docstring. setPrimary((self:psi4.core.DFChargeFitter,...); docstring. Methods Documentation. d(self: psi4.core.DFChargeFitter)  psi4.core.Vector; docstring. fit(self: psi4.core.DFChargeFitter)  psi4.core.Vector; docstring. setAuxiliary(self: psi4.core.DFChargeFitter, arg0: psi4.core.BasisSet)  None; docstring. setD(self: psi4.core.DFChargeFitter, arg0: psi4.core.Matrix)  None; docstring. setPrimary(self: psi4.core.DFChargeFitter, arg0: psi4.core.BasisSet)  None; docstring. d(self: psi4.core.DFChargeFitter)  psi4.core.Vector; docstring. fit(self: psi4.core.DFChargeFitter)  psi4.core.Vector; docstring. setAuxiliary(self: psi4.core.DFChargeFitter, arg0: psi4.core.BasisSet)  None; docstring. setD(self: psi4.core.DFChargeFitter, arg0: psi4.core.Matrix)  None; docstring. setPrimary(self: psi4.core.DFChargeFitter, arg0: psi4.core.BasisSet)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dfchargefitter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfchargefitter.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfmp2.html:281,Deployability,update,updated,281,". psi4.core.dfmp2. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.dfmp2. psi4.core.dfmp2(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the DF-MP2 code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dfmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfmp2.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfocc.html:311,Deployability,update,updated,311,". psi4.core.dfocc. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.dfocc. psi4.core.dfocc(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the density-fitted orbital optimized CC codes. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfocc.html:191,Performance,optimiz,optimized,191,". psi4.core.dfocc. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.dfocc. psi4.core.dfocc(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the density-fitted orbital optimized CC codes. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfsomcscf.html:1406,Deployability,update,update,1406,". psi4.core.DFSOMCSCF. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DFSOMCSCF. class psi4.core.DFSOMCSCF; Bases: psi4.core.SOMCSCF; docstring. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dfsomcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfsomcscf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfsomcscf.html:1740,Deployability,update,updated,1740,". psi4.core.DFSOMCSCF. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DFSOMCSCF. class psi4.core.DFSOMCSCF; Bases: psi4.core.SOMCSCF; docstring. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dfsomcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dfsomcscf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dftensor.html:1309,Deployability,update,updated,1309,". psi4.core.DFTensor. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DFTensor. class psi4.core.DFTensor; Bases: object; docstring; Methods Summary. Idfmo(...); doctsring. Imo(...); doctsring. Qmo(...); doctsring. Qoo(...); doctsring. Qov(...); doctsring. Qso(...); doctsring. Qvv(...); doctsring. Methods Documentation. Idfmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Imo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qoo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qov(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qso(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qvv(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Idfmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Imo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qoo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qov(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qso(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qvv(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dftensor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dftensor.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgbmv.html:418,Deployability,update,updated,418,". psi4.core.DGBMV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DGBMV. psi4.core.DGBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int, arg11: float, arg12: psi::Vector, arg13: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dgbmv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgbmv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgeev.html:437,Deployability,update,updated,437,". psi4.core.DGEEV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DGEEV. psi4.core.DGEEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int, arg12: psi::Vector, arg13: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dgeev.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgeev.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgemm.html:418,Deployability,update,updated,418,". psi4.core.DGEMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DGEMM. psi4.core.DGEMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Matrix, arg10: int, arg11: float, arg12: psi::Matrix, arg13: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dgemm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgemm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgemv.html:394,Deployability,update,updated,394,". psi4.core.DGEMV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DGEMV. psi4.core.DGEMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dgemv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgemv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dger.html:365,Deployability,update,updated,365,". psi4.core.DGER. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DGER. psi4.core.DGER(arg0: int, arg1: int, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dger.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dger.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgetrf.html:319,Deployability,update,updated,319,". psi4.core.DGETRF. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DGETRF. psi4.core.DGETRF(arg0: int, arg1: int, arg2: int, arg3: psi::Matrix, arg4: int, arg5: psi::IntVector)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dgetrf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgetrf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgetri.html:338,Deployability,update,updated,338,". psi4.core.DGETRI. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DGETRI. psi4.core.DGETRI(arg0: int, arg1: int, arg2: psi::Matrix, arg3: int, arg4: psi::IntVector, arg5: psi::Vector, arg6: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dgetri.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgetri.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgetrs.html:360,Deployability,update,updated,360,". psi4.core.DGETRS. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DGETRS. psi4.core.DGETRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dgetrs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dgetrs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.diagonalizeorder.html:514,Deployability,update,updated,514,". psi4.core.DiagonalizeOrder. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DiagonalizeOrder. class psi4.core.DiagonalizeOrder; Bases: object; docstring; Attributes Summary. Ascending. Descending. Attributes Documentation. Ascending = DiagonalizeOrder.Ascending. Descending = DiagonalizeOrder.Descending. Ascending = DiagonalizeOrder.Ascending. Descending = DiagonalizeOrder.Descending. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.diagonalizeorder.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.diagonalizeorder.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dimension.html:1739,Deployability,update,updated,1739,". psi4.core.Dimension. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Dimension. class psi4.core.Dimension; Bases: object; docstring; Attributes Summary. name; The name of the dimension. Methods Summary. from_list(dims[,name]); Builds a core.Dimension object from a python list or tuple. init((self:psi4.core.Dimension,arg0:int,...); Re-initializes the dimension object. n((self:psi4.core.Dimension)->int); The order of the dimension. print_out((self:psi4.core.Dimension)->None); docstring. to_tuple(dim); Converts a core.Dimension object to a tuple. Attributes Documentation. name; The name of the dimension. Used in printing. Methods Documentation. classmethod from_list(dims, name='New Dimension'); Builds a core.Dimension object from a python list or tuple. If a dimension; object is passed a copy will be returned. init(self: psi4.core.Dimension, arg0: int, arg1: str)  None; Re-initializes the dimension object. n(self: psi4.core.Dimension)  int; The order of the dimension. print_out(self: psi4.core.Dimension)  None; docstring. to_tuple(dim); Converts a core.Dimension object to a tuple. classmethod from_list(dims, name='New Dimension'); Builds a core.Dimension object from a python list or tuple. If a dimension; object is passed a copy will be returned. init(self: psi4.core.Dimension, arg0: int, arg1: str)  None; Re-initializes the dimension object. n(self: psi4.core.Dimension)  int; The order of the dimension. name; The name of the dimension. Used in printing. print_out(self: psi4.core.Dimension)  None; docstring. to_tuple(dim); Converts a core.Dimension object to a tuple. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dimension.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dimension.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dipoleint.html:543,Deployability,update,updated,543,". psi4.core.DipoleInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DipoleInt. class psi4.core.DipoleInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dipoleint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dipoleint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.disksomcscf.html:1412,Deployability,update,update,1412,". psi4.core.DiskSOMCSCF. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DiskSOMCSCF. class psi4.core.DiskSOMCSCF; Bases: psi4.core.SOMCSCF; docstring. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.disksomcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.disksomcscf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.disksomcscf.html:1746,Deployability,update,updated,1746,". psi4.core.DiskSOMCSCF. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DiskSOMCSCF. class psi4.core.DiskSOMCSCF; Bases: psi4.core.SOMCSCF; docstring. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.disksomcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.disksomcscf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dispersion.html:4830,Deployability,update,updated,4830,"rg0: str)  None; docstring. set_description(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_name(self: psi4.core.Dispersion, arg0: str)  None; docstring. sr6(self: psi4.core.Dispersion)  float; docstring. a1(self: psi4.core.Dispersion)  float; docstring. a2(self: psi4.core.Dispersion)  float; docstring. bibtex(self: psi4.core.Dispersion)  str; Get the BibTeX key for the literature reference. build(type: str, s6: float=0.0, p1: float=0.0, p2: float=0.0, p3: float=0.0)  psi4.core.Dispersion; docstring. citation(self: psi4.core.Dispersion)  str; docstring. compute_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  float; docstring. compute_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. compute_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. d(self: psi4.core.Dispersion)  float; docstring. description(self: psi4.core.Dispersion)  str; docstring. name(self: psi4.core.Dispersion)  str; docstring. print_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_out(self: psi4.core.Dispersion)  None; docstring. s6(self: psi4.core.Dispersion)  float; docstring. s8(self: psi4.core.Dispersion)  float; docstring. set_bibtex(self: psi4.core.Dispersion, arg0: str)  None; Set the BibTeX key for the literature reference. set_citation(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_description(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_name(self: psi4.core.Dispersion, arg0: str)  None; docstring. sr6(self: psi4.core.Dispersion)  float; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dispersion.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.displace_atom.html:358,Deployability,update,updated,358,". psi4.core.displace_atom. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.displace_atom. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float)  psi::Matrix; Displaces one coordinate of single atom. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.displace_atom.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.displace_atom.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dmrg.html:276,Deployability,update,updated,276,". psi4.core.dmrg. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.dmrg. psi4.core.dmrg(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the DMRG code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dnrm2.html:285,Deployability,update,updated,285,". psi4.core.DNRM2. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DNRM2. psi4.core.DNRM2(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dnrm2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dnrm2.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dpotrf.html:297,Deployability,update,updated,297,". psi4.core.DPOTRF. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DPOTRF. psi4.core.DPOTRF(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dpotrf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dpotrf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dpotri.html:297,Deployability,update,updated,297,". psi4.core.DPOTRI. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DPOTRI. psi4.core.DPOTRI(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dpotri.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dpotri.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dpotrs.html:338,Deployability,update,updated,338,". psi4.core.DPOTRS. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DPOTRS. psi4.core.DPOTRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Matrix, arg7: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dpotrs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dpotrs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.drot.html:337,Deployability,update,updated,337,". psi4.core.DROT. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DROT. psi4.core.DROT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int, arg6: float, arg7: float)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.drot.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.drot.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsbmv.html:394,Deployability,update,updated,394,". psi4.core.DSBMV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSBMV. psi4.core.DSBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dsbmv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsbmv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dscal.html:297,Deployability,update,updated,297,". psi4.core.DSCAL. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSCAL. psi4.core.DSCAL(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dscal.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dscal.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dswap.html:314,Deployability,update,updated,314,". psi4.core.DSWAP. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSWAP. psi4.core.DSWAP(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dswap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dswap.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyev.html:354,Deployability,update,updated,354,". psi4.core.DSYEV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSYEV. psi4.core.DSYEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dsyev.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyev.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsymm.html:406,Deployability,update,updated,406,". psi4.core.DSYMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSYMM. psi4.core.DSYMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dsymm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsymm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsymv.html:382,Deployability,update,updated,382,". psi4.core.DSYMV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSYMV. psi4.core.DSYMV(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: int, arg8: float, arg9: psi::Vector, arg10: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dsymv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsymv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyr.html:335,Deployability,update,updated,335,". psi4.core.DSYR. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSYR. psi4.core.DSYR(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Matrix, arg7: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dsyr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyr.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyr2.html:368,Deployability,update,updated,368,". psi4.core.DSYR2. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSYR2. psi4.core.DSYR2(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dsyr2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyr2.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyr2k.html:409,Deployability,update,updated,409,". psi4.core.DSYR2K. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSYR2K. psi4.core.DSYR2K(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dsyr2k.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyr2k.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyrk.html:374,Deployability,update,updated,374,". psi4.core.DSYRK. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSYRK. psi4.core.DSYRK(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: float, arg9: psi::Matrix, arg10: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dsyrk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsyrk.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsysv.html:388,Deployability,update,updated,388,". psi4.core.DSYSV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DSYSV. psi4.core.DSYSV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dsysv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dsysv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtbmv.html:358,Deployability,update,updated,358,". psi4.core.DTBMV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DTBMV. psi4.core.DTBMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dtbmv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtbmv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtbsv.html:358,Deployability,update,updated,358,". psi4.core.DTBSV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DTBSV. psi4.core.DTBSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dtbsv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtbsv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtrmm.html:384,Deployability,update,updated,384,". psi4.core.DTRMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DTRMM. psi4.core.DTRMM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dtrmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtrmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtrmv.html:347,Deployability,update,updated,347,". psi4.core.DTRMV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DTRMV. psi4.core.DTRMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dtrmv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtrmv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtrsm.html:384,Deployability,update,updated,384,". psi4.core.DTRSM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DTRSM. psi4.core.DTRSM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dtrsm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtrsm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtrsv.html:347,Deployability,update,updated,347,". psi4.core.DTRSV. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.DTRSV. psi4.core.DTRSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.dtrsv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.dtrsv.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.efp.html:1384,Deployability,update,updated,1384,". psi4.core.EFP. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.EFP. class psi4.core.EFP; Bases: object; Class interfacing with libefp; Methods Summary. compute((self:psi4.core.EFP)->None); Computes libefp energies and, if active, torque. nfragments((self:psi4.core.EFP)->int); Returns the number of EFP fragments in the molecule. print_out((self:psi4.core.EFP)->None); Prints options settings and EFP and QM geometries. set_qm_atoms((self:psi4.core.EFP)->None); Provides libefp with QM fragment information. Methods Documentation. compute(self: psi4.core.EFP)  None; Computes libefp energies and, if active, torque. nfragments(self: psi4.core.EFP)  int; Returns the number of EFP fragments in the molecule. print_out(self: psi4.core.EFP)  None; Prints options settings and EFP and QM geometries. set_qm_atoms(self: psi4.core.EFP)  None; Provides libefp with QM fragment information. compute(self: psi4.core.EFP)  None; Computes libefp energies and, if active, torque. nfragments(self: psi4.core.EFP)  int; Returns the number of EFP fragments in the molecule. print_out(self: psi4.core.EFP)  None; Prints options settings and EFP and QM geometries. set_qm_atoms(self: psi4.core.EFP)  None; Provides libefp with QM fragment information. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.efp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.efp.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.efp_init.html:296,Deployability,update,updated,296,". psi4.core.efp_init. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.efp_init. psi4.core.efp_init()  psi4.core.EFP; Initializes the EFP library and returns an EFP object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.efp_init.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.efp_init.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.efp_set_options.html:302,Deployability,update,updated,302,". psi4.core.efp_set_options. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.efp_set_options. psi4.core.efp_set_options()  None; Set EFP options from environment options object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.efp_set_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.efp_set_options.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.electricfieldint.html:564,Deployability,update,updated,564,". psi4.core.ElectricFieldInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ElectricFieldInt. class psi4.core.ElectricFieldInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.electricfieldint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.electricfieldint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.electrostaticint.html:564,Deployability,update,updated,564,". psi4.core.ElectrostaticInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ElectrostaticInt. class psi4.core.ElectrostaticInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.electrostaticint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.electrostaticint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.erfcomplementeri.html:402,Deployability,update,updated,402,". psi4.core.ErfComplementERI. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ErfComplementERI. class psi4.core.ErfComplementERI; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.erfcomplementeri.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.erfcomplementeri.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.erferi.html:372,Deployability,update,updated,372,". psi4.core.ErfERI. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ErfERI. class psi4.core.ErfERI; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.erferi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.erferi.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.eri.html:363,Deployability,update,updated,363,". psi4.core.ERI. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ERI. class psi4.core.ERI; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.eri.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.eri.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html:1650,Deployability,update,updated,1650,". psi4.core.ExternalPotential. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ExternalPotential. class psi4.core.ExternalPotential; Bases: object; docstring; Methods Summary. addBasis((self:psi4.core.ExternalPotential,...); docstring. addCharge(...); docstring. clear(...); docstring. computePotentialMatrix(...); docstring. print_out(...); docstring. setName((self:psi4.core.ExternalPotential,...); docstring. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector)  None; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float)  None; docstring. clear(self: psi4.core.ExternalPotential)  None; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet)  psi4.core.Matrix; docstring. print_out(self: psi4.core.ExternalPotential)  None; docstring. setName(self: psi4.core.ExternalPotential, arg0: str)  None; docstring. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector)  None; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float)  None; docstring. clear(self: psi4.core.ExternalPotential)  None; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet)  psi4.core.Matrix; docstring. print_out(self: psi4.core.ExternalPotential)  None; docstring. setName(self: psi4.core.ExternalPotential, arg0: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.externalpotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html:288,Usability,clear,clear,288,". psi4.core.ExternalPotential. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ExternalPotential. class psi4.core.ExternalPotential; Bases: object; docstring; Methods Summary. addBasis((self:psi4.core.ExternalPotential,...); docstring. addCharge(...); docstring. clear(...); docstring. computePotentialMatrix(...); docstring. print_out(...); docstring. setName((self:psi4.core.ExternalPotential,...); docstring. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector)  None; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float)  None; docstring. clear(self: psi4.core.ExternalPotential)  None; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet)  psi4.core.Matrix; docstring. print_out(self: psi4.core.ExternalPotential)  None; docstring. setName(self: psi4.core.ExternalPotential, arg0: str)  None; docstring. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector)  None; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float)  None; docstring. clear(self: psi4.core.ExternalPotential)  None; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet)  psi4.core.Matrix; docstring. print_out(self: psi4.core.ExternalPotential)  None; docstring. setName(self: psi4.core.ExternalPotential, arg0: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.externalpotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html:693,Usability,clear,clear,693,". psi4.core.ExternalPotential. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ExternalPotential. class psi4.core.ExternalPotential; Bases: object; docstring; Methods Summary. addBasis((self:psi4.core.ExternalPotential,...); docstring. addCharge(...); docstring. clear(...); docstring. computePotentialMatrix(...); docstring. print_out(...); docstring. setName((self:psi4.core.ExternalPotential,...); docstring. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector)  None; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float)  None; docstring. clear(self: psi4.core.ExternalPotential)  None; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet)  psi4.core.Matrix; docstring. print_out(self: psi4.core.ExternalPotential)  None; docstring. setName(self: psi4.core.ExternalPotential, arg0: str)  None; docstring. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector)  None; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float)  None; docstring. clear(self: psi4.core.ExternalPotential)  None; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet)  psi4.core.Matrix; docstring. print_out(self: psi4.core.ExternalPotential)  None; docstring. setName(self: psi4.core.ExternalPotential, arg0: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.externalpotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html:1238,Usability,clear,clear,1238,". psi4.core.ExternalPotential. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ExternalPotential. class psi4.core.ExternalPotential; Bases: object; docstring; Methods Summary. addBasis((self:psi4.core.ExternalPotential,...); docstring. addCharge(...); docstring. clear(...); docstring. computePotentialMatrix(...); docstring. print_out(...); docstring. setName((self:psi4.core.ExternalPotential,...); docstring. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector)  None; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float)  None; docstring. clear(self: psi4.core.ExternalPotential)  None; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet)  psi4.core.Matrix; docstring. print_out(self: psi4.core.ExternalPotential)  None; docstring. setName(self: psi4.core.ExternalPotential, arg0: str)  None; docstring. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector)  None; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float)  None; docstring. clear(self: psi4.core.ExternalPotential)  None; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet)  psi4.core.Matrix; docstring. print_out(self: psi4.core.ExternalPotential)  None; docstring. setName(self: psi4.core.ExternalPotential, arg0: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.externalpotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.f12.html:363,Deployability,update,updated,363,". psi4.core.F12. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.F12. class psi4.core.F12; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.f12.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.f12.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.f12doublecommutator.html:411,Deployability,update,updated,411,". psi4.core.F12DoubleCommutator. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.F12DoubleCommutator. class psi4.core.F12DoubleCommutator; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.f12doublecommutator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.f12doublecommutator.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.f12g12.html:372,Deployability,update,updated,372,". psi4.core.F12G12. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.F12G12. class psi4.core.F12G12; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.f12g12.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.f12g12.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.f12squared.html:384,Deployability,update,updated,384,". psi4.core.F12Squared. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.F12Squared. class psi4.core.F12Squared; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.f12squared.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.f12squared.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fchkwriter.html:482,Deployability,update,updated,482,". psi4.core.FCHKWriter. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.FCHKWriter. class psi4.core.FCHKWriter; Bases: object; docstring; Methods Summary. write((self:psi4.core.FCHKWriter,...); docstring. Methods Documentation. write(self: psi4.core.FCHKWriter, arg0: str)  None; docstring. write(self: psi4.core.FCHKWriter, arg0: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fchkwriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fchkwriter.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_1_0.html:335,Deployability,update,updated,335,". psi4.core.fd_1_0. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_1_0. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list)  psi::Matrix; Performs a finite difference gradient computation, from energy points. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_1_0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_1_0.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_1_0.html:220,Energy Efficiency,energy,energy,220,". psi4.core.fd_1_0. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_1_0. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list)  psi::Matrix; Performs a finite difference gradient computation, from energy points. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_1_0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_1_0.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_freq_0.html:375,Deployability,update,updated,375,". psi4.core.fd_freq_0. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_freq_0. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int)  psi::Matrix; Performs a finite difference frequency computation, from energy points, for a given irrep. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_freq_0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_freq_0.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_freq_0.html:241,Energy Efficiency,energy,energy,241,". psi4.core.fd_freq_0. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_freq_0. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int)  psi::Matrix; Performs a finite difference frequency computation, from energy points, for a given irrep. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_freq_0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_freq_0.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_freq_1.html:371,Deployability,update,updated,371,". psi4.core.fd_freq_1. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_freq_1. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int)  psi::Matrix; Performs a finite difference frequency computation, from gradients, for a given irrep. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_freq_1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_freq_1.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_1_0.html:376,Deployability,update,updated,376,". psi4.core.fd_geoms_1_0. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_geoms_1_0. psi4.core.fd_geoms_1_0(arg0: psi::Molecule)  List[psi::Matrix]; Gets list of displacements needed for a finite difference gradient computation, from energy points. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_geoms_1_0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_1_0.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_1_0.html:261,Energy Efficiency,energy,energy,261,". psi4.core.fd_geoms_1_0. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_geoms_1_0. psi4.core.fd_geoms_1_0(arg0: psi::Molecule)  List[psi::Matrix]; Gets list of displacements needed for a finite difference gradient computation, from energy points. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_geoms_1_0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_1_0.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_freq_0.html:416,Deployability,update,updated,416,". psi4.core.fd_geoms_freq_0. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_geoms_freq_0. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int)  List[psi::Matrix]; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_geoms_freq_0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_freq_0.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_freq_0.html:282,Energy Efficiency,energy,energy,282,". psi4.core.fd_geoms_freq_0. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_geoms_freq_0. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int)  List[psi::Matrix]; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_geoms_freq_0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_freq_0.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_freq_1.html:412,Deployability,update,updated,412,". psi4.core.fd_geoms_freq_1. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fd_geoms_freq_1. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int)  List[psi::Matrix]; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fd_geoms_freq_1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fd_geoms_freq_1.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.finalize.html:232,Deployability,update,updated,232,". psi4.core.finalize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.finalize. psi4.core.finalize()  None. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.finalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.finalize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fisapt.html:334,Deployability,update,updated,334,". psi4.core.fisapt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fisapt. psi4.core.fisapt(arg0: psi::Wavefunction)  float; Runs the functional-group intramolecular symmetry adapted perturbation theory code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fisapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fisapt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fisapt.html:200,Energy Efficiency,adapt,adapted,200,". psi4.core.fisapt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fisapt. psi4.core.fisapt(arg0: psi::Wavefunction)  float; Runs the functional-group intramolecular symmetry adapted perturbation theory code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fisapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fisapt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fisapt.html:200,Modifiability,adapt,adapted,200,". psi4.core.fisapt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fisapt. psi4.core.fisapt(arg0: psi::Wavefunction)  float; Runs the functional-group intramolecular symmetry adapted perturbation theory code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fisapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fisapt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fittedslatercorrelationfactor.html:639,Deployability,update,updated,639,". psi4.core.FittedSlaterCorrelationFactor. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.FittedSlaterCorrelationFactor. class psi4.core.FittedSlaterCorrelationFactor; Bases: psi4.core.CorrelationFactor; docstring; Methods Summary. exponent(...). Methods Documentation. exponent(self: psi4.core.FittedSlaterCorrelationFactor)  float. exponent(self: psi4.core.FittedSlaterCorrelationFactor)  float. set_params(self: psi4.core.CorrelationFactor, arg0: psi4.core.Vector, arg1: psi4.core.Vector)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fittedslatercorrelationfactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fittedslatercorrelationfactor.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fittingmetric.html:2255,Deployability,update,updated,2255,"form_full_inverse(...); docstring. get_algorithm(...); docstring. get_metric(...); docstring. get_pivots(...); docstring. get_reverse_pivots(...); docstring. is_inverted(...); docstring. is_poisson(...); docstring. Methods Documentation. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric)  None; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_fitting_metric(self: psi4.core.FittingMetric)  None; docstring. form_full_inverse(self: psi4.core.FittingMetric)  None; docstring. get_algorithm(self: psi4.core.FittingMetric)  str; docstring. get_metric(self: psi4.core.FittingMetric)  psi4.core.Matrix; docstring. get_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. get_reverse_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. is_inverted(self: psi4.core.FittingMetric)  bool; docstring. is_poisson(self: psi4.core.FittingMetric)  bool; docstring. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric)  None; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_fitting_metric(self: psi4.core.FittingMetric)  None; docstring. form_full_inverse(self: psi4.core.FittingMetric)  None; docstring. get_algorithm(self: psi4.core.FittingMetric)  str; docstring. get_metric(self: psi4.core.FittingMetric)  psi4.core.Matrix; docstring. get_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. get_reverse_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. is_inverted(self: psi4.core.FittingMetric)  bool; docstring. is_poisson(self: psi4.core.FittingMetric)  bool; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fittingmetric.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fittingmetric.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.flush_outfile.html:272,Deployability,update,updated,272,". psi4.core.flush_outfile. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.flush_outfile. psi4.core.flush_outfile()  None; Flushes the output file. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.flush_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.flush_outfile.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fnocc.html:311,Deployability,update,updated,311,". psi4.core.fnocc. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fnocc. psi4.core.fnocc(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.fnocc.html:198,Energy Efficiency,energy,energy,198,". psi4.core.fnocc. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.fnocc. psi4.core.fnocc(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.functional.html:4513,Deployability,update,updated,4513,"si4.core.Functional, arg0: bool)  None; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_name(self: psi4.core.Functional, arg0: str)  None; docstring. set_omega(self: psi4.core.Functional, arg0: float)  None; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float)  None; docstring. alpha(self: psi4.core.Functional)  float; docstring. build_base(alias: str)  psi4.core.Functional; docstring. citation(self: psi4.core.Functional)  str; docstring. description(self: psi4.core.Functional)  str; docstring. is_gga(self: psi4.core.Functional)  bool; docstring. is_lrc(self: psi4.core.Functional)  bool; docstring. is_meta(self: psi4.core.Functional)  bool; docstring. lsda_cutoff(self: psi4.core.Functional)  float; docstring. meta_cutoff(self: psi4.core.Functional)  float; docstring. name(self: psi4.core.Functional)  str; docstring. omega(self: psi4.core.Functional)  float; docstring. print_detail(self: psi4.core.SuperFunctional, arg0: int)  None; docstring. print_out(self: psi4.core.Functional)  None; docstring. set_alpha(self: psi4.core.Functional, arg0: float)  None; docstring. set_citation(self: psi4.core.Functional, arg0: str)  None; docstring. set_description(self: psi4.core.Functional, arg0: str)  None; docstring. set_gga(self: psi4.core.Functional, arg0: bool)  None; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_meta(self: psi4.core.Functional, arg0: bool)  None; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_name(self: psi4.core.Functional, arg0: str)  None; docstring. set_omega(self: psi4.core.Functional, arg0: float)  None; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.functional.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.gaussian94basissetparser.html:321,Deployability,update,updated,321,". psi4.core.Gaussian94BasisSetParser. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Gaussian94BasisSetParser. class psi4.core.Gaussian94BasisSetParser; Bases: psi4.core.BasisSetParser; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.gaussian94basissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.gaussian94basissetparser.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.gaussianshell.html:2170,Deployability,update,updated,2170,"nction_index; Basis function index where this shell starts. ncartesian; docstring. ncenter; docstring. nfunction; docstring. nprimitive; docstring. Methods Summary. coef((self:psi4.core.GaussianShell,...); docstring. erd_coef((self:psi4.core.GaussianShell,...); docstring. exp((self:psi4.core.GaussianShell,...); Returns the exponent of the given primitive. is_cartesian(...); docstring. is_pure((self:psi4.core.GaussianShell)->bool); docstring. original_coef(...); docstring. Attributes Documentation. AMCHAR; docstring. am; docstring. amchar; docstring. function_index; Basis function index where this shell starts. ncartesian; docstring. ncenter; docstring. nfunction; docstring. nprimitive; docstring. Methods Documentation. coef(self: psi4.core.GaussianShell, arg0: int)  float; docstring. erd_coef(self: psi4.core.GaussianShell, arg0: int)  float; docstring. exp(self: psi4.core.GaussianShell, arg0: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; docstring. is_pure(self: psi4.core.GaussianShell)  bool; docstring. original_coef(self: psi4.core.GaussianShell, arg0: int)  float; docstring. AMCHAR; docstring. am; docstring. amchar; docstring. coef(self: psi4.core.GaussianShell, arg0: int)  float; docstring. erd_coef(self: psi4.core.GaussianShell, arg0: int)  float; docstring. exp(self: psi4.core.GaussianShell, arg0: int)  float; Returns the exponent of the given primitive. function_index; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell)  bool; docstring. is_pure(self: psi4.core.GaussianShell)  bool; docstring. ncartesian; docstring. ncenter; docstring. nfunction; docstring. nprimitive; docstring. original_coef(self: psi4.core.GaussianShell, arg0: int)  float; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.gaussianshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.gaussianshell.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.gaussiantype.html:456,Deployability,update,updated,456,". psi4.core.GaussianType. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.GaussianType. class psi4.core.GaussianType; Bases: object; docstring; Attributes Summary. Cartesian. Pure. Attributes Documentation. Cartesian = GaussianType.Cartesian. Pure = GaussianType.Pure. Cartesian = GaussianType.Cartesian. Pure = GaussianType.Pure. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.gaussiantype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.gaussiantype.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.geometryunits.html:458,Deployability,update,updated,458,". psi4.core.GeometryUnits. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.GeometryUnits. class psi4.core.GeometryUnits; Bases: object; docstring; Attributes Summary. Angstrom. Bohr. Attributes Documentation. Angstrom = GeometryUnits.Angstrom. Bohr = GeometryUnits.Bohr. Angstrom = GeometryUnits.Angstrom. Bohr = GeometryUnits.Bohr. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.geometryunits.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.geometryunits.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_active_efp.html:300,Deployability,update,updated,300,". psi4.core.get_active_efp. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_active_efp. psi4.core.get_active_efp()  psi4.core.EFP; Returns the currently active EFP object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_active_efp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_active_efp.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_active_molecule.html:320,Deployability,update,updated,320,". psi4.core.get_active_molecule. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_active_molecule. psi4.core.get_active_molecule()  psi::Molecule; Returns the currently active molecule object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_active_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_active_molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variable.html:300,Availability,avail,available,300,". psi4.core.get_array_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_array_variable. psi4.core.get_array_variable(arg0: str)  psi::Matrix; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variable.html:412,Deployability,update,updated,412,". psi4.core.get_array_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_array_variable. psi4.core.get_array_variable(arg0: str)  psi::Matrix; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variable.html:201,Modifiability,variab,variables,201,". psi4.core.get_array_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_array_variable. psi4.core.get_array_variable(arg0: str)  psi::Matrix; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variable.html:290,Modifiability,variab,variables,290,". psi4.core.get_array_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_array_variable. psi4.core.get_array_variable(arg0: str)  psi::Matrix; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variables.html:371,Deployability,update,updated,371,". psi4.core.get_array_variables. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_array_variables. psi4.core.get_array_variables()  Dict[str, psi::Matrix]; Returns dictionary of the PSI variables set internally by the modules or python driver. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variables.html:213,Modifiability,variab,variables,213,". psi4.core.get_array_variables. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_array_variables. psi4.core.get_array_variables()  Dict[str, psi::Matrix]; Returns dictionary of the PSI variables set internally by the modules or python driver. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_atomic_point_charges.html:366,Deployability,update,updated,366,". psi4.core.get_atomic_point_charges. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_atomic_point_charges. psi4.core.get_atomic_point_charges()  psi::Vector; Returns the most recently computed atomic point charges, as a double * object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_atomic_point_charges.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_atomic_point_charges.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_atomic_point_charges.html:235,Energy Efficiency,charge,charges,235,". psi4.core.get_atomic_point_charges. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_atomic_point_charges. psi4.core.get_atomic_point_charges()  psi::Vector; Returns the most recently computed atomic point charges, as a double * object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_atomic_point_charges.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_atomic_point_charges.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_efp_torque.html:352,Deployability,update,updated,352,". psi4.core.get_efp_torque. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_efp_torque. psi4.core.get_efp_torque()  psi::Matrix; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_efp_torque.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_efp_torque.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_environment.html:288,Deployability,update,updated,288,". psi4.core.get_environment. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_environment. psi4.core.get_environment(arg0: str)  str; Get enviromental vairable. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_environment.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_environment.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_frequencies.html:333,Deployability,update,updated,333,". psi4.core.get_frequencies. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_frequencies. psi4.core.get_frequencies()  psi::Vector; Returns the most recently computed frequencies, as a 3N-6 Vector object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_global_option.html:288,Availability,error,error,288,". psi4.core.get_global_option. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_global_option. psi4.core.get_global_option(arg0: str)  object; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_global_option.html:424,Deployability,update,updated,424,". psi4.core.get_global_option. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_global_option. psi4.core.get_global_option(arg0: str)  object; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_global_option_list.html:317,Deployability,update,updated,317,". psi4.core.get_global_option_list. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_global_option_list. psi4.core.get_global_option_list()  List[str]; Returns a list of all global options. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_global_option_list.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_global_option_list.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_gradient.html:323,Deployability,update,updated,323,". psi4.core.get_gradient. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_gradient. psi4.core.get_gradient()  psi::Matrix; Returns the most recently computed gradient, as a N by 3 Matrix object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_gradient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_gradient.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_legacy_molecule.html:320,Deployability,update,updated,320,". psi4.core.get_legacy_molecule. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_legacy_molecule. psi4.core.get_legacy_molecule()  psi::Molecule; Returns the currently active molecule object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_legacy_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_legacy_molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_local_option.html:329,Availability,error,error,329,". psi4.core.get_local_option. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_local_option. psi4.core.get_local_option(arg0: str, arg1: str)  object; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_local_option.html:480,Deployability,update,updated,480,". psi4.core.get_local_option. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_local_option. psi4.core.get_local_option(arg0: str, arg1: str)  object; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_memory.html:166,Availability,avail,available,166,". psi4.core.get_memory. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_memory.html:295,Deployability,update,updated,295,". psi4.core.get_memory. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_num_threads.html:319,Deployability,update,updated,319,". psi4.core.get_num_threads. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_num_threads. psi4.core.get_num_threads()  int; Returns the number of threads to use in SMP parallel computations. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_num_threads.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_option.html:381,Availability,error,error,381,". psi4.core.get_option. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_option. psi4.core.get_option(arg0: str, arg1: str)  object; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if its been set, else the global value if its been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_option.html:573,Deployability,update,updated,573,". psi4.core.get_option. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_option. psi4.core.get_option(arg0: str, arg1: str)  object; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if its been set, else the global value if its been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_output_file.html:252,Deployability,update,updated,252,". psi4.core.get_output_file. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_output_file. psi4.core.get_output_file()  str. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_output_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_output_file.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variable.html:276,Availability,avail,available,276,". psi4.core.get_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_variable. psi4.core.get_variable(arg0: str)  float; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variable.html:388,Deployability,update,updated,388,". psi4.core.get_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_variable. psi4.core.get_variable(arg0: str)  float; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variable.html:177,Modifiability,variab,variables,177,". psi4.core.get_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_variable. psi4.core.get_variable(arg0: str)  float; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variable.html:266,Modifiability,variab,variables,266,". psi4.core.get_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_variable. psi4.core.get_variable(arg0: str)  float; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variables.html:347,Deployability,update,updated,347,". psi4.core.get_variables. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_variables. psi4.core.get_variables()  Dict[str, float]; Returns dictionary of the PSI variables set internally by the modules or python driver. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variables.html:189,Modifiability,variab,variables,189,". psi4.core.get_variables. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_variables. psi4.core.get_variables()  Dict[str, float]; Returns dictionary of the PSI variables set internally by the modules or python driver. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_writer_file_prefix.html:349,Deployability,update,updated,349,". psi4.core.get_writer_file_prefix. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.get_writer_file_prefix. psi4.core.get_writer_file_prefix(arg0: str)  str; Returns the prefix to use for writing files for external programs. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.get_writer_file_prefix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.get_writer_file_prefix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.git_version.html:285,Deployability,update,updated,285,". psi4.core.git_version. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.git_version. psi4.core.git_version()  str; Returns the git version of this copy of Psi. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.git_version.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.git_version.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_global_option_changed.html:537,Deployability,update,updated,537,". psi4.core.has_global_option_changed. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.has_global_option_changed. psi4.core.has_global_option_changed(arg0: str)  bool; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.has_global_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_global_option_changed.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_local_option_changed.html:567,Deployability,update,updated,567,". psi4.core.has_local_option_changed. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.has_local_option_changed. psi4.core.has_local_option_changed(arg0: str, arg1: str)  bool; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.has_local_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_local_option_changed.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_option_changed.html:542,Deployability,update,updated,542,". psi4.core.has_option_changed. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.has_option_changed. psi4.core.has_option_changed(arg0: str, arg1: str)  bool; Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.has_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_option_changed.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_variable.html:301,Deployability,update,updated,301,". psi4.core.has_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.has_variable. psi4.core.has_variable(arg0: str)  bool; Returns true if the PSI variable exists/is set. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.has_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_variable.html:177,Modifiability,variab,variable,177,". psi4.core.has_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.has_variable. psi4.core.has_variable(arg0: str)  bool; Returns true if the PSI variable exists/is set. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.has_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.has_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:12993,Deployability,update,updated,12993,": psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:475,Energy Efficiency,energy,energy,475,". psi4.core.HF. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.HF. class psi4.core.HF; Bases: psi4.core.Wavefunction; docstring; Methods Summary. V_potential(...); Returns the internal DFT V object. Va((self:psi4.core.HF)->psi4.core.Matrix); Returns the Alpha Kohn-Shame Potential Matrix. Vb((self:psi4.core.HF)->psi4.core.Matrix); Returns the Alpha Kohn-Shame Potential Matrix. finalize_E((self:psi4.core.HF)->float); Computes the final SCF energy. form_C((self:psi4.core.HF)->None); Forms the Orbital Matrices from the current Fock Matrices. form_D((self:psi4.core.HF)->None); Forms the Density Matrices from the current Orbitals Matrices. form_V((self:psi4.core.HF)->None); Form the Kohn-Sham Potential Matrices from the current Density Matrices. functional(...); Returns the internal DFT Superfunctional. guess_Ca((self:psi4.core.HF,...); Sets the guess Alpha Orbital Matrix. guess_Cb((self:psi4.core.HF,...); Sets the guess Beta Orbital Matrix. initialize((self:psi4.core.HF)->None); Initializes the Wavefunction. iterations((self:psi4.core.HF)->None); Iterates the Wavefunction until convergence criteria have been met. jk((self:psi4.core.HF)->psi4.core.JK); Returns the internal JK object. occupation_a(...); Returns the Alpha occupation numbers. occupation_b(...); Returns the Beta occupation numbers. reset_occ((self:psi4.core.HF,...); If True, the occupation will be reset after the guess to the inital occupation. semicanonicalize((self:psi4.core.HF)->None); Semicanonicalizes the orbitals for ROHF. set_sad_basissets((self:psi4.core.HF,...); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(...); Sets the Superposition of Atomic Densities density-fitted basisset. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF)  psi4.c",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:2125,Energy Efficiency,energy,energy,2125,"Iterates the Wavefunction until convergence criteria have been met. jk((self:psi4.core.HF)->psi4.core.JK); Returns the internal JK object. occupation_a(...); Returns the Alpha occupation numbers. occupation_b(...); Returns the Beta occupation numbers. reset_occ((self:psi4.core.HF,...); If True, the occupation will be reset after the guess to the inital occupation. semicanonicalize((self:psi4.core.HF)->None); Semicanonicalizes the orbitals for ROHF. set_sad_basissets((self:psi4.core.HF,...); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(...); Sets the Superposition of Atomic Densities density-fitted basisset. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Beta Orbital Matrix. initialize(self: psi4.core.HF)  None; Initializes the Wavefunction. iterations(self: psi4.core.HF)  None; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF)  psi4.core.JK; Returns the internal JK object. occupation_a(self: psi4.core.HF)  psi4.core.Vector; Returns the Alpha occupation numbers. occupation_b(self: psi4.core.HF)",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:5670,Energy Efficiency,charge,charges,5670,"k Matrix. H(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Core Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of d",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:6213,Energy Efficiency,energy,energy,6213,"gian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:6690,Energy Efficiency,energy,energy,6690,"lf: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessi",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:6763,Energy Efficiency,energy,energy,6763,".Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:7292,Energy Efficiency,energy,energy,7292,"efunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable(self",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:8356,Modifiability,variab,variable,8356," None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF)  None; Initializes the Wavefunction. iterations(self: psi4.core.HF)  None; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF)  psi4.core.JK; Returns the internal JK object. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction)  int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction)  str; The le",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:12433,Modifiability,variab,variable,12433,": psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:12789,Modifiability,variab,variables,12789,": psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:12882,Modifiability,variab,variables,12882,": psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.hf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.idamax.html:286,Deployability,update,updated,286,". psi4.core.IDAMAX. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.IDAMAX. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.idamax.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.idamax.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.initialize.html:238,Deployability,update,updated,238,". psi4.core.initialize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.initialize. psi4.core.initialize()  bool. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.initialize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.initialize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.integralfactory.html:8138,Deployability,update,updated,8138,"cstring. eri(self: psi4.core.IntegralFactory, deriv: int=0, use_shell_pairs: bool=True)  psi4.core.TwoBodyAOInt; docstring. f12(self: psi4.core.IntegralFactory, cf: psi::CorrelationFactor, deriv: int=0, use_shell_pairs: bool=True)  psi4.core.TwoBodyAOInt; docstring. f12_double_commutator(self: psi4.core.IntegralFactory, cf: psi::CorrelationFactor, deriv: int=0, use_shell_pairs: bool=True)  psi4.core.TwoBodyAOInt; docstring. f12_squared(self: psi4.core.IntegralFactory, cf: psi::CorrelationFactor, deriv: int=0, use_shell_pairs: bool=True)  psi4.core.TwoBodyAOInt; docstring. f12g12(self: psi4.core.IntegralFactory, cf: psi::CorrelationFactor, deriv: int=0, use_shell_pairs: bool=True)  psi4.core.TwoBodyAOInt; docstring. overlap_3c(self: psi4.core.IntegralFactory)  psi4.core.ThreeCenterOverlapInt; docstring. shells_iterator(self: psi4.core.IntegralFactory)  psi4.core.AOShellCombinationsIterator; docstring. so_angular_momentum(self: psi4.core.IntegralFactory, deriv: int=0)  psi::OneBodySOInt; docstring. so_dipole(self: psi4.core.IntegralFactory, deriv: int=0)  psi::OneBodySOInt; docstring. so_kinetic(self: psi4.core.IntegralFactory, deriv: int=0)  psi::OneBodySOInt; docstring. so_multipoles(self: psi4.core.IntegralFactory, order: int)  psi::OneBodySOInt; docstring. so_nabla(self: psi4.core.IntegralFactory, deriv: int=0)  psi::OneBodySOInt; docstring. so_overlap(self: psi4.core.IntegralFactory, deriv: int=0)  psi::OneBodySOInt; docstring. so_potential(self: psi4.core.IntegralFactory, deriv: int=0)  psi::OneBodySOInt; docstring. so_pseudospectral(self: psi4.core.IntegralFactory, deriv: int=0)  psi::OneBodySOInt; docstring. so_quadrupole(self: psi4.core.IntegralFactory)  psi::OneBodySOInt; docstring. so_traceless_quadrupole(self: psi4.core.IntegralFactory)  psi::OneBodySOInt; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.integralfactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.integralfactory.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.intvector.html:1230,Deployability,update,updated,1230,". psi4.core.IntVector. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.IntVector. class psi4.core.IntVector; Bases: object; docstring; Methods Summary. dim((self:psi4.core.IntVector,...); docstring. get((self:psi4.core.IntVector,arg0:int,...); docstring. nirrep((self:psi4.core.IntVector)->int); docstring. print_out((self:psi4.core.IntVector)->None); docstring. set((self:psi4.core.IntVector,arg0:int,...); docstring. Methods Documentation. dim(self: psi4.core.IntVector, arg0: int)  int; docstring. get(self: psi4.core.IntVector, arg0: int, arg1: int)  int; docstring. nirrep(self: psi4.core.IntVector)  int; docstring. print_out(self: psi4.core.IntVector)  None; docstring. set(self: psi4.core.IntVector, arg0: int, arg1: int, arg2: int)  None; docstring. dim(self: psi4.core.IntVector, arg0: int)  int; docstring. get(self: psi4.core.IntVector, arg0: int, arg1: int)  int; docstring. nirrep(self: psi4.core.IntVector)  int; docstring. print_out(self: psi4.core.IntVector)  None; docstring. set(self: psi4.core.IntVector, arg0: int, arg1: int, arg2: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.intvector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.intvector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.io.html:2493,Deployability,update,updated,2493,"ne); docstring. shared_object(()->psi4.core.IO); docstring. state((self:psi4.core.IO)->int); docstring. tocclean((self:psi4.core.IO,arg0:int,...); docstring. tocprint((self:psi4.core.IO,arg0:int)->None); docstring. tocwrite((self:psi4.core.IO,arg0:int)->None); docstring. Methods Documentation. change_file_namespace(fileno: int, ns1: str, ns2: str)  None; docstring. close(self: psi4.core.IO, arg0: int, arg1: int)  None; docstring. get_default_namespace()  str; docstring. open(self: psi4.core.IO, arg0: int, arg1: int)  None; docstring. open_check(self: psi4.core.IO, arg0: int)  int; docstring. rehash(self: psi4.core.IO, arg0: int)  None; docstring. set_default_namespace(ns: str)  None; docstring. set_pid(self: psi4.core.IO, arg0: str)  None; docstring. shared_object()  psi4.core.IO; docstring. state(self: psi4.core.IO)  int; docstring. tocclean(self: psi4.core.IO, arg0: int, arg1: str)  None; docstring. tocprint(self: psi4.core.IO, arg0: int)  None; docstring. tocwrite(self: psi4.core.IO, arg0: int)  None; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str)  None; docstring. close(self: psi4.core.IO, arg0: int, arg1: int)  None; docstring. get_default_namespace()  str; docstring. open(self: psi4.core.IO, arg0: int, arg1: int)  None; docstring. open_check(self: psi4.core.IO, arg0: int)  int; docstring. rehash(self: psi4.core.IO, arg0: int)  None; docstring. set_default_namespace(ns: str)  None; docstring. set_pid(self: psi4.core.IO, arg0: str)  None; docstring. shared_object()  psi4.core.IO; docstring. state(self: psi4.core.IO)  int; docstring. tocclean(self: psi4.core.IO, arg0: int, arg1: str)  None; docstring. tocprint(self: psi4.core.IO, arg0: int)  None; docstring. tocwrite(self: psi4.core.IO, arg0: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.io.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.io.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.iomanager.html:2410,Deployability,update,updated,2410," set_default_path((self:psi4.core.IOManager,...); docstring. set_specific_path(...); docstring. set_specific_retention(...); docstring. shared_object(()->psi4.core.IOManager); docstring. write_scratch_file(...); docstring. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; docstring. get_default_path(self: psi4.core.IOManager)  str; docstring. get_file_path(self: psi4.core.IOManager, arg0: int)  str; docstring. mark_file_for_retention(self: psi4.core.IOManager, arg0: str, arg1: bool)  None; docstring. print_out(self: psi4.core.IOManager)  None; docstring. psiclean(self: psi4.core.IOManager)  None; docstring. set_default_path(self: psi4.core.IOManager, arg0: str)  None; docstring. set_specific_path(self: psi4.core.IOManager, arg0: int, arg1: str)  None; docstring. set_specific_retention(self: psi4.core.IOManager, arg0: int, arg1: bool)  None; docstring. shared_object()  psi4.core.IOManager; docstring. write_scratch_file(self: psi4.core.IOManager, arg0: str, arg1: str)  None; docstring. crashclean(self: psi4.core.IOManager)  None; docstring. get_default_path(self: psi4.core.IOManager)  str; docstring. get_file_path(self: psi4.core.IOManager, arg0: int)  str; docstring. mark_file_for_retention(self: psi4.core.IOManager, arg0: str, arg1: bool)  None; docstring. print_out(self: psi4.core.IOManager)  None; docstring. psiclean(self: psi4.core.IOManager)  None; docstring. set_default_path(self: psi4.core.IOManager, arg0: str)  None; docstring. set_specific_path(self: psi4.core.IOManager, arg0: int, arg1: str)  None; docstring. set_specific_retention(self: psi4.core.IOManager, arg0: int, arg1: bool)  None; docstring. shared_object()  psi4.core.IOManager; docstring. write_scratch_file(self: psi4.core.IOManager, arg0: str, arg1: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.iomanager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.iomanager.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.jk.html:4417,Deployability,update,updated,4417,"4.core.JK, arg0: int)  None. set_omega(self: psi4.core.JK, arg0: float)  None. set_omp_nthread(self: psi4.core.JK, arg0: int)  None. wK(self: psi4.core.JK)  List[psi4.core.Matrix]. C_clear(self: psi4.core.JK)  None. C_left_add(self: psi4.core.JK, arg0: psi4.core.Matrix)  None. C_right_add(self: psi4.core.JK, arg0: psi4.core.Matrix)  None. D(self: psi4.core.JK)  List[psi4.core.Matrix]. J(self: psi4.core.JK)  List[psi4.core.Matrix]. K(self: psi4.core.JK)  List[psi4.core.Matrix]. static build(orbital_basis, aux=None, jk_type=None); Constructs a Psi4 JK object from an input basis. Parameters:; orbital_basis (BasisSet)  Orbital basis to use in the JK object.; aux (BasisSet)  Optional auxiliary basis set for density-fitted tensors. Defaults; to the DF_BASIS_SCF if set, otherwise the correspond JKFIT basis; to the passed in orbital_basis.; type (str)  Type of JK object to build (DF, Direct, PK, etc). Defaults to the; current global SCF_TYPE option. Returns:Uninitialized JK object. Return type:JK. Example; jk = psi4.core.JK.build(bas); jk.set_memory(int(5e8)) # 4GB of memory; jk.initialize(); ...; jk.C_left_add(matirx); jk.compute(); jk.C_clear(); ... build_JK(arg0: psi4.core.BasisSet, arg1: psi4.core.BasisSet)  psi4.core.JK. compute(self: psi4.core.JK)  None. finalize(self: psi4.core.JK)  None. initialize(self: psi4.core.JK)  None. print_header(self: psi4.core.JK)  None; docstring. set_cutoff(self: psi4.core.JK, arg0: float)  None. set_do_J(self: psi4.core.JK, arg0: bool)  None. set_do_K(self: psi4.core.JK, arg0: bool)  None. set_do_wK(self: psi4.core.JK, arg0: bool)  None. set_memory(self: psi4.core.JK, arg0: int)  None. set_omega(self: psi4.core.JK, arg0: float)  None. set_omp_nthread(self: psi4.core.JK, arg0: int)  None. wK(self: psi4.core.JK)  List[psi4.core.Matrix]. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.jk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.jk.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.kineticint.html:546,Deployability,update,updated,546,". psi4.core.KineticInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.KineticInt. class psi4.core.KineticInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.kineticint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.kineticint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.laplacedenominator.html:725,Deployability,update,updated,725,". psi4.core.LaplaceDenominator. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.LaplaceDenominator. class psi4.core.LaplaceDenominator; Bases: object; docstring; Methods Summary. denominator_occ(...); docstring. denominator_vir(...); docstring. Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; docstring. denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; docstring. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; docstring. denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.laplacedenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.laplacedenominator.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.legacy_wavefunction.html:359,Deployability,update,updated,359,". psi4.core.legacy_wavefunction. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.legacy_wavefunction. psi4.core.legacy_wavefunction()  psi::Wavefunction; Returns the current legacy_wavefunction object from the most recent computation. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.legacy_wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.legacy_wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.libfock.html:305,Deployability,update,updated,305,". psi4.core.libfock. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.libfock. psi4.core.libfock(arg0: psi::Wavefunction)  psi::Wavefunction; Runs a CPHF calculation, using libfock. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.libfock.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.libfock.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.localizer.html:1203,Deployability,update,updated,1203,". psi4.core.Localizer. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Localizer. class psi4.core.Localizer; Bases: object; docstring; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build((arg0:str,arg1:psi4.core.BasisSet,...); docstring. localize((self:psi4.core.Localizer)->None); Perform the localization procedure. Attributes Documentation. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Documentation. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; docstring. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. L; Localized orbital coefficients. U; Orbital rotation matrix. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; docstring. converged; Did the localization procedure converge?. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.localizer.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:16967,Deployability,update,updated,16967,"psi4.core.Matrix)  float; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule)  None; docstring. symmetry(self: psi4.core.Matrix)  int; docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix)  float; docstring. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. triplet(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: bool, arg3: bool, arg4: bool)  psi4.core.Matrix; docstring. vector_dot(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  float; docstring. zero(self: psi4.core.Matrix)  None; docstring. zero_diagonal(self: psi4.core.Matrix)  None; docstring. zero_lower(self: psi4.core.Matrix)  None; docstring. zero_upper(self: psi4.core.Matrix)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:1792,Energy Efficiency,power,power,1792," coldim(...); docstring. cols((self:psi4.core.Matrix,arg0:int)->int); docstring. copy((self:psi4.core.Matrix,...); docstring. copy_lower_to_upper(...); docstring. copy_upper_to_lower(...); docstring. diagonalize((self:psi4.core.Matrix,...); docstring. doublet((self:psi4.core.Matrix,...); docstring. from_array(arr[,name,dim1,dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm((self:psi4.core.Matrix,arg0:bool,...); docstring. get(*args,**kwargs); Overloaded function. identity((self:psi4.core.Matrix)->None); docstring. invert((self:psi4.core.Matrix)->None); docstring. load((self:psi4.core.Matrix,arg0:str)->None); docstring. load_mpqc((self:psi4.core.Matrix,...); docstring. nirrep((self:psi4.core.Matrix)->int); docstring. np_read(filename[,prefix]). np_write([filename,prefix]). partial_cholesky_factorize(...); docstring. power((self:psi4.core.Matrix,arg0:float,...); docstring. print_out((self:psi4.core.Matrix)->None); docstring. project_out((self:psi4.core.Matrix,...); docstring. remove_symmetry((self:psi4.core.Matrix,...); docstring. rms((self:psi4.core.Matrix)->float); docstring. rotate_columns((self:psi4.core.Matrix,...); docstring. rowdim(...); docstring. rows((self:psi4.core.Matrix,arg0:int)->int); docstring. save((self:psi4.core.Matrix,arg0:str,...); docstring. scale((self:psi4.core.Matrix,...); docstring. scale_column((self:psi4.core.Matrix,...); docstring. scale_row((self:psi4.core.Matrix,...); docstring. schmidt((self:psi4.core.Matrix)->None). set(*args,**kwargs); Overloaded function. subtract((self:psi4.core.Matrix,...); docstring. sum_of_squares((self:psi4.core.Matrix)->float); docstring. symmetrize_gradient((self:psi4.core.Matrix,...); docstring. symmetry((self:psi4.core.Matrix)->int); docstring. to_array(matrix[,copy,dense]); Converts a Psi4 Matrix or ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:6888,Energy Efficiency,power,power,6888," matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self: psi4.core.Matrix, arg0: bool, arg1: bool, arg2: float, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix, arg5: float)  None; docstring. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int) -> float. docstring. get(self: psi4.core.Matrix, arg0: int, arg1: int) -> float. docstring. identity(self: psi4.core.Matrix)  None; docstring. invert(self: psi4.core.Matrix)  None; docstring. load(self: psi4.core.Matrix, arg0: str)  None; docstring. load_mpqc(self: psi4.core.Matrix, arg0: str)  None; docstring. nirrep(self: psi4.core.Matrix)  int; docstring. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). partial_cholesky_factorize(self: psi4.core.Matrix, arg0: float, arg1: bool)  psi4.core.Matrix; docstring. power(self: psi4.core.Matrix, arg0: float, arg1: float)  psi4.core.Dimension; docstring. print_out(self: psi4.core.Matrix)  None; docstring. project_out(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; docstring. remove_symmetry(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; docstring. rms(self: psi4.core.Matrix)  float; docstring. rotate_columns(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float)  None; docstring. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; docstring. rows(self: psi4.core.Matrix, arg0: int)  int; docstring. save(self: psi4.core.Matrix, arg0: str, arg1: bool, arg2: bool, arg3: bool)  None; docstring. scale(self: psi4.core.Matrix, arg0: float)  None; docstring. scale_column(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float)  None; docstring. scale_row(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float)  None; docstring. schmidt(self: psi4.core.Matrix)  None. set(*args, **kw",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:13586,Energy Efficiency,power,power,13586,"method from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self: psi4.core.Matrix, arg0: bool, arg1: bool, arg2: float, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix, arg5: float)  None; docstring. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int) -> float. docstring. get(self: psi4.core.Matrix, arg0: int, arg1: int) -> float. docstring. identity(self: psi4.core.Matrix)  None; docstring. invert(self: psi4.core.Matrix)  None; docstring. load(self: psi4.core.Matrix, arg0: str)  None; docstring. load_mpqc(self: psi4.core.Matrix, arg0: str)  None; docstring. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix)  int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, arg0: float, arg1: bool)  psi4.core.Matrix; docstring. power(self: psi4.core.Matrix, arg0: float, arg1: float)  psi4.core.Dimension; docstring. print_out(self: psi4.core.Matrix)  None; docstring. project_out(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; docstring. remove_symmetry(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; docstring. rms(self: psi4.core.Matrix)  float; docstring. rotate_columns(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float)  None; docstring. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; docstring. rows(self: psi4.core.Matrix, arg0: int)  int; docstring. save(self: psi4.core.Matrix, arg0: str, arg1: bool, arg2: bool, arg3: bool)  None; docstring. scale(self: psi4.core.Matrix, arg0: float)  None; docstring. scale_column(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float)  None; docstring. scale_row(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float)  None; docstring. schmidt(self: psi4.core.Matrix)  None. set(*args, **kwargs); Overlo",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:9005,Integrability,depend,depending,9005,"ore.Matrix, arg0: int, arg1: int, arg2: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: list) -> None. docstring. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; docstring. sum_of_squares(self: psi4.core.Matrix)  float; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule)  None; docstring. symmetry(self: psi4.core.Matrix)  int; docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix)  float; docstring. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. triplet(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: bool, arg3: bool, arg4: bool)  psi4.core.Matrix; docstring. vector_dot(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  float; docstring. zero(self: psi4.core.Matrix)  None; docstring. zero_diagona",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:15722,Integrability,depend,depending,15722," arg2: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: list) -> None. docstring. shape; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; docstring. sum_of_squares(self: psi4.core.Matrix)  float; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule)  None; docstring. symmetry(self: psi4.core.Matrix)  int; docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix)  float; docstring. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. triplet(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: bool, arg3: bool, arg4: bool)  psi4.core.Matrix; docstring. vector_dot(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  float; docstring. zero(self: psi4.core.Matrix)  None; docstring. zero_diagonal(self",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:1523,Performance,load,load,1523,"((self:psi4.core.Matrix,...); docstring. array_interface((self:psi4.core.Matrix)->list). axpy((self:psi4.core.Matrix,arg0:float,...); docstring. back_transform((self:psi4.core.Matrix,...); docstring. cholesky_factorize(...); docstring. clone(...); docstring. coldim(...); docstring. cols((self:psi4.core.Matrix,arg0:int)->int); docstring. copy((self:psi4.core.Matrix,...); docstring. copy_lower_to_upper(...); docstring. copy_upper_to_lower(...); docstring. diagonalize((self:psi4.core.Matrix,...); docstring. doublet((self:psi4.core.Matrix,...); docstring. from_array(arr[,name,dim1,dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm((self:psi4.core.Matrix,arg0:bool,...); docstring. get(*args,**kwargs); Overloaded function. identity((self:psi4.core.Matrix)->None); docstring. invert((self:psi4.core.Matrix)->None); docstring. load((self:psi4.core.Matrix,arg0:str)->None); docstring. load_mpqc((self:psi4.core.Matrix,...); docstring. nirrep((self:psi4.core.Matrix)->int); docstring. np_read(filename[,prefix]). np_write([filename,prefix]). partial_cholesky_factorize(...); docstring. power((self:psi4.core.Matrix,arg0:float,...); docstring. print_out((self:psi4.core.Matrix)->None); docstring. project_out((self:psi4.core.Matrix,...); docstring. remove_symmetry((self:psi4.core.Matrix,...); docstring. rms((self:psi4.core.Matrix)->float); docstring. rotate_columns((self:psi4.core.Matrix,...); docstring. rowdim(...); docstring. rows((self:psi4.core.Matrix,arg0:int)->int); docstring. save((self:psi4.core.Matrix,arg0:str,...); docstring. scale((self:psi4.core.Matrix,...); docstring. scale_column((self:psi4.core.Matrix,...); docstring. scale_row((self:psi4.core.Matrix,...); docstring. schmidt((self:psi4.core.Matrix)->None). set(*args,**kwargs); Overloaded function. subtract((self:ps",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:6525,Performance,load,load,6525,"a Psi4.Dimension object. Returns:matrix  Returns the given Psi4 object. Return type:Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; 1; 2>>> data = np.random.rand(20); >>> vector = array_to_matrix(data). 1; 2; 3; 4>>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self: psi4.core.Matrix, arg0: bool, arg1: bool, arg2: float, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix, arg5: float)  None; docstring. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int) -> float. docstring. get(self: psi4.core.Matrix, arg0: int, arg1: int) -> float. docstring. identity(self: psi4.core.Matrix)  None; docstring. invert(self: psi4.core.Matrix)  None; docstring. load(self: psi4.core.Matrix, arg0: str)  None; docstring. load_mpqc(self: psi4.core.Matrix, arg0: str)  None; docstring. nirrep(self: psi4.core.Matrix)  int; docstring. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). partial_cholesky_factorize(self: psi4.core.Matrix, arg0: float, arg1: bool)  psi4.core.Matrix; docstring. power(self: psi4.core.Matrix, arg0: float, arg1: float)  psi4.core.Dimension; docstring. print_out(self: psi4.core.Matrix)  None; docstring. project_out(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; docstring. remove_symmetry(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; docstring. rms(self: psi4.core.Matrix)  float; docstring. rotate_columns(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float)  None; docstring. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; docstring. rows(self: psi4.core.Matrix, arg0: int)  int; docstring. save(self: psi4.core.Matrix, arg0",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:13125,Performance,load,load,13125,"sing a Psi4.Dimension object. Returns:matrix  Returns the given Psi4 object. Return type:Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; 1; 2>>> data = np.random.rand(20); >>> vector = array_to_matrix(data). 1; 2; 3; 4>>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self: psi4.core.Matrix, arg0: bool, arg1: bool, arg2: float, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix, arg5: float)  None; docstring. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int) -> float. docstring. get(self: psi4.core.Matrix, arg0: int, arg1: int) -> float. docstring. identity(self: psi4.core.Matrix)  None; docstring. invert(self: psi4.core.Matrix)  None; docstring. load(self: psi4.core.Matrix, arg0: str)  None; docstring. load_mpqc(self: psi4.core.Matrix, arg0: str)  None; docstring. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix)  int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, arg0: float, arg1: bool)  psi4.core.Matrix; docstring. power(self: psi4.core.Matrix, arg0: float, arg1: float)  psi4.core.Dimension; docstring. print_out(self: psi4.core.Matrix)  None; docstring. project_out(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; docstring. remove_symmetry(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; docstring. rms(self: psi4.core.Matrix)  float; docstring. rotate_columns(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float)  None; docstring. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; docstring. r",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:2874,Security,access,accessor,2874,"None); docstring. project_out((self:psi4.core.Matrix,...); docstring. remove_symmetry((self:psi4.core.Matrix,...); docstring. rms((self:psi4.core.Matrix)->float); docstring. rotate_columns((self:psi4.core.Matrix,...); docstring. rowdim(...); docstring. rows((self:psi4.core.Matrix,arg0:int)->int); docstring. save((self:psi4.core.Matrix,arg0:str,...); docstring. scale((self:psi4.core.Matrix,...); docstring. scale_column((self:psi4.core.Matrix,...); docstring. scale_row((self:psi4.core.Matrix,...); docstring. schmidt((self:psi4.core.Matrix)->None). set(*args,**kwargs); Overloaded function. subtract((self:psi4.core.Matrix,...); docstring. sum_of_squares((self:psi4.core.Matrix)->float); docstring. symmetrize_gradient((self:psi4.core.Matrix,...); docstring. symmetry((self:psi4.core.Matrix)->int); docstring. to_array(matrix[,copy,dense]); Converts a Psi4 Matrix or Vector to a numpy array. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace((self:psi4.core.Matrix)->float); docstring. transform(*args,**kwargs); Overloaded function. triplet((self:psi4.core.Matrix,...); docstring. vector_dot((self:psi4.core.Matrix,...); docstring. zero((self:psi4.core.Matrix)->None); docstring. zero_diagonal((self:psi4.core.Matrix)->None); docstring. zero_lower((self:psi4.core.Matrix)->None); docstring. zero_upper((self:psi4.core.Matrix)->None); docstring. Attributes Documentation. name; The name of the Matrix. Used in printing. np; View without only one irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix)  float; docstring. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; docstring. add(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; docstring. add_and_orthogonalize_row(self: psi4.core.Matrix, arg0: psi4.core.Vector)  bool; docstring. apply_denominator(self: p",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:9318,Security,access,accessor,9318,"rix)  float; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule)  None; docstring. symmetry(self: psi4.core.Matrix)  int; docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix)  float; docstring. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. triplet(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: bool, arg3: bool, arg4: bool)  psi4.core.Matrix; docstring. vector_dot(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  float; docstring. zero(self: psi4.core.Matrix)  None; docstring. zero_diagonal(self: psi4.core.Matrix)  None; docstring. zero_lower(self: psi4.core.Matrix)  None; docstring. zero_upper(self: psi4.core.Matrix)  None; docstring. absmax(self: psi4.core.Matrix)  float; docstring. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; docstring. add(self: psi4",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:16034,Security,access,accessor,16034,"psi4.core.Matrix)  float; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule)  None; docstring. symmetry(self: psi4.core.Matrix)  int; docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix)  float; docstring. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. triplet(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: bool, arg3: bool, arg4: bool)  psi4.core.Matrix; docstring. vector_dot(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  float; docstring. zero(self: psi4.core.Matrix)  None; docstring. zero_diagonal(self: psi4.core.Matrix)  None; docstring. zero_lower(self: psi4.core.Matrix)  None; docstring. zero_upper(self: psi4.core.Matrix)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:8617,Usability,simpl,simply,8617,"e.Matrix, arg0: float)  None; docstring. scale_column(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float)  None; docstring. scale_row(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float)  None; docstring. schmidt(self: psi4.core.Matrix)  None. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Matrix, arg0: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: list) -> None. docstring. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; docstring. sum_of_squares(self: psi4.core.Matrix)  float; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule)  None; docstring. symmetry(self: psi4.core.Matrix)  int; docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix)  float; docstring. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:15334,Usability,simpl,simply,15334,"e; docstring. scale_column(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float)  None; docstring. scale_row(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float)  None; docstring. schmidt(self: psi4.core.Matrix)  None. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Matrix, arg0: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: list) -> None. docstring. shape; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; docstring. sum_of_squares(self: psi4.core.Matrix)  float; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule)  None; docstring. symmetry(self: psi4.core.Matrix)  int; docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix)  float; docstring. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> N",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrixfactory.html:800,Deployability,update,updated,800,". psi4.core.MatrixFactory. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.MatrixFactory. class psi4.core.MatrixFactory; Bases: object; docstring; Methods Summary. create_matrix(*args,**kwargs); Overloaded function. Methods Documentation. create_matrix(*args, **kwargs); Overloaded function. create_matrix(self: psi4.core.MatrixFactory) -> psi4.core.Matrix. docstring. create_matrix(self: psi4.core.MatrixFactory, arg0: str) -> psi4.core.Matrix. docstring. create_matrix(*args, **kwargs); Overloaded function. create_matrix(self: psi4.core.MatrixFactory) -> psi4.core.Matrix. docstring. create_matrix(self: psi4.core.MatrixFactory, arg0: str) -> psi4.core.Matrix. docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.matrixfactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrixfactory.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.mcscf.html:324,Deployability,update,updated,324,". psi4.core.mcscf. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.mcscf. psi4.core.mcscf(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the MCSCF code, (N.B. restricted to certain active spaces). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.mcscf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.mintshelper.html:15531,Deployability,update,updated,15531,"atrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  psi4.core.Matrix; docstring. mo_spin_eri(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; docstring. mo_transform(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  psi4.core.Matrix; docstring. nbf(self: psi4.core.MintsHelper)  int; docstring. one_electron_integrals(*args, **kwargs); Overloaded function. one_electron_integrals(self: psi4.core.MintsHelper) -> None. docstring. one_electron_integrals(self: psi4.core.MintsHelper) -> None. docstring. petite_list(self: psi4.core.MintsHelper)  psi::PetiteList; docstring. petite_list1(self: psi4.core.MintsHelper, arg0: bool)  psi::PetiteList; docstring. play(self: psi4.core.MintsHelper)  None; docstring. set_print(self: psi4.core.MintsHelper, arg0: int)  None; docstring. set_rel_basisset(self: psi4.core.MintsHelper, arg0: psi::BasisSet)  None; docstring. so_angular_momentum(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; docstring. so_dipole(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; docstring. so_dkh(self: psi4.core.MintsHelper, arg0: int)  psi4.core.Matrix; docstring. so_kinetic(self: psi4.core.MintsHelper)  psi4.core.Matrix; docstring. so_nabla(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; docstring. so_overlap(self: psi4.core.MintsHelper)  psi4.core.Matrix; docstring. so_potential(self: psi4.core.MintsHelper, arg0: bool)  psi4.core.Matrix; docstring. so_quadrupole(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; docstring. so_traceless_quadrupole(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; docstring. sobasisset(self: psi4.core.MintsHelper)  psi::SOBasisSet; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.mintshelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.mintshelper.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.moldenwriter.html:806,Deployability,update,updated,806,". psi4.core.MoldenWriter. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.MoldenWriter. class psi4.core.MoldenWriter; Bases: object; docstring; Methods Summary. write((self:psi4.core.MoldenWriter,...); docstring. Methods Documentation. write(self: psi4.core.MoldenWriter, arg0: str, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector, arg7: bool)  None; docstring. write(self: psi4.core.MoldenWriter, arg0: str, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector, arg7: bool)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.moldenwriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.moldenwriter.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:997,Availability,toler,tolerance,997,". psi4.core.Molecule. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Molecule. class psi4.core.Molecule; Bases: object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Attributes Summary. units; Units (Angstrom or Bohr) used to define the geometry. Methods Summary. BFS(); Perform a breadth-first search (BFS) on the real atoms in molecule, returning an array of atom indices of fragments. Z((self:psi4.core.Molecule,arg0:int)->float); Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(...); Sets all fragments in the molecule to be active. add_atom((self:psi4.core.Molecule,...); Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self:psi4.core.Molecule,...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ((self:psi4.core.Molecule,...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self:psi4.core.Molecule,...); Finds computational molecular point group, user can override this with the symmetry keywor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:7481,Availability,toler,tolerance,7481,"olecule,...); Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(...); Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(...); Sets the specified list arg2 of fragments to be Ghost. set_mass((self:psi4.core.Molecule,...); Gets mass of atom arg1. set_molecular_charge(...); Sets the molecular charge. set_multiplicity((self:psi4.core.Molecule,...); Sets the multiplicity (defined as 2Ms + 1). set_name((self:psi4.core.Molecule,...); Sets molecule name. set_point_group((self:psi4.core.Molecule,...); Sets the molecular point group to the point group object arg2. set_variable((self:psi4.core.Molecule,...); Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol((self:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize((self:psi4.core.Molecule,...); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate((self:psi4.core.Molecule,...); Translates molecule by arg1. update_geometry(...); Reevaluates the geometry with current variable values, orientation directives, etc. x((self:psi4.core.Molecule,arg0:int)->float); x position of atom arg1 (0-indexed in Bohr). y((self:psi4.core.Molecule,arg0:int)->float); y position of atom arg1 (0-indexed in Bohr). z((self:psi4.core.Molecule,arg0:int)->float); z position of atom arg1 (0-indexed in Bohr). Attributes Documentation. units; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_al",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:8282,Availability,fault,faulty,8282,"f:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize((self:psi4.core.Molecule,...); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate((self:psi4.core.Molecule,...); Translates molecule by arg1. update_geometry(...); Reevaluates the geometry with current variable values, orientation directives, etc. x((self:psi4.core.Molecule,arg0:int)->float); x position of atom arg1 (0-indexed in Bohr). y((self:psi4.core.Molecule,arg0:int)->float); y position of atom arg1 (0-indexed in Bohr). z((self:psi4.core.Molecule,arg0:int)->float); z position of atom arg1 (0-indexed in Bohr). Attributes Documentation. units; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-index",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:9040,Availability,toler,tolerance,9040,"in Bohr). Attributes Documentation. units; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:19746,Availability,toler,tolerance,19746,"ecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed).",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:20545,Availability,fault,faulty,20545,"0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). c",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:21299,Availability,toler,tolerance,21299," atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:31934,Availability,toler,tolerance,31934,"psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. units; Units (Angstrom or Bohr) used to define the geometry. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:32724,Deployability,update,updated,32724,"psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. units; Units (Angstrom or Bohr) used to define the geometry. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:221,Energy Efficiency,charge,charge,221,". psi4.core.Molecule. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Molecule. class psi4.core.Molecule; Bases: object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Attributes Summary. units; Units (Angstrom or Bohr) used to define the geometry. Methods Summary. BFS(); Perform a breadth-first search (BFS) on the real atoms in molecule, returning an array of atom indices of fragments. Z((self:psi4.core.Molecule,arg0:int)->float); Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(...); Sets all fragments in the molecule to be active. add_atom((self:psi4.core.Molecule,...); Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self:psi4.core.Molecule,...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ((self:psi4.core.Molecule,...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self:psi4.core.Molecule,...); Finds computational molecular point group, user can override this with the symmetry keywor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:545,Energy Efficiency,charge,charge,545,". psi4.core.Molecule. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Molecule. class psi4.core.Molecule; Bases: object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Attributes Summary. units; Units (Angstrom or Bohr) used to define the geometry. Methods Summary. BFS(); Perform a breadth-first search (BFS) on the real atoms in molecule, returning an array of atom indices of fragments. Z((self:psi4.core.Molecule,arg0:int)->float); Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(...); Sets all fragments in the molecule to be active. add_atom((self:psi4.core.Molecule,...); Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self:psi4.core.Molecule,...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ((self:psi4.core.Molecule,...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self:psi4.core.Molecule,...); Finds computational molecular point group, user can override this with the symmetry keywor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:834,Energy Efficiency,charge,charge,834,". psi4.core.Molecule. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Molecule. class psi4.core.Molecule; Bases: object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Attributes Summary. units; Units (Angstrom or Bohr) used to define the geometry. Methods Summary. BFS(); Perform a breadth-first search (BFS) on the real atoms in molecule, returning an array of atom indices of fragments. Z((self:psi4.core.Molecule,arg0:int)->float); Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(...); Sets all fragments in the molecule to be active. add_atom((self:psi4.core.Molecule,...); Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self:psi4.core.Molecule,...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ((self:psi4.core.Molecule,...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self:psi4.core.Molecule,...); Finds computational molecular point group, user can override this with the symmetry keywor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:1101,Energy Efficiency,charge,charge,1101,"i4.core.Molecule; Bases: object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Attributes Summary. units; Units (Angstrom or Bohr) used to define the geometry. Methods Summary. BFS(); Perform a breadth-first search (BFS) on the real atoms in molecule, returning an array of atom indices of fragments. Z((self:psi4.core.Molecule,arg0:int)->float); Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(...); Sets all fragments in the molecule to be active. add_atom((self:psi4.core.Molecule,...); Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self:psi4.core.Molecule,...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ((self:psi4.core.Molecule,...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self:psi4.core.Molecule,...); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com((self:psi4.core.Molecule,...); Whether to fix the Cartesian position, or to translate to the C.O",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:1146,Energy Efficiency,charge,charge,1146," the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Attributes Summary. units; Units (Angstrom or Bohr) used to define the geometry. Methods Summary. BFS(); Perform a breadth-first search (BFS) on the real atoms in molecule, returning an array of atom indices of fragments. Z((self:psi4.core.Molecule,arg0:int)->float); Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(...); Sets all fragments in the molecule to be active. add_atom((self:psi4.core.Molecule,...); Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self:psi4.core.Molecule,...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ((self:psi4.core.Molecule,...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self:psi4.core.Molecule,...); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com((self:psi4.core.Molecule,...); Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation((self:psi4.core.Molecule,.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:1713,Energy Efficiency,charge,charge,1713," atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self:psi4.core.Molecule,...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ((self:psi4.core.Molecule,...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self:psi4.core.Molecule,...); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com((self:psi4.core.Molecule,...); Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation((self:psi4.core.Molecule,...); Fix the orientation at its current frame. flabel((self:psi4.core.Molecule,...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass((self:psi4.core.Molecule,...); Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(...); Uses the point group object obtain by calling point_group(). fsymbol((self:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx((self:psi4.core.Molecule,...); x position of atom arg1 (0-in",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:1810,Energy Efficiency,charge,charge,1810,"6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self:psi4.core.Molecule,...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ((self:psi4.core.Molecule,...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self:psi4.core.Molecule,...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self:psi4.core.Molecule,...); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com((self:psi4.core.Molecule,...); Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation((self:psi4.core.Molecule,...); Fix the orientation at its current frame. flabel((self:psi4.core.Molecule,...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass((self:psi4.core.Molecule,...); Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(...); Uses the point group object obtain by calling point_group(). fsymbol((self:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx((self:psi4.core.Molecule,...); x position of atom arg1 (0-indexed including dummies in Bohr). fy((self:psi4.core.Molecule,...); y position of atom arg1 (0-i",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:3658,Energy Efficiency,charge,charge,3658,"s). fx((self:psi4.core.Molecule,...); x position of atom arg1 (0-indexed including dummies in Bohr). fy((self:psi4.core.Molecule,...); y position of atom arg1 (0-indexed including dummies in Bohr). fz((self:psi4.core.Molecule,...); z position of atom arg1 (0-indexed including dummies in Bohr). geometry(...); Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(...); Gets point group name such as C3v or S8. get_variable((self:psi4.core.Molecule,...); Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(...). is_variable((self:psi4.core.Molecule,...); Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label((self:psi4.core.Molecule,...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass((self:psi4.core.Molecule,...); Gets mass of atom arg1 (0-indexed). molecular_charge(...); Gets the charge on full molecule. move_to_com((self:psi4.core.Molecule)->None); Moves molecule to center of mass. multiplicity((self:psi4.core.Molecule)->int); Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(...); Gets the number of active (non-ghosted) fragments in the molecule. nallatom((self:psi4.core.Molecule)->int); Number of real and dummy atoms. name((self:psi4.core.Molecule)->str); Gets molecule name. natom((self:psi4.core.Molecule)->int); Number of real atoms. nfragments((self:psi4.core.Molecule)->int); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(...); Computes nuclear repulsion energy. point_group(...); Returns the current point group object. print_bond_angles(...); Print the bond angle geometrical parameters. print_cluster((self:psi4.core.Molecule)->None); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(...); Pr",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:4377,Energy Efficiency,energy,energy,4377,"he list, returns true if it is, and returns false if not. label((self:psi4.core.Molecule,...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass((self:psi4.core.Molecule,...); Gets mass of atom arg1 (0-indexed). molecular_charge(...); Gets the charge on full molecule. move_to_com((self:psi4.core.Molecule)->None); Moves molecule to center of mass. multiplicity((self:psi4.core.Molecule)->int); Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(...); Gets the number of active (non-ghosted) fragments in the molecule. nallatom((self:psi4.core.Molecule)->int); Number of real and dummy atoms. name((self:psi4.core.Molecule)->str); Gets molecule name. natom((self:psi4.core.Molecule)->int); Number of real atoms. nfragments((self:psi4.core.Molecule)->int); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(...); Computes nuclear repulsion energy. point_group(...); Returns the current point group object. print_bond_angles(...); Print the bond angle geometrical parameters. print_cluster((self:psi4.core.Molecule)->None); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(...); Print the interatomic distance geometrical parameters. print_in_input_format(...); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out((self:psi4.core.Molecule)->None); Prints the molecule in Cartesians in input units. print_out_in_angstrom(...); Prints the molecule in Cartesians in Angstroms. print_out_in_bohr(...); Prints the molecule in Cartesians in Bohr. print_out_of_planes(...); Print the out-of-plane angle geometrical parameters. reinterpret_coordentry(...); Do reinterpret coordinate entries during update_geometry(). reset_point_group((self:psi4.core.Molecule,...); Overrides symmetry from outside the molecule string. rotational_constants(...); Prints the ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:6831,Energy Efficiency,charge,charge,6831,"xyz(...); Saves the string of an XYZ file to arg2. save_string_xyz_file(...); Saves an XYZ file to arg2. save_xyz_file((self:psi4.core.Molecule,...); Saves an XYZ file to arg2. schoenflies_symbol(...); Returns the Schoenflies symbol. set_active_fragment(...); Sets the specified fragment arg2 to be Real. set_active_fragments(...); Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(...); Sets basis set arg2 to all atoms. set_basis_by_label(...); Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(...); Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry((self:psi4.core.Molecule,...); Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(...); Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(...); Sets the specified list arg2 of fragments to be Ghost. set_mass((self:psi4.core.Molecule,...); Gets mass of atom arg1. set_molecular_charge(...); Sets the molecular charge. set_multiplicity((self:psi4.core.Molecule,...); Sets the multiplicity (defined as 2Ms + 1). set_name((self:psi4.core.Molecule,...); Sets molecule name. set_point_group((self:psi4.core.Molecule,...); Sets the molecular point group to the point group object arg2. set_variable((self:psi4.core.Molecule,...); Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol((self:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize((self:psi4.core.Molecule,...); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate((self:psi4.core.Molecule,...); Translates molecule by arg1. update_geometry(...); Reevaluates the geometry with current variable values, orientation directives, etc. x((self:psi4.core.Molecule,arg0:int)->float); x position of atom arg1 (0-indexed in Bohr). y((self:ps",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:8432,Energy Efficiency,charge,charge,8432,"ghest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate((self:psi4.core.Molecule,...); Translates molecule by arg1. update_geometry(...); Reevaluates the geometry with current variable values, orientation directives, etc. x((self:psi4.core.Molecule,arg0:int)->float); x position of atom arg1 (0-indexed in Bohr). y((self:psi4.core.Molecule,arg0:int)->float); y position of atom arg1 (0-indexed in Bohr). z((self:psi4.core.Molecule,arg0:int)->float); z position of atom arg1 (0-indexed in Bohr). Attributes Documentation. units; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Mol",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:8850,Energy Efficiency,charge,charge,8850,"0:int)->float); x position of atom arg1 (0-indexed in Bohr). y((self:psi4.core.Molecule,arg0:int)->float); y position of atom arg1 (0-indexed in Bohr). z((self:psi4.core.Molecule,arg0:int)->float); z position of atom arg1 (0-indexed in Bohr). Attributes Documentation. units; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments i",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:9186,Energy Efficiency,charge,charge,9186,"eturning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:9245,Energy Efficiency,charge,charge,9245,"Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 f",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:10878,Energy Efficiency,charge,charge,10878,"xtract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). fsymbol(self: psi4.core.Molecule, arg0:",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:10989,Energy Efficiency,charge,charge,10989,": list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). fsymbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx(self: p",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:13202,Energy Efficiency,charge,charge,13202,"s in Bohr). fz(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str)  float; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(self: psi4.core.Molecule)  List[str]. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed). molecular_charge(self: psi4.core.Molecule)  int; Gets the charge on full molecule. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(self: psi4.core.Molecule)  int; Gets the number of active (non-ghosted) fragments in the molecule. nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repuls",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:14275,Energy Efficiency,energy,energy,14275,"Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(self: psi4.core.Molecule)  int; Gets the number of active (non-ghosted) fragments in the molecule. nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule)  float; Computes nuclear repulsion energy. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units. print_out_in_angstrom(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in Angstroms. print_out_in_bohr(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in Bohr. print_out_of_planes(self: psi4.core.Molecule)  None; Print the out-of-plane angle geometrical parameters. reinter",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:16048,Energy Efficiency,energy,energy,16048,"rints the molecule in Cartesians in Bohr. print_out_of_planes(self: psi4.core.Molecule)  None; Print the out-of-plane angle geometrical parameters. reinterpret_coordentry(self: psi4.core.Molecule, arg0: bool)  None; Do reinterpret coordinate entries during update_geometry(). reset_point_group(self: psi4.core.Molecule, arg0: str)  None; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float)  psi4.core.Vector; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dert",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:16113,Energy Efficiency,energy,energy,16113,"rints the molecule in Cartesians in Bohr. print_out_of_planes(self: psi4.core.Molecule)  None; Print the out-of-plane angle geometrical parameters. reinterpret_coordentry(self: psi4.core.Molecule, arg0: bool)  None; Do reinterpret coordinate entries during update_geometry(). reset_point_group(self: psi4.core.Molecule, arg0: str)  None; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float)  psi4.core.Vector; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dert",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:17006,Energy Efficiency,energy,energy,17006,"f dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.M",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:17071,Energy Efficiency,energy,energy,17071,"f dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.M",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:18987,Energy Efficiency,charge,charge,18987,"ets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str)  None; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule)  None; Reevaluates ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:20694,Energy Efficiency,charge,charge,20694,"highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Molecule;",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:21110,Energy Efficiency,charge,charge,21110,"orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the mo",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:21444,Energy Efficiency,charge,charge,21444,"le, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:21502,Energy Efficiency,charge,charge,21502,"nts.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float)  int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str)  psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:23128,Energy Efficiency,charge,charge,23128,"extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). fsymbol(self: psi4.core.Molecule, arg0: int) ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:23238,Energy Efficiency,charge,charge,23238,"g1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, arg0: int)  float; Gets charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). fsymbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx(self: psi4.core",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:25433,Energy Efficiency,charge,charge,25433,"g dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str)  float; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(self: psi4.core.Molecule)  List[str]. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed). molecular_charge(self: psi4.core.Molecule)  int; Gets the charge on full molecule. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(self: psi4.core.Molecule)  int; Gets the number of active (non-ghosted) fragments in the molecule. nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_ener",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:26497,Energy Efficiency,energy,energy,26497,"si4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(self: psi4.core.Molecule)  int; Gets the number of active (non-ghosted) fragments in the molecule. nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule)  float; Computes nuclear repulsion energy. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units. print_out_in_angstrom(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in Angstroms. print_out_in_bohr(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in Bohr. print_out_of_planes(self: psi4.core.Molecule)  None; Print the out-of-plane angle geometrical parameters. reinterpret_coord",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:28257,Energy Efficiency,energy,energy,28257,"ne; Prints the molecule in Cartesians in Bohr. print_out_of_planes(self: psi4.core.Molecule)  None; Print the out-of-plane angle geometrical parameters. reinterpret_coordentry(self: psi4.core.Molecule, arg0: bool)  None; Do reinterpret coordinate entries during update_geometry(). reset_point_group(self: psi4.core.Molecule, arg0: str)  None; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float)  psi4.core.Vector; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if derty",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:28322,Energy Efficiency,energy,energy,28322,"ne; Prints the molecule in Cartesians in Bohr. print_out_of_planes(self: psi4.core.Molecule)  None; Print the out-of-plane angle geometrical parameters. reinterpret_coordentry(self: psi4.core.Molecule, arg0: bool)  None; Do reinterpret coordinate entries during update_geometry(). reset_point_group(self: psi4.core.Molecule, arg0: str)  None; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float)  psi4.core.Vector; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if derty",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:29214,Energy Efficiency,energy,energy,29214,"if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecul",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:29279,Energy Efficiency,energy,energy,29279,"if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecul",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:31181,Energy Efficiency,charge,charge,31181," None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str)  None; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. units; Units (Angstrom or Bohr) used to define the geometry. update_geo",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:16391,Integrability,interface,interface,16391,"oup(self: psi4.core.Molecule, arg0: str)  None; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float)  psi4.core.Vector; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:17349,Integrability,interface,interface,17349," by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str)  None; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2:",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:28600,Integrability,interface,interface,28600,"_group(self: psi4.core.Molecule, arg0: str)  None; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float)  psi4.core.Vector; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be i",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:29557,Integrability,interface,interface,29557,"d by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str)  None; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:3172,Modifiability,variab,variable,3172,"elf:psi4.core.Molecule,...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass((self:psi4.core.Molecule,...); Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(...); Uses the point group object obtain by calling point_group(). fsymbol((self:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx((self:psi4.core.Molecule,...); x position of atom arg1 (0-indexed including dummies in Bohr). fy((self:psi4.core.Molecule,...); y position of atom arg1 (0-indexed including dummies in Bohr). fz((self:psi4.core.Molecule,...); z position of atom arg1 (0-indexed including dummies in Bohr). geometry(...); Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(...); Gets point group name such as C3v or S8. get_variable((self:psi4.core.Molecule,...); Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(...). is_variable((self:psi4.core.Molecule,...); Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label((self:psi4.core.Molecule,...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass((self:psi4.core.Molecule,...); Gets mass of atom arg1 (0-indexed). molecular_charge(...); Gets the charge on full molecule. move_to_com((self:psi4.core.Molecule)->None); Moves molecule to center of mass. multiplicity((self:psi4.core.Molecule)->int); Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(...); Gets the number of active (non-ghosted) fragments in the molecule. nallatom((self:psi4.core.Molecule)->int); Number of real and dummy atoms. name((self:psi4.core.Molecule)->str); Gets molecule name. natom((self:psi4.core.Molecule)->int); Number of real atoms. nfragments((self:psi4.core.Molecule)->i",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:3344,Modifiability,variab,variable,3344,"Molecule,...); Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(...); Uses the point group object obtain by calling point_group(). fsymbol((self:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx((self:psi4.core.Molecule,...); x position of atom arg1 (0-indexed including dummies in Bohr). fy((self:psi4.core.Molecule,...); y position of atom arg1 (0-indexed including dummies in Bohr). fz((self:psi4.core.Molecule,...); z position of atom arg1 (0-indexed including dummies in Bohr). geometry(...); Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(...); Gets point group name such as C3v or S8. get_variable((self:psi4.core.Molecule,...); Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(...). is_variable((self:psi4.core.Molecule,...); Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label((self:psi4.core.Molecule,...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass((self:psi4.core.Molecule,...); Gets mass of atom arg1 (0-indexed). molecular_charge(...); Gets the charge on full molecule. move_to_com((self:psi4.core.Molecule)->None); Moves molecule to center of mass. multiplicity((self:psi4.core.Molecule)->int); Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(...); Gets the number of active (non-ghosted) fragments in the molecule. nallatom((self:psi4.core.Molecule)->int); Number of real and dummy atoms. name((self:psi4.core.Molecule)->str); Gets molecule name. natom((self:psi4.core.Molecule)->int); Number of real atoms. nfragments((self:psi4.core.Molecule)->int); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(...); Computes nuclear repulsion ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:7183,Modifiability,variab,variable,7183,"Real. set_basis_all_atoms(...); Sets basis set arg2 to all atoms. set_basis_by_label(...); Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(...); Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry((self:psi4.core.Molecule,...); Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(...); Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(...); Sets the specified list arg2 of fragments to be Ghost. set_mass((self:psi4.core.Molecule,...); Gets mass of atom arg1. set_molecular_charge(...); Sets the molecular charge. set_multiplicity((self:psi4.core.Molecule,...); Sets the multiplicity (defined as 2Ms + 1). set_name((self:psi4.core.Molecule,...); Sets molecule name. set_point_group((self:psi4.core.Molecule,...); Sets the molecular point group to the point group object arg2. set_variable((self:psi4.core.Molecule,...); Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol((self:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize((self:psi4.core.Molecule,...); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate((self:psi4.core.Molecule,...); Translates molecule by arg1. update_geometry(...); Reevaluates the geometry with current variable values, orientation directives, etc. x((self:psi4.core.Molecule,arg0:int)->float); x position of atom arg1 (0-indexed in Bohr). y((self:psi4.core.Molecule,arg0:int)->float); y position of atom arg1 (0-indexed in Bohr). z((self:psi4.core.Molecule,arg0:int)->float); z position of atom arg1 (0-indexed in Bohr). Attributes Documentation. units; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:7221,Modifiability,variab,variables,7221,"Real. set_basis_all_atoms(...); Sets basis set arg2 to all atoms. set_basis_by_label(...); Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(...); Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry((self:psi4.core.Molecule,...); Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(...); Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(...); Sets the specified list arg2 of fragments to be Ghost. set_mass((self:psi4.core.Molecule,...); Gets mass of atom arg1. set_molecular_charge(...); Sets the molecular charge. set_multiplicity((self:psi4.core.Molecule,...); Sets the multiplicity (defined as 2Ms + 1). set_name((self:psi4.core.Molecule,...); Sets molecule name. set_point_group((self:psi4.core.Molecule,...); Sets the molecular point group to the point group object arg2. set_variable((self:psi4.core.Molecule,...); Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol((self:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize((self:psi4.core.Molecule,...); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate((self:psi4.core.Molecule,...); Translates molecule by arg1. update_geometry(...); Reevaluates the geometry with current variable values, orientation directives, etc. x((self:psi4.core.Molecule,arg0:int)->float); x position of atom arg1 (0-indexed in Bohr). y((self:psi4.core.Molecule,arg0:int)->float); y position of atom arg1 (0-indexed in Bohr). z((self:psi4.core.Molecule,arg0:int)->float); z position of atom arg1 (0-indexed in Bohr). Attributes Documentation. units; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:7671,Modifiability,variab,variable,7671,"specified list arg2 of fragments to be Ghost. set_mass((self:psi4.core.Molecule,...); Gets mass of atom arg1. set_molecular_charge(...); Sets the molecular charge. set_multiplicity((self:psi4.core.Molecule,...); Sets the multiplicity (defined as 2Ms + 1). set_name((self:psi4.core.Molecule,...); Sets molecule name. set_point_group((self:psi4.core.Molecule,...); Sets the molecular point group to the point group object arg2. set_variable((self:psi4.core.Molecule,...); Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol((self:psi4.core.Molecule,...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize((self:psi4.core.Molecule,...); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate((self:psi4.core.Molecule,...); Translates molecule by arg1. update_geometry(...); Reevaluates the geometry with current variable values, orientation directives, etc. x((self:psi4.core.Molecule,arg0:int)->float); x position of atom arg1 (0-indexed in Bohr). y((self:psi4.core.Molecule,arg0:int)->float); y position of atom arg1 (0-indexed in Bohr). z((self:psi4.core.Molecule,arg0:int)->float); z position of atom arg1 (0-indexed in Bohr). Attributes Documentation. units; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5:",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:12615,Modifiability,variab,variable,12615,"t)  float; Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). fsymbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str)  float; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(self: psi4.core.Molecule)  List[str]. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed). molecular_charge(self: psi4.core.Molecule)  int; Gets the charge on full molecule. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(self: psi4.core.Molecule)  int; Gets the number of active (non-ghosted) fragments in the molecule. nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:12834,Modifiability,variab,variable,12834,"self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str)  float; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(self: psi4.core.Molecule)  List[str]. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed). molecular_charge(self: psi4.core.Molecule)  int; Gets the charge on full molecule. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(self: psi4.core.Molecule)  int; Gets the number of active (non-ghosted) fragments in the molecule. nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwar",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:16342,Modifiability,extend,extended,16342,"oup(self: psi4.core.Molecule, arg0: str)  None; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float)  psi4.core.Vector; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:17300,Modifiability,extend,extended,17300," by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str)  None; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2:",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:19421,Modifiability,variab,variable,19421,"g2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:19459,Modifiability,variab,variables,19459,"g2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:19992,Modifiability,variab,variable,19992," charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int)  None; Adds to Mole",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:24851,Modifiability,variab,variable,24851," arg0: int)  float; Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). fsymbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str)  float; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(self: psi4.core.Molecule)  List[str]. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed). molecular_charge(self: psi4.core.Molecule)  int; Gets the charge on full molecule. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(self: psi4.core.Molecule)  int; Gets the number of active (non-ghosted) fragments in the molecule. nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Ge",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:25068,Modifiability,variab,variable,25068," fsymbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str)  float; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(self: psi4.core.Molecule)  List[str]. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int)  str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass(self: psi4.core.Molecule, arg0: int)  float; Gets mass of atom arg1 (0-indexed). molecular_charge(self: psi4.core.Molecule)  int; Gets the charge on full molecule. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(self: psi4.core.Molecule)  int; Gets the number of active (non-ghosted) fragments in the molecule. nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overlo",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:28551,Modifiability,extend,extended,28551,"_group(self: psi4.core.Molecule, arg0: str)  None; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float)  psi4.core.Vector; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be i",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:29508,Modifiability,extend,extended,29508,"d by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimmes dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str)  None; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:31611,Modifiability,variab,variable,31611,"., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. units; Units (Angstrom or Bohr) used to define the geometry. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:31649,Modifiability,variab,variables,31649,"., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. units; Units (Angstrom or Bohr) used to define the geometry. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:32239,Modifiability,variab,variable,32239,"psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list)  None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int)  str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg1. units; Units (Angstrom or Bohr) used to define the geometry. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg1 (0-indexed in Bohr). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.mowriter.html:452,Deployability,update,updated,452,". psi4.core.MOWriter. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.MOWriter. class psi4.core.MOWriter; Bases: object; docstring; Methods Summary. write((self:psi4.core.MOWriter)->None); docstring. Methods Documentation. write(self: psi4.core.MOWriter)  None; docstring. write(self: psi4.core.MOWriter)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.mowriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.mowriter.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.mrcc_generate_input.html:362,Deployability,update,updated,362,". psi4.core.mrcc_generate_input. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.mrcc_generate_input. psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict)  psi4.core.PsiReturnType; Generates an input for Kallays MRCC code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.mrcc_generate_input.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.mrcc_generate_input.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.mrcc_load_densities.html:374,Deployability,update,updated,374,". psi4.core.mrcc_load_densities. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.mrcc_load_densities. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict)  psi4.core.PsiReturnType; Reads in the density matrices from Kallays MRCC code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.mrcc_load_densities.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.mrcc_load_densities.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.multipoleint.html:552,Deployability,update,updated,552,". psi4.core.MultipoleInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.MultipoleInt. class psi4.core.MultipoleInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.multipoleint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.multipoleint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.multipolesymmetry.html:554,Deployability,update,updated,554,". psi4.core.MultipoleSymmetry. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.MultipoleSymmetry. class psi4.core.MultipoleSymmetry; Bases: object; docstring; Methods Summary. create_matrices(...); docstring. Methods Documentation. create_matrices(self: psi4.core.MultipoleSymmetry, arg0: str)  List[psi4.core.Matrix]; docstring. create_matrices(self: psi4.core.MultipoleSymmetry, arg0: str)  List[psi4.core.Matrix]; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.multipolesymmetry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.multipolesymmetry.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.nablaint.html:540,Deployability,update,updated,540,". psi4.core.NablaInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.NablaInt. class psi4.core.NablaInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.nablaint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.nablaint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.nbowriter.html:476,Deployability,update,updated,476,". psi4.core.NBOWriter. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.NBOWriter. class psi4.core.NBOWriter; Bases: object; docstring; Methods Summary. write((self:psi4.core.NBOWriter,...); docstring. Methods Documentation. write(self: psi4.core.NBOWriter, arg0: str)  None; docstring. write(self: psi4.core.NBOWriter, arg0: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.nbowriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.nbowriter.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.occ.html:290,Deployability,update,updated,290,". psi4.core.occ. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.occ. psi4.core.occ(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the orbital optimized CC codes. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.occ.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.occ.html:170,Performance,optimiz,optimized,170,". psi4.core.occ. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.occ. psi4.core.occ(arg0: psi::Wavefunction)  psi::Wavefunction; Runs the orbital optimized CC codes. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.occ.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html:3316,Deployability,update,updated,3316,"t each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; docstring. clear(self: psi4.core.Prop)  None; docstring. compute(self: psi4.core.OEProp)  None; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0)  None; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0)  None; docstring. set_Db_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; docstring. clear(self: psi4.core.Prop)  None; docstring. compute(self: psi4.core.OEProp)  None; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0)  None; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0)  None; docstring. set_Db_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_title(self: psi4.core.Prop, arg0: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html:665,Usability,clear,clear,665,". psi4.core.OEProp. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.OEProp. class psi4.core.OEProp; Bases: psi4.core.Prop; docstring; Methods Summary. Exvals((self:psi4.core.OEProp)->List[float]); The x component of the field (in a.u.) at each grid point. Eyvals((self:psi4.core.OEProp)->List[float]); The y component of the field (in a.u.) at each grid point. Ezvals((self:psi4.core.OEProp)->List[float]); The z component of the field (in a.u.) at each grid point. Vvals((self:psi4.core.OEProp)->List[float]); The electrostatic potential (in a.u.) at each grid point. add((self:psi4.core.OEProp,arg0:str)->None); docstring. clear((self:psi4.core.Prop)->None); docstring. compute((self:psi4.core.OEProp)->None); docstring. set_Da_ao((self:psi4.core.Prop,...); docstring. set_Da_mo((self:psi4.core.Prop,...); docstring. set_Da_so((self:psi4.core.Prop,...); docstring. set_Db_ao((self:psi4.core.Prop,...); docstring. set_Db_mo((self:psi4.core.Prop,...); docstring. set_Db_so((self:psi4.core.Prop,...); docstring. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; docstring. clear(self: psi4.core.Prop)  None; docstring. compute(self: psi4.core.OEProp)  None; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0)  None; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0)  None; docstring. set_Db_mo(self",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html:1573,Usability,clear,clear,1573,".) at each grid point. add((self:psi4.core.OEProp,arg0:str)->None); docstring. clear((self:psi4.core.Prop)->None); docstring. compute((self:psi4.core.OEProp)->None); docstring. set_Da_ao((self:psi4.core.Prop,...); docstring. set_Da_mo((self:psi4.core.Prop,...); docstring. set_Da_so((self:psi4.core.Prop,...); docstring. set_Db_ao((self:psi4.core.Prop,...); docstring. set_Db_mo((self:psi4.core.Prop,...); docstring. set_Db_so((self:psi4.core.Prop,...); docstring. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; docstring. clear(self: psi4.core.Prop)  None; docstring. compute(self: psi4.core.OEProp)  None; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0)  None; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0)  None; docstring. set_Db_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html:2605,Usability,clear,clear,2605,"t each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; docstring. clear(self: psi4.core.Prop)  None; docstring. compute(self: psi4.core.OEProp)  None; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0)  None; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0)  None; docstring. set_Db_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; docstring. clear(self: psi4.core.Prop)  None; docstring. compute(self: psi4.core.OEProp)  None; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0)  None; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0)  None; docstring. set_Db_mo(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_Db_so(self: psi4.core.Prop, arg0: psi::Matrix)  None; docstring. set_title(self: psi4.core.Prop, arg0: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.onebodyaoint.html:1127,Deployability,update,updated,1127,". psi4.core.OneBodyAOInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.OneBodyAOInt. class psi4.core.OneBodyAOInt; Bases: object; docstring; Attributes Summary. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. origin; The origin about which the one body ints are being computed. Methods Summary. compute_shell((self:psi4.core.OneBodyAOInt,...); docstring. Attributes Documentation. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. origin; The origin about which the one body ints are being computed. Methods Documentation. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.onebodyaoint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.onebodyaoint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.optking.html:286,Deployability,update,updated,286,". psi4.core.optking. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.optking. psi4.core.optking()  int; Runs the geometry optimization / frequency analysis code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.optking.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.optking.html:146,Performance,optimiz,optimization,146,". psi4.core.optking. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.optking. psi4.core.optking()  int; Runs the geometry optimization / frequency analysis code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.optking.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.opt_clean.html:276,Deployability,update,updated,276,". psi4.core.opt_clean. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.opt_clean. psi4.core.opt_clean()  None; Cleans up the optimizers scratch files. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.opt_clean.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.opt_clean.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.opt_clean.html:149,Performance,optimiz,optimizer,149,". psi4.core.opt_clean. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.opt_clean. psi4.core.opt_clean()  None; Cleans up the optimizers scratch files. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.opt_clean.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.opt_clean.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.orbitalspace.html:2345,Deployability,update,updated,2345,"ral(...); docstring. name((self:psi4.core.OrbitalSpace)->str); docstring. nirrep((self:psi4.core.OrbitalSpace)->int); docstring. print_out((self:psi4.core.OrbitalSpace)->None); docstring. Methods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; docstring. basisset(self: psi4.core.OrbitalSpace)  psi::BasisSet; docstring. build_cabs_space(arg0: psi4.core.OrbitalSpace, arg1: psi4.core.OrbitalSpace, arg2: float)  psi4.core.OrbitalSpace; docstring. build_ri_space(arg0: psi::Molecule, arg1: str, arg2: str, arg3: float)  psi4.core.OrbitalSpace; docstring. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; docstring. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; docstring. id(self: psi4.core.OrbitalSpace)  str; docstring. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; docstring. name(self: psi4.core.OrbitalSpace)  str; docstring. nirrep(self: psi4.core.OrbitalSpace)  int; docstring. print_out(self: psi4.core.OrbitalSpace)  None; docstring. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; docstring. basisset(self: psi4.core.OrbitalSpace)  psi::BasisSet; docstring. build_cabs_space(arg0: psi4.core.OrbitalSpace, arg1: psi4.core.OrbitalSpace, arg2: float)  psi4.core.OrbitalSpace; docstring. build_ri_space(arg0: psi::Molecule, arg1: str, arg2: str, arg3: float)  psi4.core.OrbitalSpace; docstring. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; docstring. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; docstring. id(self: psi4.core.OrbitalSpace)  str; docstring. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; docstring. name(self: psi4.core.OrbitalSpace)  str; docstring. nirrep(self: psi4.core.OrbitalSpace)  int; docstring. print_out(self: psi4.core.OrbitalSpace)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.orbitalspace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.orbitalspace.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.outfile_name.html:280,Deployability,update,updated,280,". psi4.core.outfile_name. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.outfile_name. psi4.core.outfile_name()  str; Returns the name of the output file. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.outfile_name.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.outfile_name.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.overlapint.html:546,Deployability,update,updated,546,". psi4.core.OverlapInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.OverlapInt. class psi4.core.OverlapInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.overlapint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.overlapint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.petitelist.html:796,Deployability,update,updated,796,". psi4.core.PetiteList. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.PetiteList. class psi4.core.PetiteList; Bases: object; docstring; Methods Summary. aotoso(...); docstring. print((self:psi4.core.PetiteList,...); docstring. sotoao(...); docstring. Methods Documentation. aotoso(self: psi4.core.PetiteList)  psi4.core.Matrix; docstring. print(self: psi4.core.PetiteList, arg0: str)  None; docstring. sotoao(self: psi4.core.PetiteList)  psi4.core.Matrix; docstring. aotoso(self: psi4.core.PetiteList)  psi4.core.Matrix; docstring. print(self: psi4.core.PetiteList, arg0: str)  None; docstring. sotoao(self: psi4.core.PetiteList)  psi4.core.Matrix; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.petitelist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.petitelist.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html:335,Deployability,update,updated,335,". psi4.core.plugin. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction)  psi::Wavefunction; Call the plugin of name arg0. Returns the plugin code result. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html:13,Modifiability,plugin,plugin,13,". psi4.core.plugin. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction)  psi::Wavefunction; Call the plugin of name arg0. Returns the plugin code result. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html:89,Modifiability,plugin,plugin,89,". psi4.core.plugin. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction)  psi::Wavefunction; Call the plugin of name arg0. Returns the plugin code result. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html:108,Modifiability,plugin,plugin,108,". psi4.core.plugin. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction)  psi::Wavefunction; Call the plugin of name arg0. Returns the plugin code result. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html:182,Modifiability,plugin,plugin,182,". psi4.core.plugin. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction)  psi::Wavefunction; Call the plugin of name arg0. Returns the plugin code result. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html:215,Modifiability,plugin,plugin,215,". psi4.core.plugin. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction)  psi::Wavefunction; Call the plugin of name arg0. Returns the plugin code result. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_close.html:284,Deployability,update,updated,284,". psi4.core.plugin_close. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin_close. psi4.core.plugin_close(arg0: str)  None; Close the plugin of name arg0. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin_close.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_close.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_close.html:163,Modifiability,plugin,plugin,163,". psi4.core.plugin_close. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin_close. psi4.core.plugin_close(arg0: str)  None; Close the plugin of name arg0. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin_close.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_close.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_close_all.html:280,Deployability,update,updated,280,". psi4.core.plugin_close_all. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin_close_all. psi4.core.plugin_close_all()  None; Close all open plugins. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin_close_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_close_all.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_close_all.html:171,Modifiability,plugin,plugins,171,". psi4.core.plugin_close_all. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin_close_all. psi4.core.plugin_close_all()  None; Close all open plugins. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin_close_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_close_all.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html:338,Deployability,update,updated,338,". psi4.core.plugin_load. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html:158,Modifiability,plugin,plugin,158,". psi4.core.plugin_load. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html:196,Performance,load,loaded,196,". psi4.core.plugin_load. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html:209,Performance,load,loaded,209,". psi4.core.plugin_load. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html:230,Performance,load,loaded,230,". psi4.core.plugin_load. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.pmlocalizer.html:579,Deployability,update,updated,579,". psi4.core.PMLocalizer. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.PMLocalizer. class psi4.core.PMLocalizer; Bases: psi4.core.Localizer; docstring. L; Localized orbital coefficients. U; Orbital rotation matrix. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; docstring. converged; Did the localization procedure converge?. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.pmlocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.pmlocalizer.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.pointgroup.html:563,Deployability,update,updated,563,". psi4.core.PointGroup. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.PointGroup. class psi4.core.PointGroup; Bases: object; docstring; Methods Summary. symbol((self:psi4.core.PointGroup)->str); Returns Schoenflies symbol for point group. Methods Documentation. symbol(self: psi4.core.PointGroup)  str; Returns Schoenflies symbol for point group. symbol(self: psi4.core.PointGroup)  str; Returns Schoenflies symbol for point group. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.pointgroup.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.pointgroup.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.potentialint.html:552,Deployability,update,updated,552,". psi4.core.PotentialInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.PotentialInt. class psi4.core.PotentialInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.potentialint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.potentialint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.prepare_options_for_module.html:385,Deployability,update,updated,385,". psi4.core.prepare_options_for_module. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.prepare_options_for_module. psi4.core.prepare_options_for_module(arg0: str)  None; Sets the options module up to return options pertaining to the named argument (e.g. SCF). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.prepare_options_for_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.prepare_options_for_module.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.primitivetype.html:508,Deployability,update,updated,508,". psi4.core.PrimitiveType. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.PrimitiveType. class psi4.core.PrimitiveType; Bases: object; docstring; Attributes Summary. Normalized. Unnormalized. Attributes Documentation. Normalized = PrimitiveType.Normalized. Unnormalized = PrimitiveType.Unnormalized. Normalized = PrimitiveType.Normalized. Unnormalized = PrimitiveType.Unnormalized. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.primitivetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.primitivetype.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_global_options.html:342,Deployability,update,updated,342,". psi4.core.print_global_options. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.print_global_options. psi4.core.print_global_options()  None; Prints the currently set global (all modules) options to the output file. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.print_global_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_global_options.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_options.html:325,Deployability,update,updated,325,". psi4.core.print_options. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.print_options. psi4.core.print_options()  None; Prints the currently set options (to the output file) for the current module. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.print_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_options.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_out.html:310,Deployability,update,updated,310,". psi4.core.print_out. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.print_out. psi4.core.print_out(arg0: str)  None; Prints a string (using sprintf-like notation) to the output file. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.print_out.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_out.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_variables.html:309,Deployability,update,updated,309,". psi4.core.print_variables. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.print_variables. psi4.core.print_variables()  None; Prints all PSI variables that have been set internally. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.print_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_variables.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_variables.html:168,Modifiability,variab,variables,168,". psi4.core.print_variables. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.print_variables. psi4.core.print_variables()  None; Prints all PSI variables that have been set internally. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.print_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.print_variables.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.prop.html:458,Deployability,update,updated,458,". psi4.core.Prop. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Prop. class psi4.core.Prop; Bases: object; docstring; Methods Summary. set_title((self:psi4.core.Prop,...); docstring. Methods Documentation. set_title(self: psi4.core.Prop, arg0: str)  None; docstring. set_title(self: psi4.core.Prop, arg0: str)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.prop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.pseudospectralint.html:567,Deployability,update,updated,567,". psi4.core.PseudospectralInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.PseudospectralInt. class psi4.core.PseudospectralInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.pseudospectralint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.pseudospectralint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.pseudotrial.html:1075,Deployability,update,updated,1075,". psi4.core.PseudoTrial. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.PseudoTrial. class psi4.core.PseudoTrial; Bases: object; docstring; Methods Summary. getA(...); docstring. getI(...); docstring. getIPS(...); docstring. getQ(...); docstring. getR(...); docstring. Methods Documentation. getA(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. getI(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. getIPS(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. getQ(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. getR(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. getA(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. getI(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. getIPS(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. getQ(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. getR(self: psi4.core.PseudoTrial)  psi4.core.Matrix; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.pseudotrial.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.pseudotrial.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.psimrcc.html:299,Deployability,update,updated,299,". psi4.core.psimrcc. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.psimrcc. psi4.core.psimrcc(arg0: psi::Wavefunction)  float; Runs the multireference coupled cluster code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.psimrcc.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.psireturntype.html:605,Deployability,update,updated,605,". psi4.core.PsiReturnType. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.PsiReturnType. class psi4.core.PsiReturnType; Bases: object; docstring; Attributes Summary. Balk. EndLoop. Failure. Success. Attributes Documentation. Balk = PsiReturnType.Balk. EndLoop = PsiReturnType.EndLoop. Failure = PsiReturnType.Failure. Success = PsiReturnType.Success. Balk = PsiReturnType.Balk. EndLoop = PsiReturnType.EndLoop. Failure = PsiReturnType.Failure. Success = PsiReturnType.Success. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.psireturntype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.psireturntype.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.psi_top_srcdir.html:290,Deployability,update,updated,290,". psi4.core.psi_top_srcdir. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.psi_top_srcdir. psi4.core.psi_top_srcdir()  str; Returns the location of the source code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.psi_top_srcdir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.psi_top_srcdir.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.quadrupoleint.html:555,Deployability,update,updated,555,". psi4.core.QuadrupoleInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.QuadrupoleInt. class psi4.core.QuadrupoleInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.quadrupoleint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.quadrupoleint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.reopen_outfile.html:275,Deployability,update,updated,275,". psi4.core.reopen_outfile. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.reopen_outfile. psi4.core.reopen_outfile()  None; Reopens the output file. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.reopen_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.reopen_outfile.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.revoke_global_option_changed.html:628,Deployability,update,updated,628,". psi4.core.revoke_global_option_changed. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.revoke_global_option_changed. psi4.core.revoke_global_option_changed(arg0: str)  None; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.revoke_global_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.revoke_global_option_changed.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.revoke_local_option_changed.html:665,Deployability,update,updated,665,". psi4.core.revoke_local_option_changed. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.revoke_local_option_changed. psi4.core.revoke_local_option_changed(arg0: str, arg1: str)  None; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.revoke_local_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.revoke_local_option_changed.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:9484,Deployability,update,updated,9484,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:2145,Energy Efficiency,charge,charges,2145,"atrix. H(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Core Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of d",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:2688,Energy Efficiency,energy,energy,2688,"gian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:3165,Energy Efficiency,energy,energy,3165,"lf: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the H",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:3238,Energy Efficiency,energy,energy,3238,".Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:3768,Energy Efficiency,energy,energy,3768,"function)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:4836,Modifiability,variab,variable,4836,"ne; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF)  None; Initializes the Wavefunction. iterations(self: psi4.core.HF)  None; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF)  psi4.core.JK; Returns the internal JK object. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction)  int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction)  str; T",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:8924,Modifiability,variab,variable,8924,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:9280,Modifiability,variab,variables,9280,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html:9373,Modifiability,variab,variables,9373,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:10028,Deployability,update,updated,10028,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:2513,Energy Efficiency,charge,charges,2513,"atrix. H(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Core Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of d",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:3056,Energy Efficiency,energy,energy,3056,"gian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:3533,Energy Efficiency,energy,energy,3533,"lf: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the H",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:3606,Energy Efficiency,energy,energy,3606,".Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:4136,Energy Efficiency,energy,energy,4136,"function)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:5204,Modifiability,variab,variable,5204,"ne; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF)  None; Initializes the Wavefunction. iterations(self: psi4.core.HF)  None; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF)  psi4.core.JK; Returns the internal JK object. moFa(self: psi4.core.ROHF)  psi4.core.Matrix; docstring. moFb(self: psi4.core.ROHF)  psi4.core.Matrix; docstring. moFeff(self: psi4.core.ROHF)  psi4.core.Matrix; docstring. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction)  int; Number",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:9468,Modifiability,variab,variable,9468,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:9824,Modifiability,variab,variables,9824,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:9917,Modifiability,variab,variables,9917,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.rohf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.run_gdma.html:287,Deployability,update,updated,287,". psi4.core.run_gdma. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.run_gdma. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str)  float; Runs the GDMA code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.run_gdma.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.run_gdma.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.sapt.html:346,Deployability,update,updated,346,". psi4.core.sapt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.sapt. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction)  float; Runs the symmetry adapted perturbation theory code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.sapt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.sapt.html:212,Energy Efficiency,adapt,adapted,212,". psi4.core.sapt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.sapt. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction)  float; Runs the symmetry adapted perturbation theory code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.sapt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.sapt.html:212,Modifiability,adapt,adapted,212,". psi4.core.sapt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.sapt. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction)  float; Runs the symmetry adapted perturbation theory code. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.sapt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.scatter.html:319,Deployability,update,updated,319,". psi4.core.scatter. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.scatter. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list)  None; New Scatter function. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.scatter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.scatter.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.scfgrad.html:320,Deployability,update,updated,320,". psi4.core.scfgrad. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.scfgrad. psi4.core.scfgrad(arg0: psi::Wavefunction)  psi::Matrix; Run scfgrad, which is a specialized DF-SCF gradient program. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.scfgrad.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.scfgrad.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.scfhess.html:319,Deployability,update,updated,319,". psi4.core.scfhess. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.scfhess. psi4.core.scfhess(arg0: psi::Wavefunction)  psi::Matrix; Run scfhess, which is a specialized DF-SCF hessian program. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.scfhess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.scfhess.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_active_molecule.html:349,Deployability,update,updated,349,". psi4.core.set_active_molecule. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_active_molecule. psi4.core.set_active_molecule(arg0: psi::Molecule)  None; Activates a previously defined (in the input) molecule, by name. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_active_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_active_molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_array_variable.html:320,Deployability,update,updated,320,". psi4.core.set_array_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_array_variable. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix)  None; Sets a PSI variable, by name. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_array_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_array_variable.html:201,Modifiability,variab,variable,201,". psi4.core.set_array_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_array_variable. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix)  None; Sets a PSI variable, by name. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_array_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_efp_torque.html:354,Deployability,update,updated,354,". psi4.core.set_efp_torque. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_efp_torque. psi4.core.set_efp_torque(arg0: psi::Matrix)  None; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_efp_torque.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_efp_torque.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_environment.html:299,Deployability,update,updated,299,". psi4.core.set_environment. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_environment. psi4.core.set_environment(arg0: str, arg1: str)  str; Set enviromental vairable. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_environment.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_environment.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_frequencies.html:351,Deployability,update,updated,351,". psi4.core.set_frequencies. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_frequencies. psi4.core.set_frequencies(arg0: psi::Vector)  None; Assigns the global frequencies to the values stored in the 3N-6 Vector argument. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_global_option.html:711,Deployability,update,updated,711,". psi4.core.set_global_option. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_global_option. psi4.core.set_global_option(*args, **kwargs); Overloaded function. set_global_option(arg0: str, arg1: list) -> bool. Sets value arg2 to array keyword arg1 for all modules. set_global_option(arg0: str, arg1: int) -> bool. Sets value arg2 to integer keyword arg1 for all modules. set_global_option(arg0: str, arg1: float) -> bool. Sets value arg2 to double keyword arg1 for all modules. set_global_option(arg0: str, arg1: str) -> bool. Sets value arg2 to string keyword arg1 for all modules. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_global_option.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_global_option_python.html:349,Deployability,update,updated,349,". psi4.core.set_global_option_python. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_global_option_python. psi4.core.set_global_option_python(arg0: str, arg1: object)  bool; Sets a global option to a Python object type. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_global_option_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_global_option_python.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_gradient.html:341,Deployability,update,updated,341,". psi4.core.set_gradient. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_gradient. psi4.core.set_gradient(arg0: psi::Matrix)  None; Assigns the global gradient to the values stored in the N by 3 Matrix argument. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_gradient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_gradient.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_legacy_molecule.html:349,Deployability,update,updated,349,". psi4.core.set_legacy_molecule. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_legacy_molecule. psi4.core.set_legacy_molecule(arg0: psi::Molecule)  None; Activates a previously defined (in the input) molecule, by name. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_legacy_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_legacy_molecule.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_legacy_wavefunction.html:381,Deployability,update,updated,381,". psi4.core.set_legacy_wavefunction. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_legacy_wavefunction. psi4.core.set_legacy_wavefunction(arg0: psi::Wavefunction)  None; Returns the current legacy_wavefunction object from the most recent computation. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_legacy_wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_legacy_wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_local_option.html:836,Deployability,update,updated,836,". psi4.core.set_local_option. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_local_option. psi4.core.set_local_option(*args, **kwargs); Overloaded function. set_local_option(arg0: str, arg1: str, arg2: list) -> bool. Sets value arg3 to array keyword arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: int) -> bool. Sets value arg3 to integer keyword arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: float) -> bool. Sets value arg3 to double keyword arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: str) -> bool. Sets value arg3 to string keyword arg2 scoped only to a specific module arg1. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_local_option.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_local_option_python.html:371,Deployability,update,updated,371,". psi4.core.set_local_option_python. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_local_option_python. psi4.core.set_local_option_python(arg0: str, arg1: object)  None; Sets an option to a Python object, but scoped only to a single module. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_local_option_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_local_option_python.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_memory_bytes.html:202,Availability,avail,available,202,". psi4.core.set_memory_bytes. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_memory_bytes. psi4.core.set_memory_bytes(memory: int, quiet: bool=False)  None; Sets the memory available to Psi (in bytes). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_memory_bytes.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_memory_bytes.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_memory_bytes.html:331,Deployability,update,updated,331,". psi4.core.set_memory_bytes. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_memory_bytes. psi4.core.set_memory_bytes(memory: int, quiet: bool=False)  None; Sets the memory available to Psi (in bytes). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_memory_bytes.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_memory_bytes.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_num_threads.html:348,Deployability,update,updated,348,". psi4.core.set_num_threads. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_num_threads. psi4.core.set_num_threads(nthread: int, quiet: bool=False)  None; Sets the number of threads to use in SMP parallel computations. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_num_threads.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_output_file.html:274,Deployability,update,updated,274,". psi4.core.set_output_file. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_output_file. psi4.core.set_output_file(arg0: str, arg1: bool)  None. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_output_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_output_file.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_parent_symmetry.html:408,Deployability,update,updated,408,". psi4.core.set_parent_symmetry. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_parent_symmetry. psi4.core.set_parent_symmetry(arg0: str)  None; Sets the symmetry of the parent (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_parent_symmetry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_parent_symmetry.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_psi_file_prefix.html:274,Deployability,update,updated,274,". psi4.core.set_psi_file_prefix. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_psi_file_prefix. psi4.core.set_psi_file_prefix(arg0: str)  None. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_psi_file_prefix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_psi_file_prefix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_variable.html:296,Deployability,update,updated,296,". psi4.core.set_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_variable. psi4.core.set_variable(arg0: str, arg1: float)  None; Sets a PSI variable, by name. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_variable.html:177,Modifiability,variab,variable,177,". psi4.core.set_variable. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.set_variable. psi4.core.set_variable(arg0: str, arg1: float)  None; Sets a PSI variable, by name. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.shellinfo.html:247,Deployability,update,updated,247,". psi4.core.ShellInfo. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ShellInfo. class psi4.core.ShellInfo; Bases: object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.shellinfo.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.shellinfo.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.sobasisset.html:481,Deployability,update,updated,481,". psi4.core.SOBasisSet. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.SOBasisSet. class psi4.core.SOBasisSet; Bases: object; docstring; Methods Summary. petite_list(...); docstring. Methods Documentation. petite_list(self: psi4.core.SOBasisSet)  psi4.core.PetiteList; docstring. petite_list(self: psi4.core.SOBasisSet)  psi4.core.PetiteList; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.sobasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.sobasisset.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.somcscf.html:718,Deployability,update,update,718,". psi4.core.SOMCSCF. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.SOMCSCF. class psi4.core.SOMCSCF; Bases: object; docstring; Methods Summary. Ck((self:psi4.core.SOMCSCF,...). H_approx_diag(...). approx_solve(...). compute_AFock((self:psi4.core.SOMCSCF,...). compute_Hk((self:psi4.core.SOMCSCF,...). compute_Q((self:psi4.core.SOMCSCF,...). compute_Qk((self:psi4.core.SOMCSCF,...). current_AFock(...). current_IFock(...). current_ci_energy(...). current_docc_energy(...). current_total_energy(...). form_rotation_matrix(...). gradient(...). gradient_rms((self:psi4.core.SOMCSCF)->float). rhf_energy((self:psi4.core.SOMCSCF,...). solve((self:psi4.core.SOMCSCF,arg0:int,...). update((self:psi4.core.SOMCSCF,...). zero_redundant((self:psi4.core.SOMCSCF,...). Methods Documentation. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOM",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.somcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.somcscf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.somcscf.html:2064,Deployability,update,update,2064,".SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(se",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.somcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.somcscf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.somcscf.html:3518,Deployability,update,update,3518,"i4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.somcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.somcscf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.somcscf.html:3850,Deployability,update,updated,3850,"i4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.somcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.somcscf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.superfunctional.html:7619,Deployability,update,updated,7619," docstring. is_meta(self: psi4.core.SuperFunctional)  bool; docstring. is_x_hybrid(self: psi4.core.SuperFunctional)  bool; docstring. is_x_lrc(self: psi4.core.SuperFunctional)  bool; docstring. max_points(self: psi4.core.SuperFunctional)  int; docstring. name(self: psi4.core.SuperFunctional)  str; docstring. print_detail(self: psi4.core.SuperFunctional, arg0: int)  None; docstring. print_out(self: psi4.core.SuperFunctional)  None; docstring. set_c_alpha(self: psi4.core.SuperFunctional, arg0: float)  None; docstring. set_c_omega(self: psi4.core.SuperFunctional, arg0: float)  None; docstring. set_c_os_alpha(self: psi4.core.SuperFunctional, arg0: float)  None; docstring. set_c_ss_alpha(self: psi4.core.SuperFunctional, arg0: float)  None; docstring. set_citation(self: psi4.core.SuperFunctional, arg0: str)  None; docstring. set_deriv(self: psi4.core.SuperFunctional, arg0: int)  None; docstring. set_description(self: psi4.core.SuperFunctional, arg0: str)  None; docstring. set_max_points(self: psi4.core.SuperFunctional, arg0: int)  None; docstring. set_name(self: psi4.core.SuperFunctional, arg0: str)  None; docstring. set_x_alpha(self: psi4.core.SuperFunctional, arg0: float)  None; docstring. set_x_omega(self: psi4.core.SuperFunctional, arg0: float)  None; docstring. test_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Vector, arg1: psi4.core.Vector, arg2: psi4.core.Vector, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector)  None; docstring. value(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Vector; docstring. x_alpha(self: psi4.core.SuperFunctional)  float; docstring. x_functional(self: psi4.core.SuperFunctional, arg0: str)  psi::Functional; docstring. x_omega(self: psi4.core.SuperFunctional)  float; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.superfunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.superfunctional.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.superfunctional.html:261,Energy Efficiency,allocate,allocate,261,". psi4.core.SuperFunctional. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.SuperFunctional. class psi4.core.SuperFunctional; Bases: object; docstring; Methods Summary. add_c_functional(...); docstring. add_x_functional(...); docstring. allocate(...); docstring. ansatz((self:psi4.core.SuperFunctional)->int); docstring. blank(()->psi4.core.SuperFunctional); docstring. c_alpha(...); docstring. c_functional(...); docstring. c_omega(...); docstring. c_os_alpha(...); docstring. c_ss_alpha(...); docstring. citation(...); docstring. deriv((self:psi4.core.SuperFunctional)->int); docstring. description(...); docstring. is_c_hybrid(...); docstring. is_c_lrc(...); docstring. is_c_scs_hybrid(...); docstring. is_gga((self:psi4.core.SuperFunctional)->bool); docstring. is_meta(...); docstring. is_x_hybrid(...); docstring. is_x_lrc(...); docstring. max_points(...); docstring. name((self:psi4.core.SuperFunctional)->str); docstring. print_detail(...); docstring. print_out(...); docstring. set_c_alpha(...); docstring. set_c_omega(...); docstring. set_c_os_alpha(...); docstring. set_c_ss_alpha(...); docstring. set_citation(...); docstring. set_deriv((self:psi4.core.SuperFunctional,...); docstring. set_description(...); docstring. set_max_points(...); docstring. set_name((self:psi4.core.SuperFunctional,...); docstring. set_x_alpha(...); docstring. set_x_omega(...); docstring. test_functional(...); docstring. value((self:psi4.core.SuperFunctional,...); docstring. x_alpha(...); docstring. x_functional(...); docstring. x_omega(...); docstring. Methods Documentation. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional)  None; docstring. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional)  None; docstring. allocate(self: psi4.core.SuperFunctional)  None; docstring. ansatz(self: psi4.core.SuperFunctional)  int; docstring. blank()  psi4.core.SuperFunctional; docstring. c_alpha(self: psi4.core.SuperFun",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.superfunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.superfunctional.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.superfunctional.html:1799,Energy Efficiency,allocate,allocate,1799,"...); docstring. is_x_hybrid(...); docstring. is_x_lrc(...); docstring. max_points(...); docstring. name((self:psi4.core.SuperFunctional)->str); docstring. print_detail(...); docstring. print_out(...); docstring. set_c_alpha(...); docstring. set_c_omega(...); docstring. set_c_os_alpha(...); docstring. set_c_ss_alpha(...); docstring. set_citation(...); docstring. set_deriv((self:psi4.core.SuperFunctional,...); docstring. set_description(...); docstring. set_max_points(...); docstring. set_name((self:psi4.core.SuperFunctional,...); docstring. set_x_alpha(...); docstring. set_x_omega(...); docstring. test_functional(...); docstring. value((self:psi4.core.SuperFunctional,...); docstring. x_alpha(...); docstring. x_functional(...); docstring. x_omega(...); docstring. Methods Documentation. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional)  None; docstring. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional)  None; docstring. allocate(self: psi4.core.SuperFunctional)  None; docstring. ansatz(self: psi4.core.SuperFunctional)  int; docstring. blank()  psi4.core.SuperFunctional; docstring. c_alpha(self: psi4.core.SuperFunctional)  float; docstring. c_functional(self: psi4.core.SuperFunctional, arg0: str)  psi::Functional; docstring. c_omega(self: psi4.core.SuperFunctional)  float; docstring. c_os_alpha(self: psi4.core.SuperFunctional)  float; docstring. c_ss_alpha(self: psi4.core.SuperFunctional)  float; docstring. citation(self: psi4.core.SuperFunctional)  str; docstring. deriv(self: psi4.core.SuperFunctional)  int; docstring. description(self: psi4.core.SuperFunctional)  str; docstring. is_c_hybrid(self: psi4.core.SuperFunctional)  bool; docstring. is_c_lrc(self: psi4.core.SuperFunctional)  bool; docstring. is_c_scs_hybrid(self: psi4.core.SuperFunctional)  bool; docstring. is_gga(self: psi4.core.SuperFunctional)  bool; docstring. is_meta(self: psi4.core.SuperFunctional)  bool; docstring",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.superfunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.superfunctional.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.superfunctional.html:4770,Energy Efficiency,allocate,allocate,4770,"uperFunctional, arg0: int)  None; docstring. set_name(self: psi4.core.SuperFunctional, arg0: str)  None; docstring. set_x_alpha(self: psi4.core.SuperFunctional, arg0: float)  None; docstring. set_x_omega(self: psi4.core.SuperFunctional, arg0: float)  None; docstring. test_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Vector, arg1: psi4.core.Vector, arg2: psi4.core.Vector, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector)  None; docstring. value(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Vector; docstring. x_alpha(self: psi4.core.SuperFunctional)  float; docstring. x_functional(self: psi4.core.SuperFunctional, arg0: str)  psi::Functional; docstring. x_omega(self: psi4.core.SuperFunctional)  float; docstring. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional)  None; docstring. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional)  None; docstring. allocate(self: psi4.core.SuperFunctional)  None; docstring. ansatz(self: psi4.core.SuperFunctional)  int; docstring. blank()  psi4.core.SuperFunctional; docstring. c_alpha(self: psi4.core.SuperFunctional)  float; docstring. c_functional(self: psi4.core.SuperFunctional, arg0: str)  psi::Functional; docstring. c_omega(self: psi4.core.SuperFunctional)  float; docstring. c_os_alpha(self: psi4.core.SuperFunctional)  float; docstring. c_ss_alpha(self: psi4.core.SuperFunctional)  float; docstring. citation(self: psi4.core.SuperFunctional)  str; docstring. deriv(self: psi4.core.SuperFunctional)  int; docstring. description(self: psi4.core.SuperFunctional)  str; docstring. is_c_hybrid(self: psi4.core.SuperFunctional)  bool; docstring. is_c_lrc(self: psi4.core.SuperFunctional)  bool; docstring. is_c_scs_hybrid(self: psi4.core.SuperFunctional)  bool; docstring. is_gga(self: psi4.core.SuperFunctional)  bool; docstring. is_meta(self: psi4.core.SuperFunctional)  bool; docstring. is_x_hybrid(se",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.superfunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.superfunctional.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html:4584,Deployability,update,updated,4584,"ryOperation; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation)  None; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation)  None; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation)  None; Zero out the symmetry operation. E(self: psi4.core.SymmetryOperation)  None; Set equal to E. c2_x(self: psi4.core.SymmetryOperation)  None; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation)  None; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation)  None; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation)  None; Set equal to an inversion. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation)  psi4.core.SymmetryOperation; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int)  None; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float)  None; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation)  None; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation)  None; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation)  None; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation)  float; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation)  psi4.core.SymmetryOperation; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation)  None; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation)  None; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation)  None; Zero out the symmetry operation. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.symmetryoperation.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.thermo.html:298,Deployability,update,updated,298,". psi4.core.thermo. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.thermo. psi4.core.thermo(arg0: psi::Wavefunction, arg1: psi::Vector)  float; Computes thermodynamic data. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.thermo.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.thermo.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.threecenteroverlapint.html:576,Deployability,update,updated,576,". psi4.core.ThreeCenterOverlapInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.ThreeCenterOverlapInt. class psi4.core.ThreeCenterOverlapInt; Bases: object; docstring; Methods Summary. compute_shell(...); docstring. Methods Documentation. compute_shell(self: psi4.core.ThreeCenterOverlapInt, arg0: int, arg1: int, arg2: int)  None; docstring. compute_shell(self: psi4.core.ThreeCenterOverlapInt, arg0: int, arg1: int, arg2: int)  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.threecenteroverlapint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.threecenteroverlapint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.tracelessquadrupoleint.html:582,Deployability,update,updated,582,". psi4.core.TracelessQuadrupoleInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.TracelessQuadrupoleInt. class psi4.core.TracelessQuadrupoleInt; Bases: psi4.core.OneBodyAOInt; docstring. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; docstring. origin; The origin about which the one body ints are being computed. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.tracelessquadrupoleint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.tracelessquadrupoleint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.tstart.html:237,Deployability,update,updated,237,". psi4.core.tstart. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.tstart. psi4.core.tstart()  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.tstart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.tstart.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.tstop.html:234,Deployability,update,updated,234,". psi4.core.tstop. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.tstop. psi4.core.tstop()  None; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.tstop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.tstop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.twobodyaoint.html:582,Deployability,update,updated,582,". psi4.core.TwoBodyAOInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.TwoBodyAOInt. class psi4.core.TwoBodyAOInt; Bases: object; docstring; Methods Summary. compute_shell((self:psi4.core.TwoBodyAOInt,...); docstring. Methods Documentation. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.twobodyaoint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.twobodyaoint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.twoelectronint.html:604,Deployability,update,updated,604,". psi4.core.TwoElectronInt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.TwoElectronInt. class psi4.core.TwoElectronInt; Bases: psi4.core.TwoBodyAOInt; docstring; Methods Summary. compute_shell((self:psi4.core.TwoBodyAOInt,...); docstring. Methods Documentation. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.twoelectronint.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.twoelectronint.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:9484,Deployability,update,updated,9484,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:2145,Energy Efficiency,charge,charges,2145,"atrix. H(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Core Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of d",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:2688,Energy Efficiency,energy,energy,2688,"gian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:3165,Energy Efficiency,energy,energy,3165,"lf: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the H",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:3238,Energy Efficiency,energy,energy,3238,".Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:3768,Energy Efficiency,energy,energy,3768,"function)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF)  float; Computes the final SCF energy. form_C(self: psi4.core.HF)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:4836,Modifiability,variab,variable,4836,"ne; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF)  psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix)  None; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF)  None; Initializes the Wavefunction. iterations(self: psi4.core.HF)  None; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF)  psi4.core.JK; Returns the internal JK object. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction)  int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction)  str; T",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:8924,Modifiability,variab,variable,8924,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:9280,Modifiability,variab,variables,9280,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html:9373,Modifiability,variab,variables,9373,"psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.uhf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.uhf.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vbase.html:2384,Deployability,update,updated,2384,"lf:psi4.core.VBase)->None); doctsring. functional(...); doctsring. initialize((self:psi4.core.VBase)->None); doctsring. quadrature_values(...); doctsring. Methods Documentation. C(self: psi4.core.VBase)  List[psi4.core.Matrix]; doctsring. C_add(self: psi4.core.VBase, arg0: psi4.core.Matrix)  None. C_clear(self: psi4.core.VBase)  None. D(self: psi4.core.VBase)  List[psi4.core.Matrix]; doctsring. V(self: psi4.core.VBase)  List[psi4.core.Matrix]; doctsring. basis(self: psi4.core.VBase)  psi4.core.BasisSet; doctsring. build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. compute(self: psi4.core.VBase)  None; doctsring. compute_gradient(self: psi4.core.VBase)  psi4.core.Matrix; doctsring. finalize(self: psi4.core.VBase)  None; doctsring. functional(self: psi4.core.VBase)  psi4.core.SuperFunctional; doctsring. initialize(self: psi4.core.VBase)  None; doctsring. quadrature_values(self: psi4.core.VBase)  Dict[str, float]; doctsring. C(self: psi4.core.VBase)  List[psi4.core.Matrix]; doctsring. C_add(self: psi4.core.VBase, arg0: psi4.core.Matrix)  None. C_clear(self: psi4.core.VBase)  None. D(self: psi4.core.VBase)  List[psi4.core.Matrix]; doctsring. V(self: psi4.core.VBase)  List[psi4.core.Matrix]; doctsring. basis(self: psi4.core.VBase)  psi4.core.BasisSet; doctsring. build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. compute(self: psi4.core.VBase)  None; doctsring. compute_gradient(self: psi4.core.VBase)  psi4.core.Matrix; doctsring. finalize(self: psi4.core.VBase)  None; doctsring. functional(self: psi4.core.VBase)  psi4.core.SuperFunctional; doctsring. initialize(self: psi4.core.VBase)  None; doctsring. quadrature_values(self: psi4.core.VBase)  Dict[str, float]; doctsring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vbase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vbase.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:7055,Deployability,update,updated,7055,"0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, arg0: int) -> float. docstring. get(self: psi4.core.Vector, arg0: int, arg1: int) -> float. docstring. name; The name of the Vector. Used in printing. nirrep(self: psi4.core.Vector)  int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. print_out(self: psi4.core.Vector)  None; docstring. scale(self: psi4.core.Vector, arg0: float)  None; docstring. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. shape; Shape of the Psi4 data object. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:3707,Integrability,depend,depending,3707,"ctor, arg0: int, arg1: int) -> float. docstring. nirrep(self: psi4.core.Vector)  int; docstring. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). print_out(self: psi4.core.Vector)  None; docstring. scale(self: psi4.core.Vector, arg0: float)  None; docstring. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. array_interface(self: psi4.core.Vector)  list. dim(self: psi4.core.Vector, arg0: int)  int; docstring. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays)  Numpy array or list of arrays to use as the data for a new core.Matrix; name (str)  Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional))  If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix beside",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:6606,Integrability,depend,depending,6606,"0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, arg0: int) -> float. docstring. get(self: psi4.core.Vector, arg0: int, arg1: int) -> float. docstring. name; The name of the Vector. Used in printing. nirrep(self: psi4.core.Vector)  int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. print_out(self: psi4.core.Vector)  None; docstring. scale(self: psi4.core.Vector, arg0: float)  None; docstring. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. shape; Shape of the Psi4 data object. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:1056,Security,access,accessor,1056," PSI4. psi4.core.Vector. class psi4.core.Vector; Bases: object; docstring; Attributes Summary. name; The name of the Vector. np; View without only one irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Summary. array_interface((self:psi4.core.Vector)->list). dim((self:psi4.core.Vector,arg0:int)->int); docstring. from_array(arr[,name,dim1,dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args,**kwargs); Overloaded function. nirrep((self:psi4.core.Vector)->int); docstring. np_read(filename[,prefix]). np_write([filename,prefix]). print_out((self:psi4.core.Vector)->None); docstring. scale((self:psi4.core.Vector,...); docstring. set(*args,**kwargs); Overloaded function. to_array(matrix[,copy,dense]); Converts a Psi4 Matrix or Vector to a numpy array. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. Attributes Documentation. name; The name of the Vector. Used in printing. np; View without only one irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. array_interface(self: psi4.core.Vector)  list. dim(self: psi4.core.Vector, arg0: int)  int; docstring. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays)  Numpy array or list of arrays to use as the data for a new core.Matrix; name (str)  Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional))  If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2  Same as dim1 only if using a Psi4.Dimension object. Returns:matrix",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:4020,Security,access,accessor,4020,"nction. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. array_interface(self: psi4.core.Vector)  list. dim(self: psi4.core.Vector, arg0: int)  int; docstring. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays)  Numpy array or list of arrays to use as the data for a new core.Matrix; name (str)  Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional))  If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2  Same as dim1 only if using a Psi4.Dimension object. Returns:matrix  Returns the given Psi4 object. Return type:Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; 1; 2>>> data = np.random.rand(20); >>> vect",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:6918,Security,access,accessor,6918,"0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, arg0: int) -> float. docstring. get(self: psi4.core.Vector, arg0: int, arg1: int) -> float. docstring. name; The name of the Vector. Used in printing. nirrep(self: psi4.core.Vector)  int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. print_out(self: psi4.core.Vector)  None; docstring. scale(self: psi4.core.Vector, arg0: float)  None; docstring. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. shape; Shape of the Psi4 data object. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:3319,Usability,simpl,simply,3319,"data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, arg0: int) -> float. docstring. get(self: psi4.core.Vector, arg0: int, arg1: int) -> float. docstring. nirrep(self: psi4.core.Vector)  int; docstring. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). print_out(self: psi4.core.Vector)  None; docstring. scale(self: psi4.core.Vector, arg0: float)  None; docstring. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. array_interface(self: psi4.core.Vector)  list. dim(self: psi4.core.Vector, arg0: int)  int; docstring. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Pa",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:6218,Usability,simpl,simply,6218,"0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, arg0: int) -> float. docstring. get(self: psi4.core.Vector, arg0: int, arg1: int) -> float. docstring. name; The name of the Vector. Used in printing. nirrep(self: psi4.core.Vector)  int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. print_out(self: psi4.core.Vector)  None; docstring. scale(self: psi4.core.Vector, arg0: float)  None; docstring. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. shape; Shape of the Psi4 data object. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector)  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array  Returns either a list of np.arrays or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector3.html:1847,Deployability,update,updated,1847,". psi4.core.Vector3. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.Vector3. class psi4.core.Vector3; Bases: object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; Methods Summary. cross((self:psi4.core.Vector3,...); Returns cross product of arg1 and arg2. distance((self:psi4.core.Vector3,...); Returns distance between two points represented by arg1 and arg2. dot((self:psi4.core.Vector3,...); Returns dot product of arg1 and arg2. norm((self:psi4.core.Vector3)->float); Returns Euclidean norm of arg1. normalize((self:psi4.core.Vector3)->None); Returns vector of unit length and arg1 direction. Methods Documentation. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  psi4.core.Vector3; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  float; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  float; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3)  float; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3)  None; Returns vector of unit length and arg1 direction. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  psi4.core.Vector3; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  float; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  float; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3)  float; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3)  None; Returns vector of unit length and arg1 direction. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vector3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector3.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html:1437,Availability,error,error,1437,"en list. insert((self:List[psi::Matrix],i:int,...); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove((self:List[psi::Matrix],...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vectormatrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html:2221,Availability,error,error,2221,"en list. insert((self:List[psi::Matrix],i:int,...); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove((self:List[psi::Matrix],...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vectormatrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html:2353,Deployability,update,updated,2353,"en list. insert((self:List[psi::Matrix],i:int,...); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove((self:List[psi::Matrix],...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vectormatrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html:336,Modifiability,extend,extend,336,". psi4.core.VectorMatrix. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.VectorMatrix. class psi4.core.VectorMatrix; Bases: object; Methods Summary. append((self:List[psi::Matrix],...); Add an item to the end of the list. count((self:List[psi::Matrix],...); Return the number of times x appears in the list. extend((self:List[psi::Matrix],...); Extend the list by appending all the items in the given list. insert((self:List[psi::Matrix],i:int,...); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove((self:List[psi::Matrix],...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the la",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vectormatrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html:877,Modifiability,extend,extend,877,". psi4.core.VectorMatrix. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.VectorMatrix. class psi4.core.VectorMatrix; Bases: object; Methods Summary. append((self:List[psi::Matrix],...); Add an item to the end of the list. count((self:List[psi::Matrix],...); Return the number of times x appears in the list. extend((self:List[psi::Matrix],...); Extend the list by appending all the items in the given list. insert((self:List[psi::Matrix],i:int,...); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove((self:List[psi::Matrix],...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the la",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vectormatrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html:1665,Modifiability,extend,extend,1665,"en list. insert((self:List[psi::Matrix],i:int,...); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove((self:List[psi::Matrix],...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi::Matrix], x: psi::Matrix)  None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix)  int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix])  None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.vectormatrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.version.html:272,Deployability,update,updated,272,". psi4.core.version. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.version. psi4.core.version()  str; Returns the version ID of this copy of Psi. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.version.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.version.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.view.html:361,Deployability,update,updated,361,". psi4.core.View. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.core.View. class psi4.core.View; Bases: object; Methods Summary. __call__(...); docstring. Methods Documentation. __call__(self: psi4.core.View)  psi4.core.Matrix; docstring. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.view.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.view.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:19624,Deployability,update,updated,19624,"vefunction; docstring. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. set_array(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:1157,Energy Efficiency,charge,charges,1157,"s: object; docstring; Methods Summary. Ca(...); Returns the Alpha Orbitals. Ca_subset((self:psi4.core.Wavefunction,...); Returns the requested Alpha Orbital subset. Cb(...); Returns the Beta Orbitals. Cb_subset((self:psi4.core.Wavefunction,...); Returns the requested Beta Orbital subset. Da(...); Returns the Alpha Density Matrix. Da_subset((self:psi4.core.Wavefunction,...); Returns the requested Alpha Density subset. Db(...); Returns the Beta Density Matrix. Db_subset((self:psi4.core.Wavefunction,...); Returns the requested Beta Density subset. Fa(...); Returns the Alpha Fock Matrix. Fb(...); Returns the Beta Fock Matrix. H(...); Returns the Core Matrix (Potential + Kinetic) Integrals. S(...); Returns the One-electron Overlap Matrix. X(...); Returns the Lagrangian Matrix. alpha_orbital_space(...); docstring. aotoso(...); Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(...); Returns the map of all internal arrays. atomic_point_charges(...); Returns the set atomic point charges. basis_projection(...); Projects a orbital matrix from one basis to another. basisset(...); Returns the current orbital basis. beta_orbital_space(...); docstring. build(mol[,basis]). compute_energy(...); Computes the energy of the Wavefunction. compute_gradient(...); Computes the gradient of the Wavefunction. compute_hessian(...); Computes the Hessian of the Wavefunction. deep_copy((self:psi4.core.Wavefunction,...); Deep copies the internal data. doccpi(...); Returns the number of doubly occupied orbitals per irrep. energy((self:psi4.core.Wavefunction)->float); Returns the Wavefunctions energy. epsilon_a(...); Returns the Alpha Eigenvalues. epsilon_a_subset(...); Returns the requested Alpha Eigenvalues subset. epsilon_b(...); Returns the Beta Eigenvalues. epsilon_b_subset(...); Returns the requested Beta Eigenvalues subset. frequencies(...); Returns the frequencies of the Hessian. frzcpi(...); Returns the number of frozen core orbitals per irrep. frzvpi(...); ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:1383,Energy Efficiency,energy,energy,1383,"...); Returns the requested Beta Orbital subset. Da(...); Returns the Alpha Density Matrix. Da_subset((self:psi4.core.Wavefunction,...); Returns the requested Alpha Density subset. Db(...); Returns the Beta Density Matrix. Db_subset((self:psi4.core.Wavefunction,...); Returns the requested Beta Density subset. Fa(...); Returns the Alpha Fock Matrix. Fb(...); Returns the Beta Fock Matrix. H(...); Returns the Core Matrix (Potential + Kinetic) Integrals. S(...); Returns the One-electron Overlap Matrix. X(...); Returns the Lagrangian Matrix. alpha_orbital_space(...); docstring. aotoso(...); Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(...); Returns the map of all internal arrays. atomic_point_charges(...); Returns the set atomic point charges. basis_projection(...); Projects a orbital matrix from one basis to another. basisset(...); Returns the current orbital basis. beta_orbital_space(...); docstring. build(mol[,basis]). compute_energy(...); Computes the energy of the Wavefunction. compute_gradient(...); Computes the gradient of the Wavefunction. compute_hessian(...); Computes the Hessian of the Wavefunction. deep_copy((self:psi4.core.Wavefunction,...); Deep copies the internal data. doccpi(...); Returns the number of doubly occupied orbitals per irrep. energy((self:psi4.core.Wavefunction)->float); Returns the Wavefunctions energy. epsilon_a(...); Returns the Alpha Eigenvalues. epsilon_a_subset(...); Returns the requested Alpha Eigenvalues subset. epsilon_b(...); Returns the Beta Eigenvalues. epsilon_b_subset(...); Returns the requested Beta Eigenvalues subset. frequencies(...); Returns the frequencies of the Hessian. frzcpi(...); Returns the number of frozen core orbitals per irrep. frzvpi(...); Returns the number of frozen virtual orbitals per irrep. get_array((self:psi4.core.Wavefunction,...); Sets the requested internal array. get_basisset((self:psi4.core.Wavefunction,...); Returns the requested auxiliary basis. get_variable((se",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:1690,Energy Efficiency,energy,energy,1690,"set. Fa(...); Returns the Alpha Fock Matrix. Fb(...); Returns the Beta Fock Matrix. H(...); Returns the Core Matrix (Potential + Kinetic) Integrals. S(...); Returns the One-electron Overlap Matrix. X(...); Returns the Lagrangian Matrix. alpha_orbital_space(...); docstring. aotoso(...); Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(...); Returns the map of all internal arrays. atomic_point_charges(...); Returns the set atomic point charges. basis_projection(...); Projects a orbital matrix from one basis to another. basisset(...); Returns the current orbital basis. beta_orbital_space(...); docstring. build(mol[,basis]). compute_energy(...); Computes the energy of the Wavefunction. compute_gradient(...); Computes the gradient of the Wavefunction. compute_hessian(...); Computes the Hessian of the Wavefunction. deep_copy((self:psi4.core.Wavefunction,...); Deep copies the internal data. doccpi(...); Returns the number of doubly occupied orbitals per irrep. energy((self:psi4.core.Wavefunction)->float); Returns the Wavefunctions energy. epsilon_a(...); Returns the Alpha Eigenvalues. epsilon_a_subset(...); Returns the requested Alpha Eigenvalues subset. epsilon_b(...); Returns the Beta Eigenvalues. epsilon_b_subset(...); Returns the requested Beta Eigenvalues subset. frequencies(...); Returns the frequencies of the Hessian. frzcpi(...); Returns the number of frozen core orbitals per irrep. frzvpi(...); Returns the number of frozen virtual orbitals per irrep. get_array((self:psi4.core.Wavefunction,...); Sets the requested internal array. get_basisset((self:psi4.core.Wavefunction,...); Returns the requested auxiliary basis. get_variable((self:psi4.core.Wavefunction,...); Returns the requested internal variable. gradient(...); Returns the Wavefunctions gradient. hessian(...); Returns the Wavefunctions Hessian. molecule(...); Returns the Wavefunctions molecule. nalpha((self:psi4.core.Wavefunction)->int); Number of Alpha electrons. nalphapi(.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:1765,Energy Efficiency,energy,energy,1765," Fb(...); Returns the Beta Fock Matrix. H(...); Returns the Core Matrix (Potential + Kinetic) Integrals. S(...); Returns the One-electron Overlap Matrix. X(...); Returns the Lagrangian Matrix. alpha_orbital_space(...); docstring. aotoso(...); Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(...); Returns the map of all internal arrays. atomic_point_charges(...); Returns the set atomic point charges. basis_projection(...); Projects a orbital matrix from one basis to another. basisset(...); Returns the current orbital basis. beta_orbital_space(...); docstring. build(mol[,basis]). compute_energy(...); Computes the energy of the Wavefunction. compute_gradient(...); Computes the gradient of the Wavefunction. compute_hessian(...); Computes the Hessian of the Wavefunction. deep_copy((self:psi4.core.Wavefunction,...); Deep copies the internal data. doccpi(...); Returns the number of doubly occupied orbitals per irrep. energy((self:psi4.core.Wavefunction)->float); Returns the Wavefunctions energy. epsilon_a(...); Returns the Alpha Eigenvalues. epsilon_a_subset(...); Returns the requested Alpha Eigenvalues subset. epsilon_b(...); Returns the Beta Eigenvalues. epsilon_b_subset(...); Returns the requested Beta Eigenvalues subset. frequencies(...); Returns the frequencies of the Hessian. frzcpi(...); Returns the number of frozen core orbitals per irrep. frzvpi(...); Returns the number of frozen virtual orbitals per irrep. get_array((self:psi4.core.Wavefunction,...); Sets the requested internal array. get_basisset((self:psi4.core.Wavefunction,...); Returns the requested auxiliary basis. get_variable((self:psi4.core.Wavefunction,...); Returns the requested internal variable. gradient(...); Returns the Wavefunctions gradient. hessian(...); Returns the Wavefunctions Hessian. molecule(...); Returns the Wavefunctions molecule. nalpha((self:psi4.core.Wavefunction)->int); Number of Alpha electrons. nalphapi(...); Returns the number of alpha orbitals pe",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:6598,Energy Efficiency,charge,charges,6598,"t(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Core Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the numb",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:7148,Energy Efficiency,energy,energy,7148,"trix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:7625,Energy Efficiency,energy,energy,7625,"4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.cor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:7698,Energy Efficiency,energy,energy,7698,", arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Basi",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:13944,Energy Efficiency,charge,charges,13944,". Db_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Core Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doub",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:14489,Energy Efficiency,energy,energy,14489,"angian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalu",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:14962,Energy Efficiency,energy,energy,14962,"self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefun",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:15034,Energy Efficiency,energy,energy,15034,"re.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Re",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:2454,Modifiability,variab,variable,2454,"s the gradient of the Wavefunction. compute_hessian(...); Computes the Hessian of the Wavefunction. deep_copy((self:psi4.core.Wavefunction,...); Deep copies the internal data. doccpi(...); Returns the number of doubly occupied orbitals per irrep. energy((self:psi4.core.Wavefunction)->float); Returns the Wavefunctions energy. epsilon_a(...); Returns the Alpha Eigenvalues. epsilon_a_subset(...); Returns the requested Alpha Eigenvalues subset. epsilon_b(...); Returns the Beta Eigenvalues. epsilon_b_subset(...); Returns the requested Beta Eigenvalues subset. frequencies(...); Returns the frequencies of the Hessian. frzcpi(...); Returns the number of frozen core orbitals per irrep. frzvpi(...); Returns the number of frozen virtual orbitals per irrep. get_array((self:psi4.core.Wavefunction,...); Sets the requested internal array. get_basisset((self:psi4.core.Wavefunction,...); Returns the requested auxiliary basis. get_variable((self:psi4.core.Wavefunction,...); Returns the requested internal variable. gradient(...); Returns the Wavefunctions gradient. hessian(...); Returns the Wavefunctions Hessian. molecule(...); Returns the Wavefunctions molecule. nalpha((self:psi4.core.Wavefunction)->int); Number of Alpha electrons. nalphapi(...); Returns the number of alpha orbitals per irrep. name((self:psi4.core.Wavefunction)->str); The level of theory this wavefunction corresponds to. nbeta((self:psi4.core.Wavefunction)->int); Number of Beta electrons. nbetapi(...); Returns the number of beta orbitals per irrep. nfrzc((self:psi4.core.Wavefunction)->int); Number of frozen core electrons. nirrep((self:psi4.core.Wavefunction)->int); Number of irreps in the system. nmo((self:psi4.core.Wavefunction)->int); Number of molecule orbitals. nmopi(...); Returns the number of molecular orbitals per irrep. normalmodes(...); Returns the normal modes of the Wavefunction. nso((self:psi4.core.Wavefunction)->int); Number of symmetry orbitals. nsopi(...); Returns the nu",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:4559,Modifiability,variab,variable,4559,"ion. reference_wavefunction(...); docstring. same_a_b_dens(...); Returns true if the alpha and beta densities are the same. same_a_b_orbs(...); Returns true if the alpha and beta orbitals are the same. set_array((self:psi4.core.Wavefunction,...); Returns the requested internal array. set_basisset((self:psi4.core.Wavefunction,...); Sets the requested auxiliary basis. set_frequencies(...); Sets the frequencies of the Hessian. set_gradient((self:psi4.core.Wavefunction,...); Sets the Wavefunctions gradient. set_hessian((self:psi4.core.Wavefunction,...); Sets the Wavefunctions Hessian. set_name((self:psi4.core.Wavefunction,...); Sets the level of theory this wavefunction corresponds to. set_oeprop((self:psi4.core.Wavefunction,...); Associate an OEProp object with this wavefunction. set_print((self:psi4.core.Wavefunction,...); Sets the print level of the Wavefunction. set_reference_wavefunction(...); docstring. set_variable((self:psi4.core.Wavefunction,...); Sets the requested internal variable. shallow_copy((self:psi4.core.Wavefunction,...); Copies the pointers to the internal data. sobasisset(...); Returns the symmetry orbitals basis. soccpi(...); Returns the number of singly occupied orbitals per irrep. variables(...); Returns the map of all internal variables. Methods Documentation. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction)  psi4.core.Matrix; Return",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:4786,Modifiability,variab,variables,4786,"...); Returns the requested internal array. set_basisset((self:psi4.core.Wavefunction,...); Sets the requested auxiliary basis. set_frequencies(...); Sets the frequencies of the Hessian. set_gradient((self:psi4.core.Wavefunction,...); Sets the Wavefunctions gradient. set_hessian((self:psi4.core.Wavefunction,...); Sets the Wavefunctions Hessian. set_name((self:psi4.core.Wavefunction,...); Sets the level of theory this wavefunction corresponds to. set_oeprop((self:psi4.core.Wavefunction,...); Associate an OEProp object with this wavefunction. set_print((self:psi4.core.Wavefunction,...); Sets the print level of the Wavefunction. set_reference_wavefunction(...); docstring. set_variable((self:psi4.core.Wavefunction,...); Sets the requested internal variable. shallow_copy((self:psi4.core.Wavefunction,...); Copies the pointers to the internal data. sobasisset(...); Returns the symmetry orbitals basis. soccpi(...); Returns the number of singly occupied orbitals per irrep. variables(...); Returns the map of all internal variables. Methods Documentation. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Fock Matrix. Fb(self: psi4.co",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:4834,Modifiability,variab,variables,4834,"ternal array. set_basisset((self:psi4.core.Wavefunction,...); Sets the requested auxiliary basis. set_frequencies(...); Sets the frequencies of the Hessian. set_gradient((self:psi4.core.Wavefunction,...); Sets the Wavefunctions gradient. set_hessian((self:psi4.core.Wavefunction,...); Sets the Wavefunctions Hessian. set_name((self:psi4.core.Wavefunction,...); Sets the level of theory this wavefunction corresponds to. set_oeprop((self:psi4.core.Wavefunction,...); Associate an OEProp object with this wavefunction. set_print((self:psi4.core.Wavefunction,...); Sets the print level of the Wavefunction. set_reference_wavefunction(...); docstring. set_variable((self:psi4.core.Wavefunction,...); Sets the requested internal variable. shallow_copy((self:psi4.core.Wavefunction,...); Copies the pointers to the internal data. sobasisset(...); Returns the symmetry orbitals basis. soccpi(...); Returns the number of singly occupied orbitals per irrep. variables(...); Returns the map of all internal variables. Methods Documentation. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction)  psi4.core.Ma",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:8818,Modifiability,variab,variable,8818,"nvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction)  int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction)  str; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction)  int; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction)  int; Number of frozen core electrons. nirrep(self: psi4.core.Wavefunction)  int; Number of irreps in the system. nmo(self: psi4.core.Wavefunction)  int; Number of molecule ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:11771,Modifiability,variab,variable,11771,"ted internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subse",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:12127,Modifiability,variab,variables,12127,"avefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Fock Matrix. Fb(self:",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:12220,Modifiability,variab,variables,12220," Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns th",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:16144,Modifiability,variab,variable,16144,"pha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Vector; Returns the requested Beta Eigenvalues subset. frequencies(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction)  int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction)  str; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction)  int; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction)  int; Number of frozen core electrons. nirrep(self: psi4.core.Wavefunction)  int; Number of irreps in the system. nmo(self: psi4.core.Wavefunction)  int; Number of molecule orbitals. n",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:19068,Modifiability,variab,variable,19068,"vefunction; docstring. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. set_array(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:19421,Modifiability,variab,variables,19421,"vefunction; docstring. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. set_array(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:19513,Modifiability,variab,variables,19513,"vefunction; docstring. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. set_array(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector)  None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp)  None; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the map of all internal variables. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.core.wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.activate.html:399,Deployability,update,updated,399,". psi4.driver.activate. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.activate. psi4.driver.activate(mol)[source]; Function to set molecule object mol as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.activate.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.activate.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.ancestor.html:284,Deployability,update,updated,284,". psi4.driver.ancestor. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ancestor. psi4.driver.ancestor(dir, n=1)[source]; Get the nth ancestor of a directory. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.ancestor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.ancestor.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.banner.html:519,Deployability,update,updated,519,". psi4.driver.banner. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.banner. psi4.driver.banner(text, type=1, width=35, strNotOutfile=False)[source]; Function to print text to output file in a banner of; minimum width width and minimum three-line height for; type = 1 or one-line height for type = 2. If strNotOutfile; is True, function returns string rather than printing it; to output file. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.banner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.banner.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.basis_helper.html:682,Deployability,update,updated,682,". psi4.driver.basis_helper. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.basis_helper. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]; For PsiAPI mode, forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and cc54 test cases. Unless; set_option is False, name will be set as current active key,; equivalent to set key name or set_option({key: name}). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.basis_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.basis_helper.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.basis_helper.html:445,Testability,test,test,445,". psi4.driver.basis_helper. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.basis_helper. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]; For PsiAPI mode, forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and cc54 test cases. Unless; set_option is False, name will be set as current active key,; equivalent to set key name or set_option({key: name}). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.basis_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.basis_helper.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.bfs.html:286,Availability,fault,faulty,286,". psi4.driver.BFS. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.BFS. psi4.driver.BFS(self)[source]; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.bfs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.bfs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.bfs.html:479,Deployability,update,updated,479,". psi4.driver.BFS. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.BFS. psi4.driver.BFS(self)[source]; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.bfs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.bfs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:9478,Availability,avail,available,9478,"[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defa",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:9514,Availability,avail,available,9514,"ence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:13956,Deployability,update,updated,13956,"replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:177,Energy Efficiency,energy,energy,177,". psi4.driver.cbs. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:393,Energy Efficiency,energy,energy,393,". psi4.driver.cbs. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:842,Energy Efficiency,energy,energy,842,". psi4.driver.cbs. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:991,Energy Efficiency,energy,energy,991,". psi4.driver.cbs. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:1015,Energy Efficiency,energy,energy,1015,". psi4.driver.cbs. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:1062,Energy Efficiency,energy,energy,1062,". psi4.driver.cbs. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:1796,Energy Efficiency,energy,energy,1796," CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn}}^{\textbf{delta_basis}}\right) - \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn_lesser}}^{\textbf{delta_basis}}\right)\]. \[\delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; = \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn}}^{\textbf{delta2_basis}}\right) - \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn_lesser}}^{\textbf{delta2_basis}}\right)\]. \[\delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; = \mathcal",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:1806,Energy Efficiency,energy,energy,1806," CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn}}^{\textbf{delta_basis}}\right) - \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn_lesser}}^{\textbf{delta_basis}}\right)\]. \[\delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; = \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn}}^{\textbf{delta2_basis}}\right) - \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn_lesser}}^{\textbf{delta2_basis}}\right)\]. \[\delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; = \mathcal",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:3659,Energy Efficiency,energy,energy,3659,"orl},\; \textbf{delta3_wfn}}^{\textbf{delta3_basis}}\right) - \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn_lesser}}^{\textbf{delta3_basis}}\right)\]. \[\delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; = \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn}}^{\textbf{delta4_basis}}\right) - \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn_lesser}}^{\textbf{delta4_basis}}\right)\]. \[\delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}} \; = \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn}}^{\textbf{delta5_basis}}\right) - \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn_lesser}}^{\textbf{delta5_basis}}\right)\]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step o",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:3707,Energy Efficiency,energy,energy,3707,"orl},\; \textbf{delta3_wfn}}^{\textbf{delta3_basis}}\right) - \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn_lesser}}^{\textbf{delta3_basis}}\right)\]. \[\delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; = \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn}}^{\textbf{delta4_basis}}\right) - \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn_lesser}}^{\textbf{delta4_basis}}\right)\]. \[\delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}} \; = \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn}}^{\textbf{delta5_basis}}\right) - \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn_lesser}}^{\textbf{delta5_basis}}\right)\]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step o",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:4458,Energy Efficiency,energy,energy,4458,"; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the r",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:4660,Energy Efficiency,energy,energy,4660,"d to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:5124,Energy Efficiency,energy,energy,5124,"aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtai",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:5341,Energy Efficiency,energy,energy,5341,"check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:5379,Energy Efficiency,energy,energy,5379,"check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:5628,Energy Efficiency,energy,energy,5628,"lowing energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:5668,Energy Efficiency,energy,energy,5668,"lowing energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:5855,Energy Efficiency,energy,energy,5855," fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:5918,Energy Efficiency,energy,energy,5918," fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6053,Energy Efficiency,energy,energy,6053,"mputational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6116,Energy Efficiency,energy,energy,6116,"mputational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6218,Energy Efficiency,energy,energy,6218,"f_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6288,Energy Efficiency,energy,energy,6288,"f_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6429,Energy Efficiency,energy,energy,6429,n be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. de,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6499,Energy Efficiency,energy,energy,6499,n be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. de,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6601,Energy Efficiency,energy,energy,6601, method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the ,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6670,Energy Efficiency,energy,energy,6670, method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the ,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6812,Energy Efficiency,energy,energy,6812,"uperior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\L",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6881,Energy Efficiency,energy,energy,6881,"uperior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\L",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:6983,Energy Efficiency,energy,energy,6983,"p2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:7053,Energy Efficiency,energy,energy,7053,"p2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:7195,Energy Efficiency,energy,energy,7195,"d for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:7265,Energy Efficiency,energy,energy,7265,"d for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:7367,Energy Efficiency,energy,energy,7367,"etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation en",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:7436,Energy Efficiency,energy,energy,7436,"etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation en",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:7578,Energy Efficiency,energy,energy,7578,"od for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (b",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:7647,Energy Efficiency,energy,energy,7647,"od for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string)  \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (b",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:7980,Energy Efficiency,energy,energy,7980,"| etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string)  \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction;",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:8216,Energy Efficiency,energy,energy,8216," inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transfor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:8399,Energy Efficiency,energy,energy,8399,"(superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string)  \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exa",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:8590,Energy Efficiency,energy,energy,8590,")' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:8780,Energy Efficiency,energy,energy,8780," have no influence; on a cbs calculation. Parameters:; scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; D",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:8971,Energy Efficiency,energy,energy,8971,"s the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_sch",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:9161,Energy Efficiency,energy,energy,9161,"-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Default",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:9201,Energy Efficiency,energy,energy,9201," delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. d",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:9724,Energy Efficiency,energy,energy,9724,"ates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extra",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:10099,Energy Efficiency,energy,energy,10099,"; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:10430,Energy Efficiency,energy,energy,10430," of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation sc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:10770,Energy Efficiency,energy,energy,10770,"erence energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolatio",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:11110,Energy Efficiency,energy,energy,11110," scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the s",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:11451,Energy Efficiency,energy,energy,11451," correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(n",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:11791,Energy Efficiency,energy,energy,11791,"correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 corre",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:12111,Energy Efficiency,energy,energy,12111,"to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:12270,Energy Efficiency,energy,energy,12270,"(function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:12382,Energy Efficiency,energy,energy,12382," to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xt",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:12519,Energy Efficiency,energy,energy,12519,"pl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO databa",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:12746,Energy Efficiency,energy,energy,12746,"ets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:12909,Energy Efficiency,energy,energy,12909,"ets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:13216,Energy Efficiency,energy,energy,13216,"replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:417,Modifiability,variab,variables,417,". psi4.driver.cbs. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:5165,Performance,perform,performed,5165,"aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtai",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:13749,Performance,optimiz,optimize,13749,"replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:13770,Performance,optimiz,optimize,13770,"replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:12057,Usability,simpl,simple,12057,"to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:12208,Usability,simpl,simple,12208,"(function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function)  \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_arrays.html:366,Availability,failure,failure,366,". psi4.driver.compare_arrays. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_arrays. psi4.driver.compare_arrays(expected, computed, digits, label)[source]; Function to compare two numpy arrays. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_arrays.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_arrays.html:573,Deployability,update,updated,573,". psi4.driver.compare_arrays. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_arrays. psi4.driver.compare_arrays(expected, computed, digits, label)[source]; Function to compare two numpy arrays. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_arrays.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_arrays.html:461,Testability,test,test,461,". psi4.driver.compare_arrays. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_arrays. psi4.driver.compare_arrays(expected, computed, digits, label)[source]; Function to compare two numpy arrays. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_arrays.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_csx.html:348,Deployability,update,updated,348,". psi4.driver.compare_csx. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_csx. psi4.driver.compare_csx()[source]; Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_csx.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_csx.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_csx.html:160,Security,validat,validate,160,". psi4.driver.compare_csx. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_csx. psi4.driver.compare_csx()[source]; Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_csx.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_csx.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_cubes.html:309,Availability,failure,failure,309,". psi4.driver.compare_cubes. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_cubes. psi4.driver.compare_cubes(expected, computed, label)[source]; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_cubes.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_cubes.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_cubes.html:457,Deployability,update,updated,457,". psi4.driver.compare_cubes. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_cubes. psi4.driver.compare_cubes(expected, computed, label)[source]; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_cubes.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_cubes.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_cubes.html:345,Testability,test,test,345,". psi4.driver.compare_cubes. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_cubes. psi4.driver.compare_cubes(expected, computed, label)[source]; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_cubes.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_cubes.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_integers.html:316,Availability,failure,failure,316,". psi4.driver.compare_integers. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_integers. psi4.driver.compare_integers(expected, computed, label)[source]; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_integers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_integers.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_integers.html:464,Deployability,update,updated,464,". psi4.driver.compare_integers. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_integers. psi4.driver.compare_integers(expected, computed, label)[source]; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_integers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_integers.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_integers.html:352,Testability,test,test,352,". psi4.driver.compare_integers. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_integers. psi4.driver.compare_integers(expected, computed, label)[source]; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_integers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_integers.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_matrices.html:368,Availability,failure,failure,368,". psi4.driver.compare_matrices. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_matrices. psi4.driver.compare_matrices(expected, computed, digits, label)[source]; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_matrices.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_matrices.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_matrices.html:576,Deployability,update,updated,576,". psi4.driver.compare_matrices. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_matrices. psi4.driver.compare_matrices(expected, computed, digits, label)[source]; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_matrices.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_matrices.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_matrices.html:464,Testability,test,test,464,". psi4.driver.compare_matrices. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_matrices. psi4.driver.compare_matrices(expected, computed, digits, label)[source]; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_matrices.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_matrices.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_strings.html:322,Availability,failure,failure,322,". psi4.driver.compare_strings. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_strings. psi4.driver.compare_strings(expected, computed, label)[source]; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_strings.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_strings.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_strings.html:470,Deployability,update,updated,470,". psi4.driver.compare_strings. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_strings. psi4.driver.compare_strings(expected, computed, label)[source]; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_strings.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_strings.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_strings.html:358,Testability,test,test,358,". psi4.driver.compare_strings. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_strings. psi4.driver.compare_strings(expected, computed, label)[source]; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_strings.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_strings.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html:409,Availability,failure,failure,409,". psi4.driver.compare_values. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_values. psi4.driver.compare_values(expected, computed, digits, label, exitonfail=True)[source]; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits < 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_values.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html:465,Availability,error,error,465,". psi4.driver.compare_values. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_values. psi4.driver.compare_values(expected, computed, digits, label, exitonfail=True)[source]; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits < 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_values.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html:619,Deployability,update,updated,619,". psi4.driver.compare_values. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_values. psi4.driver.compare_values(expected, computed, digits, label, exitonfail=True)[source]; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits < 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_values.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html:471,Integrability,message,message,471,". psi4.driver.compare_values. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_values. psi4.driver.compare_values(expected, computed, digits, label, exitonfail=True)[source]; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits < 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_values.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html:507,Testability,test,test,507,". psi4.driver.compare_values. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_values. psi4.driver.compare_values(expected, computed, digits, label, exitonfail=True)[source]; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits < 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_values.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_vectors.html:364,Availability,failure,failure,364,". psi4.driver.compare_vectors. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_vectors. psi4.driver.compare_vectors(expected, computed, digits, label)[source]; Function to compare two vectors. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_vectors.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_vectors.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_vectors.html:571,Deployability,update,updated,571,". psi4.driver.compare_vectors. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_vectors. psi4.driver.compare_vectors(expected, computed, digits, label)[source]; Function to compare two vectors. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_vectors.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_vectors.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_vectors.html:459,Testability,test,test,459,". psi4.driver.compare_vectors. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.compare_vectors. psi4.driver.compare_vectors(expected, computed, digits, label)[source]; Function to compare two vectors. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.compare_vectors.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_vectors.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.convergenceerror.html:318,Availability,error,error,318,". psi4.driver.ConvergenceError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, maxit)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems with converging and iterative method. Prints; error message msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.convergenceerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.convergenceerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.convergenceerror.html:583,Deployability,update,updated,583,". psi4.driver.ConvergenceError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, maxit)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems with converging and iterative method. Prints; error message msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.convergenceerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.convergenceerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.convergenceerror.html:324,Integrability,message,message,324,". psi4.driver.ConvergenceError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, maxit)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems with converging and iterative method. Prints; error message msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.convergenceerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.convergenceerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.copy_file_from_scratch.html:1084,Deployability,update,updated,1084,". psi4.driver.copy_file_from_scratch. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.copy_file_from_scratch. psi4.driver.copy_file_from_scratch(filename, prefix, namespace, unit, move=False)[source]; Function to move file out of scratch with correct naming; convention.; Arguments:; @arg filename full path to target file; @arg prefix computation prefix, usually psi; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy); Example:; Assume PID is 12345 and SCRATCH is /scratch/parrish/. copy_file_to_scratch(temp, psi, h2o, 32):; -cp /scratch/parrish/psi.12345.h2o.32 .temp; copy_file_to_scratch(/tmp/temp, psi, h2o, 32):; -cp /scratch/parrish/psi.12345.h2o.32 /tmp/temp; copy_file_to_scratch(/tmp/temp, psi, , 32):; -cp /scratch/parrish/psi.12345.32 /tmp/temp; copy_file_to_scratch(/tmp/temp, psi, , 32, True):; -mv /scratch/parrish/psi.12345.32 /tmp/temp. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.copy_file_from_scratch.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.copy_file_from_scratch.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.copy_file_to_scratch.html:1070,Deployability,update,updated,1070,". psi4.driver.copy_file_to_scratch. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.copy_file_to_scratch. psi4.driver.copy_file_to_scratch(filename, prefix, namespace, unit, move=False)[source]; Function to move file into scratch with correct naming; convention.; Arguments:; @arg filename full path to file; @arg prefix computation prefix, usually psi; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy); Example:; Assume PID is 12345 and SCRATCH is /scratch/parrish/. copy_file_to_scratch(temp, psi, h2o, 32):; -cp ./temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch(/tmp/temp, psi, h2o, 32):; -cp /tmp/temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch(/tmp/temp, psi, , 32):; -cp /tmp/temp /scratch/parrish/psi.12345.32; copy_file_to_scratch(/tmp/temp, psi, , 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.copy_file_to_scratch.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.copy_file_to_scratch.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.create_plugin.html:338,Deployability,update,updated,338,". psi4.driver.create_plugin. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.create_plugin. psi4.driver.create_plugin(name, template)[source]; Generate plugin in directory with sanitized name based upon template. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.create_plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.create_plugin.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.create_plugin.html:177,Modifiability,plugin,plugin,177,". psi4.driver.create_plugin. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.create_plugin. psi4.driver.create_plugin(name, template)[source]; Generate plugin in directory with sanitized name based upon template. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.create_plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.create_plugin.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.create_plugin.html:202,Security,sanitiz,sanitized,202,". psi4.driver.create_plugin. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.create_plugin. psi4.driver.create_plugin(name, template)[source]; Generate plugin in directory with sanitized name based upon template. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.create_plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.create_plugin.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.csx2endict.html:246,Availability,avail,available,246,". psi4.driver.csx2endict. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.csx2endict. psi4.driver.csx2endict()[source]; Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.csx2endict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.csx2endict.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.csx2endict.html:406,Deployability,update,updated,406,". psi4.driver.csx2endict. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.csx2endict. psi4.driver.csx2endict()[source]; Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.csx2endict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.csx2endict.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.csx2endict.html:208,Modifiability,variab,variables,208,". psi4.driver.csx2endict. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.csx2endict. psi4.driver.csx2endict()[source]; Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.csx2endict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.csx2endict.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.csxerror.html:447,Deployability,update,updated,447,". psi4.driver.CSXError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.CSXError. exception psi4.driver.CSXError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when CSX generation fails. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.csxerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.csxerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cubeprop.html:875,Deployability,update,updated,875,". psi4.driver.cubeprop. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cubeprop. psi4.driver.cubeprop(wfn, **kwargs)[source]; Evaluate properties on a grid and generate cube files. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files. Examples:. 1; 2; 3>>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). 1; 2; 3; 4; 5; 6>>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cubeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cubeprop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cubeprop.html:444,Energy Efficiency,energy,energy,444,". psi4.driver.cubeprop. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cubeprop. psi4.driver.cubeprop(wfn, **kwargs)[source]; Evaluate properties on a grid and generate cube files. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files. Examples:. 1; 2; 3>>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). 1; 2; 3; 4; 5; 6>>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cubeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cubeprop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cubeprop.html:724,Energy Efficiency,energy,energy,724,". psi4.driver.cubeprop. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.cubeprop. psi4.driver.cubeprop(wfn, **kwargs)[source]; Evaluate properties on a grid and generate cube files. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files. Examples:. 1; 2; 3>>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). 1; 2; 3; 4; 5; 6>>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.cubeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cubeprop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.dftd3error.html:413,Deployability,update,updated,413,". psi4.driver.Dftd3Error. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.Dftd3Error. exception psi4.driver.Dftd3Error(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.dftd3error.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.dftd3error.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.dynamic_variable_bind.html:352,Deployability,update,updated,352,". psi4.driver.dynamic_variable_bind. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.dynamic_variable_bind. psi4.driver.dynamic_variable_bind(cls)[source]; Function to dynamically add extra members to; the core.Molecule class. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.dynamic_variable_bind.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.dynamic_variable_bind.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.empericaldispersion.html:628,Deployability,update,updated,628,". psi4.driver.EmpericalDispersion. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.EmpericalDispersion. class psi4.driver.EmpericalDispersion(alias, dtype, **kwargs)[source]; Bases: object; Methods Summary. compute_energy(molecule). compute_gradient(molecule). print_out([level]). Methods Documentation. compute_energy(molecule)[source]. compute_gradient(molecule)[source]. print_out(level=1)[source]. compute_energy(molecule)[source]. compute_gradient(molecule)[source]. print_out(level=1)[source]. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.empericaldispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.empericaldispersion.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:4528,Deployability,configurat,configuration,4528,"inear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. ccsd(at); CCSD with asymmetric perturbative triples (CCSD(AT)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramole",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:4828,Deployability,configurat,configuration,4828,"(CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. ccsd(at); CCSD with asymmetric perturbative triples (CCSD(AT)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispe",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14972,Deployability,update,updated,14972,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:15,Energy Efficiency,energy,energy,15,". psi4.driver.energy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string)  ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:93,Energy Efficiency,energy,energy,93,". psi4.driver.energy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string)  ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:114,Energy Efficiency,energy,energy,114,". psi4.driver.energy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string)  ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:195,Energy Efficiency,energy,energy,195,". psi4.driver.energy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string)  ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:236,Energy Efficiency,energy,energy,236,". psi4.driver.energy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string)  ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:286,Energy Efficiency,energy,energy,286,". psi4.driver.energy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string)  ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:326,Energy Efficiency,energy,energy,326,". psi4.driver.energy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string)  ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:888,Energy Efficiency,energy,energy,888,". psi4.driver.energy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string)  ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:5409,Energy Efficiency,adapt,adapted,5409,"nual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based disper",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:6482,Energy Efficiency,charge,charge,6482,"al exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. name; calls method DFT [manual]. b2plyp; B2PLYP Double Hybrid Exchange-Correlation Functional. b2plyp-d; . b2plyp-d3; . b2plyp-d3bj; . b2plyp-d3m; . b2plyp-d3mbj; . b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b3lyp-d3bj; . b3lyp-d3m; . b3lyp-d3mbj; . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:13405,Energy Efficiency,energy,energy,13405,"tq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:13650,Energy Efficiency,energy,energy,13650,"ve terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CC",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:13721,Energy Efficiency,energy,energy,13721,"ogram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation fo",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14063,Energy Efficiency,energy,energy,14063,"upled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14181,Energy Efficiency,energy,energy,14181,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14386,Energy Efficiency,energy,energy,14386,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14423,Energy Efficiency,energy,energy,14423,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14535,Energy Efficiency,energy,energy,14535,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14793,Energy Efficiency,energy,energy,14793,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:381,Modifiability,variab,variables,381,". psi4.driver.energy. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string)  ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theor",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:4528,Modifiability,config,configuration,4528,"inear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. ccsd(at); CCSD with asymmetric perturbative triples (CCSD(AT)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramole",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:4828,Modifiability,config,configuration,4828,"(CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. ccsd(at); CCSD with asymmetric perturbative triples (CCSD(AT)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispe",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:5409,Modifiability,adapt,adapted,5409,"nual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based disper",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:2034,Performance,optimiz,optimized,2034,"fective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. scs-omp2; spin-component scaled OMP2 [manual]. scs(n)-omp2; a special version of SCS-OMP2 for nucleobase interactions [manual]. scs-omp2-vdw; a special version of SCS-OMP2 (from ethene dimers) [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. sos-pi-omp2; A special version of SOS-OMP2 for pi systems [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. scs-omp3; spin-component scaled OMP3 [manual]. scs(n)-omp3; a special version of SCS-OMP3 for nucleobase interactions [manual]. scs-omp3-vdw; a special version of SCS-OMP3 (from ethene dimers) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. f",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:2421,Performance,optimiz,optimized,2421,"ion theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. scs-omp2; spin-component scaled OMP2 [manual]. scs(n)-omp2; a special version of SCS-OMP2 for nucleobase interactions [manual]. scs-omp2-vdw; a special version of SCS-OMP2 (from ethene dimers) [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. sos-pi-omp2; A special version of SOS-OMP2 for pi systems [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. scs-omp3; spin-component scaled OMP3 [manual]. scs(n)-omp3; a special version of SCS-OMP3 for nucleobase interactions [manual]. scs-omp3-vdw; a special version of SCS-OMP3 (from ethene dimers) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual]. fno-aqcc; AQCC with frozen natural orbitals [manu",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:2809,Performance,optimiz,optimized,2809,"P4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. scs-omp2; spin-component scaled OMP2 [manual]. scs(n)-omp2; a special version of SCS-OMP2 for nucleobase interactions [manual]. scs-omp2-vdw; a special version of SCS-OMP2 (from ethene dimers) [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. sos-pi-omp2; A special version of SOS-OMP2 for pi systems [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. scs-omp3; spin-component scaled OMP3 [manual]. scs(n)-omp3; a special version of SCS-OMP3 for nucleobase interactions [manual]. scs-omp3-vdw; a special version of SCS-OMP3 (from ethene dimers) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual]. fno-qcisd; QCISD with frozen natural orbitals [manual]. lccd; Linear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coup",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:3662,Performance,optimiz,optimized,3662,"s) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual]. fno-qcisd; QCISD with frozen natural orbitals [manual]. lccd; Linear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. ccsd(at); CCSD with asymmetric perturbative triples (CCSD(AT)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt;",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14488,Performance,perform,perform,14488,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14600,Performance,perform,perform,14600,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.extract_clusters.html:545,Deployability,update,updated,545,". psi4.driver.extract_clusters. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.extract_clusters. psi4.driver.extract_clusters(mol, ghost=True, cluster_size=0)[source]; Function to return all subclusters of the molecule mol of; real size cluster_size and all other atoms ghosted if ghost; equals true, all other atoms discarded if ghost is false. If; cluster_size = 0, returns all possible combinations of cluster size. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.extract_clusters.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.extract_clusters.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.extract_cluster_indexing.html:473,Deployability,update,updated,473,". psi4.driver.extract_cluster_indexing. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.extract_cluster_indexing. psi4.driver.extract_cluster_indexing(mol, cluster_size=0)[source]; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of cluster size. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.extract_cluster_indexing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.extract_cluster_indexing.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.fchk.html:656,Deployability,update,updated,656,". psi4.driver.fchk. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.fchk. psi4.driver.fchk(wfn, filename)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string)  destination file name for FCHK file; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate fchk file. Examples:. 1; 2; 3>>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.fchk.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.fchk.html:492,Energy Efficiency,energy,energy,492,". psi4.driver.fchk. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.fchk. psi4.driver.fchk(wfn, filename)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string)  destination file name for FCHK file; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate fchk file. Examples:. 1; 2; 3>>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.fchk.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.filter_comments.html:333,Deployability,update,updated,333,". psi4.driver.filter_comments. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.filter_comments. psi4.driver.filter_comments(string)[source]; Remove from string any Python-style comments (# to end of line). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.filter_comments.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.filter_comments.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.find_approximate_string_matches.html:406,Deployability,update,updated,406,". psi4.driver.find_approximate_string_matches. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.find_approximate_string_matches. psi4.driver.find_approximate_string_matches(seq1, options, max_distance)[source]; Function to compute approximate string matches from a list of options. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.find_approximate_string_matches.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.find_approximate_string_matches.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1870,Availability,avail,available,1870,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1931,Availability,avail,available,1931,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:2337,Availability,avail,available,2337,"' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created u",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:2445,Availability,avail,availability,2445,"ite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:2614,Availability,avail,available,2614,"ite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1295,Deployability,continuous,continuous,1295,"tional method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1502,Deployability,continuous,continuous,1502,"tional method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:3276,Deployability,update,updated,3276,"ite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:251,Energy Efficiency,energy,energy,251,". psi4.driver.freq. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:303,Energy Efficiency,energy,energy,303,". psi4.driver.freq. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:779,Energy Efficiency,energy,energy,779,". psi4.driver.freq. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:941,Energy Efficiency,energy,energy,941,". psi4.driver.freq. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1068,Energy Efficiency,energy,energy,1068,"4.driver.freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1830,Energy Efficiency,energy,energy,1830,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:996,Performance,perform,performed,996,". psi4.driver.freq. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1090,Performance,perform,performs,1090,"4.driver.freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1985,Performance,perform,performed,1985,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:845,Security,access,accessed,845,". psi4.driver.freq. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1044,Security,access,accesses,1044,"4.driver.freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1891,Availability,avail,available,1891,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1952,Availability,avail,available,1952,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:2358,Availability,avail,available,2358,"' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created u",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:2466,Availability,avail,availability,2466,"ite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:2635,Availability,avail,available,2635,"ite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1316,Deployability,continuous,continuous,1316,"tional method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1523,Deployability,continuous,continuous,1523,"tional method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:3297,Deployability,update,updated,3297,"ite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:272,Energy Efficiency,energy,energy,272,". psi4.driver.frequencies. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is t",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:324,Energy Efficiency,energy,energy,324,". psi4.driver.frequencies. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is t",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:800,Energy Efficiency,energy,energy,800,". psi4.driver.frequencies. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is t",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:962,Energy Efficiency,energy,energy,962,". psi4.driver.frequencies. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is t",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1089,Energy Efficiency,energy,energy,1089,"encies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1851,Energy Efficiency,energy,energy,1851,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1017,Performance,perform,performed,1017,". psi4.driver.frequencies. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is t",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1111,Performance,perform,performs,1111,"encies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:2006,Performance,perform,performed,2006,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:866,Security,access,accessed,866,". psi4.driver.frequencies. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is t",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1065,Security,access,accesses,1065,"encies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1893,Availability,avail,available,1893,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1954,Availability,avail,available,1954,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:2360,Availability,avail,available,2360,"' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created u",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:2468,Availability,avail,availability,2468,"ite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:2637,Availability,avail,available,2637,"ite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1318,Deployability,continuous,continuous,1318,"tional method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1525,Deployability,continuous,continuous,1525,"tional method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:3299,Deployability,update,updated,3299,"ite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). 1; 2; 3; 4; 5>>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:274,Energy Efficiency,energy,energy,274,". psi4.driver.frequency. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:326,Energy Efficiency,energy,energy,326,". psi4.driver.frequency. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:802,Energy Efficiency,energy,energy,802,". psi4.driver.frequency. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:964,Energy Efficiency,energy,energy,964,". psi4.driver.frequency. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1091,Energy Efficiency,energy,energy,1091,". psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1853,Energy Efficiency,energy,energy,1853,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1019,Performance,perform,performed,1019,". psi4.driver.frequency. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1113,Performance,perform,performs,1113,". psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:2008,Performance,perform,performed,2008,"nction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:868,Security,access,accessed,868,". psi4.driver.frequency. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1067,Security,access,accesses,1067,". psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float  Total electronic energy in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.gdma.html:921,Deployability,update,updated,921,". psi4.driver.gdma. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.gdma. psi4.driver.gdma(wfn, datafile='')[source]; Function to use wavefunction information in wfn and, if specified,; additional commands in filename to run GDMA analysis. New in version 0.6. Returns:None. Parameters:; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate DMA analysis; datafile (string)  optional control file (see GDMA manual) to peform more complicated DMA; analyses. If this option is used, the File keyword must be set to read; a filename.fchk, where filename is provided by WRITER_FILE_LABEL . Examples:. 1; 2; 3>>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.gdma.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.gdma.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.geometry.html:474,Deployability,update,updated,474,". psi4.driver.geometry. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.geometry. psi4.driver.geometry(geom, name='default')[source]; Function to create a molecule object of name name from the; geometry in string geom. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.geometry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.geometry.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.getfromdict.html:265,Deployability,update,updated,265,". psi4.driver.getFromDict. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.getFromDict. psi4.driver.getFromDict(dataDict, mapList)[source]. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.getfromdict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.getfromdict.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.get_memory.html:293,Deployability,update,updated,293,". psi4.driver.get_memory. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.get_memory. psi4.driver.get_memory()[source]; Function to return the total memory allocation. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.get_memory.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.gradient.html:787,Deployability,update,updated,787,". psi4.driver.gradient. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.gradient. psi4.driver.gradient(name, **kwargs)[source]; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix  Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction)  gradient and wavefunction when return_wfn specified. Examples:. 1; 2; 3; 4; 5; 6>>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.gradient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.gradient.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.gradient.html:196,Performance,optimiz,optimize,196,". psi4.driver.gradient. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.gradient. psi4.driver.gradient(name, **kwargs)[source]; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix  Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction)  gradient and wavefunction when return_wfn specified. Examples:. 1; 2; 3; 4; 5; 6>>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.gradient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.gradient.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.hessian.html:921,Deployability,update,updated,921,". psi4.driver.hessian. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.hessian. psi4.driver.hessian(name, **kwargs)[source]; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns:Matrix  Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns:(Matrix, Wavefunction)  Hessian and wavefunction when return_wfn specified. Examples:. 1; 2>>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). 1; 2; 3; 4; 5; 6>>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.hessian.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.hessian.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.join_path.html:255,Deployability,update,updated,255,". psi4.driver.join_path. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.join_path. psi4.driver.join_path(prefix, *args)[source]. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.join_path.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.join_path.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.levenshtein.html:324,Deployability,update,updated,324,". psi4.driver.levenshtein. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.levenshtein. psi4.driver.levenshtein(seq1, seq2)[source]; Function to compute the Levenshtein distance between two strings. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.levenshtein.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.levenshtein.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.managedmethoderror.html:439,Deployability,update,updated,439,". psi4.driver.ManagedMethodError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ManagedMethodError. exception psi4.driver.ManagedMethodError(circs)[source]; Bases: psi4.driver.p4util.exceptions.PsiException. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.managedmethoderror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.managedmethoderror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html:2079,Deployability,update,updated,2079,"e, density_b=None, dovirtual=None)[source]; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files; filename (string)  destination file name for MOLDEN file (optional); density_a (Matrix)  density in the MO basis to build alpha NOs from (optional); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). 1; 2; 3>>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 1; 2; 3; 4; 5>>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html:452,Energy Efficiency,energy,energy,452,". psi4.driver.molden. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.molden. psi4.driver.molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None)[source]; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files; filename (string)  destination file name for MOLDEN file (optional); density_a (Matrix)  density in the MO basis to build alpha NOs from (optional); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). 1; 2; 3>>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 1; 2; 3; 4; 5>>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Navigation. Index. mod",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html:1260,Energy Efficiency,energy,energy,1260,"e, density_b=None, dovirtual=None)[source]; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files; filename (string)  destination file name for MOLDEN file (optional); density_a (Matrix)  density in the MO basis to build alpha NOs from (optional); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). 1; 2; 3>>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 1; 2; 3; 4; 5>>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html:1411,Energy Efficiency,energy,energy,1411,"e, density_b=None, dovirtual=None)[source]; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files; filename (string)  destination file name for MOLDEN file (optional); density_a (Matrix)  density in the MO basis to build alpha NOs from (optional); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). 1; 2; 3>>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 1; 2; 3; 4; 5>>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html:1592,Energy Efficiency,energy,energy,1592,"e, density_b=None, dovirtual=None)[source]; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files; filename (string)  destination file name for MOLDEN file (optional); density_a (Matrix)  density in the MO basis to build alpha NOs from (optional); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). 1; 2; 3>>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 1; 2; 3; 4; 5>>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molecule_get_attr.html:335,Deployability,update,updated,335,". psi4.driver.molecule_get_attr. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.molecule_get_attr. psi4.driver.molecule_get_attr(self, name)[source]; Function to redefine __getattr__ method of molecule class. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.molecule_get_attr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molecule_get_attr.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molecule_set_attr.html:342,Deployability,update,updated,342,". psi4.driver.molecule_set_attr. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.molecule_set_attr. psi4.driver.molecule_set_attr(self, name, value)[source]; Function to redefine __setattr__ method of molecule class. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.molecule_set_attr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.molecule_set_attr.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.oeprop.html:689,Deployability,update,updated,689,". psi4.driver.oeprop. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.oeprop. psi4.driver.oeprop(wfn, *args, **kwargs)[source]; Evaluate one-electron properties. Returns:None. Parameters:wfn (Wavefunction)  set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters:title (string)  label prepended to all psivars computed. Examples:. 1; 2; 3>>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.oeprop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.oeprop.html:499,Energy Efficiency,energy,energy,499,". psi4.driver.oeprop. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.oeprop. psi4.driver.oeprop(wfn, *args, **kwargs)[source]; Evaluate one-electron properties. Returns:None. Parameters:wfn (Wavefunction)  set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters:title (string)  label prepended to all psivars computed. Examples:. 1; 2; 3>>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.oeprop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1911,Availability,avail,available,1911,"tion result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2335,Availability,avail,available,2335,"d of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1386,Deployability,continuous,continuous,1386,"scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1586,Deployability,continuous,continuous,1586,"scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7951,Deployability,update,updated,7951,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:223,Energy Efficiency,energy,energy,223,". psi4.driver.opt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:298,Energy Efficiency,energy,energy,298,". psi4.driver.opt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:679,Energy Efficiency,energy,energy,679,". psi4.driver.opt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:952,Energy Efficiency,energy,energy,952,". psi4.driver.opt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1033,Energy Efficiency,energy,energy,1033,"ules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1160,Energy Efficiency,energy,energy,1160," Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1871,Energy Efficiency,energy,energy,1871,"tion result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2422,Energy Efficiency,energy,energy,2422,"| 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybr",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7405,Energy Efficiency,energy,energy,7405,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:457,Modifiability,variab,variables,457,". psi4.driver.opt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:142,Performance,perform,perform,142,". psi4.driver.opt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:161,Performance,optimiz,optimization,161,". psi4.driver.opt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:233,Performance,optimiz,optimized,233,". psi4.driver.opt. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1088,Performance,perform,performed,1088,"ules  .  . ; 1.1; . PSI4. psi4.driver.opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1182,Performance,perform,performs,1182," Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1469,Performance,optimiz,optimization,1469,"scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1545,Performance,optimiz,optimization,1545,"scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1944,Performance,optimiz,optimization,1944,"tion result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1966,Performance,perform,performed,1966,"tion result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2074,Performance,perform,perform,2074,"n to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2124,Performance,optimiz,optimization,2124,"n to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2501,Performance,optimiz,optimizations,2501,"; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2896,Performance,optimiz,optimized,2896,able) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b3lyp-d3bj; . b3lyp-d3m; . b3lyp-d3mbj; . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2966,Performance,optimiz,optimized,2966,with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b3lyp-d3bj; . b3lyp-d3m; . b3lyp-d3mbj; . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; . b97-d3; . b97-d3bj; . b97-d3m; . b97-d3mbj; . blyp; BLYP GGA ,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:3037,Performance,optimiz,optimized,3037, computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b3lyp-d3bj; . b3lyp-d3m; . b3lyp-d3mbj; . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; . b97-d3; . b97-d3bj; . b97-d3m; . b97-d3mbj; . blyp; BLYP GGA Exchange-Correlation Functional. blyp-d; . blyp-d3; ,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:3115,Performance,optimiz,optimized,3115,etry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b3lyp-d3bj; . b3lyp-d3m; . b3lyp-d3mbj; . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; . b97-d3; . b97-d3bj; . b97-d3m; . b97-d3mbj; . blyp; BLYP GGA Exchange-Correlation Functional. blyp-d; . blyp-d3; . blyp-d3bj; . blyp-d3m; . blyp-d3mbj; . bp86; BP86 GGA Exchange-Correlation,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7063,Performance,optimiz,optimization,7063,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7081,Performance,optimiz,optimize,7081,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7139,Performance,optimiz,optimization,7139,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7317,Performance,optimiz,optimization,7317,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7381,Performance,optimiz,optimize,7381,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7459,Performance,perform,perform,7459,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7506,Performance,optimiz,optimize,7506,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7577,Performance,perform,perform,7577,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7770,Performance,optimiz,optimize,7770,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1136,Security,access,accesses,1136," Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2105,Usability,guid,guide,2105,"n to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1934,Availability,avail,available,1934,"tion result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:2358,Availability,avail,available,2358,"d of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1409,Deployability,continuous,continuous,1409,"scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1609,Deployability,continuous,continuous,1609,"scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7974,Deployability,update,updated,7974,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:246,Energy Efficiency,energy,energy,246,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:321,Energy Efficiency,energy,energy,321,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:702,Energy Efficiency,energy,energy,702,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:975,Energy Efficiency,energy,energy,975,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1056,Energy Efficiency,energy,energy,1056,"; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1183,Energy Efficiency,energy,energy,1183," Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1894,Energy Efficiency,energy,energy,1894,"tion result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:2445,Energy Efficiency,energy,energy,2445,"| 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybr",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7428,Energy Efficiency,energy,energy,7428,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:480,Modifiability,variab,variables,480,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:15,Performance,optimiz,optimize,15,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:95,Performance,optimiz,optimize,95,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:118,Performance,optimiz,optimize,118,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:165,Performance,perform,perform,165,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:184,Performance,optimiz,optimization,184,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:256,Performance,optimiz,optimized,256,". psi4.driver.optimize. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. h",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1111,Performance,perform,performed,1111,"; 1.1; . PSI4. psi4.driver.optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1205,Performance,perform,performs,1205," Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1492,Performance,optimiz,optimization,1492,"scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1568,Performance,optimiz,optimization,1568,"scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1967,Performance,optimiz,optimization,1967,"tion result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1989,Performance,perform,performed,1989,"tion result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:2097,Performance,perform,perform,2097,"n to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:2147,Performance,optimiz,optimization,2147,"n to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:2524,Performance,optimiz,optimizations,2524,"; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:2919,Performance,optimiz,optimized,2919,able) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b3lyp-d3bj; . b3lyp-d3m; . b3lyp-d3mbj; . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:2989,Performance,optimiz,optimized,2989,with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b3lyp-d3bj; . b3lyp-d3m; . b3lyp-d3mbj; . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; . b97-d3; . b97-d3bj; . b97-d3m; . b97-d3mbj; . blyp; BLYP GGA ,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:3060,Performance,optimiz,optimized,3060, computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b3lyp-d3bj; . b3lyp-d3m; . b3lyp-d3mbj; . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; . b97-d3; . b97-d3bj; . b97-d3m; . b97-d3mbj; . blyp; BLYP GGA Exchange-Correlation Functional. blyp-d; . blyp-d3; ,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:3138,Performance,optimiz,optimized,3138,etry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d; . b3lyp-d3; . b3lyp-d3bj; . b3lyp-d3m; . b3lyp-d3mbj; . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; . b97-d3; . b97-d3bj; . b97-d3m; . b97-d3mbj; . blyp; BLYP GGA Exchange-Correlation Functional. blyp-d; . blyp-d3; . blyp-d3bj; . blyp-d3m; . blyp-d3mbj; . bp86; BP86 GGA Exchange-Correlation,MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7086,Performance,optimiz,optimization,7086,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7104,Performance,optimiz,optimize,7104,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7162,Performance,optimiz,optimization,7162,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7340,Performance,optimiz,optimization,7340,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7404,Performance,optimiz,optimize,7404,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7482,Performance,perform,perform,7482,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7529,Performance,optimiz,optimize,7529,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7600,Performance,perform,perform,7600,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:7793,Performance,optimiz,optimize,7793,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1159,Security,access,accesses,1159," Aliases:opt(). Returns:float  Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:2128,Usability,guid,guide,2128,"n to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string)  \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.parsingerror.html:269,Availability,error,error,269,". psi4.driver.ParsingError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ParsingError. exception psi4.driver.ParsingError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems parsing a text file. Prints error message; msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.parsingerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.parsingerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.parsingerror.html:535,Deployability,update,updated,535,". psi4.driver.ParsingError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ParsingError. exception psi4.driver.ParsingError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems parsing a text file. Prints error message; msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.parsingerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.parsingerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.parsingerror.html:275,Integrability,message,message,275,". psi4.driver.ParsingError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ParsingError. exception psi4.driver.ParsingError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems parsing a text file. Prints error message; msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.parsingerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.parsingerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:458,Availability,reliab,reliable,458,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:467,Deployability,install,install,467,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:558,Deployability,install,install,558,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:614,Deployability,install,installation,614,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:885,Deployability,install,install,885,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:905,Deployability,install,install,905,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:942,Deployability,install,install,942,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:950,Deployability,install,install,950,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:1028,Deployability,install,install,1028,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:1107,Deployability,install,install,1107,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:1588,Deployability,update,updated,1588,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html:970,Safety,detect,detected,970,". psi4.driver.PastureRequiredError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PastureRequiredError. exception psi4.driver.PastureRequiredError(option)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when the specified value of option requires some; module(s) from Psi4Pasture, but could not be imported. args. install_instructions = ""\n Note: Psi4Pasture is currently in an experimental state with no reliable install\n procedure yet, but this is what it would look like.\n\n To Build Psi4Pasture and install the required modules within your current\n Psi4 installation\n\n >>> # clone the pasture repo\n >>> git clone https://github.com/psi4/psi4pasture.git\n\n >>> cmake -H. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}\n >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4\n >>> # install you want to install pasture to\n\n >>> # build + install install location is detected automatically\n >>> cd objdir\n >>> make && make install\n\n See https://github.com/psi4/psi4pasture for more details\n\n Or to install using psi4's own build system add\n {module_args}\n to cmake command line when building psi4.\n "". msg_tmpl = 'Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}\n\n '. pasture_required_modules = {'RUN_CCTRANSORT': ['ccsort', 'transqt2']}. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pasturerequirederror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pcm_helper.html:301,Deployability,update,updated,301,". psi4.driver.pcm_helper. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.pcm_helper. psi4.driver.pcm_helper(block)[source]; Passes multiline string block to PCMSolver parser. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.pcm_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.pcm_helper.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.print_stderr.html:192,Availability,error,error,192,". psi4.driver.print_stderr. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.print_stderr. psi4.driver.print_stderr(stuff)[source]; Function to print stuff to standard error stream. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.print_stderr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.print_stderr.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.print_stderr.html:306,Deployability,update,updated,306,". psi4.driver.print_stderr. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.print_stderr. psi4.driver.print_stderr(stuff)[source]; Function to print stuff to standard error stream. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.print_stderr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.print_stderr.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.print_stdout.html:307,Deployability,update,updated,307,". psi4.driver.print_stdout. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.print_stdout. psi4.driver.print_stdout(stuff)[source]; Function to print stuff to standard output stream. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.print_stdout.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.print_stdout.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.process_input.html:823,Deployability,update,updated,823,". psi4.driver.process_input. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.process_input. psi4.driver.process_input(raw_input, print_level=1)[source]; Function to preprocess raw input, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; raw_input is printed to the output file unless print_level =0. Does; a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the users .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.process_input.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.process_input.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.process_input.html:256,Security,validat,validate,256,". psi4.driver.process_input. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.process_input. psi4.driver.process_input(raw_input, print_level=1)[source]; Function to preprocess raw input, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; raw_input is printed to the output file unless print_level =0. Does; a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the users .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.process_input.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.process_input.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.process_pubchem_command.html:348,Deployability,update,updated,348,". psi4.driver.process_pubchem_command. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.process_pubchem_command. psi4.driver.process_pubchem_command(matchobj)[source]; Function to process match of pubchem in molecule block. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.process_pubchem_command.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.process_pubchem_command.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.prop.html:1217,Deployability,configurat,configurational,1217,"ex. modules  .  . ; 1.1; . PSI4. psi4.driver.prop. psi4.driver.prop(name, **kwargs); Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, ..., fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string)  'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings)  \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.prop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.prop.html:1961,Deployability,update,updated,1961,"ex. modules  .  . ; 1.1; . PSI4. psi4.driver.prop. psi4.driver.prop(name, **kwargs); Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, ..., fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string)  'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings)  \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.prop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.prop.html:1217,Modifiability,config,configurational,1217,"ex. modules  .  . ; 1.1; . PSI4. psi4.driver.prop. psi4.driver.prop(name, **kwargs); Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, ..., fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string)  'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings)  \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.prop.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.property.html:1237,Deployability,configurat,configurational,1237,"  . ; 1.1; . PSI4. psi4.driver.property. psi4.driver.property(name, **kwargs)[source]; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, ..., fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string)  'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings)  \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.property.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.property.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.property.html:1981,Deployability,update,updated,1981,"  . ; 1.1; . PSI4. psi4.driver.property. psi4.driver.property(name, **kwargs)[source]; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, ..., fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string)  'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings)  \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.property.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.property.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.property.html:1237,Modifiability,config,configurational,1237,"  . ; 1.1; . PSI4. psi4.driver.property. psi4.driver.property(name, **kwargs)[source]; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, ..., fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string)  'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings)  \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.property.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.property.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiexception.html:402,Deployability,update,updated,402,". psi4.driver.PsiException. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PsiException. exception psi4.driver.PsiException[source]; Bases: Exception; Error class for Psi. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.psiexception.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiexception.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiimporterror.html:282,Availability,error,error,282,". psi4.driver.PsiImportError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PsiImportError. exception psi4.driver.PsiImportError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems import python dependencies. Prints error message; msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.psiimporterror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiimporterror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiimporterror.html:548,Deployability,update,updated,548,". psi4.driver.PsiImportError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PsiImportError. exception psi4.driver.PsiImportError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems import python dependencies. Prints error message; msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.psiimporterror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiimporterror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiimporterror.html:261,Integrability,depend,dependencies,261,". psi4.driver.PsiImportError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PsiImportError. exception psi4.driver.PsiImportError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems import python dependencies. Prints error message; msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.psiimporterror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiimporterror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiimporterror.html:288,Integrability,message,message,288,". psi4.driver.PsiImportError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.PsiImportError. exception psi4.driver.PsiImportError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems import python dependencies. Prints error message; msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.psiimporterror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.psiimporterror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:1536,Deployability,update,updated,1536,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:218,Energy Efficiency,charge,charge,218,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:324,Energy Efficiency,charge,charge,324,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:421,Energy Efficiency,charge,charge,421,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:482,Energy Efficiency,charge,charge,482,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:546,Energy Efficiency,charge,charges,546,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:642,Energy Efficiency,charge,charge,642,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:758,Energy Efficiency,charge,charge,758,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:865,Energy Efficiency,charge,charge,865,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:935,Energy Efficiency,charge,charge,935,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:1000,Energy Efficiency,charge,charges,1000,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:1072,Energy Efficiency,charge,charge,1072,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:1187,Energy Efficiency,charge,charge,1187,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:1293,Energy Efficiency,charge,charge,1293,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:1362,Energy Efficiency,charge,charge,1362,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html:1427,Energy Efficiency,charge,charges,1427,". psi4.driver.QMMM. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.QMMM. class psi4.driver.QMMM[source]; Bases: object; Methods Summary. addChargeAngstrom(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Angstroms. addChargeBohr(Q,x,y,z); Function to add a point charge of magnitude Q at position (x, y, z) Bohr. addDiffuse(diffuse); Function to add a diffuse charge field diffuse. populateExtern(); Function to define a charge field external to the molecule through point and diffuse charges. Methods Documentation. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. addChargeAngstrom(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]; Function to add a diffuse charge field diffuse. populateExtern()[source]; Function to define a charge field external to the; molecule through point and diffuse charges. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.qmmm.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.sanitize_name.html:494,Deployability,update,updated,494,". psi4.driver.sanitize_name. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.sanitize_name. psi4.driver.sanitize_name(name)[source]; Function to return name in coded form, stripped of; characters that confuse filenames, characters into lowercase,; + into p, * into s, and (, ), -,; & , into _.; Also checks the sanitized name against a list of restricted C++ keywords. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.sanitize_name.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.sanitize_name.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.sanitize_name.html:336,Security,sanitiz,sanitized,336,". psi4.driver.sanitize_name. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.sanitize_name. psi4.driver.sanitize_name(name)[source]; Function to return name in coded form, stripped of; characters that confuse filenames, characters into lowercase,; + into p, * into s, and (, ), -,; & , into _.; Also checks the sanitized name against a list of restricted C++ keywords. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.sanitize_name.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.sanitize_name.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.scf_helper.html:464,Deployability,update,updated,464,". psi4.driver.scf_helper. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.scf_helper. psi4.driver.scf_helper(name, **kwargs)[source]; Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.scf_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.scf_helper.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.scf_wavefunction_factory.html:385,Deployability,update,updated,385,". psi4.driver.scf_wavefunction_factory. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.scf_wavefunction_factory. psi4.driver.scf_wavefunction_factory(reference, ref_wfn, functional=None)[source]; Builds the correct wavefunction from the provided information. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.scf_wavefunction_factory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.scf_wavefunction_factory.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.set_memory.html:1397,Deployability,update,updated,1397,". psi4.driver.set_memory. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.set_memory. psi4.driver.set_memory(inputval, execute=True)[source]; Function to reset the total memory allocation. Takes memory value; inputval as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing value (e.g., 30 mb); which is case-insensitive. Set execute to False to interpret inputval; without setting in Psi4 core. Returns:memory_amount (float) Number of bytes of memory set. Raises:ValidationError when <500MiB or disallowed type or misformatted. Examples:. 1; 2; 3; 4>>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. 1; 2; 3; 4>>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. Good examples:. 800000000 # 800000000; 2004088624.9 # 2004088624; 1.0e9 # 1000000000; 600 mb # 600000000; 600.0 MiB # 629145600; .6 Gb # 600000000;  100000000kB  # 100000000000; 2 eb # 2000000000000000000. Bad examples:. {} # odd type;  # no info; 8 dimms # unacceptable units; 1e5 gb # string w/ exponent; 5e5 # string w/o units; 2000 # mem too small; -5e5 # negative (and too small). Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.set_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.set_memory.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.set_module_options.html:364,Deployability,update,updated,364,". psi4.driver.set_module_options. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.set_module_options. psi4.driver.set_module_options(module, options_dict)[source]; Sets Psi4 module options from a module specification and input dictionary. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.set_module_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.set_module_options.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.set_options.html:311,Deployability,update,updated,311,". psi4.driver.set_options. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.set_options. psi4.driver.set_options(options_dict)[source]; Sets Psi4 global options from an input dictionary. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.set_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.set_options.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.success.html:353,Deployability,update,updated,353,". psi4.driver.success. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.success. psi4.driver.success(label)[source]; Function to print a label...PASSED line to screen.; Used by util.compare_values() family when functions pass. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.success.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.success.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.table.html:2099,Deployability,update,updated,2099,", cols=(), width=16, precision=10)[source]; Bases: object; Class defining a flexible Table object for storing data.; Methods Summary. absolute_to_relative([Factor]); Function to shift the data of each column of the Table object such that the lowest value is zero. copy(); Function to return a copy of the Table object. format_label(); Function to pad the width of Table object labels. format_values(values); Function to pad the width of Table object data cells. save(file); Function to save string of the Table object to file. scale([Factor]); Function to apply a scaling factor Factor to the data of the Table object. Methods Documentation. absolute_to_relative(Factor=627.5095)[source]; Function to shift the data of each column of the Table object; such that the lowest value is zero. A scaling factor of Factor is applied. copy()[source]; Function to return a copy of the Table object. format_label()[source]; Function to pad the width of Table object labels. format_values(values)[source]; Function to pad the width of Table object data cells. save(file)[source]; Function to save string of the Table object to file. scale(Factor=627.5095)[source]; Function to apply a scaling factor Factor to the; data of the Table object. absolute_to_relative(Factor=627.5095)[source]; Function to shift the data of each column of the Table object; such that the lowest value is zero. A scaling factor of Factor is applied. copy()[source]; Function to return a copy of the Table object. format_label()[source]; Function to pad the width of Table object labels. format_values(values)[source]; Function to pad the width of Table object data cells. save(file)[source]; Function to save string of the Table object to file. scale(Factor=627.5095)[source]; Function to apply a scaling factor Factor to the; data of the Table object. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.table.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.table.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.table.html:251,Modifiability,flexible,flexible,251,". psi4.driver.Table. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.Table. class psi4.driver.Table(rows=(), row_label_width=10, row_label_precision=4, cols=(), width=16, precision=10)[source]; Bases: object; Class defining a flexible Table object for storing data.; Methods Summary. absolute_to_relative([Factor]); Function to shift the data of each column of the Table object such that the lowest value is zero. copy(); Function to return a copy of the Table object. format_label(); Function to pad the width of Table object labels. format_values(values); Function to pad the width of Table object data cells. save(file); Function to save string of the Table object to file. scale([Factor]); Function to apply a scaling factor Factor to the data of the Table object. Methods Documentation. absolute_to_relative(Factor=627.5095)[source]; Function to shift the data of each column of the Table object; such that the lowest value is zero. A scaling factor of Factor is applied. copy()[source]; Function to return a copy of the Table object. format_label()[source]; Function to pad the width of Table object labels. format_values(values)[source]; Function to pad the width of Table object data cells. save(file)[source]; Function to save string of the Table object to file. scale(Factor=627.5095)[source]; Function to apply a scaling factor Factor to the; data of the Table object. absolute_to_relative(Factor=627.5095)[source]; Function to shift the data of each column of the Table object; such that the lowest value is zero. A scaling factor of Factor is applied. copy()[source]; Function to return a copy of the Table object. format_label()[source]; Function to pad the width of Table object labels. format_values(values)[source]; Function to pad the width of Table object data cells. save(file)[source]; Function to save string of the Table object to file. scale(Factor=627.5095)[source]; Function to apply a scaling factor Factor to the; data of the Table object. Na",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.table.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.table.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html:319,Availability,error,error,319,". psi4.driver.TestComparisonError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.TestComparisonError. exception psi4.driver.TestComparisonError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html:585,Deployability,update,updated,585,". psi4.driver.TestComparisonError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.TestComparisonError. exception psi4.driver.TestComparisonError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html:325,Integrability,message,message,325,". psi4.driver.TestComparisonError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.TestComparisonError. exception psi4.driver.TestComparisonError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html:256,Testability,test,test,256,". psi4.driver.TestComparisonError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.TestComparisonError. exception psi4.driver.TestComparisonError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.validationerror.html:279,Availability,error,error,279,". psi4.driver.ValidationError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ValidationError. exception psi4.driver.ValidationError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems with the input file. Prints; error message msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.validationerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.validationerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.validationerror.html:544,Deployability,update,updated,544,". psi4.driver.ValidationError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ValidationError. exception psi4.driver.ValidationError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems with the input file. Prints; error message msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.validationerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.validationerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.validationerror.html:285,Integrability,message,message,285,". psi4.driver.ValidationError. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.ValidationError. exception psi4.driver.ValidationError(msg)[source]; Bases: psi4.driver.p4util.exceptions.PsiException; Error called for problems with the input file. Prints; error message msg to standard output stream and output file. args. with_traceback(); Exception.with_traceback(tb) ; set self.__traceback__ to tb and return self. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.validationerror.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.validationerror.html
https://psicode.org/psi4manual/1.1.0/api/psi4.driver.xml2dict.html:336,Deployability,update,updated,336,". psi4.driver.xml2dict. Navigation. Index. modules  .  . ; 1.1; . PSI4. psi4.driver.xml2dict. psi4.driver.xml2dict(filename=None)[source]; Read XML filename into nested OrderedDict-s. filename defaults to; active CSX file. Navigation. Index. modules  .  . ; 1.1; . PSI4.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/api/psi4.driver.xml2dict.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.xml2dict.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel-1.html:354,Deployability,update,updated,354,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel-1.html:139,Performance,cache,cache,139,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel.html:354,Deployability,update,updated,354,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel.html:139,Performance,cache,cache,139,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__memory-1.html:149,Availability,avail,available,149,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__memory-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__memory-1.html:345,Deployability,update,updated,345,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__memory-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__memory.html:149,Availability,avail,available,149,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__memory.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__memory.html:345,Deployability,update,updated,345,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__memory.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__newton_convergence-1.html:372,Deployability,update,updated,372,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. NEWTON_CONVERGENCE. The convergence criterion for pole searching step. Type: conv double; Default: 1e-7. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__newton_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__newton_convergence-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__newton_convergence.html:372,Deployability,update,updated,372,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. NEWTON_CONVERGENCE. The convergence criterion for pole searching step. Type: conv double; Default: 1e-7. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__newton_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__newton_convergence.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__norm_tolerance-1.html:365,Deployability,update,updated,365,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. NORM_TOLERANCE. The cutoff norm of residual vector in SEM step. Type: conv double; Default: 1e-6. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__norm_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__norm_tolerance-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__norm_tolerance.html:365,Deployability,update,updated,365,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. NORM_TOLERANCE. The cutoff norm of residual vector in SEM step. Type: conv double; Default: 1e-6. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__norm_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__norm_tolerance.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__num_amps_print-1.html:365,Deployability,update,updated,365,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. NUM_AMPS_PRINT. Number of components of transition amplitudes printed. Type: integer; Default: 5. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__num_amps_print-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__num_amps_print.html:365,Deployability,update,updated,365,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. NUM_AMPS_PRINT. Number of components of transition amplitudes printed. Type: integer; Default: 5. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__num_amps_print.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__pole_maxiter-1.html:353,Deployability,update,updated,353,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. POLE_MAXITER. Maximum iteration number in pole searching. Type: integer; Default: 20. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__pole_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__pole_maxiter-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__pole_maxiter.html:353,Deployability,update,updated,353,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. POLE_MAXITER. Maximum iteration number in pole searching. Type: integer; Default: 20. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__pole_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__pole_maxiter.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__pr-1.html:380,Deployability,update,updated,380,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. PR. Do use the partial renormalization scheme for the ground state wavefunction?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__pr-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__pr-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__pr.html:380,Deployability,update,updated,380,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. PR. Do use the partial renormalization scheme for the ground state wavefunction?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__pr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__pr.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__reference-1.html:357,Deployability,update,updated,357,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__reference-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__reference.html:357,Deployability,update,updated,357,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__reference.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__roots_per_irrep-1.html:346,Deployability,update,updated,346,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. ROOTS_PER_IRREP. The poles per irrep vector. Type: array; Default: No Default. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__roots_per_irrep-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__roots_per_irrep.html:346,Deployability,update,updated,346,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. ROOTS_PER_IRREP. The poles per irrep vector. Type: array; Default: No Default. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__roots_per_irrep.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__sem_maxiter-1.html:367,Deployability,update,updated,367,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. SEM_MAXITER. Maximum iteration number in simultaneous expansion method. Type: integer; Default: 30. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__sem_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__sem_maxiter-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__sem_maxiter.html:367,Deployability,update,updated,367,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC. SEM_MAXITER. Maximum iteration number in simultaneous expansion method. Type: integer; Default: 30. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; ADC.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/adc__sem_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__sem_maxiter.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ael-1.html:407,Deployability,update,updated,407,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. AEL. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__ael-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ael-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ael.html:407,Deployability,update,updated,407,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. AEL. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__ael.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ael.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ao_basis-1.html:429,Deployability,update,updated,429,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. AO_BASIS. The algorithm to use for the \(\left\langle VV||VV\right \rangle\) terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ao_basis-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ao_basis.html:429,Deployability,update,updated,429,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. AO_BASIS. The algorithm to use for the \(\left\langle VV||VV\right \rangle\) terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ao_basis.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel-1.html:360,Deployability,update,updated,360,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. CACHELEVEL. The amount of caching of data to perform. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel-1.html:171,Performance,perform,perform,171,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. CACHELEVEL. The amount of caching of data to perform. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel.html:360,Deployability,update,updated,360,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. CACHELEVEL. The amount of caching of data to perform. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel.html:171,Performance,perform,perform,171,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. CACHELEVEL. The amount of caching of data to perform. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__gauge-1.html:358,Deployability,update,updated,358,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__gauge-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__gauge-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__gauge.html:358,Deployability,update,updated,358,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__gauge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__gauge.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ints_tolerance-1.html:390,Deployability,update,updated,390,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__ints_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ints_tolerance-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ints_tolerance.html:390,Deployability,update,updated,390,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__ints_tolerance.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm-1.html:359,Deployability,update,updated,359,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ONEPDM. Do compute one-particle density matrix?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm.html:359,Deployability,update,updated,359,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ONEPDM. Do compute one-particle density matrix?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_cutoff-1.html:405,Deployability,update,updated,405,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ONEPDM_GRID_CUTOFF. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_cutoff-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_cutoff.html:405,Deployability,update,updated,405,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ONEPDM_GRID_CUTOFF. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_cutoff.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_dump-1.html:389,Deployability,update,updated,389,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ONEPDM_GRID_DUMP. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_dump-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_dump-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_dump.html:389,Deployability,update,updated,389,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ONEPDM_GRID_DUMP. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_dump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_dump.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_stepsize-1.html:400,Deployability,update,updated,400,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ONEPDM_GRID_STEPSIZE. Step size (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_stepsize-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_stepsize-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_stepsize.html:400,Deployability,update,updated,400,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ONEPDM_GRID_STEPSIZE. Step size (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_stepsize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__onepdm_grid_stepsize.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__opdm_relax-1.html:365,Deployability,update,updated,365,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. OPDM_RELAX. Do relax the one-particle density matrix?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__opdm_relax-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__opdm_relax-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__opdm_relax.html:365,Deployability,update,updated,365,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. OPDM_RELAX. Do relax the one-particle density matrix?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__opdm_relax.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__opdm_relax.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_all-1.html:374,Deployability,update,updated,374,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. PROP_ALL. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__prop_all-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_all-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_all.html:374,Deployability,update,updated,374,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. PROP_ALL. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__prop_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_all.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_root-1.html:374,Deployability,update,updated,374,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__prop_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_root-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_root.html:374,Deployability,update,updated,374,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__prop_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_root.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_sym-1.html:340,Deployability,update,updated,340,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. PROP_SYM. The symmetry of states. Type: integer; Default: 1. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__prop_sym-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_sym-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_sym.html:340,Deployability,update,updated,340,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. PROP_SYM. The symmetry of states. Type: integer; Default: 1. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__prop_sym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__prop_sym.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__reference-1.html:347,Deployability,update,updated,347,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__reference-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__reference.html:347,Deployability,update,updated,347,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__reference.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__roots_per_irrep-1.html:407,Deployability,update,updated,407,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__roots_per_irrep-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__roots_per_irrep.html:407,Deployability,update,updated,407,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__roots_per_irrep.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__wfn-1.html:331,Deployability,update,updated,331,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. WFN. Wavefunction type. Type: string; Default: SCF. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__wfn-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__wfn.html:331,Deployability,update,updated,331,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. WFN. Wavefunction type. Type: string; Default: SCF. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__wfn.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__xi-1.html:330,Deployability,update,updated,330,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. XI. Do compute Xi?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__xi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__xi-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__xi.html:330,Deployability,update,updated,330,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. XI. Do compute Xi?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__xi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__xi.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__xi_connect-1.html:373,Deployability,update,updated,373,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. XI_CONNECT. Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__xi_connect-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__xi_connect-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__xi_connect.html:373,Deployability,update,updated,373,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. XI_CONNECT. Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__xi_connect.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__xi_connect.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__zeta-1.html:330,Deployability,update,updated,330,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ZETA. Do use zeta?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__zeta-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__zeta-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__zeta.html:330,Deployability,update,updated,330,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY. ZETA. Do use zeta?. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCDENSITY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccdensity__zeta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__zeta.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__abcd-1.html:375,Deployability,update,updated,375,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__abcd-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__abcd.html:375,Deployability,update,updated,375,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__abcd.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__analyze-1.html:343,Deployability,update,updated,343,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. ANALYZE. Do analyze T2 amplitudes. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__analyze-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__analyze-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__analyze.html:343,Deployability,update,updated,343,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. ANALYZE. Do analyze T2 amplitudes. Type: boolean; Default: false. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__analyze.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__analyze.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__ao_basis-1.html:1021,Deployability,update,updated,1021,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. AO_BASIS. The algorithm to use for the \(\left\langle VV||VV\right\rangle\) terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__ao_basis-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__ao_basis.html:1021,Deployability,update,updated,1021,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. AO_BASIS. The algorithm to use for the \(\left\langle VV||VV\right\rangle\) terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__ao_basis.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__bccd_maxiter-1.html:358,Deployability,update,updated,358,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. BCCD_MAXITER. Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__bccd_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__bccd_maxiter-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__bccd_maxiter.html:358,Deployability,update,updated,358,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. BCCD_MAXITER. Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__bccd_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__bccd_maxiter.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html:501,Deployability,update,updated,501,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html:287,Integrability,depend,depending,287,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html:501,Deployability,update,updated,501,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html:287,Integrability,depend,depending,287,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html:805,Deployability,update,updated,805,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html:287,Performance,cache,cache,287,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html:349,Performance,cache,cache,349,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html:619,Performance,cache,cache,619,". <no title>. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. Navigation. Index. modules  .  .  .  . ; 1.1; . PSI4. Appendices; Keywords by Module; CCENERGY.  Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html
