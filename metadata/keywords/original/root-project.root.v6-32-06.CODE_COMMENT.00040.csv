id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:77,Modifiability,variab,variable,77,"/// getIVIncOperand returns an induction variable increment's induction; /// variable operand.; ///; /// If allowScale is set, any type of GEP is allowed as long as the nonIV; /// operands dominate InsertPos.; ///; /// If allowScale is not set, ensure that a GEP increment conforms to one of the; /// simple patterns generated by getAddRecExprPHILiterally and; /// expandAddtoGEP. If the pattern isn't recognized, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:301,Usability,simpl,simple,301,"/// getIVIncOperand returns an induction variable increment's induction; /// variable operand.; ///; /// If allowScale is set, any type of GEP is allowed as long as the nonIV; /// operands dominate InsertPos.; ///; /// If allowScale is not set, ensure that a GEP increment conforms to one of the; /// simple patterns generated by getAddRecExprPHILiterally and; /// expandAddtoGEP. If the pattern isn't recognized, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:15,Usability,simpl,simple,15,// Check for a simple Add/Sub or GEP of a loop invariant step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:135,Deployability,update,update,135,"/// If the insert point of the current builder or any of the builders on the; /// stack of saved builders has 'I' as its insert point, update it to point to; /// the instruction after 'I'. This is intended to be used when the instruction; /// 'I' is being moved. If this fixup is not done and 'I' is moved to a; /// different block, the inconsistent insert point (with a mismatched; /// Instruction and Block) can lead to an instruction being inserted in a block; /// other than its parent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:87,Availability,avail,available,87,"/// hoistStep - Attempt to hoist a simple IV increment above InsertPos to make; /// it available to other uses in this loop. Recursively hoist any operands,; /// until we reach a value that dominates InsertPos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:35,Usability,simpl,simple,35,"/// hoistStep - Attempt to hoist a simple IV increment above InsertPos to make; /// it available to other uses in this loop. Recursively hoist any operands,; /// until we reach a value that dominates InsertPos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:11,Safety,safe,safe,11,// IncV is safe to hoist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:81,Availability,avail,available,81,/// Check whether we can cheaply express the requested SCEV in terms of; /// the available PHI SCEV by truncation and/or inversion of the step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:42,Safety,avoid,avoid,42,// TODO: this possibly can be reworked to avoid this cast at all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:32,Usability,usab,usable,32,"// Ok, the add recurrence looks usable.; // Remember this PHI, even in post-inc mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:10,Integrability,wrap,wrap,10,// The no-wrap behavior proved by IsIncrement(NUW|NSW) is only applicable if; // we actually do emit an addition. It does not apply if we emit a; // subtraction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:79,Safety,safe,safe,79,"// We might be introducing a new use of the post-inc IV that is not poison; // safe, in which case we should drop poison generating flags. Only keep; // those flags for which SCEV has proven that they always hold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:17,Modifiability,variab,variable,17,"// The induction variable's postinc expansion does not dominate this use.; // IVUsers tries to prevent this case, so it is rare. However, it can; // happen when an IVUser outside the loop is not dominated by the latch; // block. Adjusting IVIncInsertPos before expansion begins cannot handle; // all cases. Consider a phi outside whose operand is replaced during; // expansion with the value of the postinc user. Without fundamentally; // changing the way postinc users are tracked, the only remedy is; // inserting an extra IV increment. StepV might fold into PostLoopOffset,; // but hopefully expandCodeFor handles that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:41,Modifiability,variab,variable,41,// We have decided to reuse an induction variable of a dominating loop. Apply; // truncation and/or inversion of the step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:166,Safety,avoid,avoid,166,"// In canonical mode we compute the addrec as an expression of a canonical IV; // using evaluateAtIteration and expand the resulting SCEV expression. This; // way we avoid introducing new IVs to carry on the computation of the addrec; // throughout the loop.; //; // For nested addrecs evaluateAtIteration might need a canonical IV of a; // type wider than the addrec itself. Emitting a canonical IV of the; // proper type might produce non-legal types, for example expanding an i64; // {0,+,2,+,1} addrec would need an i65 canonical IV. To avoid this just fall; // back to non-canonical mode for nested addrecs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:541,Safety,avoid,avoid,541,"// In canonical mode we compute the addrec as an expression of a canonical IV; // using evaluateAtIteration and expand the resulting SCEV expression. This; // way we avoid introducing new IVs to carry on the computation of the addrec; // throughout the loop.; //; // For nested addrecs evaluateAtIteration might need a canonical IV of a; // type wider than the addrec itself. Emitting a canonical IV of the; // proper type might produce non-legal types, for example expanding an i64; // {0,+,2,+,1} addrec would need an i65 canonical IV. To avoid this just fall; // back to non-canonical mode for nested addrecs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite an AddRec in terms of the canonical induction variable, if; // its type is more narrow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:57,Modifiability,variab,variable,57,"// Rewrite an AddRec in terms of the canonical induction variable, if; // its type is more narrow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:52,Modifiability,variab,variable,52,// Create and insert the PHI node for the induction variable in the; // specified loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:44,Modifiability,variab,variable,44,"// {0,+,1} --> Insert a canonical induction variable into the loop!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:44,Usability,simpl,simple,44,"// {0,+,F} --> {0,+,1} * F; // If this is a simple linear addrec, emit it now as a special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:156,Usability,simpl,simplify,156,"// If this is a chain of recurrences, turn it into a closed form, using the; // folders, then expandCodeFor the closed form. This allows the folders to; // simplify the expression without having to build a bunch of special code; // into this folder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:23,Availability,down,down,23,"// Truncate the result down to the original type, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:47,Safety,safe,safe,47,// Make sure reusing the instruction is poison-safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:94,Safety,risk,risky,94,// We can move insertion point only if there is no div or rem operations; // otherwise we are risky to move it over the check for zero denominator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:87,Usability,simpl,simplify,87,"// LSR sets the insertion point for AddRec start/step values to the; // block start to simplify value reuse, even though it's an invalid; // position. SCEVExpander must correct for this in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:125,Usability,simpl,simply,125,"// Remember the expanded value for this SCEV at this location.; //; // This is independent of PostIncLoops. The mapped value simply materializes; // the expression at this insertion point. If the mapped value happened to be; // a postinc expansion, it could be reused by a non-postinc user, but only if; // its insertion point was already at the head of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:202,Integrability,depend,depend,202,/// replaceCongruentIVs - Check for congruent phis in this loop header and; /// replace them with their most canonical representative. Return the number of; /// phis eliminated.; ///; /// This does not depend on any SCEVExpander state but should be used in; /// the same context that SCEVExpander is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:94,Testability,log,logic,94,// Fold constant phis. They may be congruent to other constant phis and; // would confuse the logic below that expects proper IVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:21,Modifiability,rewrite,rewrite,21,"// Make sure we only rewrite using simple induction variables;; // otherwise, we can make the trip count of a loop unanalyzable; // to SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:52,Modifiability,variab,variables,52,"// Make sure we only rewrite using simple induction variables;; // otherwise, we can make the trip count of a loop unanalyzable; // to SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:35,Usability,simpl,simple,35,"// Make sure we only rewrite using simple induction variables;; // otherwise, we can make the trip count of a loop unanalyzable; // to SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:65,Safety,redund,redundancy,65,"// Replacing the congruent phi is sufficient because acyclic; // redundancy elimination, CSE/GVN, should handle the; // rest. However, once SCEV proves that a phi is congruent,; // it's often the head of an IV user cycle that is isomorphic; // with the original phi. It's worth eagerly cleaning up the; // common case of a single IV increment so that DeleteDeadPHIs; // can remove cycles that had postinc uses.; // Because we may potentially introduce a new use of OrigIV that didn't; // exist before at this point, its poison flags need readjustment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:30,Usability,simpl,simple,30,// Look for suitable value in simple conditions at the loop exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:16,Testability,log,logic,16,// Use expand's logic which is used for reusing a previous Value in; // ExprValueMap. Note that we don't currently model the cost of; // needing to drop poison generating flags on the instruction if we; // want to reuse it. We effectively assume that has zero cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:7,Safety,safe,safety,7,// The safety net against poison.; // FIXME: this is broken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:84,Energy Efficiency,charge,charge,84,"// In this polynominal, we may have some zero operands, and we shouldn't; // really charge for those. So how many non-zero coefficients are there?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:101,Availability,avail,available,101,"// We have already accounted for this expression.; // If we can find an existing value for this scev available at the point ""At""; // then consider the expression cheap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:46,Performance,optimiz,optimizing,46,// Only evalulate the costs of constants when optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:231,Usability,simpl,simple,231,"// UDivExpr is very likely a UDiv that ScalarEvolution's HowFarToZero or; // HowManyLessThans produced to compute a precise expression, rather than a; // UDiv from the user's code. If we can't find a UDiv in the code with some; // simple searching, we need to account for it's cost.; // At the beginning of this function we already tried to find existing; // value for plain 'S'. Now try to lookup 'S + 1' since it is common; // pattern involving division. This is just a simple search heuristic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:472,Usability,simpl,simple,472,"// UDivExpr is very likely a UDiv that ScalarEvolution's HowFarToZero or; // HowManyLessThans produced to compute a precise expression, rather than a; // UDiv from the user's code. If we can't find a UDiv in the code with some; // simple searching, we need to account for it's cost.; // At the beginning of this function we already tried to find existing; // value for plain 'S'. Now try to lookup 'S + 1' since it is common; // pattern involving division. This is just a simple search heuristic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:7,Usability,simpl,simple,7,// The simple nary expr will require one less op (or pair of ops); // than the number of it's terms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:159,Integrability,depend,depending,159,"// Compute |Step| * Backedge; // Compute:; // 1. Start + |Step| * Backedge < Start; // 2. Start - |Step| * Backedge > Start; //; // And select either 1. or 2. depending on whether step is positive or; // negative. If Step is known to be positive or negative, only create; // either 1. or 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:48,Modifiability,extend,extended,48,// Get the backedge taken count and truncate or extended to the AR type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:195,Performance,optimiz,optimized,195,"// Special-case Step of one. Potentially-costly `umul_with_overflow` isn't; // needed, there is never an overflow, so to avoid artificially inflating; // the cost of the check, directly emit the optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:121,Safety,avoid,avoid,121,"// Special-case Step of one. Potentially-costly `umul_with_overflow` isn't; // needed, there is never an overflow, so to avoid artificially inflating; // the cost of the check, directly emit the optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1008,Energy Efficiency,reduce,reduced,1008,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:47,Safety,safe,safe,47,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:142,Safety,unsafe,unsafe,142,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:404,Safety,safe,safe,404,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:225,Performance,load,loads,225,"// Some instructions can be handled but are rejected above. Catch; // those cases by falling through to here.; // TODO: Mark globals as being constant earlier, so; // TODO: wouldInstructionBeTriviallyDead() knows that atomic loads; // TODO: are safe to remove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:245,Safety,safe,safe,245,"// Some instructions can be handled but are rejected above. Catch; // those cases by falling through to here.; // TODO: Mark globals as being constant earlier, so; // TODO: wouldInstructionBeTriviallyDead() knows that atomic loads; // TODO: are safe to remove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:223,Deployability,update,updated,223,"// Replacing `musttail` instructions with constant breaks `musttail` invariant; // unless the call itself can be removed.; // Calls with ""clang.arc.attachedcall"" implicitly use the return value and; // those uses cannot be updated with a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:33,Modifiability,variab,variable,33,// Replaces all of the uses of a variable with uses of the constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:51,Testability,log,logical,51,"// If the shifted value is not negative, this is a logical shift right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:35,Deployability,update,update,35,// Wire up the new instruction and update state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:82,Modifiability,variab,variable,82,"/// GlobalValue - If we are tracking any values for the contents of a global; /// variable, we keep a mapping from the constant accessor to the element of; /// the global, to the currently known value. If the value becomes; /// overdefined, it's entry is simply removed from this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:128,Security,access,accessor,128,"/// GlobalValue - If we are tracking any values for the contents of a global; /// variable, we keep a mapping from the constant accessor to the element of; /// the global, to the currently known value. If the value becomes; /// overdefined, it's entry is simply removed from this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:255,Usability,simpl,simply,255,"/// GlobalValue - If we are tracking any values for the contents of a global; /// variable, we keep a mapping from the constant accessor to the element of; /// the global, to the currently known value. If the value becomes; /// overdefined, it's entry is simply removed from this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:100,Usability,clear,cleared,100,"/// The set of values whose lattice has been invalidated.; /// Populated by resetLatticeValueFor(), cleared after resolving undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:95,Energy Efficiency,efficient,efficient,95,/// MRVFunctionsTracked - Each function in TrackedMultipleRetVals is; /// represented here for efficient lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:109,Deployability,update,updated,109,"// Helper to push \p V to the worklist, after updating it to \p IV. Also; // prints a debug message with the updated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:92,Integrability,message,message,92,"// Helper to push \p V to the worklist, after updating it to \p IV. Also; // prints a debug message with the updated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:181,Deployability,update,updated,181,"// markConstant - Make a value be marked as ""constant"". If the value; // is not already a constant, add it to the instruction work list so that; // the users of the instruction are updated later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:200,Deployability,update,updated,200,"// markOverdefined - Make a value be marked as ""overdefined"". If the; // value is not already overdefined, add it to the overdefined instruction; // work list so that the users of the instruction are updated later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:169,Deployability,update,update,169,"// OperandChangedState - This method is invoked on all of the users of an; // instruction that was just changed state somehow. Based on this; // information, we need to update the specified user of this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:148,Deployability,update,update,148,// Functions include their arguments in the use-list. Changed function; // values mean that the result of the function changed. We only need to; // update the call sites with the new function result and do not have to; // propagate the call arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:25,Modifiability,variab,variables,25,"// Overdefined condition variables, and branches on unfoldable constant; // conditions, mean the branch could go either way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:22,Modifiability,variab,variables,22,// Constant condition variables mean the branch can only go a single way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:109,Availability,down,down,109,"// Quick exit; // Super-extra-high-degree PHI nodes are unlikely to ever be marked constant,; // and slow us down a lot. Just mark them overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:10,Usability,simpl,simplify,10,// Try to simplify to a constant range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:10,Performance,cache,cache,10,"// Do not cache this lookup, getValueState calls later in the function might; // invalidate the reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:76,Availability,avail,available,76,"// For parameters, use ParamState which includes constant range info if; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:10,Performance,load,load,10,"// Handle load instructions. If the operand is a constant pointer to a constant; // global, we can replace the load with the loaded constant value!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:111,Performance,load,load,111,"// Handle load instructions. If the operand is a constant pointer to a constant; // global, we can replace the load with the loaded constant value!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:125,Performance,load,loaded,125,"// Handle load instructions. If the operand is a constant pointer to a constant; // global, we can replace the load with the loaded constant value!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:11,Performance,load,load,11,"// If this load is of a struct or the load is volatile, just mark the result; // as overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:38,Performance,load,load,38,"// If this load is of a struct or the load is volatile, just mark the result; // as overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:3,Performance,load,load,3,// load null is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:13,Performance,load,load,13,// Transform load (constant global) into the value loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:51,Performance,load,loaded,51,// Transform load (constant global) into the value loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:13,Performance,load,load,13,// Transform load from a constant into a constant if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:266,Deployability,Update,Update,266,"// ""I"" got into the work list because it either made the transition from; // bottom to constant, or to overdefined.; //; // Anything on this worklist that is overdefined need not be visited; // since all of its users will have already been marked as overdefined; // Update all of the users of this instruction's value.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:240,Deployability,Update,Update,240,"// ""I"" got into the work list because it made the transition from undef to; // constant.; //; // Anything on this worklist that is overdefined need not be visited; // since all of its users will have already been marked as overdefined.; // Update all of the users of this instruction's value.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:5,Performance,load,load,5,"// A load here means one of two things: a load of undef from a global,; // a load from an unknown pointer. Either way, having it return undef; // is okay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:42,Performance,load,load,42,"// A load here means one of two things: a load of undef from a global,; // a load from an unknown pointer. Either way, having it return undef; // is okay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:77,Performance,load,load,77,"// A load here means one of two things: a load of undef from a global,; // a load from an unknown pointer. Either way, having it return undef; // is okay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:777,Usability,simpl,simplicity,777,"/// While solving the dataflow for a function, we don't compute a result for; /// operations with an undef operand, to allow undef to be lowered to a; /// constant later. For example, constant folding of ""zext i8 undef to i16""; /// would result in ""i16 0"", and if undef is later lowered to ""i8 1"", then the; /// zext result would become ""i16 1"" and would result into an overdefined; /// lattice value once merged with the previous result. Not computing the; /// result of the zext (treating undef the same as unknown) allows us to handle; /// a later undef->constant lowering more optimally.; ///; /// However, if the operand remains undef when the solver returns, we do need; /// to assign some result to the instruction (otherwise we would treat it as; /// unreachable). For simplicity, we mark any instructions that are still; /// unknown as overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:33,Performance,perform,perform,33,"//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Peephole optimize the CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:392,Performance,optimiz,optimize,392,"//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Peephole optimize the CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:7,Usability,Simpl,SimplifyCFG,7,"//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Peephole optimize the CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Usability,simpl,simplification,45,"//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Peephole optimize the CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:59,Energy Efficiency,power,power,59,"// Chosen as 2 so as to be cheap, but still to have enough power to fold; // a select, so the ""clamp"" idiom (of a min followed by a max) will be caught.; // To catch this, we need to fold a compare and a select, hence '2' being the; // minimum reasonable default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Testability,log,logical,45,// Two is chosen to allow one negation and a logical combine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,Safety,safe,safe,25,/// Return true if it is safe to merge these two; /// terminator instructions together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:40,Safety,safe,safe,40,"// Can't merge with self!; // It is not safe to merge these two switch instructions if they have a common; // successor, and if that successor has a PHI node, and if *that* PHI node has; // conflicting incoming values from the two switch blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:4,Deployability,Update,Update,4,"/// Update PHI nodes in Succ to indicate that there will now be entries in it; /// from the 'NewPred' block. The values that will be flowing into the PHI nodes; /// will be the same as those coming in from ExistPred, an existing predecessor; /// of Succ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:97,Safety,safe,safe,97,"/// Compute an abstract ""cost"" of speculating the given instruction,; /// which is assumed to be safe to speculate. TCC_Free means cheap,; /// TCC_Basic means less cheap, and TCC_Expensive means prohibitively; /// expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:242,Safety,avoid,avoid,242,"// It is possible to hit a zero-cost cycle (phi/gep instructions for example),; // so limit the recursion depth.; // TODO: While this recursion limit does prevent pathological behavior, it; // would be better to track visited instructions to avoid cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:364,Performance,optimiz,optimizations,364,// Allow exactly one instruction to be speculated regardless of its cost; // (as long as it is safe to do so).; // This is intended to flatten the CFG even if the instruction is a division; // or other expensive operation. The speculation of an expensive instruction; // is expected to be undone in CodeGenPrepare if the speculation has not; // enabled further IR optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:95,Safety,safe,safe,95,// Allow exactly one instruction to be speculated regardless of its cost; // (as long as it is safe to do so).; // This is intended to flatten the CFG even if the instruction is a division; // or other expensive operation. The speculation of an expensive instruction; // is expected to be undone in CodeGenPrepare if the speculation has not; // enabled further IR optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:289,Usability,undo,undone,289,// Allow exactly one instruction to be speculated regardless of its cost; // (as long as it is safe to do so).; // This is intended to flatten the CFG even if the instruction is a division; // or other expensive operation. The speculation of an expensive instruction; // is expected to be undone in CodeGenPrepare if the speculation has not; // enabled further IR optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:14,Safety,safe,safe,14,"// Okay, it's safe to do this! Remember this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:105,Availability,recover,recover,105,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:105,Safety,recover,recover,105,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:515,Security,validat,validate,515,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:611,Testability,test,test,611,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:199,Availability,failure,failure,199,"/// Try to match Instruction ""I"" as a comparison against a constant and; /// populates the array Vals with the set of values that match (or do not; /// match depending on isEQ).; /// Return false on failure. On success, the Value the comparison matched; /// against is placed in CompValue.; /// If CompValue is already set, the function is expected to fail if a match; /// is found but the value compared to is different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:158,Integrability,depend,depending,158,"/// Try to match Instruction ""I"" as a comparison against a constant and; /// populates the array Vals with the set of values that match (or do not; /// match depending on isEQ).; /// Return false on failure. On success, the Value the comparison matched; /// against is placed in CompValue.; /// If CompValue is already set, the function is expected to fail if a match; /// is found but the value compared to is different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:86,Usability,undo,undoes,86,// Pattern match a special case; // (x & ~2^z) == y --> x == y || x == y|2^z; // This undoes a transformation done by instcombine to fuse 2 compares.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:254,Availability,mask,mask,254,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:306,Availability,mask,mask,306,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:327,Availability,mask,mask,327,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:360,Availability,mask,mask,360,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:385,Availability,mask,mask,385,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:405,Availability,mask,mask,405,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:439,Availability,mask,mask,439,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1057,Availability,mask,mask,1057,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1083,Availability,mask,mask,1083,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1119,Availability,mask,mask,1119,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1261,Availability,mask,mask,1261,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1282,Availability,mask,mask,1282,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1315,Availability,mask,mask,1315,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:50,Availability,mask,mask,50,// Pattern match a special case:; /*; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:70,Availability,mask,mask,70,// Pattern match a special case:; /*; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:104,Availability,mask,mask,104,// Pattern match a special case:; /*; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:24,Integrability,depend,depending,24,"// If it is a || (or && depending on isEQ), process the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:38,Safety,abort,abort,38,"// Failed to parse a proper sequence, abort now",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:283,Usability,simpl,simplify,283,"/// If TI is known to be a terminator instruction and its block is known to; /// only have a single predecessor block, check to see if that predecessor is; /// also a value comparison with the same value, and if that comparison; /// determines the outcome of this comparison. If so, simplify TI. This does a; /// very limited form of jump threading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:109,Usability,simpl,simplify,109,"// Remove default from cases.; // If TI's block is the default block from Pred's comparison, potentially; // simplify TI based on this knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,Usability,simpl,simplify,160,"// If we are here, we know that the value is none of those cases listed in; // PredCases. If there are any cases in ThisCases that are in PredCases, we; // can simplify TI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:84,Integrability,depend,depend,84,/// This class implements a stable ordering of constant; /// integers that does not depend on their address. This is important for; /// applications that sort ConstantInt's to ensure uniqueness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:194,Safety,avoid,avoid,194,"// Unless the instruction has the same !dbg location as the original; // branch, drop it. When we fold the bonus instructions we want to make; // sure we reset their debug locations in order to avoid stepping on; // dead code caused by folding dead branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,"// Update (liveout) uses of bonus instructions,; // now that the bonus instruction has been cloned into predecessor.; // Note that we expect to be in a block-closed SSA form for this to work!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update the branch weight metadata along the way,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:84,Deployability,update,update,84,"// Okay, at this point, we know which new successor Pred will get. Make; // sure we update the number of entries in the PHI nodes for these; // successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:31,Deployability,update,updated,31,"// Now that the successors are updated, create the new Switch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:240,Safety,safe,safe,240,"/// The specified terminator is a value equality comparison instruction; /// (either a switch or a branch on ""X == c"").; /// See if any of the predecessors of the terminator block are value comparisons; /// on the same value. If so, and if safe to do so, fold them together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,Safety,safe,safe,25,// Returns true if it is safe to reorder an instruction across preceding; // instructions in a basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:32,Performance,load,load,32,// Don't reorder a store over a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:58,Safety,unsafe,unsafe,58,"// If we have seen an instruction with side effects, it's unsafe to reorder an; // instruction which reads memory or itself has side effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,Safety,unsafe,unsafe,13,// It's also unsafe/illegal to hoist an instruction above its instruction; // operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:168,Performance,perform,perform,168,"/// Hoist any common code in the successor blocks up into the block. This; /// function guarantees that BB dominates all successors. If EqTermsOnly is; /// given, only perform hoisting in case both blocks only contain a terminator.; /// In that case, only the original BI will be replaced and selects for PHIs are; /// added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:61,Safety,safe,safe,61,"// Even if the instructions are identical, it may not; // be safe to hoist them if we have skipped over; // instructions with side effects or their operands; // weren't hoisted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:162,Usability,simpl,simply,162,"// The debug location is an integral part of a debug info intrinsic; // and can't be separated from it or replaced. Instead of attempting; // to merge locations, simply hoist both copies of the intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,Availability,redundant,redundant,160,"// For a normal instruction, we just move one to right before the; // branch, then replace all uses of the other with the first. Finally,; // we remove the now redundant second instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,Safety,redund,redundant,160,"// For a normal instruction, we just move one to right before the; // branch, then replace all uses of the other with the first. Finally,; // we remove the now redundant second instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:89,Safety,safe,safety,89,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:129,Testability,Test,Test,129,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:144,Testability,test,test,144,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,Usability,Simpl,SimplifyCFG,160,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:15,Safety,safe,safe,15,"// Okay, it is safe to hoist the terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in our new successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:90,Modifiability,variab,variables,90,// TODO: Refine this. This should avoid cases like turning constant memcpy sizes; // into variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:34,Safety,avoid,avoid,34,// TODO: Refine this. This should avoid cases like turning constant memcpy sizes; // into variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Performance,load,load,45,"// swifterror pointers can only be used by a load or store; sinking a load; // or store would require introducing a select for the pointer operand,; // which isn't allowed for swifterror pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:70,Performance,load,load,70,"// swifterror pointers can only be used by a load or store; sinking a load; // or store would require introducing a select for the pointer operand,; // which isn't allowed for swifterror pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:379,Availability,down,down,379,"// Because SROA can't handle speculating stores of selects, try not to sink; // loads, stores or lifetime markers of allocas when we'd have to create a; // PHI for the address operand. Also, because it is likely that loads or; // stores of allocas will disappear when Mem2Reg/SROA is run, don't sink; // them.; // This can cause code churn which can have unintended consequences down; // the line - see https://llvm.org/bugs/show_bug.cgi?id=30244.; // FIXME: This is a workaround for a deficiency in SROA - see; // https://llvm.org/bugs/show_bug.cgi?id=30188",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:80,Performance,load,loads,80,"// Because SROA can't handle speculating stores of selects, try not to sink; // loads, stores or lifetime markers of allocas when we'd have to create a; // PHI for the address operand. Also, because it is likely that loads or; // stores of allocas will disappear when Mem2Reg/SROA is run, don't sink; // them.; // This can cause code churn which can have unintended consequences down; // the line - see https://llvm.org/bugs/show_bug.cgi?id=30244.; // FIXME: This is a workaround for a deficiency in SROA - see; // https://llvm.org/bugs/show_bug.cgi?id=30188",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:217,Performance,load,loads,217,"// Because SROA can't handle speculating stores of selects, try not to sink; // loads, stores or lifetime markers of allocas when we'd have to create a; // PHI for the address operand. Also, because it is likely that loads or; // stores of allocas will disappear when Mem2Reg/SROA is run, don't sink; // them.; // This can cause code churn which can have unintended consequences down; // the line - see https://llvm.org/bugs/show_bug.cgi?id=30244.; // FIXME: This is a workaround for a deficiency in SROA - see; // https://llvm.org/bugs/show_bug.cgi?id=30188",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:106,Usability,simpl,simplifycfg,106,"// This check is different to that in canSinkInstructions. There, we; // cared about the global view once simplifycfg (and instcombine) have; // completed - it takes into account PHIs that become trivially; // simplifiable. However here we need a more local view; if an operand; // differs we create a PHI and rely on instcombine to clean up the very; // small mess we may make.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:210,Usability,simpl,simplifiable,210,"// This check is different to that in canSinkInstructions. There, we; // cared about the global view once simplifycfg (and instcombine) have; // completed - it takes into account PHIs that become trivially; // simplifiable. However here we need a more local view; if an operand; // differs we create a PHI and rely on instcombine to clean up the very; // small mess we may make.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,"// Update metadata and IR flags, and merge debug locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:375,Usability,simpl,simplified,375,"// The debug location for the ""common"" instruction is the merged locations; // of all the commoned instructions. We start with the original location; // of the ""common"" instruction and iteratively merge each location in the; // loop below.; // This is an N-way merge, which will be inefficient if I0 is a CallInst.; // However, as N-way merge for CallInst is rare, so we use simplified API; // instead of using complex API for N-way merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:197,Integrability,depend,depends,197,"// We've determined that we are going to sink last ScanIdx instructions,; // and recorded them in InstructionsToSink. Now, some instructions may be; // unprofitable to sink. But that determination depends on the instructions; // that we are going to sink.; // First, forward scan: find the first instruction unprofitable to sink,; // recording all the ones that are profitable to sink.; // FIXME: would it be better, after we detect that not all are profitable.; // to either record the profitable ones, or erase the unprofitable ones?; // Maybe we need to choose (at runtime) the one that will touch least; // instrs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:426,Safety,detect,detect,426,"// We've determined that we are going to sink last ScanIdx instructions,; // and recorded them in InstructionsToSink. Now, some instructions may be; // unprofitable to sink. But that determination depends on the instructions; // that we are going to sink.; // First, forward scan: find the first instruction unprofitable to sink,; // recording all the ones that are profitable to sink.; // FIXME: would it be better, after we detect that not all are profitable.; // to either record the profitable ones, or erase the unprofitable ones?; // Maybe we need to choose (at runtime) the one that will touch least; // instrs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:208,Performance,perform,performant,208,"// If we detect that an instruction becomes unprofitable to sink,; // all earlier instructions won't be sunk either,; // so preemptively keep InstructionsProfitableToSink in sync.; // FIXME: is this the most performant approach?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:9,Safety,detect,detect,9,"// If we detect that an instruction becomes unprofitable to sink,; // all earlier instructions won't be sunk either,; // so preemptively keep InstructionsProfitableToSink in sync.; // FIXME: is this the most performant approach?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:61,Performance,perform,perform,61,"// Now that we've analyzed all potential sinking candidates, perform the; // actual sink. We iteratively sink the last non-terminator of the source; // blocks into their common successor unless doing so would require too; // many PHI instructions to be generated (currently only one PHI is allowed; // per sunk instruction).; //; // We can use InstructionsToSink to discount values needing PHI-merging that will; // actually be sunk in a later iteration. This allows us to be more; // aggressive in what we sink. This does allow a false positive where we; // sink presuming a later value will also be sunk, but stop half way through; // and never actually sink it which means we produce more PHIs than intended.; // This is unlikely in practice though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Perform,Perform,3,"// Perform a linear scan over all the existing sets, see if the new `invoke`; // is compatible with any particular set. Since we know that all the `invokes`; // within a set are compatible, only check the first `invoke` in each set.; // WARNING: at worst, this has quadratic complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:155,Deployability,update,update,155,"// We've ensured that each PHI node has compatible (identical) incoming values; // when coming from each of the `invoke`s in the current merge set,; // so update the PHI nodes accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:81,Security,access,accesses,81,// Skip pseudo probe intrinsic calls which are not really killing any memory; // accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:86,Safety,avoid,avoid,86,"// Found the previous store to same location and type. Make sure it is; // simple, to avoid introducing a spurious non-atomic write after an; // atomic write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:75,Usability,simpl,simple,75,"// Found the previous store to same location and type. Make sure it is; // simple, to avoid introducing a spurious non-atomic write after an; // atomic write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:268,Performance,concurren,concurrently,268,"// Local objects (created by an `alloca` instruction) are always; // writable, so once we are past a read from a location it is valid to; // also write to that same location.; // If the address of the local object never escapes the function, that; // means it's never concurrently read or written, hence moving the store; // from under the condition will not introduce a data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:20,Performance,load,load,20,"// Found a previous load, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:7,Performance,load,load,7,"// The load didn't work out, but we may still find a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:641,Energy Efficiency,power,powerful,641,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:562,Performance,optimiz,optimizations,562,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:95,Safety,risk,risky,95,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:551,Usability,simpl,simplistic,551,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:46,Safety,predict,predicted,46,"// If the branch is non-unpredictable, and is predicted to *not* branch to; // the `then` block, then avoid speculating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:102,Safety,avoid,avoid,102,"// If the branch is non-unpredictable, and is predicted to *not* branch to; // the `then` block, then avoid speculating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:122,Performance,optimiz,optimization,122,"// Skip pseudo probes. The consequence is we lose track of the branch; // probability for ThenBB, which is fine since the optimization here takes; // place regardless of the branch probability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:39,Safety,unsafe,unsafe,39,// Don't hoist the instruction if it's unsafe or expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:19,Integrability,depend,dependent,19,"// Metadata can be dependent on the condition we are hoisting above.; // Strip all UB-implying metadata on the instruction. Drop the debug loc; // to avoid making it appear as if the condition is a constant, which would; // be misleading while debugging.; // Similarly strip attributes that maybe dependent on condition we are; // hoisting above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:297,Integrability,depend,dependent,297,"// Metadata can be dependent on the condition we are hoisting above.; // Strip all UB-implying metadata on the instruction. Drop the debug loc; // to avoid making it appear as if the condition is a constant, which would; // be misleading while debugging.; // Similarly strip attributes that maybe dependent on condition we are; // hoisting above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:150,Safety,avoid,avoid,150,"// Metadata can be dependent on the condition we are hoisting above.; // Strip all UB-implying metadata on the instruction. Drop the debug loc; // to avoid making it appear as if the condition is a constant, which would; // be misleading while debugging.; // Similarly strip attributes that maybe dependent on condition we are; // hoisting above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:9,Deployability,update,update,9,// Don't update the DILocation of dbg.assign intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:22,Modifiability,rewrite,rewrite,22,// Insert selects and rewrite the PHI operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:29,Energy Efficiency,reduce,reduce,29,"// TODO: These just exist to reduce test diff, we can drop them if we like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:36,Testability,test,test,36,"// TODO: These just exist to reduce test diff, we can drop them if we like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update PHI nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update operands due to translation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:21,Usability,simpl,simplification,21,// Check for trivial simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:52,Performance,cache,cache,52,// Register the new instruction with the assumption cache if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:133,Safety,avoid,avoids,133,"// For simplicity, we created a separate basic block for the edge. Merge; // it back into the predecessor if possible. This not only avoids; // unnecessary SimplifyCFG iterations, but also makes sure that we don't; // bypass the check for trivial cycles above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:7,Usability,simpl,simplicity,7,"// For simplicity, we created a separate basic block for the edge. Merge; // it back into the predecessor if possible. This not only avoids; // unnecessary SimplifyCFG iterations, but also makes sure that we don't; // bypass the check for trivial cycles above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:156,Usability,Simpl,SimplifyCFG,156,"// For simplicity, we created a separate basic block for the edge. Merge; // it back into the predecessor if possible. This not only avoids; // unnecessary SimplifyCFG iterations, but also makes sure that we don't; // bypass the check for trivial cycles above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:18,Usability,simpl,simplifying,18,"// Signal repeat, simplifying any other constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:292,Integrability,depend,dependence,292,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:63,Usability,simpl,simple,63,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:107,Usability,simpl,simple,107,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:335,Usability,simpl,simplifycfg,335,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:56,Safety,predict,predictably,56,"// If the branch is non-unpredictable, see if we either predictably jump to; // the merge bb (if we have only a single 'then' block), or if we predictably; // jump to one specific 'then' block (if we have two of them).; // It isn't beneficial to speculatively execute the code; // from the block that we know is predictably not entered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:143,Safety,predict,predictably,143,"// If the branch is non-unpredictable, see if we either predictably jump to; // the merge bb (if we have only a single 'then' block), or if we predictably; // jump to one specific 'then' block (if we have two of them).; // It isn't beneficial to speculatively execute the code; // from the block that we know is predictably not entered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:312,Safety,predict,predictably,312,"// If the branch is non-unpredictable, see if we either predictably jump to; // the merge bb (if we have only a single 'then' block), or if we predictably; // jump to one specific 'then' block (if we have two of them).; // It isn't beneficial to speculatively execute the code; // from the block that we know is predictably not entered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:103,Usability,simpl,simplified,103,"// If we folded the first phi, PN dangles at this point. Refresh it. If; // we ran out of PHIs then we simplified them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:64,Testability,test,tests,64,"// If we can still promote the PHI nodes after this gauntlet of tests,; // do all of the PHI's now.; // Move all 'aggressive' instructions, which are defined in the; // conditional parts of the if's up to the dominating block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:143,Safety,avoid,avoid,143,"// At this point, all IfBlocks are empty, so our if statement; // has been flattened. Change DomBlock to jump directly to our new block to; // avoid other simplifycfg's kicking in on the diamond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:155,Usability,simpl,simplifycfg,155,"// At this point, all IfBlocks are empty, so our if statement; // has been flattened. Change DomBlock to jump directly to our new block to; // avoid other simplifycfg's kicking in on the diamond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:16,Testability,log,logical,16,// Try to relax logical op to binary op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:54,Availability,avail,available,54,"/// Return true if either PBI or BI has branch weight available, and store; /// the weights in {Pred|Succ}{True|False}Weight. If one of PBI and BI does; /// not have branch weight, use 1:1 as its weight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:95,Safety,predict,predictable,95,"// We have the potential to fold the conditions together, but if the; // predecessor branch is predictable, we may not want to merge them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:123,Deployability,update,update,123,"// Before cloning instructions, notify the successor basic block that it; // is about to have a new predecessor. This will update PHI nodes,; // which will allow us to update live-out uses of bonus instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:168,Deployability,update,update,168,"// Before cloning instructions, notify the successor basic block that it; // is about to have a new predecessor. This will update PHI nodes,; // which will allow us to update live-out uses of bonus instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:10,Deployability,update,update,10,// Try to update branch weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:8,Deployability,update,update,8,"// Now, update the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:159,Testability,log,logical,159,"/// If this basic block is simple enough, and if a predecessor branches to us; /// and one of our successors, fold the block into the predecessor and use; /// logical operations to pick the right destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:27,Usability,simpl,simple,27,"/// If this basic block is simple enough, and if a predecessor branches to us; /// and one of our successors, fold the block into the predecessor and use; /// logical operations to pick the right destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:58,Performance,perform,performing,58,// Check the cost of inserting the necessary logic before performing the; // transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Testability,log,logic,45,// Check the cost of inserting the necessary logic before performing the; // transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,Safety,safe,safe,13,// I must be safe to execute unconditionally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:27,Performance,Perform,Perform,27,"// Ok, we have the budget. Perform the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:268,Performance,perform,performance,268,"// For every pointer, there must be exactly two stores, one coming from; // PTB or PFB, and the other from QTB or QFB. We don't support more than one; // store (to any address) in PTB,PFB or QTB,QFB.; // FIXME: We could relax this restriction with a bit more work and performance; // testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:284,Testability,test,testing,284,"// For every pointer, there must be exactly two stores, one coming from; // PTB or PFB, and the other from QTB or QFB. We don't support more than one; // store (to any address) in PTB,PFB or QTB,QFB.; // FIXME: We could relax this restriction with a bit more work and performance; // testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:251,Availability,down,down,251,"// Check that sinking the store won't cause program behavior changes. Sinking; // the store out of the Q blocks won't change any behavior as we're sinking; // from a block to its unconditional successor. But we're moving a store from; // the P blocks down through the middle block (QBI) and past both QFB and QTB.; // So we need to check that there are no aliasing loads or stores in; // QBI, QTB and QFB. We also need to check there are no conflicting memory; // operations between PStore and the end of its parent block.; //; // The ideal way to do this is to query AliasAnalysis, but we don't; // preserve AA currently so that is dangerous. Be super safe and just; // check there are no other memory operations at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:365,Performance,load,loads,365,"// Check that sinking the store won't cause program behavior changes. Sinking; // the store out of the Q blocks won't change any behavior as we're sinking; // from a block to its unconditional successor. But we're moving a store from; // the P blocks down through the middle block (QBI) and past both QFB and QTB.; // So we need to check that there are no aliasing loads or stores in; // QBI, QTB and QFB. We also need to check there are no conflicting memory; // operations between PStore and the end of its parent block.; //; // The ideal way to do this is to query AliasAnalysis, but we don't; // preserve AA currently so that is dangerous. Be super safe and just; // check there are no other memory operations at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:653,Safety,safe,safe,653,"// Check that sinking the store won't cause program behavior changes. Sinking; // the store out of the Q blocks won't change any behavior as we're sinking; // from a block to its unconditional successor. But we're moving a store from; // the P blocks down through the middle block (QBI) and past both QFB and QTB.; // So we need to check that there are no aliasing loads or stores in; // QBI, QTB and QFB. We also need to check there are no conflicting memory; // operations between PStore and the end of its parent block.; //; // The ideal way to do this is to query AliasAnalysis, but we don't; // preserve AA currently so that is dangerous. Be super safe and just; // check there are no other memory operations at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:44,Performance,optimiz,optimize,44,"// If we're not in aggressive mode, we only optimize if we have some; // confidence that by optimizing we'll allow P and/or Q to be if-converted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:92,Performance,optimiz,optimizing,92,"// If we're not in aggressive mode, we only optimize if we have some; // confidence that by optimizing we'll allow P and/or Q to be if-converted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:197,Safety,safe,safe,197,"// Choose the minimum alignment. If we could prove both stores execute, we; // could use biggest one. In this case, though, we only know that one of the; // stores executes. And we don't know it's safe to take the alignment from a; // store that doesn't execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:422,Energy Efficiency,reduce,reduce,422,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:576,Performance,optimiz,optimization,576,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:625,Testability,test,test-and-set,625,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:704,Usability,simpl,simple,704,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:81,Usability,clear,clear,81,// set_intersect mutates PStoreAddresses in place. Rename it here to make it; // clear what it contains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:222,Safety,safe,safety,222,"/// If the previous block ended with a widenable branch, determine if reusing; /// the target block is profitable and legal. This will have the effect of; /// ""widening"" PBI, but doesn't require us to reason about hosting safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:103,Usability,simpl,simply,103,// TODO: This can be generalized in two important ways:; // 1) We can allow phi nodes in IfFalseBB and simply reuse all the input; // values from the PBI edge.; // 2) We can sink side effecting instructions into BI's fallthrough; // successor provided they doesn't contribute to computation of; // BI's condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:23,Safety,avoid,avoid,23,// TODO; // This helps avoid infinite loop with SimplifyCondBranchToCondBranch which; // may undo the transform done here.; // TODO: There might be a more fine-grained solution to this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:48,Usability,Simpl,SimplifyCondBranchToCondBranch,48,// TODO; // This helps avoid infinite loop with SimplifyCondBranchToCondBranch which; // may undo the transform done here.; // TODO: There might be a more fine-grained solution to this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:93,Usability,undo,undo,93,// TODO; // This helps avoid infinite loop with SimplifyCondBranchToCondBranch which; // may undo the transform done here.; // TODO: There might be a more fine-grained solution to this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:99,Usability,simpl,simplify,99,"/// If we have a conditional branch as a predecessor of another block,; /// this function tries to simplify it. We know; /// that PBI and BI are both conditional branches, and BI is in one of the; /// successor blocks of PBI - PBI branches to BI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:161,Availability,redundant,redundant,161,"// If this block ends with a branch instruction, and if there is a; // predecessor that ends on a branch of the same condition, make; // this conditional branch redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:161,Safety,redund,redundant,161,"// If this block ends with a branch instruction, and if there is a; // predecessor that ends on a branch of the same condition, make; // this conditional branch redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:219,Safety,safe,safety,219,"// If the previous block ended with a widenable branch, determine if reusing; // the target block is profitable and legal. This will have the effect of; // ""widening"" PBI, but doesn't require us to reason about hosting safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:164,Testability,log,logical,164,"// If this is a conditional branch in an empty block, and if any; // predecessors are a conditional branch to one of our destinations,; // fold the conditions into logical ops and one cond br.; // Ignore dbg intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:10,Performance,perform,perform,10,"// Do not perform this transformation if it would require; // insertion of a large number of select instructions. For targets; // without predication/cmovs, this is a big pessimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:54,Testability,log,logical,54,"// Finally, if everything is ok, fold the branches to logical ops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:199,Safety,avoid,avoids,199,"// If OtherDest *is* BB, then BB is a basic block with a single conditional; // branch in it, where one edge (OtherDest) goes back to itself but the other; // exits. We don't *know* that the program avoids the infinite loop; // (even though that seems likely). If we do this xform naively, we'll end up; // recursively unpeeling the loop. Since we know that (after the xform is; // done) that the block *is* infinite if reached, we just make it an obviously; // infinite loop with no cond branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update branch weight for PBI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:151,Testability,log,logical,151,"// Although the select has the same condition as PBI, the original branch; // weights for PBI do not apply to the new select because the select's; // 'logical' edges are incoming edges of the phi that is eliminated, not; // the outgoing edges of PBI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Usability,Simpl,Simplifies,3,// Simplifies a terminator by replacing it with a branch to TrueBB if Cond is; // true or to FalseBB if Cond is false.; // Takes care of updating the successors and removing the old terminator.; // Also makes sure not to introduce new successors by assuming that edges to; // non-successor TrueBBs and FalseBBs aren't reachable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Perform,Perform,3,// Perform the actual simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:22,Usability,simpl,simplification,22,// Perform the actual simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Perform,Perform,3,// Perform the actual simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:22,Usability,simpl,simplification,22,// Perform the actual simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:261,Usability,simpl,simplified,261,"/// This is called when we find an icmp instruction; /// (a seteq/setne with a constant) as the only instruction in a; /// block that ends with an uncond branch. We are looking for a very specific; /// pattern that occurs when ""A == 1 || A == 2 || A == 3"" gets simplified. In; /// this case, we merge the first two ""or's of icmp"" into a switch, but then the; /// default value goes to an uncond block with a seteq in it, we get something; /// like:; ///; /// switch i8 %A, label %DEFAULT [ i8 1, label %end i8 2, label %end ]; /// DEFAULT:; /// %tmp = icmp eq i8 %A, 92; /// br label %end; /// end:; /// ... = phi i1 [ true, %entry ], [ %tmp, %DEFAULT ], [ true, %entry ]; ///; /// We prefer to split the edge to 'end' so that there is a true/false entry to; /// the PHI, merging the third icmp into the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:204,Usability,simpl,simplify,204,// The pattern we're looking for is where our only predecessor is a switch on; // 'V' and this block is the default case for the switch. In this case we can; // fold the compared value into the switch to simplify things.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:53,Usability,simpl,simply,53,"// If BB is reachable on a non-default case, then we simply know the value of; // V in this block. Substitute it and constant fold the icmp instruction; // away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:39,Usability,simpl,simplify,39,"// BB is now empty, so it is likely to simplify away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:39,Usability,simpl,simplify,39,"// BB is now empty, so it is likely to simplify away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:87,Integrability,depend,depending,87,// Replace ICI (which is used by the PHI for the default value) with true or; // false depending on if it is EQ or NE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Safety,Avoid,Avoid,3,// Avoid turning single icmps into a switch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:7,Usability,resume,resume,7,// The resume must unwind the exception that caused control to branch here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Usability,Simpl,Simplify,3,// Simplify resume that is shared by several landing pads (phi of landing pad).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Usability,resume,resume,12,// Simplify resume that is shared by several landing pads (phi of landing pad).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:113,Usability,resume,resume,113,// Check that there are no other instructions except for debug and lifetime; // intrinsics between the phi's and resume instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:84,Integrability,depend,dependents,84,"// If the block has other successors, we can not delete it because; // it has other dependents.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Usability,simpl,simplifications,45,"// If no trivial unwind blocks, don't do any simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:23,Usability,simpl,simplified,23,"// Blocks that will be simplified should be removed from the phi node.; // Note there could be multiple edges to the resume block, and we need; // to remove them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:117,Usability,resume,resume,117,"// Blocks that will be simplified should be removed from the phi node.; // Note there could be multiple edges to the resume block, and we need; // to remove them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:11,Usability,Simpl,SimplifyCFG,11,"// In each SimplifyCFG run, only the current processed block can be erased.; // Otherwise, it will break the iteration of SimplifyCFG pass. So instead; // of erasing TrivialBB, we only remove the branch to the common resume; // block so that we can later erase the resume block since it has no; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:122,Usability,Simpl,SimplifyCFG,122,"// In each SimplifyCFG run, only the current processed block can be erased.; // Otherwise, it will break the iteration of SimplifyCFG pass. So instead; // of erasing TrivialBB, we only remove the branch to the common resume; // block so that we can later erase the resume block since it has no; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:217,Usability,resume,resume,217,"// In each SimplifyCFG run, only the current processed block can be erased.; // Otherwise, it will break the iteration of SimplifyCFG pass. So instead; // of erasing TrivialBB, we only remove the branch to the common resume; // block so that we can later erase the resume block since it has no; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:265,Usability,resume,resume,265,"// In each SimplifyCFG run, only the current processed block can be erased.; // Otherwise, it will break the iteration of SimplifyCFG pass. So instead; // of erasing TrivialBB, we only remove the branch to the common resume; // block so that we can later erase the resume block since it has no; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:14,Usability,resume,resume,14,// Delete the resume block if all its predecessors have been removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Usability,Simpl,Simplify,3,// Simplify resume that is only used by a single (non-phi) landing pad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Usability,resume,resume,12,// Simplify resume that is only used by a single (non-phi) landing pad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:183,Deployability,update,updated,183,"// If this is a trivial cleanup pad that executes no instructions, it can be; // eliminated. If the cleanup pad continues to the caller, any predecessor; // that is an EH pad will be updated to continue to the caller and any; // predecessor that terminates with an invoke instruction will have its invoke; // instruction converted to a call instruction. If the cleanup pad being; // simplified does not continue to the caller, each predecessor will be; // updated to continue to the unwind destination of the cleanup pad being; // simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:456,Deployability,update,updated,456,"// If this is a trivial cleanup pad that executes no instructions, it can be; // eliminated. If the cleanup pad continues to the caller, any predecessor; // that is an EH pad will be updated to continue to the caller and any; // predecessor that terminates with an invoke instruction will have its invoke; // instruction converted to a call instruction. If the cleanup pad being; // simplified does not continue to the caller, each predecessor will be; // updated to continue to the unwind destination of the cleanup pad being; // simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:383,Usability,simpl,simplified,383,"// If this is a trivial cleanup pad that executes no instructions, it can be; // eliminated. If the cleanup pad continues to the caller, any predecessor; // that is an EH pad will be updated to continue to the caller and any; // predecessor that terminates with an invoke instruction will have its invoke; // instruction converted to a call instruction. If the cleanup pad being; // simplified does not continue to the caller, each predecessor will be; // updated to continue to the unwind destination of the cleanup pad being; // simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:531,Usability,simpl,simplified,531,"// If this is a trivial cleanup pad that executes no instructions, it can be; // eliminated. If the cleanup pad continues to the caller, any predecessor; // that is an EH pad will be updated to continue to the caller and any; // predecessor that terminates with an invoke instruction will have its invoke; // instruction converted to a call instruction. If the cleanup pad being; // simplified does not continue to the caller, each predecessor will be; // updated to continue to the unwind destination of the cleanup pad being; // simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:32,Usability,simpl,simplifying,32,"// If the cleanup return we are simplifying unwinds to the caller, this will; // set UnwindDest to nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:164,Safety,avoid,avoids,164,"// We're about to remove BB from the control flow. Before we do, sink any; // PHINodes into the unwind destination. Doing this before changing the; // control flow avoids some potentially slow checks, since we can currently; // be certain that UnwindDest and BB have no common predecessors (since they; // are both EH pads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:53,Deployability,update,update,53,"// First, go through the PHI nodes in UnwindDest and update any nodes that; // reference the block we are removing",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:148,Modifiability,inherit,inherit,148,"// Otherwise, sink this PHI node into UnwindDest.; // Any predecessors to UnwindDest which are not already represented; // must be back edges which inherit the value from the path through; // BB. In this case, the PHI value must reference itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:85,Safety,safe,safe,85,"// This cleanupret isn't the only predecessor of this cleanuppad, it wouldn't; // be safe to merge without code duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:11,Usability,simpl,simply,11,"// Now, we simply replace the cleanupret with a branch to the unwind; // destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:541,Modifiability,variab,variable,541,"// Can not drop any more instructions. We're done here.; // Otherwise, this instruction can be freely erased,; // even if it is not side-effect free.; // Note that deleting EH's here is in fact okay, although it involves a bit; // of subtle reasoning. If this inst is an EH, all the predecessors of this; // block will be the unwind edges of Invoke/CatchSwitch/CleanupReturn,; // and we can therefore guarantee this block will be erased.; // If we're deleting this, we're deleting any subsequent dbg.values, so; // delete DPValue records of variable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:131,Usability,simpl,simplify,131,"// If the unreachable instruction is the first in the block, take a gander; // at all of the predecessors of this instruction, and simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all preds to unwind to caller (or from invoke to call).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update weight for the newly-created conditional branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Availability,mask,masked,12,/// Compute masked bits for the condition of a switch; /// and use it to remove dead cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Safety,avoid,avoid,3,/* avoid overflow */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:32,Usability,simpl,simplification,32,"/// If BB would be eligible for simplification by; /// TryToSimplifyUncondBranchFromEmptyBlock (i.e. it is empty and terminated; /// by an unconditional branch), look at the phi node for BB in the successor; /// block and see if the incoming value is equal to CaseValue. If so, return; /// the phi node, and set PhiIndex to BB's index in the phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:42,Usability,simpl,simplification,42,// BB must be empty to be a candidate for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:120,Modifiability,variab,variable,120,"// Replace phi operands in successor blocks that are using the constant case; // value rather than the switch condition variable:; // switchbb:; // switch i32 %x, label %default [; // i32 17, label %succ; // ...; // succ:; // %r = phi i32 ... [ 17, %switchbb ] ...; // -->; // %r = phi i32 ... [ %x, %switchbb ] ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:67,Usability,simpl,simple,67,"/// Try to fold instruction I into a constant. This works for; /// simple instructions such as binary operations where both operands are; /// constant or can be replaced by constants from the ConstantPool. Returns the; /// resulting constant on success, 0 otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:26,Usability,simpl,simple,26,"// If the terminator is a simple branch, continue to the next block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:148,Safety,safe,safe,148,"// Instruction is side-effect free and constant.; // If the instruction has uses outside this block or a phi node slot for; // the block, it is not safe to bypass the instruction since it would then; // no longer dominate all its uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:44,Safety,abort,abort,44,"// If the destination isn't the common one, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:98,Deployability,update,updated,98,// Helper function used to add CaseVal to the list of cases that generate; // Result. Returns the updated number of cases that generate this result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:37,Safety,abort,abort,37,// If the default value is not found abort unless the default destination; // is unreachable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:63,Usability,simpl,simple,63,"// If we are selecting between only two cases transform into a simple; // select or a two-way select if default is possible.; // Example:; // switch (a) { %0 = icmp eq i32 %a, 10; // case 10: return 42; %1 = select i1 %0, i32 42, i32 4; // case 20: return 2; ----> %2 = icmp eq i32 %a, 20; // default: return 4; %3 = select i1 %2, i32 2, i32 %1; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Integrability,Depend,Depending,3,"// Depending on the contents of the table, it can be represented in; // different ways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:118,Usability,simpl,simple,118,// For tables where there is a linear relationship between table index; // and values. We calculate the result with a simple multiplication; // and addition instead of a table lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:156,Availability,mask,mask,156,"// For small tables with integer elements, we can pack them into a bitmap; // that fits into a target-legal register. Values are retrieved by; // shift and mask operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:70,Performance,load,load,70,// The table is stored as an array of values. Values are retrieved by load; // instructions from the table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:64,Performance,load,loading,64,// Set the alignment to that of an array items. We will be only loading one; // value out of it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:161,Safety,safe,safe,161,"// Cast Index to the same type as the bitmap.; // Note: The Index is <= the number of elements in the table, so; // truncating it to the width of the bitmask is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:9,Availability,down,down,9,// Shift down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Availability,Mask,Mask,3,// Mask off.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:127,Safety,Avoid,Avoid,127,"// FIXME: If the type is wider than it needs to be, e.g. i8 but all values; // are <= 15, we could try to narrow the type.; // Avoid overflow, fitsInLegalInteger uses unsigned int for the width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:14,Energy Efficiency,power,power,14,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:169,Performance,load,loads,169,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:328,Performance,load,load,328,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:401,Performance,load,load,401,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Safety,Avoid,Avoid,3,// Avoid multiplication overflows below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:348,Modifiability,extend,extend,348,"/// Determine whether a lookup table should be built for this switch, based on; /// the number of cases, size of the table, and the types of the results.; // TODO: We could support larger than legal types by limiting based on the; // number of loads required and/or table size. If the constants are small we; // could use smaller table entries and extend after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:244,Performance,load,loads,244,"/// Determine whether a lookup table should be built for this switch, based on; /// the number of cases, size of the table, and the types of the results.; // TODO: We could support larger than legal types by limiting based on the; // number of loads required and/or table size. If the constants are small we; // could use smaller table entries and extend after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:365,Performance,load,load,365,"/// Determine whether a lookup table should be built for this switch, based on; /// the number of cases, size of the table, and the types of the results.; // TODO: We could support larger than legal types by limiting based on the; // number of loads required and/or table size. If the constants are small we; // could use smaller table entries and extend after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:260,Performance,optimiz,optimized,260,/// Try to reuse the switch table index compare. Following pattern:; /// \code; /// if (idx < tablesize); /// r = table[idx]; // table does not contain default_value; /// else; /// r = default_value;; /// if (r != default_value); /// ...; /// \endcode; /// Is optimized to:; /// \code; /// cond = idx < tablesize;; /// if (cond); /// r = table[idx];; /// else; /// r = default_value;; /// if (cond); /// ...; /// \endcode; /// Jump threading will then eliminate the second if(cond).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:66,Usability,simpl,simple,66,"// Check if the branch instruction dominates the phi node. It's a simple; // dominance check, but sufficient for our needs.; // Although this check is invariant in the calling loops, it's better to do it; // at this late stage. Practically we do it at most once for a switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:40,Testability,test,test,40,// As an extra penalty for the validity test we require more cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:37,Testability,benchmark,benchmark,37,// FIXME: Find best threshold value (benchmark).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:110,Modifiability,variab,variable,110,"// If the default destination is unreachable, or if the lookup table covers; // all values of the conditional variable, branch directly to the lookup table; // BB. Otherwise, check that the condition is within the case range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:56,Safety,avoid,avoid,56,"// Grow the table to cover all possible index values to avoid the range check.; // It will use the default result to fill in the table hole later, so make; // sure it exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:138,Availability,mask,mask,138,// Note: We call removeProdecessor later since we need to be able to get the; // PHI value for the default case in case we're using a bit mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Availability,mask,mask,12,// Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid; // unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:49,Energy Efficiency,power,power-of-,49,// Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid; // unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:63,Safety,avoid,avoid,63,// Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid; // unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:6,Performance,cache,cached,6,"// We cached PHINodes in PHIs. To avoid accessing deleted PHINodes later,; // do not delete PHINodes here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:34,Safety,avoid,avoid,34,"// We cached PHINodes in PHIs. To avoid accessing deleted PHINodes later,; // do not delete PHINodes here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:40,Security,access,accessing,40,"// We cached PHINodes in PHIs. To avoid accessing deleted PHINodes later,; // do not delete PHINodes here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:23,Performance,optimiz,optimization,23,// Do a small peephole optimization: re-use the switch table compare if; // possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:185,Energy Efficiency,reduce,reduced,185,"/// Try to transform a switch that has ""holes"" in it to a contiguous sequence; /// of cases.; ///; /// A switch such as: switch(i) {case 5: case 9: case 13: case 17:} can be; /// range-reduced to: switch ((i-5) / 4) {case 0: case 1: case 2: case 3:}.; ///; /// This converts a sparse switch into a dense switch which allows better; /// lowering and could also allow transforming into a lookup table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,Performance,optimiz,optimization,25,// Only bother with this optimization if there are more than 3 switch cases;; // SDAG will only bother creating jump tables for 4 or more cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:140,Performance,optimiz,optimize,140,"// This transform is agnostic to the signedness of the input or case values. We; // can treat the case values as signed or unsigned. We can optimize more common; // cases such as a sequence crossing zero {-4,0,4,8} if we interpret case values; // as signed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:321,Performance,perform,performs,321,"// The obvious transform is to shift the switch condition right and emit a; // check that the condition actually cleanly divided by GCD, i.e.; // C & (1 << Shift - 1) == 0; // inserting a new CFG edge to handle the case where it didn't divide cleanly.; //; // A cheaper way of doing this is a simple ROTR(C, Shift). This performs the; // shift and puts the shifted-off bits in the uppermost bits. If any of these; // are nonzero then the switch condition will be very large and will hit the; // default case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:293,Usability,simpl,simple,293,"// The obvious transform is to shift the switch condition right and emit a; // check that the condition actually cleanly divided by GCD, i.e.; // C & (1 << Shift - 1) == 0; // inserting a new CFG edge to handle the case where it didn't divide cleanly.; //; // A cheaper way of doing this is a simple ROTR(C, Shift). This performs the; // shift and puts the shifted-off bits in the uppermost bits. If any of these; // are nonzero then the switch condition will be very large and will hit the; // default case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:33,Energy Efficiency,power,powers,33,"/// Tries to transform switch of powers of two to reduce switch range.; /// For example, switch like:; /// switch (C) { case 1: case 2: case 64: case 128: }; /// will be transformed to:; /// switch (count_trailing_zeros(C)) { case 0: case 1: case 6: case 7: }; ///; /// This transformation allows better lowering and could allow transforming into; /// a lookup table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:50,Energy Efficiency,reduce,reduce,50,"/// Tries to transform switch of powers of two to reduce switch range.; /// For example, switch like:; /// switch (C) { case 1: case 2: case 64: case 128: }; /// will be transformed to:; /// switch (count_trailing_zeros(C)) { case 0: case 1: case 6: case 7: }; ///; /// This transformation allows better lowering and could allow transforming into; /// a lookup table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,Performance,optimiz,optimization,25,// Only bother with this optimization if there are more than 3 switch cases.; // SDAG will only bother creating jump tables for 4 or more cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:151,Energy Efficiency,power,power,151,// We perform this optimization only for switches with; // unreachable default case.; // This assumtion will save us from checking if `Condition` is a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:6,Performance,perform,perform,6,// We perform this optimization only for switches with; // unreachable default case.; // This assumtion will save us from checking if `Condition` is a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:19,Performance,optimiz,optimization,19,// We perform this optimization only for switches with; // unreachable default case.; // This assumtion will save us from checking if `Condition` is a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:31,Energy Efficiency,power,powers,31,// Check that switch cases are powers of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:184,Deployability,pipeline,pipeline,184,"// Try to transform the switch into an icmp and a branch.; // The conversion from switch to comparison may lose information on; // impossible switch values, so disable it early in the pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:327,Deployability,pipeline,pipeline,327,"// The conversion from switch to lookup tables results in difficult-to-analyze; // code and makes pruning branches much harder. This is a problem if the; // switch expression itself can still be restricted as a result of inlining or; // CVP. Therefore, only apply this transformation during late stages of the; // optimisation pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,Availability,redundant,redundant,13,// Eliminate redundant destinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,Safety,redund,redundant,13,// Eliminate redundant destinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:359,Energy Efficiency,schedul,scheduling,359,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:430,Performance,optimiz,optimizer,430,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:635,Performance,optimiz,optimization,635,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:666,Performance,perform,performing,666,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:716,Performance,optimiz,optimization,716,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:660,Safety,avoid,avoid,660,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:35,Deployability,Update,Update,35,// We've found an identical block. Update our predecessors to take that; // path instead and make ourselves dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:125,Deployability,update,update,125,// The debug info in OtherPred doesn't cover the merged control flow that; // used to go through BB. We need to delete it or update it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:54,Usability,simpl,simplify,54,"// If the Terminator is the only non-phi instruction, simplify the block.; // If LoopHeader is provided, check if the block or its successor is a loop; // header. (This is for early invocations before loop simplify and; // vectorization to keep canonical loop forms for nested loops. These blocks; // can be eliminated when the pass is invoked later in the back-end.); // Note that if BB has only one predecessor then we do not introduce new; // backedge, so we can eliminate BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:206,Usability,simpl,simplify,206,"// If the Terminator is the only non-phi instruction, simplify the block.; // If LoopHeader is provided, check if the block or its successor is a loop; // header. (This is for early invocations before loop simplify and; // vectorization to keep canonical loop forms for nested loops. These blocks; // can be eliminated when the pass is invoked later in the back-end.); // Note that if BB has only one predecessor then we do not introduce new; // backedge, so we can eliminate BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:99,Usability,simpl,simplify,99,"// If the only instruction in the block is a seteq/setne comparison against a; // constant, try to simplify the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:189,Deployability,update,update,189,"// If this basic block is ONLY a compare and a branch, and if a predecessor; // branches to us and our successor, fold the comparison into the; // predecessor and use logical operations to update the incoming value; // for PHI nodes in common successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:167,Testability,log,logical,167,"// If this basic block is ONLY a compare and a branch, and if a predecessor; // branches to us and our successor, fold the comparison into the; // predecessor and use logical operations to update the incoming value; // for PHI nodes in common successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:175,Testability,log,logical,175,"// If this basic block is ONLY a compare and a branch, and if a predecessor; // branches to us and one of our successors, fold the comparison into the; // predecessor and use logical operations to pick the right destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:31,Safety,avoid,avoid,31,"// Only look at the first use, avoid hurting compile time with long uselists",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:24,Performance,load,load,24,// Look through GEPs. A load from a GEP derived from NULL is still undefined,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Load,Load,3,// Load from null is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Usability,simpl,simplify,12,// Repeated simplify BB as long as resimplification is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Perform,Perform,3,// Perform one round of simplifcation. Resimplify flag will be set if; // another iteration is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:24,Usability,simpl,simplifcation,24,// Perform one round of simplifcation. Resimplify flag will be set if; // another iteration is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:39,Modifiability,variab,variable,39,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:414,Modifiability,variab,variable,414,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:555,Modifiability,variab,variables,555,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:8,Usability,Simpl,SimplifyIndVar,8,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:48,Usability,simpl,simplification,48,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:423,Usability,simpl,simplification,423,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:527,Usability,simpl,simplify,527,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:48,Modifiability,variab,variables,48,"/// This is a utility for simplifying induction variables; /// based on ScalarEvolution. It is the primary instrument of the; /// IndvarSimplify pass, but it may also be directly invoked to cleanup after; /// other loop passes that preserve SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:26,Usability,simpl,simplifying,26,"/// This is a utility for simplifying induction variables; /// based on ScalarEvolution. It is the primary instrument of the; /// IndvarSimplify pass, but it may also be directly invoked to cleanup after; /// other loop passes that preserve SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:94,Modifiability,variab,variable,94,/// Iteratively perform simplification on a worklist of users of the; /// specified induction variable. This is the top-level driver that applies; /// all simplifications to users of an IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:16,Performance,perform,perform,16,/// Iteratively perform simplification on a worklist of users of the; /// specified induction variable. This is the top-level driver that applies; /// all simplifications to users of an IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Usability,simpl,simplification,24,/// Iteratively perform simplification on a worklist of users of the; /// specified induction variable. This is the top-level driver that applies; /// all simplifications to users of an IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:155,Usability,simpl,simplifications,155,/// Iteratively perform simplification on a worklist of users of the; /// specified induction variable. This is the top-level driver that applies; /// all simplifications to users of an IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:72,Safety,safe,safely,72,"/// Find a point in code which dominates all given instructions. We can safely; /// assume that, whatever fact we can prove at the found point, this fact is; /// also true for each of the given instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:266,Modifiability,variab,variable,266,"/// Fold an IV operand into its use. This removes increments of an; /// aligned IV when used by a instruction that ignores the low bits.; ///; /// IVOperand is guaranteed SCEVable, but UseInst may not be.; ///; /// Return the operand of IVOperand for this induction variable if IVOperand can; /// be folded (in case more folding opportunities have been exposed).; /// Otherwise return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:353,Security,expose,exposed,353,"/// Fold an IV operand into its use. This removes increments of an; /// aligned IV when used by a instruction that ignores the low bits.; ///; /// IVOperand is guaranteed SCEVable, but UseInst may not be.; ///; /// Return the operand of IVOperand for this induction variable if IVOperand can; /// be folded (in case more folding opportunities have been exposed).; /// Otherwise return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:89,Modifiability,variab,variable,89,/// SimplifyIVUsers helper for eliminating useless; /// comparisons against an induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:4,Usability,Simpl,SimplifyIVUsers,4,/// SimplifyIVUsers helper for eliminating useless; /// comparisons against an induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:143,Performance,optimiz,optimizations,143,"// If we were unable to make anything above, all we can is to canonicalize; // the comparison hoping that it will open the doors for other; // optimizations. If we find out that we compare two non-negative values,; // we turn the instruction's predicate to its unsigned version. Note that; // we cannot rely on Pred here unless we check if we have swapped it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:3,Usability,Simpl,Simplify,3,// Simplify unnecessary loops away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:103,Modifiability,variab,variable,103,/// SimplifyIVUsers helper for eliminating useless remainder operations; /// operating on an induction variable or replacing srem by urem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:4,Usability,Simpl,SimplifyIVUsers,4,/// SimplifyIVUsers helper for eliminating useless remainder operations; /// operating on an induction variable or replacing srem by urem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:3,Usability,Simpl,Simplify,3,// Simplify unnecessary loops away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:682,Performance,optimiz,optimizations,682,"// It is always legal to replace; // icmp <pred> i32 trunc(iv), n; // with; // icmp <pred> i64 sext(trunc(iv)), sext(n), if pred is signed predicate.; // Or with; // icmp <pred> i64 zext(trunc(iv)), zext(n), if pred is unsigned predicate.; // Or with either of these if pred is an equality predicate.; //; // If we can prove that iv == sext(trunc(iv)) or iv == zext(trunc(iv)) for; // every comparison which uses trunc, it means that we can replace each of; // them with comparison of iv against sext/zext(n). We no longer need trunc; // after that.; //; // TODO: Should we do this if we can widen *some* comparisons, but not all; // of them? Sometimes it is enough to enable other optimizations, but the; // trunc instruction will stay in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Safety,safe,safely,24,"// For equality, we can safely zext both parts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:43,Usability,simpl,simple,43,"/// Eliminate an operation that consumes a simple IV and has no observable; /// side-effect given the range of IV values. IVOperand is guaranteed SCEVable,; /// but UseInst may not be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:66,Safety,safe,safe,66,/// Replace the UseInst with a loop invariant expression if it is safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:14,Availability,redundant,redundant,14,/// Eliminate redundant type cast between integer and float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:14,Safety,redund,redundant,14,/// Eliminate redundant type cast between integer and float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Testability,log,logic,24,"// To match InstCombine logic, we only need sext if both fptosi and; // sitofp are used. If one of them is unsigned, then we can use zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:105,Performance,perform,performing,105,"// The getStrengthenedNoWrapFlagsFromBinOp() check inferred additional nowrap; // flags on addrecs while performing zero/sign extensions. We could call; // forgetValue() here to make sure those flags also propagate to any other; // SCEV expressions based on the addrec. However, this can have pathological; // compile-time impact, see https://bugs.llvm.org/show_bug.cgi?id=50384.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:3,Safety,Avoid,Avoid,3,"// Avoid infinite or exponential worklist processing.; // Also ensure unique worklist users.; // If Def is a LoopPhi, it may not be in the Simplified set, so check for; // self edges first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:139,Usability,Simpl,Simplified,139,"// Avoid infinite or exponential worklist processing.; // Also ensure unique worklist users.; // If Def is a LoopPhi, it may not be in the Simplified set, so check for; // self edges first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:48,Usability,simpl,simple,48,/// Return true if this instruction generates a simple SCEV; /// expression in terms of that IV.; ///; /// This is similar to IVUsers' isInteresting() but processes each instruction; /// non-recursively when the operand is already known to be a simpleIVUser.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:245,Usability,simpl,simpleIVUser,245,/// Return true if this instruction generates a simple SCEV; /// expression in terms of that IV.; ///; /// This is similar to IVUsers' isInteresting() but processes each instruction; /// non-recursively when the operand is already known to be a simpleIVUser.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:459,Availability,down,down,459,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:94,Modifiability,variab,variable,94,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:379,Modifiability,variab,variables,379,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:16,Performance,perform,perform,16,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:513,Performance,optimiz,optimization,513,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Usability,simpl,simplification,24,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:120,Usability,simpl,simplification,120,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:199,Usability,simpl,simplification,199,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:287,Usability,simpl,simplifies,287,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:507,Usability,clear,clear,507,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:29,Usability,Simpl,SimplifyIndvar,29,// Instructions processed by SimplifyIndvar for CurrIV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Safety,avoid,avoid,24,// Bypass back edges to avoid extra work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:69,Usability,simpl,simplifications,69,// Try to replace UseInst with a loop invariant before any other; // simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:6,Performance,queue,queue,6,// re-queue uses of the now modified binary operator and fall; // through to the checks that remain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:6,Performance,queue,queue,6,// Re-queue the potentially new direct uses of IVOperand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:50,Modifiability,variab,variable,50,/// Simplify instructions that use this induction variable; /// by using ScalarEvolution to analyze the IV's recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:4,Usability,Simpl,Simplify,4,/// Simplify instructions that use this induction variable; /// by using ScalarEvolution to analyze the IV's recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:32,Modifiability,variab,variables,32,/// Simplify users of induction variables within this; /// loop. This does not actually change or add IVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:4,Usability,Simpl,Simplify,4,/// Simplify users of induction variables within this; /// loop. This does not actually change or add IVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:101,Modifiability,Variab,Variables,101,//===----------------------------------------------------------------------===//; // Widen Induction Variables - Extend the width of an IV to cover its; // widest uses.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:113,Modifiability,Extend,Extend,113,//===----------------------------------------------------------------------===//; // Widen Induction Variables - Extend the width of an IV to cover its; // widest uses.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:101,Safety,avoid,avoid,101,// Does the module have any calls to the llvm.experimental.guard intrinsic; // at all? If not we can avoid scanning instructions looking for guards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:22,Integrability,depend,dependent,22,// A map with control-dependent ranges for post increment IV uses. The key is; // a pair of IV def and a use of this def denoting the context. The value is; // a ConstantRange representing possible values of the def at the given; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:132,Safety,avoid,avoids,132,/// Record a link in the Narrow IV def-use chain along with the WideIV that; /// computes the same value as the Narrow IV def. This avoids caching Use*; /// pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:148,Safety,safe,safely,148,/// Instantiate a wide operation to replace a narrow operation. This only needs; /// to handle operations that can evaluation to SCEVAddRec. It can safely return; /// 0 for any operation we decide not to clone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:271,Modifiability,extend,extending,271,"// We're trying to find X such that; //; // Widen(NarrowDef `op` NonIVNarrowDef) == WideAR == WideDef `op.wide` X; //; // We guess two solutions to X, sext(NonIVNarrowDef) and zext(NonIVNarrowDef),; // and check using SCEV if any of them are correct.; // Returns true if extending NonIVNarrowDef according to `SignExt` is a; // correct solution to X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:7,Integrability,wrap,wrap,7,"/// No-wrap operations can transfer sign extension of their result to their; /// operands. Generate the SCEV value for the widened operation without; /// actually modifying the IR yet. If the expression after extending the; /// operands is an AddRec for this loop, return the AddRec and the kind of; /// extension used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:209,Modifiability,extend,extending,209,"/// No-wrap operations can transfer sign extension of their result to their; /// operands. Generate the SCEV value for the widened operation without; /// actually modifying the IR yet. If the expression after extending the; /// operands is an AddRec for this loop, return the AddRec and the kind of; /// extension used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:44,Modifiability,extend,extended,44,// One operand (NarrowDef) has already been extended to WideDef. Now determine; // if extending the other will lead to a recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:86,Modifiability,extend,extending,86,// One operand (NarrowDef) has already been extended to WideDef. Now determine; // if extending the other will lead to a recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:104,Modifiability,extend,extend,104,"// For a non-negative NarrowDef, we can choose either type of; // extension. We want to use the current extend kind if legal; // (see above), and we only hit this code if we need to check; // the opposite case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:150,Integrability,wrap,wrap,150,"// When creating this SCEV expr, don't apply the current operations NSW or NUW; // flags. This instruction may be guarded by control flow that the no-wrap; // behavior depends on. Non-control-equivalent instructions can be mapped to; // the same SCEV expression, and it would be incorrect to transfer NSW/NUW; // semantics to those operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:168,Integrability,depend,depends,168,"// When creating this SCEV expr, don't apply the current operations NSW or NUW; // flags. This instruction may be guarded by control flow that the no-wrap; // behavior depends on. Non-control-equivalent instructions can be mapped to; // the same SCEV expression, and it would be incorrect to transfer NSW/NUW; // semantics to those operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:130,Modifiability,extend,extend,130,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:262,Modifiability,extend,extended,262,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:346,Modifiability,Extend,ExtendKind,346,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:140,Safety,safe,safely,140,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:60,Usability,simpl,simplification,60,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:113,Modifiability,extend,extend,113,"/// If the narrow use is a compare instruction, then widen the compare; // (and possibly the other operand). The extend operation is hoisted into the; // loop preheader as far as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:277,Modifiability,extend,extending,277,"// We can legally widen the comparison in the following two cases:; //; // - The signedness of the IV extension and comparison match; //; // - The narrow IV is always positive (and thus its sign extension is equal; // to its zero extension). For instance, let's say we're zero extending; // %narrow for the following use; //; // icmp slt i32 %narrow, %val ... (A); //; // and %narrow is always positive. Then; //; // (A) == icmp slt i32 sext(%narrow), sext(%val); // == icmp slt i32 zext(%narrow), sext(%val)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:438,Modifiability,extend,extended,438,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:827,Modifiability,extend,extended,827,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:210,Performance,load,load,210,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:18,Safety,avoid,avoids,18,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:310,Safety,avoid,avoid,310,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:173,Modifiability,extend,extend,173,// Check that all uses are either:; // - narrow def (in case of we are widening the IV increment);; // - single-input LCSSA Phis;; // - comparison of the chosen type;; // - extend of the chosen type (raison d'etre).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:148,Modifiability,extend,extend,148,"// We have 3 types of predicates: signed, unsigned and equality; // predicates. For equality, it's legal to widen icmp for either sign and; // zero extend. For sign extend, we can also do so for signed predicates,; // likeweise for zero extend we can widen icmp for unsigned predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:165,Modifiability,extend,extend,165,"// We have 3 types of predicates: signed, unsigned and equality; // predicates. For equality, it's legal to widen icmp for either sign and; // zero extend. For sign extend, we can also do so for signed predicates,; // likeweise for zero extend we can widen icmp for unsigned predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:237,Modifiability,extend,extend,237,"// We have 3 types of predicates: signed, unsigned and equality; // predicates. For equality, it's legal to widen icmp for either sign and; // zero extend. For sign extend, we can also do so for signed predicates,; // likeweise for zero extend we can widen icmp for unsigned predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:62,Integrability,wrap,wrap,62,"// Because InstCombine turns 'sub nuw' to 'add' losing the no-wrap flag, we; // will most likely not see it. Let's try to prove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:65,Usability,Simpl,SimplifyCFG,65,"// For LCSSA phis, sink the truncate outside the loop.; // After SimplifyCFG most loop exit targets have a single predecessor.; // Otherwise fall back to a truncate within the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:55,Testability,log,logical,55,// Widening the PHI requires us to insert a trunc. The logical place; // for this trunc is in the same BB as the PHI. This is not possible if; // the BB is terminated by a catchswitch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:11,Modifiability,extend,extend,11,// A wider extend was hidden behind a narrower one. This may induce; // another round of IV widening in which the intermediate IV becomes; // dead. It should be very rare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:16,Modifiability,extend,extend,16,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:43,Security,expose,expose,43,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:86,Usability,simpl,simplification,86,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:135,Usability,Simpl,SimplifyIVUsers,135,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:76,Modifiability,extend,extended,76,"// Evaluation of WideAddRec ensured that the narrow expression could be; // extended outside the loop without overflow. This suggests that the wide use; // evaluates to the same expression as the extended narrow use, but doesn't; // absolutely guarantee it. Hence the following failsafe check. In rare cases; // where it fails, we simply throw away the newly created wide use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:196,Modifiability,extend,extended,196,"// Evaluation of WideAddRec ensured that the narrow expression could be; // extended outside the loop without overflow. This suggests that the wide use; // evaluates to the same expression as the extended narrow use, but doesn't; // absolutely guarantee it. Hence the following failsafe check. In rare cases; // where it fails, we simply throw away the newly created wide use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:331,Usability,simpl,simply,331,"// Evaluation of WideAddRec ensured that the narrow expression could be; // extended outside the loop without overflow. This suggests that the wide use; // evaluates to the same expression as the extended narrow use, but doesn't; // absolutely guarantee it. Hence the following failsafe check. In rare cases; // where it fails, we simply throw away the newly created wide use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:74,Performance,perform,performance,74,"// We are here about to generate a truncate instruction that may hurt; // performance because the scalar evolution expression computed earlier; // in WideAddRec.first does not indicate a polynomial induction expression.; // In that case, look at the operands of the use instruction to determine; // if we can still widen the use instead of truncating its operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:27,Integrability,depend,dependent,27,// We might have a control-dependent range information for this context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:31,Modifiability,variab,variable,31,"/// Process a single induction variable. First use the SCEVExpander to create a; /// wide induction variable that evaluates to the same recurrence as the; /// original narrow IV. Then use a worklist to forward traverse the narrow IV's; /// def-use chain. After widenIVUse has processed all interesting IV users, the; /// narrow IV will be isolated for removal by DeleteDeadPHIs.; ///; /// It would be simpler to delete uses as they are processed, but we must avoid; /// invalidating SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:100,Modifiability,variab,variable,100,"/// Process a single induction variable. First use the SCEVExpander to create a; /// wide induction variable that evaluates to the same recurrence as the; /// original narrow IV. Then use a worklist to forward traverse the narrow IV's; /// def-use chain. After widenIVUse has processed all interesting IV users, the; /// narrow IV will be isolated for removal by DeleteDeadPHIs.; ///; /// It would be simpler to delete uses as they are processed, but we must avoid; /// invalidating SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:459,Safety,avoid,avoid,459,"/// Process a single induction variable. First use the SCEVExpander to create a; /// wide induction variable that evaluates to the same recurrence as the; /// original narrow IV. Then use a worklist to forward traverse the narrow IV's; /// def-use chain. After widenIVUse has processed all interesting IV users, the; /// narrow IV will be isolated for removal by DeleteDeadPHIs.; ///; /// It would be simpler to delete uses as they are processed, but we must avoid; /// invalidating SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:401,Usability,simpl,simpler,401,"/// Process a single induction variable. First use the SCEVExpander to create a; /// wide induction variable that evaluates to the same recurrence as the; /// original narrow IV. Then use a worklist to forward traverse the narrow IV's; /// def-use chain. After widenIVUse has processed all interesting IV users, the; /// narrow IV will be isolated for removal by DeleteDeadPHIs.; ///; /// It would be simpler to delete uses as they are processed, but we must avoid; /// invalidating SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:28,Modifiability,variab,variable,28,// Is this phi an induction variable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:23,Modifiability,variab,variable,23,// Widen the induction variable expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:17,Modifiability,extend,extended,17,// Can the IV be extended outside the loop without overflow?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:189,Integrability,depend,dependent,189,"// Iterate over IV uses (including transitive ones) looking for IV increments; // of the form 'add nsw %iv, <const>'. For each increment and each use of; // the increment calculate control-dependent range information basing on; // dominating conditions inside of the loop (e.g. a range check inside of the; // loop). Calculated ranges are stored in PostIncRangeInfos map.; //; // Control-dependent range information is later used to prove that a narrow; // definition is not negative (see pushNarrowIVUsers). It's difficult to do; // this on demand because when pushNarrowIVUsers needs this information some; // of the dominating conditions might be already widened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:388,Integrability,depend,dependent,388,"// Iterate over IV uses (including transitive ones) looking for IV increments; // of the form 'add nsw %iv, <const>'. For each increment and each use of; // the increment calculate control-dependent range information basing on; // dominating conditions inside of the loop (e.g. a range check inside of the; // loop). Calculated ranges are stored in PostIncRangeInfos map.; //; // Control-dependent range information is later used to prove that a narrow; // definition is not negative (see pushNarrowIVUsers). It's difficult to do; // this on demand because when pushNarrowIVUsers needs this information some; // of the dominating conditions might be already widened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:7,Modifiability,rewrite,rewriter,7,"// The rewriter provides a value for the desired IV expression. This may; // either find an existing phi or materialize a new one. Either way, we; // expect a well-formed cyclic phi-with-increments. i.e. any operand not part; // of the phi-SCC dominates the loop entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:23,Integrability,depend,dependent,23,/// Calculates control-dependent range for the given def at the given context; /// by looking at dominating conditions inside of the loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:12,Usability,Simpl,SimplifyLibCalls,12,"//===------ SimplifyLibCalls.cpp - Library calls simplifier ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the library calls simplifier. It does not implement; // any pass, but can't be used by other passes to do simplifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:49,Usability,simpl,simplifier,49,"//===------ SimplifyLibCalls.cpp - Library calls simplifier ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the library calls simplifier. It does not implement; // any pass, but can't be used by other passes to do simplifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:422,Usability,simpl,simplifier,422,"//===------ SimplifyLibCalls.cpp - Library calls simplifier ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the library calls simplifier. It does not implement; // any pass, but can't be used by other passes to do simplifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:510,Usability,simpl,simplifications,510,"//===------ SimplifyLibCalls.cpp - Library calls simplifier ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the library calls simplifier. It does not implement; // any pass, but can't be used by other passes to do simplifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:327,Safety,avoid,avoids,327,"// Convert the entire string Str representing an integer in Base, up to; // the terminating nul if present, to a constant according to the rules; // of strtoul[l] or, when AsSigned is set, of strtol[l]. On success; // return the result, otherwise null.; // The function assumes the string is encoded in ASCII and carefully; // avoids converting sequences (including """") that the corresponding; // library call might fail and set errno for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:151,Integrability,wrap,wrapped,151,"// Copy CallInst ""flags"" like musttail, notail, and tail. Return New param for; // easier chaining. Calls to emit* and B.createCall should probably be wrapped; // in this function when New is created to replace Old. Callers should take; // care to check Old.isMustTailCall() if they aren't replacing Old directly; // with New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:13,Safety,avoid,avoid,13,// Helper to avoid truncating the length if size_t is 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:116,Performance,Optimiz,Optimizations,116,//===----------------------------------------------------------------------===//; // String and Memory Library Call Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:33,Usability,simpl,simple,33,"// Unbias length.; // Handle the simple, do-nothing case: strcat(x, """") -> x",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:12,Performance,optimiz,optimize,12,// We don't optimize this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:75,Performance,optimiz,optimized,75,"// strncat(x, s, c) -> strcat(x, s); // s is constant so the strcat can be optimized further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:74,Availability,avail,available,74,"// Try to expand strrchr to the memrchr nonstandard extension if it's; // available, or simply fail otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:88,Usability,simpl,simply,88,"// Try to expand strrchr to the memrchr nonstandard extension if it's; // available, or simply fail otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize a memcmp or, when StrNCmp is true, strncmp call CI with constant; // arrays LHS and RHS and nonconstant Size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Safety,Avoid,Avoid,3,// Avoid truncating the 64-bit Length to 32 bits in ILP32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize a call to size_t strlcpy(char*, const char*, size_t).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:129,Safety,avoid,avoid,129,"// Try to determine the length of the source, substituting its size; // when it's not nul-terminated (as it's required to be) to avoid; // reading past its end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize a call CI to either stpncpy when RetEnd is true, or to strncpy; // otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:29,Security,access,access,29,"// Both st{p,r}ncpy(D, S, N) access the source and destination arrays; // only when N is nonzero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:421,Performance,optimiz,optimization,421,"// If s is a constant pointer pointing to a string literal, we can fold; // strlen(s + x) to strlen(s) - x, when x is known to be in the range; // [0, strlen(s)] or the string has a single null terminator '\0' at the end.; // We only try to simplify strlen when the pointer s points to an array; // of CharSize elements. Otherwise, we would need to scale the offset x before; // doing the subtraction. This will make the optimization more complex, and; // it's not very useful because calling strlen for a pointer of other types is; // very uncommon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:241,Usability,simpl,simplify,241,"// If s is a constant pointer pointing to a string literal, we can fold; // strlen(s + x) to strlen(s) - x, when x is known to be in the range; // [0, strlen(s)] or the string has a single null terminator '\0' at the end.; // We only try to simplify strlen when the pointer s points to an array; // of CharSize elements. Otherwise, we would need to scale the offset x before; // doing the subtraction. This will make the optimization more complex, and; // it's not very useful because calling strlen for a pointer of other types is; // very uncommon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:77,Performance,optimiz,optimize,77,"// If Offset is not provably in the range [0, NullTermIdx], we can still; // optimize if we can prove that the program has undefined behavior when; // Offset is outside that range. That is the case when GEP->getOperand(0); // is a pointer to an object whose memory extent is NullTermIdx+1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:13,Performance,perform,perform,13,// We cannot perform this optimization without wchar_size metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:26,Performance,optimiz,optimization,26,// We cannot perform this optimization without wchar_size metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:22,Security,access,accesses,22,// Punt out-of-bounds accesses to sanitizers and/or libc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:34,Security,sanitiz,sanitizers,34,// Punt out-of-bounds accesses to sanitizers and/or libc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:40,Performance,load,load,40,"// S is dereferenceable so it's safe to load from it and fold; // memchr(S, C, N) == S to N && *S == C for any C and N.; // TODO: This is safe even for nonconstant S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:32,Safety,safe,safe,32,"// S is dereferenceable so it's safe to load from it and fold; // memchr(S, C, N) == S to N && *S == C for any C and N.; // TODO: This is safe even for nonconstant S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:138,Safety,safe,safe,138,"// S is dereferenceable so it's safe to load from it and fold; // memchr(S, C, N) == S to N && *S == C for any C and N.; // TODO: This is safe even for nonconstant S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:18,Modifiability,variab,variable,18,"// If the char is variable but the input str and length are not we can turn; // this memchr call into a simple bit field test. Of course this only works; // when the return value is only checked against null.; //; // It would be really nice to reuse switch lowering here but we can't change; // the CFG at this point.; //; // memchr(""\r\n"", C, 2) != nullptr -> (1 << C & ((1 << '\r') | (1 << '\n'))); // != 0; // after bounds check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:121,Testability,test,test,121,"// If the char is variable but the input str and length are not we can turn; // this memchr call into a simple bit field test. Of course this only works; // when the return value is only checked against null.; //; // It would be really nice to reuse switch lowering here but we can't change; // the CFG at this point.; //; // memchr(""\r\n"", C, 2) != nullptr -> (1 << C & ((1 << '\r') | (1 << '\n'))); // != 0; // after bounds check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:104,Usability,simpl,simple,104,"// If the char is variable but the input str and length are not we can turn; // this memchr call into a simple bit field test. Of course this only works; // when the return value is only checked against null.; //; // It would be really nice to reuse switch lowering here but we can't change; // the CFG at this point.; //; // memchr(""\r\n"", C, 2) != nullptr -> (1 << C & ((1 << '\r') | (1 << '\n'))); // != 0; // after bounds check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:17,Performance,optimiz,optimization,17,// Restrict this optimization to profitable cases with one or two range; // checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:27,Energy Efficiency,power,power-of-,27,// For the bit field use a power-of-2 type with at least 8 bits to avoid; // creating unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:67,Safety,avoid,avoid,67,// For the bit field use a power-of-2 type with at least 8 bits to avoid; // creating unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:51,Availability,mask,mask,51,"// Adjust width of ""C"" to the bitfield width, then mask off the high bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:34,Security,access,access,34,// First check that the bit field access is within bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize a memcmp or, when StrNCmp is true, strncmp call CI with constant; // arrays LHS and RHS and nonconstant Size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,// Optimize a memcmp call CI with constant size Len.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:28,Performance,load,loads,28,"// Don't generate unaligned loads. If either source is constant data,; // alignment doesn't matter for that source because there is no load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:135,Performance,load,load,135,"// Don't generate unaligned loads. If either source is constant data,; // alignment doesn't matter for that source because there is no load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:8,Usability,simpl,simplifications,8,// Most simplifications for memcmp also apply to bcmp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:71,Energy Efficiency,efficient,efficient,71,"// memcmp(x, y, Len) == 0 -> bcmp(x, y, Len) == 0; // bcmp can be more efficient than memcmp because it only has to know that; // there is a difference, not how different one is to the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Integrability,Wrap,Wrap,3,// Wrap arg 'c' of type int to char,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:98,Performance,Optimiz,Optimizations,98,//===----------------------------------------------------------------------===//; // Math Library Optimizations; //===----------------------------------------------------------------------===//; // Replace a libcall \p CI with a call to intrinsic \p IID,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:153,Usability,simpl,simply,153,"/// Return a variant of Val with float type.; /// Currently this works in two cases: If Val is an FPExtension of a float; /// value to something bigger, simply return the operand.; /// If Val is a ConstantFP but can be converted to a float ConstantFP without; /// loss of precision do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:21,Modifiability,extend,extended,21,// Return a properly extended integer (DstWidth bits wide) if the operation is; // an itofp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:79,Safety,avoid,avoiding,79,"// Make sure that the exponent fits inside an ""int"" of size DstWidth,; // thus avoiding any range issues that FP has not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:792,Availability,avail,available,792,"// Evaluate special cases related to a nested function as the base.; // pow(exp(x), y) -> exp(x * y); // pow(exp2(x), y) -> exp2(x * y); // If exp{,2}() is used only once, it is better to fold two transcendental; // math functions into one. If used again, exp{,2}() would still have to be; // called with the original argument, then keep both original transcendental; // functions. However, this transformation is only safe with fully relaxed; // math semantics, since, besides rounding differences, it changes overflow; // and underflow behavior quite dramatically. For example:; // pow(exp(1000), 0.001) = pow(inf, 0.001) = inf; // Whereas:; // exp(1000 * 0.001) = exp(1); // TODO: Loosen the requirement for fully relaxed math semantics.; // TODO: Handle exp10() when more targets have it available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:419,Safety,safe,safe,419,"// Evaluate special cases related to a nested function as the base.; // pow(exp(x), y) -> exp(x * y); // pow(exp2(x), y) -> exp2(x * y); // If exp{,2}() is used only once, it is better to fold two transcendental; // math functions into one. If used again, exp{,2}() would still have to be; // called with the original argument, then keep both original transcendental; // functions. However, this transformation is only safe with fully relaxed; // math semantics, since, besides rounding differences, it changes overflow; // and underflow behavior quite dramatically. For example:; // pow(exp(1000), 0.001) = pow(inf, 0.001) = inf; // Whereas:; // exp(1000 * 0.001) = exp(1); // TODO: Loosen the requirement for fully relaxed math semantics.; // TODO: Handle exp10() when more targets have it available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:88,Performance,optimiz,optimizePow,88,"// pow(1, inf) is defined to be 1 but exp2(log2(1) * inf) evaluates to NaN.; // Luckily optimizePow has already handled the x == 1 case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:36,Security,access,accesses,36,"// If we have a pow() library call (accesses memory) and we can't guarantee; // that the base is not an infinity, give up:; // pow(-Inf, 0.5) is optionally required to have a result of +Inf (not setting; // errno), but sqrt(-Inf) is required by various standards to set errno.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:110,Performance,optimiz,optimization,110,"// The LLVM intrinsics minnum/maxnum correspond to fmin/fmax. Canonicalize to; // the intrinsics for improved optimization (for example, vectorization).; // No-signed-zeros is implied by the definitions of fmax/fmin themselves.; // From the C standard draft WG14/N1256:; // ""Ideally, fmax would be sensitive to the sign of zero, for example; // fmax(-0.0, +0.0) would return +0; however, implementation in software; // might be impractical.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:30,Testability,log,log,30,"// This is only applicable to log(), log2(), log10().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Testability,log,log,3,"// log(pow(x,y)) -> y*log(x)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:22,Testability,log,log,22,"// log(pow(x,y)) -> y*log(x)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Testability,log,log,3,"// log(exp{,2,10}(y)) -> y*log({e,2,10}); // TODO: There is no exp10() intrinsic yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:27,Testability,log,log,27,"// log(exp{,2,10}(y)) -> y*log({e,2,10}); // TODO: There is no exp10() intrinsic yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Usability,Simpl,Simple,3,// Simple match: the operands of the multiply are identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:124,Usability,simpl,simplified,124,"// If we found a non-repeated factor, we still need to get its square; // root. We then multiply that by the value that was simplified out; // of the square root calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:116,Safety,abort,abort,116,"// Make sure the prototype is as expected, otherwise the rest of the; // function is probably invalid and likely to abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:106,Performance,Optimiz,Optimizations,106,//===----------------------------------------------------------------------===//; // Integer Library Call Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:116,Performance,Optimiz,Optimizations,116,//===----------------------------------------------------------------------===//; // Formatting and IO Library Call Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Availability,Error,Error,3,"// Error reporting calls should be cold, mark them as such.; // This applies even to non-builtin calls: it is only a hint and applies to; // functions that the frontend might not understand as builtins.; // This heuristic was suggested in:; // Improving Static Branch Prediction in a Compiler; // Brian L. Deitrich, Ben-Chung Cheng, Wen-mei W. Hwu; // Proceedings of PACT'98, Oct. 1998, IEEE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:268,Safety,Predict,Prediction,268,"// Error reporting calls should be cold, mark them as such.; // This applies even to non-builtin calls: it is only a hint and applies to; // functions that the frontend might not understand as builtins.; // This heuristic was suggested in:; // Improving Static Branch Prediction in a Compiler; // Brian L. Deitrich, Ben-Chung Cheng, Wen-mei W. Hwu; // Proceedings of PACT'98, Oct. 1998, IEEE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Availability,Toler,Tolerate,3,// Tolerate printf's declared void.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:78,Safety,avoid,avoid,78,// Convert the character to unsigned char before passing it to putchar; // to avoid host-specific sign extension in the IR. Putchar converts; // it to unsigned char regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:78,Safety,avoid,avoid,78,// Convert the character to unsigned char before passing it to putchar; // to avoid host-specific sign extension in the IR. Putchar converts; // it to unsigned char regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize specific format strings.; // printf(""%c"", chr) --> putchar(chr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:17,Performance,optimiz,optimizations,17,"// The remaining optimizations require the format string to be ""%s"" or ""%c""; // and have an extra operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:17,Performance,optimiz,optimizations,17,"// The remaining optimizations require the format string to be ""%s"" or ""%c""; // and have an extra operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:25,Integrability,depend,depend,25,// All the optimizations depend on the format string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:11,Performance,optimiz,optimizations,11,// All the optimizations depend on the format string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:17,Performance,optimiz,optimizations,17,"// The remaining optimizations require the format string to be ""%s"" or ""%c""; // and have an extra operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:9,Modifiability,rewrite,rewrite,9,// Don't rewrite fputs to fwrite when optimising for size because fwrite; // requires more arguments and thus extra MOVs are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:12,Performance,optimiz,optimize,12,// We can't optimize if return value is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:9,Performance,optimiz,optimize,9,// Don't optimize calls that require strict floating point semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:134,Performance,optimiz,optimized,134,// TODO: Split out the code below that operates on FP calls so that; // we can all non-FP calls with the StrictFP attribute to be; // optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:86,Performance,optimiz,optimizeFloatingPointLibCall,86,// Command-line parameter overrides instruction attribute.; // This can't be moved to optimizeFloatingPointLibCall() because it may be; // used by the intrinsic optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:161,Performance,optimiz,optimizations,161,// Command-line parameter overrides instruction attribute.; // This can't be moved to optimizeFloatingPointLibCall() because it may be; // used by the intrinsic optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:15,Usability,simpl,simplify,15,// Also try to simplify calls to fortified library functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:831,Performance,Optimiz,Optimizations,831,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:214,Testability,log,log,214,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:235,Testability,log,log,235,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:240,Testability,log,logf,240,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:246,Testability,log,logl,246,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:258,Testability,log,log,258,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:281,Testability,log,log,281,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:298,Testability,log,log,298,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:311,Testability,log,log,311,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:330,Testability,log,log,330,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:344,Testability,log,log,344,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:364,Testability,log,log,364,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:80,Performance,perform,perform,80,"// If this function takes a flag argument, the implementation may use it to; // perform extra checks. Don't fold into the non-checking variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:124,Availability,avail,availability,124,"// FIXME: We shouldn't be changing ""nobuiltin"" or TLI unavailable calls here.; // Some clang users checked for _chk libcall availability using:; // __has_builtin(__builtin___memcpy_chk); // When compiling with -fno-builtin, this is always true.; // When passing -ffreestanding/-mkernel, which both imply -fno-builtin, we; // end up with fortified libcalls, which isn't acceptable in a freestanding; // environment which only provides their non-fortified counterparts.; //; // Until we change clang and/or teach external users to check for availability; // differently, disregard the ""nobuiltin"" attribute and TLI::has.; //; // PR23093.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:539,Availability,avail,availability,539,"// FIXME: We shouldn't be changing ""nobuiltin"" or TLI unavailable calls here.; // Some clang users checked for _chk libcall availability using:; // __has_builtin(__builtin___memcpy_chk); // When compiling with -fno-builtin, this is always true.; // When passing -ffreestanding/-mkernel, which both imply -fno-builtin, we; // end up with fortified libcalls, which isn't acceptable in a freestanding; // environment which only provides their non-fortified counterparts.; //; // Until we change clang and/or teach external users to check for availability; // differently, disregard the ""nobuiltin"" attribute and TLI::has.; //; // PR23093.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp:33,Performance,optimiz,optimization,33,"//===-- SizeOpts.cpp - code size optimization related code ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared code size optimization related code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp:424,Performance,optimiz,optimization,424,"//===-- SizeOpts.cpp - code size optimization related code ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared code size optimization related code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:565,Performance,optimiz,optimization,565,"//===- SplitModule.cpp - Split a module into partitions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function llvm::SplitModule, which splits a module; // into multiple linkable partitions. It can be used to implement parallel code; // generation for link-time optimization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:25,Performance,queue,queue,25,// Pre-populate priority queue with N slot blanks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:20,Security,hash,hash,20,// Partition by MD5 hash. We only need a few bits for evenness as the number; // of partitions will generally be in the 1-2 figure range; the low 16 bits; // are enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:8,Performance,perform,performs,8,"// This performs splitting without a need for externalization, which might not; // always be possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:41,Deployability,Update,Update,41,"//===- SSAUpdater.cpp - Unstructured SSA Update Tool ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SSAUpdater class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:44,Modifiability,variab,variable,44,"// If there is no definition of the renamed variable in this block, just use; // GetValueAtEndOfBlock to do our work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:68,Availability,avail,available,68,"// Otherwise, we do need a PHI: check to see if we already have one available; // in this block that produces the right value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:44,Availability,avail,available,44,"// Set the DebugLoc of the inserted PHI, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:113,Energy Efficiency,allocate,allocate,113,"/// FindPredecessorBlocks - Put the predecessors of Info->BB into the Preds; /// vector, set Info->NumPreds, and allocate space in Info->Preds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:43,Availability,Avail,AvailableVals,43,"// end namespace llvm; /// Check to see if AvailableVals has an entry for the specified BB and if so,; /// return it. If not, construct SSA form by first calculating the required; /// placement of PHIs and then inserting new PHIs where needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:85,Performance,Load,LoadAndStorePromoter,85,//===----------------------------------------------------------------------===//; // LoadAndStorePromoter Implementation; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:116,Performance,load,loads,116,"// Okay, now we can iterate over all the blocks in the function with uses,; // processing them. Keep track of which loads are loading a live-in value.; // Walk the uses in the use-list order to be determinstic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:126,Performance,load,loading,126,"// Okay, now we can iterate over all the blocks in the function with uses,; // processing them. Keep track of which loads are loading a live-in value.; // Walk the uses in the use-list order to be determinstic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:100,Modifiability,rewrite,rewrite,100,"// Okay, this is the first use in the block. If this block just has a; // single user in it, we can rewrite it trivially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:39,Modifiability,rewrite,rewrite,39,"// Otherwise it is a load, queue it to rewrite as a live-in load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:21,Performance,load,load,21,"// Otherwise it is a load, queue it to rewrite as a live-in load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:27,Performance,queue,queue,27,"// Otherwise it is a load, queue it to rewrite as a live-in load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:60,Performance,load,load,60,"// Otherwise it is a load, queue it to rewrite as a live-in load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:48,Performance,load,loads,48,"// Otherwise, check to see if this block is all loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:71,Energy Efficiency,efficient,efficient,71,"// If so, we can queue them all as live in loads. We don't have an; // efficient way to tell which on is first in the block and don't want to; // scan large blocks, so just add all loads as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:17,Performance,queue,queue,17,"// If so, we can queue them all as live in loads. We don't have an; // efficient way to tell which on is first in the block and don't want to; // scan large blocks, so just add all loads as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:43,Performance,load,loads,43,"// If so, we can queue them all as live in loads. We don't have an; // efficient way to tell which on is first in the block and don't want to; // scan large blocks, so just add all loads as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:181,Performance,load,loads,181,"// If so, we can queue them all as live in loads. We don't have an; // efficient way to tell which on is first in the block and don't want to; // scan large blocks, so just add all loads as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:28,Performance,load,loads,28,"// Otherwise, we have mixed loads and stores (or just a bunch of stores).; // Since SSAUpdater is purely for cross-block values, we need to determine; // the order of these instructions in the block. If the first use in the; // block is a load, then it uses the live in value. The last store defines; // the live out value. We handle this by doing a linear scan of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:239,Performance,load,load,239,"// Otherwise, we have mixed loads and stores (or just a bunch of stores).; // Since SSAUpdater is purely for cross-block values, we need to determine; // the order of these instructions in the block. If the first use in the; // block is a load, then it uses the live in value. The last store defines; // the live out value. We handle this by doing a linear scan of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:16,Performance,load,load,16,"// If this is a load from an unrelated pointer, ignore it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:16,Modifiability,rewrite,rewrite,16,"// Okay, now we rewrite all loads that use live-in values in the loop,; // inserting PHI nodes as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:28,Performance,load,loads,28,"// Okay, now we rewrite all loads that use live-in values in the loop,; // inserting PHI nodes as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:3,Safety,Avoid,Avoid,3,// Avoid assertions in unreachable code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:9,Testability,assert,assertions,9,// Avoid assertions in unreachable code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:250,Deployability,update,updates,250,"// If this is a load that still has uses, then the load must have been added; // as a live value in the SSAUpdate data structure for a block (e.g. because; // the loaded value was stored later). In this case, we need to recursively; // propagate the updates until we get to the real value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:16,Performance,load,load,16,"// If this is a load that still has uses, then the load must have been added; // as a live value in the SSAUpdate data structure for a block (e.g. because; // the loaded value was stored later). In this case, we need to recursively; // propagate the updates until we get to the real value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:51,Performance,load,load,51,"// If this is a load that still has uses, then the load must have been added; // as a live value in the SSAUpdate data structure for a block (e.g. because; // the loaded value was stored later). In this case, we need to recursively; // propagate the updates until we get to the real value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:163,Performance,load,loaded,163,"// If this is a load that still has uses, then the load must have been added; // as a live value in the SSAUpdate data structure for a block (e.g. because; // the loaded value was stored later). In this case, we need to recursively; // propagate the updates until we get to the real value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:13,Availability,down,down,13,"// Propagate down to the ultimate replacee. The intermediately loads; // could theoretically already have been deleted, so we don't want to; // dereference the Value*'s.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:63,Performance,load,loads,63,"// Propagate down to the ultimate replacee. The intermediately loads; // could theoretically already have been deleted, so we don't want to; // dereference the Value*'s.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:45,Deployability,Update,Update,45,"//===- SSAUpdaterBulk.cpp - Unstructured SSA Update Tool ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SSAUpdaterBulk class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:14,Modifiability,variab,variable,14,/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:34,Modifiability,rewrite,rewriter,34,/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:39,Availability,avail,available,39,/// Indicate that a rewritten value is available in the specified block with the; /// specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:57,Deployability,update,updated,57,/// Record a use of the symbolic value. This use will be updated with a; /// rewritten value when RewriteAllUses is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:98,Modifiability,Rewrite,RewriteAllUses,98,/// Record a use of the symbolic value. This use will be updated with a; /// rewritten value when RewriteAllUses is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:30,Deployability,update,updates,30,"/// Perform all the necessary updates, including new PHI-nodes insertion and the; /// requested uses update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:101,Deployability,update,update,101,"/// Perform all the necessary updates, including new PHI-nodes insertion and the; /// requested uses update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:4,Performance,Perform,Perform,4,"/// Perform all the necessary updates, including new PHI-nodes insertion and the; /// requested uses update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite actual uses with the inserted definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp:62,Modifiability,Rewrite,RewriteStatePoints,62,"//===- StripGCRelocates.cpp - Remove gc.relocates inserted by RewriteStatePoints===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a little utility pass that removes the gc.relocates inserted by; // RewriteStatepointsForGC. Note that the generated IR is incorrect,; // but this is useful as a single pass in itself, for analysis of IR, without; // the GC.relocates. The statepoint and gc.result intrinsics would still be; // present.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp:464,Modifiability,Rewrite,RewriteStatepointsForGC,464,"//===- StripGCRelocates.cpp - Remove gc.relocates inserted by RewriteStatePoints===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a little utility pass that removes the gc.relocates inserted by; // RewriteStatepointsForGC. Note that the generated IR is incorrect,; // but this is useful as a single pass in itself, for analysis of IR, without; // the GC.relocates. The statepoint and gc.result intrinsics would still be; // present.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp:154,Usability,clear,clear,154,"// Replace all uses of gc.relocate and delete the gc.relocate; // There maybe unncessary bitcasts back to the OrigPtr type, an instcombine; // pass would clear this up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:549,Deployability,configurat,configuration,549,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:586,Deployability,configurat,configuration,586,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:35,Modifiability,Rewrite,Rewriter,35,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:423,Modifiability,rewrite,rewrite,423,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:523,Modifiability,config,configured,523,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:549,Modifiability,config,configuration,549,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:586,Modifiability,config,configuration,586,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:635,Modifiability,Rewrite,RewriteMapFile,635,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:653,Modifiability,Rewrite,RewriteDescriptors,653,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:676,Modifiability,Rewrite,RewriteDescriptors,676,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:698,Modifiability,Rewrite,RewriteDescriptor,698,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:718,Modifiability,Rewrite,RewriteDescriptors,718,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:741,Modifiability,Rewrite,RewriteDescriptor,741,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:762,Modifiability,Rewrite,RewriteDescriptorType,762,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:792,Modifiability,Rewrite,RewriteDescriptorFields,792,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:824,Modifiability,Rewrite,RewriteDescriptorFields,824,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:851,Modifiability,Rewrite,RewriteDescriptorField,851,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:876,Modifiability,Rewrite,RewriteDescriptorFields,876,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:904,Modifiability,Rewrite,RewriteDescriptorField,904,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:969,Modifiability,Rewrite,RewriteDescriptorType,969,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1402,Modifiability,variab,variable,1402,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1437,Modifiability,variab,variable,1437,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1507,Modifiability,variab,variable,1507,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1864,Modifiability,rewrite,rewrite,1864,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1914,Modifiability,rewrite,rewrite,1914,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1958,Modifiability,extend,extended,1958,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1971,Modifiability,rewrite,rewrite,1971,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2025,Modifiability,Rewrite,RewriteDescriptor,2025,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2044,Modifiability,Rewrite,RewriteDescriptorType,2044,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2171,Modifiability,extend,extending,2171,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2185,Modifiability,rewrite,rewrite,2185,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2222,Modifiability,Rewrite,RewriteMapParser,2222,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2271,Modifiability,rewrite,rewrite,2271,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2303,Modifiability,rewrite,rewrite-symbols,2303,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2392,Modifiability,rewrite,rewrite-map-file,2392,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for an explicitly named (function) symbol. Both the; /// source function name and target function name of the transformation are; /// explicitly spelt out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:57,Modifiability,variab,variable,57,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:96,Modifiability,variab,variable,96,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:121,Modifiability,variab,variable,121,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:189,Modifiability,variab,variables,189,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for an explicitly named global alias. Both the source; /// and target name are explicitly spelt out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for a regular expression based pattern for functions.; /// A pattern for the function name is provided and a transformation for that; /// pattern to determine the target function name create the rewrite rule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:220,Modifiability,rewrite,rewrite,220,/// Represents a rewrite for a regular expression based pattern for functions.; /// A pattern for the function name is provided and a transformation for that; /// pattern to determine the target function name create the rewrite rule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for a global variable based upon a matching pattern.; /// Each global variable matching the provided pattern will be transformed as; /// described in the transformation pattern for the target. Applies only to; /// module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:38,Modifiability,variab,variable,38,/// Represents a rewrite for a global variable based upon a matching pattern.; /// Each global variable matching the provided pattern will be transformed as; /// described in the transformation pattern for the target. Applies only to; /// module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:95,Modifiability,variab,variable,95,/// Represents a rewrite for a global variable based upon a matching pattern.; /// Each global variable matching the provided pattern will be transformed as; /// described in the transformation pattern for the target. Applies only to; /// module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:252,Modifiability,variab,variables,252,/// Represents a rewrite for a global variable based upon a matching pattern.; /// Each global variable matching the provided pattern will be transformed as; /// described in the transformation pattern for the target. Applies only to; /// module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:54,Modifiability,rewrite,rewrite,54,/// PatternRewriteNamedAliasDescriptor - represents a rewrite for global; /// aliases which match a given pattern. The provided transformation will be; /// applied to each of the matching names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:65,Modifiability,rewrite,rewrite,65,// TODO see if there is a more elegant solution to selecting the rewrite; // descriptor type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp:797,Testability,assert,assert,797,"//===- UnifyLoopExits.cpp - Redirect exiting edges to one block -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // For each natural loop with multiple exit blocks, this pass creates a new; // block N such that all exiting blocks now branch to N, and then control flow; // is redistributed to all the original exit blocks.; //; // Limitation: This assumes that all terminators in the CFG are direct branches; // (the ""br"" instruction). The presence of any other control flow; // such as indirectbr, switch or callbr will cause an assert.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp:183,Energy Efficiency,efficient,efficient,183,"// To unify the loop exits, we need a list of the exiting blocks as; // well as exit blocks. The functions for locating these lists both; // traverse the entire loop body. It is more efficient to first; // locate the exiting blocks and then examine their successors to; // locate the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:25,Integrability,Interface,Interface,25,"//===- ValueMapper.cpp - Interface shared by lib/Transforms/Utils ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the MapValue function, which is shared by various parts of; // the lib/Transforms/Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:113,Deployability,update,update,113,"// Post-order traversal.; /// Propagate changed operands through the post-order traversal.; ///; /// Iteratively update \a Data::HasChanged for each node based on \a; /// Data::HasChanged of its operands, until fixed point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:500,Integrability,depend,depends,500,"/// Map a metadata node (and its transitive operands).; ///; /// Map all the (unmapped) nodes in the subgraph under \c N. The iterative; /// algorithm handles distinct nodes and uniqued node subgraphs using; /// different strategies.; ///; /// Distinct nodes are immediately mapped and added to \a DistinctWorklist; /// using \a mapDistinctNode(). Their mapping can always be computed; /// immediately without visiting operands, even if their operands change.; ///; /// The mapping for uniqued nodes depends on whether their operands change.; /// \a mapTopLevelUniquedNode() traverses the transitive uniqued subgraph of; /// a node to calculate uniqued node mappings in bulk. Distinct leafs are; /// added to \a DistinctWorklist with \a mapDistinctNode().; ///; /// After mapping \c N itself, this function remaps the operands of the; /// distinct nodes in \a DistinctWorklist until the entire subgraph under \c; /// N has been mapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:164,Integrability,depend,depending,164,"/// Map all the nodes in the given uniqued graph.; ///; /// This visits all the nodes in \c G in post-order, using the identity; /// mapping or creating a new node depending on \a Data::HasChanged.; ///; /// \pre \a getMappedOp() returns std::nullopt for nodes in \c G, but not for; /// any of their operands outside of \c G. \pre \a Data::HasChanged is true; /// for a node in \c G iff any of its operands have changed. \post \a; /// getMappedOp() returns the mapped node for every node in \c G.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:104,Deployability,update,update,104,/// Remap a node's operands using the given functor.; ///; /// Iterate through the operands of \c N and update them in place using \c; /// mapOperand.; ///; /// \pre N.isDistinct() or N.isTemporary().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:9,Modifiability,variab,variables,9,// Remap variables and DILocations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:99,Safety,avoid,avoid,99,///< Current operand of \c N.; /// Keep a flag of whether operands have changed in the worklist to avoid; /// hitting the map in \a UniquedGraph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:3,Deployability,Update,Update,3,// Update graph with all nodes that have changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:178,Deployability,update,updated,178,"// mapAppendingVariable call can change AppendingInits if initalizer for; // the variable depends on another appending global, because of that inits; // need to be extracted and updated before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:90,Integrability,depend,depends,90,"// mapAppendingVariable call can change AppendingInits if initalizer for; // the variable depends on another appending global, because of that inits; // need to be extracted and updated before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:81,Modifiability,variab,variable,81,"// mapAppendingVariable call can change AppendingInits if initalizer for; // the variable depends on another appending global, because of that inits; // need to be extracted and updated before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:10,Testability,log,logic,10,// Finish logic for block addresses now that all global values have been; // handled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:42,Testability,assert,assert,42,"// If we aren't ignoring missing entries, assert that something happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:42,Testability,assert,assert,42,"// If we aren't ignoring missing entries, assert that something happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:15,Deployability,upgrade,upgrade,15,// FIXME: This upgrade is done during linking to support the C API. See; // also IRLinker::linkAppendingVarProto() in IRMover.cpp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:10,Performance,load,loaded,10,"// If the loaded/stored value is a first class array/struct, or scalable type,; // don't try to transform them. We need to be able to bitcast to integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:64,Performance,scalab,scalable,64,"// If the loaded/stored value is a first class array/struct, or scalable type,; // don't try to transform them. We need to be able to bitcast to integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:46,Performance,load,load,46,// The store has to be at least as big as the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:60,Performance,load,load,60,"/// If we saw a store of a value to memory, and; /// then a load from a must-aliased pointer of a different type, try to coerce; /// the stored value. LoadedTy is the type of the load we want to replace.; /// IRB is IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:151,Performance,Load,LoadedTy,151,"/// If we saw a store of a value to memory, and; /// then a load from a must-aliased pointer of a different type, try to coerce; /// the stored value. LoadedTy is the type of the load we want to replace.; /// IRB is IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:179,Performance,load,load,179,"/// If we saw a store of a value to memory, and; /// then a load from a must-aliased pointer of a different type, try to coerce; /// the stored value. LoadedTy is the type of the load we want to replace.; /// IRB is IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:26,Performance,load,load,26,// Cast to pointer if the load needs a pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:43,Availability,avail,available,43,"// If the loaded value is smaller than the available value, then we can; // extract out a piece from it. If the available value is too small, then we; // can't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:112,Availability,avail,available,112,"// If the loaded value is smaller than the available value, then we can; // extract out a piece from it. If the available value is too small, then we; // can't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:10,Performance,load,loaded,10,"// If the loaded value is smaller than the available value, then we can; // extract out a piece from it. If the available value is too small, then we; // can't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:62,Availability,down,down,62,"// If this is a big-endian system, we need to shift the value down to the low; // bits so that a truncate will work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:61,Performance,load,load,61,"/// This function is called when we have a memdep query of a load that ends up; /// being a clobbering memory write (store, memset, memcpy, memmove). This; /// means that the write *may* provide bits used by the load but we can't be; /// sure because the pointers don't must-alias.; ///; /// Check this case to see if there is anything more we can do before we give; /// up. This returns -1 if we have to give up, or a byte number in the stored; /// value of the piece that feeds the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:212,Performance,load,load,212,"/// This function is called when we have a memdep query of a load that ends up; /// being a clobbering memory write (store, memset, memcpy, memmove). This; /// means that the write *may* provide bits used by the load but we can't be; /// sure because the pointers don't must-alias.; ///; /// Check this case to see if there is anything more we can do before we give; /// up. This returns -1 if we have to give up, or a byte number in the stored; /// value of the piece that feeds the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:484,Performance,load,load,484,"/// This function is called when we have a memdep query of a load that ends up; /// being a clobbering memory write (store, memset, memcpy, memmove). This; /// means that the write *may* provide bits used by the load but we can't be; /// sure because the pointers don't must-alias.; ///; /// Check this case to see if there is anything more we can do before we give; /// up. This returns -1 if we have to give up, or a byte number in the stored; /// value of the piece that feeds the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:10,Performance,load,loaded,10,"// If the loaded/stored value is a first class array/struct, or scalable type,; // don't try to transform them. We need to be able to bitcast to integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:64,Performance,scalab,scalable,64,"// If the loaded/stored value is a first class array/struct, or scalable type,; // don't try to transform them. We need to be able to bitcast to integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:10,Performance,Load,Load,10,"// If the Load isn't completely contained within the stored bits, we don't; // have all the bits to feed it. We could do something crazy in the future; // (issue a smaller load then merge the bits in) but this seems unlikely to be; // valuable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:172,Performance,load,load,172,"// If the Load isn't completely contained within the stored bits, we don't; // have all the bits to feed it. We could do something crazy in the future; // (issue a smaller load then merge the bits in) but this seems unlikely to be; // valuable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:95,Performance,load,load,95,"// Okay, we can do this transformation. Return the number of bytes into the; // store that the load is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:66,Performance,load,load,66,/// This function is called when we have a; /// memdep query of a load that ends up being a clobbering store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:64,Performance,scalab,scalable,64,// Cannot handle reading from store of first-class aggregate or scalable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:66,Performance,load,load,66,/// This function is called when we have a; /// memdep query of a load that ends up being clobbered by another load. See if; /// the other load can feed into the second load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:111,Performance,load,load,111,/// This function is called when we have a; /// memdep query of a load that ends up being clobbered by another load. See if; /// the other load can feed into the second load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:139,Performance,load,load,139,/// This function is called when we have a; /// memdep query of a load that ends up being clobbered by another load. See if; /// the other load can feed into the second load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:169,Performance,load,load,169,/// This function is called when we have a; /// memdep query of a load that ends up being clobbered by another load. See if; /// the other load can feed into the second load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:14,Security,access,access,14,// See if the access is within the bounds of the transfer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:44,Performance,load,load,44,"// Otherwise, see if we can constant fold a load from the constant with the; // offset applied as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:128,Safety,avoid,avoids,128,"// If two pointers are in the same address space, they have the same size,; // so we don't need to do any truncation, etc. This avoids introducing; // ptrtoint instructions for pointers that may be non-integral.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:64,Performance,load,load,64,// Compute which bits of the stored value are being used by the load. Convert; // to an integer type to start with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:43,Integrability,depend,depending,43,// Shift the bits to the least significant depending on endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:66,Performance,load,load,66,/// This function is called when we have a; /// memdep query of a load that ends up being a clobbering mem intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:101,Performance,load,load,101,// We know that this method is only called when the mem transfer fully; // provides the bits for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:54,Modifiability,variab,variable,54,"// memset(P, 'x', 1234) -> splat('x'), even if x is a variable, and; // independently of what the offset is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:101,Performance,load,load,101,// We know that this method is only called when the mem transfer fully; // provides the bits for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:762,Deployability,pipeline,pipeline,762,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:7,Performance,Load,LoadStoreVectorizer,7,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:37,Performance,Load,Load,37,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:400,Performance,load,loads,400,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:465,Performance,load,loads,465,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:654,Performance,load,loads,654,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:909,Performance,load,load,909,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:975,Performance,load,load,975,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1209,Performance,load,load,1209,"ion.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and term",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1370,Performance,load,load,1370,"is pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their success",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1376,Performance,load,loads,1376,"is pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their success",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1552,Performance,load,loads,1552,"s is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1648,Performance,load,loads,1648,"thing also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, an",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1673,Performance,perform,performance,1673,"thing also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, an",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1871,Performance,load,loads,1871,"xploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only con",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1954,Performance,load,load,1954,"al elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:2023,Performance,load,load,2023,"al elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:2433,Performance,load,loads,2433,"vidually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; // The O(n^2) behavior of this pass comes from initially building the chains.; // In the worst case we have to compare each new instruction to all of those; // that came before. To limit this, we only calculate the offset to the leaders; // of the N most recently-used chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:2525,Performance,load,loaded,2525,"vidually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; // The O(n^2) behavior of this pass comes from initially building the chains.; // In the worst case we have to compare each new instruction to all of those; // that came before. To limit this, we only calculate the offset to the leaders; // of the N most recently-used chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:2836,Security,access,accesses,2836,"vidually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; // The O(n^2) behavior of this pass comes from initially building the chains.; // In the worst case we have to compare each new instruction to all of those; // that came before. To limit this, we only calculate the offset to the leaders; // of the N most recently-used chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:623,Usability,simpl,simplicity,623,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:62,Performance,load,loads,62,"// Equivalence class key, the initial tuple by which we group loads/stores.; // Loads/stores with different EqClassKeys are never merged.; //; // (We could in theory remove element-size from the this tuple. We'd just need; // to fix up the vector packing/unpacking code.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:80,Performance,Load,Loads,80,"// Equivalence class key, the initial tuple by which we group loads/stores.; // Loads/stores with different EqClassKeys are never merged.; //; // (We could in theory remove element-size from the this tuple. We'd just need; // to fix up the vector packing/unpacking code.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:3,Performance,Load,Load,3,/* Load/Store element size bits */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:132,Performance,load,loads,132,"// A Chain is a set of instructions such that:; // - All instructions have the same equivalence class, so in particular all are; // loads, or all are stores.; // - We know the address accessed by the i'th chain elem relative to the; // chain's leader instruction, which is the first instr of the chain in BB; // order.; //; // Chains have two canonical orderings:; // - BB order, sorted by Instr->comesBefore.; // - Offset order, sorted by OffsetFromLeader.; // This pass switches back and forth between these orders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:184,Security,access,accessed,184,"// A Chain is a set of instructions such that:; // - All instructions have the same equivalence class, so in particular all are; // loads, or all are stores.; // - We know the address accessed by the i'th chain elem relative to the; // chain's leader instruction, which is the first instr of the chain in BB; // order.; //; // Chains have two canonical orderings:; // - BB order, sorted by Instr->comesBefore.; // - Offset order, sorted by OffsetFromLeader.; // This pass switches back and forth between these orders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:37,Integrability,depend,depends,37,"/// Reorders the instructions that I depends on (the instructions defining its; /// operands), to ensure they dominate I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:196,Usability,simpl,simpler,196,"// We could erase instrs right after vectorizing them, but that can mess up; // our BB iterators, and also can make the equivalence class keys point to; // freed memory. This is fixable, but it's simpler just to wait until we're; // done with the BB and erase all at once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:66,Performance,load,loads,66,"/// Runs the vectorizer on one equivalence class, i.e. one set of loads/stores; /// in the same BB with the same value for getUnderlyingObject() etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:104,Security,access,access,104,"/// Runs the vectorizer on one chain, i.e. a subset of an equivalence class; /// where all instructions access a known, constant offset from the first; /// instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:61,Performance,load,loads,61,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:131,Performance,load,loads,131,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:47,Safety,safe,safe,47,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:118,Safety,safe,safe,118,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:61,Security,access,accesses,61,"/// Splits the chain into subchains that make legal, aligned accesses.; /// Discards any length-1 subchains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:62,Performance,load,load,62,/// Converts the instrs in the chain into a single vectorized load or store.; /// Adds the old scalar loads/stores to ToErase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:102,Performance,load,loads,102,/// Converts the instrs in the chain into a single vectorized load or store.; /// Adds the old scalar loads/stores to ToErase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:60,Performance,load,load,60,/// Gets the element type of the vector that the chain will load or store.; /// This is nontrivial because the chain may contain elements of different; /// types; e.g. it's legal to have a chain that contains both i32 and float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:64,Availability,down,down,64,"/// Determines whether ChainElem can be moved up (if IsLoad) or down (if; /// !IsLoad) to ChainBegin -- i.e. there are no intervening may-alias; /// instructions.; ///; /// The map ChainElemOffsets must contain all of the elements in; /// [ChainBegin, ChainElem] and their offsets from some arbitrary base; /// address. It's ok if it contains additional entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:13,Performance,load,loads,13,"/// Collects loads and stores grouped by ""equivalence class"", where:; /// - all elements in an eq class are a load or all are a store,; /// - they all load/store the same element size (it's OK to have e.g. i8 and; /// <4 x i8> in the same class, but not i32 and <4 x i8>), and; /// - they all have the same value for getUnderlyingObject().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:110,Performance,load,load,110,"/// Collects loads and stores grouped by ""equivalence class"", where:; /// - all elements in an eq class are a load or all are a store,; /// - they all load/store the same element size (it's OK to have e.g. i8 and; /// <4 x i8> in the same class, but not i32 and <4 x i8>), and; /// - they all have the same value for getUnderlyingObject().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:151,Performance,load,load,151,"/// Collects loads and stores grouped by ""equivalence class"", where:; /// - all elements in an eq class are a load or all are a store,; /// - they all load/store the same element size (it's OK to have e.g. i8 and; /// <4 x i8> in the same class, but not i32 and <4 x i8>), and; /// - they all have the same value for getUnderlyingObject().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:209,Performance,load,load,209,"// Break up the BB if there are any instrs which aren't guaranteed to transfer; // execution to their successor.; //; // Consider, for example:; //; // def assert_arr_len(int n) { if (n < 2) exit(); }; //; // load arr[0]; // call assert_array_len(arr.length); // load arr[1]; //; // Even though assert_arr_len does not read or write any memory, we can't; // speculate the second load before the call. More info at; // https://github.com/llvm/llvm-project/issues/52950.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:263,Performance,load,load,263,"// Break up the BB if there are any instrs which aren't guaranteed to transfer; // execution to their successor.; //; // Consider, for example:; //; // def assert_arr_len(int n) { if (n < 2) exit(); }; //; // load arr[0]; // call assert_array_len(arr.length); // load arr[1]; //; // Even though assert_arr_len does not read or write any memory, we can't; // speculate the second load before the call. More info at; // https://github.com/llvm/llvm-project/issues/52950.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:379,Performance,load,load,379,"// Break up the BB if there are any instrs which aren't guaranteed to transfer; // execution to their successor.; //; // Consider, for example:; //; // def assert_arr_len(int n) { if (n < 2) exit(); }; //; // load arr[0]; // call assert_array_len(arr.length); // load arr[1]; //; // Even though assert_arr_len does not read or write any memory, we can't; // speculate the second load before the call. More info at; // https://github.com/llvm/llvm-project/issues/52950.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:143,Security,hash,hashtable,143,"// We know that elements in the chain with nonverlapping offsets can't; // alias, but AA may not be smart enough to figure this out. Use a; // hashtable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:76,Availability,down,down,76,"// Loads get hoisted up to the first load in the chain. Stores get sunk; // down to the last store in the chain. Our algorithm for loads is:; //; // - Take the first element of the chain. This is the start of a new chain.; // - Take the next element of `Chain` and check for may-alias instructions; // up to the start of NewChain. If no may-alias instrs, add it to; // NewChain. Otherwise, start a new NewChain.; //; // For stores it's the same except in the reverse direction.; //; // We expect IsLoad to be an std::bool_constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:3,Performance,Load,Loads,3,"// Loads get hoisted up to the first load in the chain. Stores get sunk; // down to the last store in the chain. Our algorithm for loads is:; //; // - Take the first element of the chain. This is the start of a new chain.; // - Take the next element of `Chain` and check for may-alias instructions; // up to the start of NewChain. If no may-alias instrs, add it to; // NewChain. Otherwise, start a new NewChain.; //; // For stores it's the same except in the reverse direction.; //; // We expect IsLoad to be an std::bool_constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:37,Performance,load,load,37,"// Loads get hoisted up to the first load in the chain. Stores get sunk; // down to the last store in the chain. Our algorithm for loads is:; //; // - Take the first element of the chain. This is the start of a new chain.; // - Take the next element of `Chain` and check for may-alias instructions; // up to the start of NewChain. If no may-alias instrs, add it to; // NewChain. Otherwise, start a new NewChain.; //; // For stores it's the same except in the reverse direction.; //; // We expect IsLoad to be an std::bool_constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:131,Performance,load,loads,131,"// Loads get hoisted up to the first load in the chain. Stores get sunk; // down to the last store in the chain. Our algorithm for loads is:; //; // - Take the first element of the chain. This is the start of a new chain.; // - Take the next element of `Chain` and check for may-alias instructions; // up to the start of NewChain. If no may-alias instrs, add it to; // NewChain. Otherwise, start a new NewChain.; //; // For stores it's the same except in the reverse direction.; //; // We expect IsLoad to be an std::bool_constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:10,Security,access,accesses,10,"// `prev` accesses offsets [PrevDistFromBase, PrevReadEnd).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:275,Performance,load,load,275,"// The rules are:; // - If there are any pointer types in the chain, use an integer type.; // - Prefer an integer type if it appears in the chain.; // - Otherwise, use the first type in the chain.; //; // The rule about pointer types is a simplification when we merge e.g. a load; // of a ptr and a double. There's no direct conversion from a ptr to a; // double; it requires a ptrtoint followed by a bitcast.; //; // It's unclear to me if the other rules have any practical effect, but we do; // it to match this pass's previous behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:239,Usability,simpl,simplification,239,"// The rules are:; // - If there are any pointer types in the chain, use an integer type.; // - Prefer an integer type if it appears in the chain.; // - Otherwise, use the first type in the chain.; //; // The rule about pointer types is a simplification when we merge e.g. a load; // of a ptr and a double. There's no direct conversion from a ptr to a; // double; it requires a ptrtoint followed by a bitcast.; //; // It's unclear to me if the other rules have any practical effect, but we do; // it to match this pass's previous behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:164,Energy Efficiency,power,power,164,"// We use a simple greedy algorithm.; // - Given a chain of length N, find all prefixes that; // (a) are not longer than the max register length, and; // (b) are a power of 2.; // - Starting from the longest prefix, try to create a vector of that length.; // - If one of them works, great. Repeat the algorithm on any remaining; // elements in the chain.; // - If none of them work, discard the first element and repeat on a chain; // of length N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:12,Usability,simpl,simple,12,"// We use a simple greedy algorithm.; // - Given a chain of length N, find all prefixes that; // (a) are not longer than the max register length, and; // (b) are a power of 2.; // - Starting from the longest prefix, try to create a vector of that length.; // - If one of them works, great. Repeat the algorithm on any remaining; // elements in the chain.; // - If none of them work, discard the first element and repeat on a chain; // of length N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:24,Energy Efficiency,power,power,24,"// Note, VecElemTy is a power of 2, but might be less than one byte. For; // example, we can vectorize 2 x <2 x i4> to <4 x i4>, and in this case; // VecElemTy would be i4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:33,Energy Efficiency,power,powers,33,"// SizeBytes and VecElemBits are powers of 2, so they divide evenly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:8,Performance,load,load,8,// Is a load/store with this alignment allowed by TTI and at least as fast; // as an unvectorized load/store?; //; // TTI and F are passed as explicit captures to WAR an MSVC misparse (??).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:98,Performance,load,load,98,// Is a load/store with this alignment allowed by TTI and at least as fast; // as an unvectorized load/store?; //; // TTI and F are passed as explicit captures to WAR an MSVC misparse (??).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:92,Deployability,upgrade,upgrade,92,"// If we're loading/storing from an alloca, align it if possible.; //; // FIXME: We eagerly upgrade the alignment, regardless of whether TTI; // tells us this is beneficial. This feels a bit odd, but it matches; // existing tests. This isn't *so* bad, because at most we align to 4; // bytes (current value of StackAdjustedAlignment).; //; // FIXME: We will upgrade the alignment of the alloca even if it turns out; // we can't vectorize for some other reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:358,Deployability,upgrade,upgrade,358,"// If we're loading/storing from an alloca, align it if possible.; //; // FIXME: We eagerly upgrade the alignment, regardless of whether TTI; // tells us this is beneficial. This feels a bit odd, but it matches; // existing tests. This isn't *so* bad, because at most we align to 4; // bytes (current value of StackAdjustedAlignment).; //; // FIXME: We will upgrade the alignment of the alloca even if it turns out; // we can't vectorize for some other reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:12,Performance,load,loading,12,"// If we're loading/storing from an alloca, align it if possible.; //; // FIXME: We eagerly upgrade the alignment, regardless of whether TTI; // tells us this is beneficial. This feels a bit odd, but it matches; // existing tests. This isn't *so* bad, because at most we align to 4; // bytes (current value of StackAdjustedAlignment).; //; // FIXME: We will upgrade the alignment of the alloca even if it turns out; // we can't vectorize for some other reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:224,Testability,test,tests,224,"// If we're loading/storing from an alloca, align it if possible.; //; // FIXME: We eagerly upgrade the alignment, regardless of whether TTI; // tells us this is beneficial. This feels a bit odd, but it matches; // existing tests. This isn't *so* bad, because at most we align to 4; // bytes (current value of StackAdjustedAlignment).; //; // FIXME: We will upgrade the alignment of the alloca even if it turns out; // we can't vectorize for some other reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:14,Energy Efficiency,power,power,14,"// VecTy is a power of 2 and 1 byte at smallest, but VecElemTy may be smaller; // than 1 byte (e.g. VecTy == <32 x i1>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:55,Deployability,upgrade,upgraded,55,"// If this is a load/store of an alloca, we might have upgraded the alloca's; // alignment earlier. Get the new alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:16,Performance,load,load,16,"// If this is a load/store of an alloca, we might have upgraded the alloca's; // alignment earlier. Get the new alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:3,Performance,Load,Loads,3,// Loads get hoisted to the location of the first load in the chain. We may; // also need to hoist the (transitive) operands of the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:50,Performance,load,load,50,// Loads get hoisted to the location of the first load in the chain. We may; // also need to hoist the (transitive) operands of the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:132,Performance,load,loads,132,// Loads get hoisted to the location of the first load in the chain. We may; // also need to hoist the (transitive) operands of the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:218,Performance,load,load,218,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:264,Performance,load,load,264,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:313,Performance,load,load,313,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:350,Performance,load,load,350,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:418,Performance,load,loadv,418,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:426,Performance,load,load,426,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:473,Performance,load,loadv,473,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:509,Performance,load,loadv,509,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:558,Performance,load,loadv,558,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:13,Performance,load,loads,13,// Invariant loads can always be reordered; by definition they are not; // clobbered by stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:3,Performance,Load,Loads,3,// Loads can be reordered with other loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:37,Performance,load,loads,37,// Loads can be reordered with other loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:38,Performance,load,loads,38,// Stores can be sunk below invariant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:235,Performance,load,loads,235,"// If I is in the chain, we can tell whether it aliases ChainIt by checking; // what offset ChainIt accesses. This may be better than AA is able to do.; //; // We should really only have duplicate offsets for stores (the duplicate; // loads should be CSE'ed), but in case we have a duplicate load, we'll; // split the chain so we don't have to handle this case specially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:292,Performance,load,load,292,"// If I is in the chain, we can tell whether it aliases ChainIt by checking; // what offset ChainIt accesses. This may be better than AA is able to do.; //; // We should really only have duplicate offsets for stores (the duplicate; // loads should be CSE'ed), but in case we have a duplicate load, we'll; // split the chain so we don't have to handle this case specially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:100,Security,access,accesses,100,"// If I is in the chain, we can tell whether it aliases ChainIt by checking; // what offset ChainIt accesses. This may be better than AA is able to do.; //; // We should really only have duplicate offsets for stores (the duplicate; // loads should be CSE'ed), but in case we have a duplicate load, we'll; // split the chain so we don't have to handle this case specially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:138,Safety,safe,safe,138,"// If both OpA and OpB are adds with NSW/NUW and with one of the operands; // being the same, we can guarantee that the transformation is safe if we can; // prove that OpA won't overflow when Ret added to the other operand of OpA.; // For example:; // %tmp7 = add nsw i32 %tmp2, %v0; // %tmp8 = sext i32 %tmp7 to i64; // ...; // %tmp11 = add nsw i32 %v0, 1; // %tmp12 = add nsw i32 %tmp2, %tmp11; // %tmp13 = sext i32 %tmp12 to i64; //; // Both %tmp7 and %tmp12 have the nsw flag and the first operand is %tmp2.; // It's guaranteed that adding 1 to %tmp7 won't overflow because %tmp11 adds; // 1 to %v0 and both %tmp11 and %tmp12 have the nsw flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:116,Performance,load,load,116,"// When computing known bits, use the GEPs as context instructions, since; // they likely are in the same BB as the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:272,Security,access,accesses,272,"// The select's themselves are distinct instructions even if they share; // the same condition and evaluate to consecutive pointers for true and; // false values of the condition. Therefore using the select's themselves; // for grouping instructions would put consecutive accesses into different; // lists and they won't be even checked for being consecutive, and won't; // be vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:145,Performance,load,load,145,"// Skip vectors of pointers. The vectorizeLoadChain/vectorizeStoreChain; // functions are currently using an integer type for the vectorized; // load/store, and does not support casting between the integer type and a; // vector of pointers (e.g. i64 to <2 x i16*>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:15,Energy Efficiency,power,power-of-two,15,// Only handle power-of-two sized elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:29,Security,hash,hashtable,29,"// Machinery to build an MRU-hashtable of Chains.; //; // (Ideally this could be done with MapVector, but as currently implemented,; // moving an element to the front of a MapVector is O(n).)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:64,Performance,scalab,scalable,64,"// If the metadata doesn't explicitly specify whether to enable scalable; // vectorization, then decide based on the following criteria (increasing; // level of priority):; // - Target default; // - Metadata width; // - Force option (always overrides)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:64,Performance,scalab,scalable,64,"// If the width is set, but the metadata says nothing about the scalable; // property, then assume it concerns only a fixed-width UserVF.; // If width is not set, the flag takes precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:42,Performance,scalab,scalable,42,"// If the flag is set to force any use of scalable vectors, override the loop; // hints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:3,Performance,Scalab,Scalable,3,// Scalable vectorization is disabled if no preference is specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:3,Deployability,Update,Update,3,// Update internal cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:19,Performance,cache,cache,19,// Update internal cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:123,Availability,error,errors,123,// FIXME: Add interleave.disable metadata. This will allow; // vectorize.disable to be used without disabling the pass and errors; // to differentiate between disabled vectorization and a width of 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:1027,Availability,redundant,redundantly,1027,"// Return true if the inner loop \p Lp is uniform with regard to the outer loop; // \p OuterLp (i.e., if the outer loop is vectorized, all the vector lanes; // executing the inner loop will execute the same iterations). This check is; // very constrained for now but it will be relaxed in the future. \p Lp is; // considered uniform if it meets all the following conditions:; // 1) it has a canonical IV (starting from 0 and with stride 1),; // 2) its latch terminator is a conditional branch and,; // 3) its latch condition is a compare instruction whose operands are the; // canonical IV and an OuterLp invariant.; // This check doesn't take into account the uniformity of other conditions not; // related to the loop latch because they don't affect the loop uniformity.; //; // NOTE: We decided to keep all these checks and its associated documentation; // together so that we can easily have a picture of the current supported loop; // nests. However, some of the current checks don't depend on \p OuterLp and; // would be redundantly executed for each \p Lp if we invoked this function for; // different candidate outer loops. This is not the case for now because we; // don't currently have the infrastructure to evaluate multiple candidate outer; // loops and \p OuterLp will be a fixed parameter while we only support explicit; // outer loop vectorization. It's also very likely that these checks go away; // before introducing the aforementioned infrastructure. However, if this is not; // the case, we should move the \p OuterLp independent checks to a separate; // function that is only executed once for each \p Lp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:989,Integrability,depend,depend,989,"// Return true if the inner loop \p Lp is uniform with regard to the outer loop; // \p OuterLp (i.e., if the outer loop is vectorized, all the vector lanes; // executing the inner loop will execute the same iterations). This check is; // very constrained for now but it will be relaxed in the future. \p Lp is; // considered uniform if it meets all the following conditions:; // 1) it has a canonical IV (starting from 0 and with stride 1),; // 2) its latch terminator is a conditional branch and,; // 3) its latch condition is a compare instruction whose operands are the; // canonical IV and an OuterLp invariant.; // This check doesn't take into account the uniformity of other conditions not; // related to the loop latch because they don't affect the loop uniformity.; //; // NOTE: We decided to keep all these checks and its associated documentation; // together so that we can easily have a picture of the current supported loop; // nests. However, some of the current checks don't depend on \p OuterLp and; // would be redundantly executed for each \p Lp if we invoked this function for; // different candidate outer loops. This is not the case for now because we; // don't currently have the infrastructure to evaluate multiple candidate outer; // loops and \p OuterLp will be a fixed parameter while we only support explicit; // outer loop vectorization. It's also very likely that these checks go away; // before introducing the aforementioned infrastructure. However, if this is not; // the case, we should move the \p OuterLp independent checks to a separate; // function that is only executed once for each \p Lp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:1027,Safety,redund,redundantly,1027,"// Return true if the inner loop \p Lp is uniform with regard to the outer loop; // \p OuterLp (i.e., if the outer loop is vectorized, all the vector lanes; // executing the inner loop will execute the same iterations). This check is; // very constrained for now but it will be relaxed in the future. \p Lp is; // considered uniform if it meets all the following conditions:; // 1) it has a canonical IV (starting from 0 and with stride 1),; // 2) its latch terminator is a conditional branch and,; // 3) its latch condition is a compare instruction whose operands are the; // canonical IV and an OuterLp invariant.; // This check doesn't take into account the uniformity of other conditions not; // related to the loop latch because they don't affect the loop uniformity.; //; // NOTE: We decided to keep all these checks and its associated documentation; // together so that we can easily have a picture of the current supported loop; // nests. However, some of the current checks don't depend on \p OuterLp and; // would be redundantly executed for each \p Lp if we invoked this function for; // different candidate outer loops. This is not the case for now because we; // don't currently have the infrastructure to evaluate multiple candidate outer; // loops and \p OuterLp will be a fixed parameter while we only support explicit; // outer loop vectorization. It's also very likely that these checks go away; // before introducing the aforementioned infrastructure. However, if this is not; // the case, we should move the \p OuterLp independent checks to a separate; // function that is only executed once for each \p Lp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:94,Modifiability,variab,variable,94,/// Check that the instruction has outside loop users and is not an; /// identified reduction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:227,Availability,mask,masked,227,"// FIXME: Currently, the set of symbolic strides is sometimes queried before; // it's collected. This happens from canVectorizeWithIfConvert, when the; // pointer is checked to reference consecutive elements suitable for a; // masked access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:234,Security,access,access,234,"// FIXME: Currently, the set of symbolic strides is sometimes queried before; // it's collected. This happens from canVectorizeWithIfConvert, when the; // pointer is checked to reference consecutive elements suitable for a; // masked access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:6,Modifiability,rewrite,rewriter,6,"/// A rewriter to build the SCEVs for each of the VF lanes in the expected; /// vectorized loop, which can then be compared to detect their uniformity. This; /// is done by replacing the AddRec SCEVs of the original scalar loop (TheLoop); /// with new AddRecs where the step is multiplied by StepMultiplier and Offset *; /// Step is added. Also checks if all sub-expressions are analyzable w.r.t.; /// uniformity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:127,Safety,detect,detect,127,"/// A rewriter to build the SCEVs for each of the VF lanes in the expected; /// vectorized loop, which can then be compared to detect their uniformity. This; /// is done by replacing the AddRec SCEVs of the original scalar loop (TheLoop); /// with new AddRecs where the step is multiplied by StepMultiplier and Offset *; /// Step is added. Also checks if all sub-expressions are analyzable w.r.t.; /// uniformity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:22,Modifiability,rewrite,rewrite,22,/// Loop for which to rewrite AddRecsFor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:213,Safety,avoid,avoid,213,/// Bail out if the expression does not contain an UDiv expression.; /// Uniform values which are not loop invariant require operations to strip; /// out the lowest bits. For now just look for UDivs and use it to avoid; /// re-writing UDIV-free expressions for other lanes to limit compile time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite AddRecs in TheLoop to step by VF and check if the expression for; // lane 0 matches the expressions for all other lanes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:60,Performance,load,loads,60,"// Note: There's nothing inherent which prevents predicated loads and; // stores from being uniform. The current lowering simply doesn't handle; // it; in particular, the cost model distinguishes scatter/gather from; // scalar w/predication, and we currently rely on the scalar path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:122,Usability,simpl,simply,122,"// Note: There's nothing inherent which prevents predicated loads and; // stores from being uniform. The current lowering simply doesn't handle; // it; in particular, the cost model distinguishes scatter/gather from; // scalar w/predication, and we currently rely on the scalar path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:77,Usability,simpl,simple,77,"// Check whether inner loops are uniform. At this point, we only support; // simple outer loops scenarios with uniform nested loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:254,Modifiability,variab,variable,254,"// Use the phi node with the widest type as induction. Use the last; // one if there are multiple (no good reason for doing this other; // than it is expedient). We've checked that it begins at zero and; // steps by one, so this is a canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:51,Safety,hazard,hazards,51,// Scan the instructions in the block and look for hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:193,Modifiability,variab,variables,193,"// If this PHINode is not in the header block, then we know that we; // can convert it to select during if-conversion. No need to check if; // the PHIs in this block are induction or reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:127,Integrability,depend,dependencies,127,"// Non-header phi nodes that have outside uses can be vectorized. Add; // them to the list of allowed exits.; // Unsafe cyclic dependencies with header phis are identified during; // legalization for reduction, induction and fixed order; // recurrences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:113,Safety,Unsafe,Unsafe,113,"// Non-header phi nodes that have outside uses can be vectorized. Add; // them to the list of allowed exits.; // Unsafe cyclic dependencies with header phis are identified during; // legalization for reduction, induction and fixed order; // recurrences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:248,Availability,avail,available,248,"// TODO: Instead of recording the AllowedExit, it would be good to; // record the complementary set: NotAllowedExit. These include (but may; // not be limited to):; // 1. Reduction phis as they represent the one-before-last value, which; // is not available when vectorized; // 2. Induction phis and increment when SCEV predicates cannot be used; // outside the loop - see addInductionPhi; // 3. Non-Phis with outside uses when SCEV predicates cannot be used; // outside the loop - see call to hasOutsideLoopUser in the non-phi; // handling below; // 4. FixedOrderRecurrence phis that can possibly be handled by; // extraction.; // By recording these, we can then reason about ways to vectorize each; // of these NotAllowedExit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:151,Availability,avail,available,151,// end of PHI handling; // We handle calls that:; // * Are debug info intrinsics.; // * Have a mapping to an IR intrinsic.; // * Have a vector version available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:19,Performance,load,loads,19,"// For nontemporal loads, check that a nontemporal vector version is; // supported on the target (arbitrarily try a vector of 2 elements).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:29,Safety,unsafe,unsafe,29,"// FP instructions can allow unsafe algebra, thus vectorizable by; // non-IEEE-754 compliant SIMD units.; // This applies to floating-point math operations and calls, not memory; // operations, shuffles, or casts, as they don't change precision or; // semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:10,Safety,safe,safely,10,// We can safely vectorize loops where instructions within the loop are; // used outside the loop only if the SCEV predicates within the loop is; // same as outside the loop. Allowing the exit means reusing the SCEV; // outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:130,Integrability,depend,dependence,130,"// For each invariant address, check its last stored value is the result; // of one of our reductions.; //; // We do not check if dependence with loads exists because they are; // currently rejected earlier in LoopAccessInfo::analyzeLoop. In case this; // behaviour changes we have to modify this code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:146,Performance,load,loads,146,"// For each invariant address, check its last stored value is the result; // of one of our reductions.; //; // We do not check if dependence with loads exists because they are; // currently rejected earlier in LoopAccessInfo::analyzeLoop. In case this; // behaviour changes we have to modify this code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:482,Testability,test,test,482,"// Earlier stores to this address are effectively deadcode.; // With opaque pointers it is possible for one pointer to be used with; // different sizes of stored values:; // store i32 0, ptr %x; // store i8 0, ptr %x; // The latest store doesn't complitely overwrite the first one in the; // example. That is why we have to make sure that types of stored; // values are same.; // TODO: Check that bitwidth of unhandled store is smaller then the; // one that overwrites it and add a test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:24,Security,validat,validate,24,// TODO: we should also validate against InvariantMemSets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:16,Availability,mask,masked,16,"// We can allow masked calls if there's at least one vector variant, even; // if we end up scalarizing due to the cost model calculations.; // TODO: Allow other calls if they have appropriate attributes... readonly; // and argmemonly?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:25,Availability,mask,masking,25,// Loads are handled via masking (or speculated if safe to do so.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:3,Performance,Load,Loads,3,// Loads are handled via masking (or speculated if safe to do so.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:51,Safety,safe,safe,51,// Loads are handled via masking (or speculated if safe to do so.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:42,Availability,mask,masking,42,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:58,Availability,mask,masked,58,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:108,Performance,load,load-blend-store,108,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:179,Performance,race condition,race conditions,179,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:134,Safety,safe,safe,134,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:320,Availability,fault,fault,320,"// A list of pointers which are known to be dereferenceable within scope of; // the loop body for each iteration of the loop which executes. That is,; // the memory pointed to can be dereferenced (with the access size implied by; // the value's type) unconditionally within the loop header without; // introducing a new fault.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:206,Security,access,access,206,"// A list of pointers which are known to be dereferenceable within scope of; // the loop body for each iteration of the loop which executes. That is,; // the memory pointed to can be dereferenced (with the access size implied by; // the value's type) unconditionally within the loop header without; // introducing a new fault.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:11,Safety,safe,safe,11,// Collect safe addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:185,Availability,fault,fault,185,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:248,Performance,load,loads,248,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:294,Performance,concurren,concurrency,294,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:60,Safety,safe,safe,60,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:68,Security,access,access,68,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:28,Testability,test,tests,28,"// Okay! We've done all the tests. If any have failed, return false. Otherwise; // we can vectorize, and at this point we don't have any other mem analysis; // which may limit our maximum vectorization factor, so just return true with; // no restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:67,Availability,mask,masking,67,// TODO: handle non-reduction outside users when tail is folded by masking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:36,Safety,safe,safely,36,// The list of pointers that we can safely read and write to remains empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:11,Availability,mask,masked,11,// Collect masked ops in temporary set first to avoid partially populating; // MaskedOp if a block cannot be predicated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:79,Availability,Mask,MaskedOp,79,// Collect masked ops in temporary set first to avoid partially populating; // MaskedOp if a block cannot be predicated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:48,Safety,avoid,avoid,48,// Collect masked ops in temporary set first to avoid partially populating; // MaskedOp if a block cannot be predicated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:655,Performance,optimiz,optimizes,655,"//===- LoopVectorizationPlanner.h - Planner for LoopVectorization ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file provides a LoopVectorizationPlanner class.; /// InnerLoopVectorizer vectorizes loops which contain only one basic; /// LoopVectorizationPlanner - drives the vectorization process after having; /// passed Legality checks.; /// The planner builds and optimizes the Vectorization Plans which record the; /// decisions how to vectorize the given loop. In particular, represent the; /// control-flow of the vectorized version, the replication of instructions that; /// are to be scalarized, and interleave access groups.; ///; /// Also provides a VPlan-based builder utility analogous to IRBuilder.; /// It provides an instruction-level API for generating VPInstructions while; /// abstracting away the Recipe manipulation details.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:907,Security,access,access,907,"//===- LoopVectorizationPlanner.h - Planner for LoopVectorization ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file provides a LoopVectorizationPlanner class.; /// InnerLoopVectorizer vectorizes loops which contain only one basic; /// LoopVectorizationPlanner - drives the vectorization process after having; /// passed Legality checks.; /// The planner builds and optimizes the Vectorization Plans which record the; /// decisions how to vectorize the given loop. In particular, represent the; /// control-flow of the vectorized version, the replication of instructions that; /// are to be scalarized, and interleave access groups.; ///; /// Also provides a VPlan-based builder utility analogous to IRBuilder.; /// It provides an instruction-level API for generating VPInstructions while; /// abstracting away the Recipe manipulation details.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:4,Usability,Clear,Clear,4,/// Clear the insertion point: created instructions will not be inserted into; /// a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:138,Performance,scalab,scalable,138,/// A class that represents two vectorization factors (initialized with 0 by; /// default). One for fixed-width vectorization and one for scalable; /// vectorization. This can be used by the vectorizer to choose from a range of; /// fixed and/or scalable VFs in order to find the most cost-effective VF to; /// vectorize with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:246,Performance,scalab,scalable,246,/// A class that represents two vectorization factors (initialized with 0 by; /// default). One for fixed-width vectorization and one for scalable; /// vectorization. This can be used by the vectorizer to choose from a range of; /// fixed and/or scalable VFs in order to find the most cost-effective VF to; /// vectorize with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:37,Performance,scalab,scalable,37,/// \return true if either fixed- or scalable VF is non-zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:37,Performance,scalab,scalable,37,/// \return true if either fixed- or scalable VF is a valid vector VF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:20,Security,access,access,20,/// The interleaved access analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:130,Safety,avoid,avoided,130,"/// Plan how to best vectorize, return the best VF and its cost, or; /// std::nullopt if vectorization and interleaving should be avoided up front.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:188,Safety,avoid,avoid,188,/// Generate the IR code for the vectorized loop captured in VPlan \p BestPlan; /// according to the best selected \p VF and \p UF.; ///; /// TODO: \p IsEpilogueVectorization is needed to avoid issues due to epilogue; /// vectorization re-using plans for both the main and epilogue vector loops.; /// It should be removed once the re-use issue has been fixed.; /// \p ExpandedSCEVs is passed during execution of the plan for epilogue loop; /// to re-use expansion results generated during main plan execution.; ///; /// Returns a mapping of SCEVs to their expanded IR values and a mapping for; /// the reduction resume values. Note that this is a temporary workaround; /// needed due to the current epilogue handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:612,Usability,resume,resume,612,/// Generate the IR code for the vectorized loop captured in VPlan \p BestPlan; /// according to the best selected \p VF and \p UF.; ///; /// TODO: \p IsEpilogueVectorization is needed to avoid issues due to epilogue; /// vectorization re-using plans for both the main and epilogue vector loops.; /// It should be removed once the re-use issue has been fixed.; /// \p ExpandedSCEVs is passed during execution of the plan for epilogue loop; /// to re-use expansion results generated during main plan execution.; ///; /// Returns a mapping of SCEVs to their expanded IR values and a mapping for; /// the reduction resume values. Note that this is a temporary workaround; /// needed due to the current epilogue handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:4,Testability,Test,Test,4,"/// Test a \p Predicate on a \p Range of VF's. Return the value of applying; /// \p Predicate on Range.Start, possibly decreasing Range.End such that the; /// returned value holds for the entire \p Range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:21,Energy Efficiency,power,power-of-,21,"/// Build VPlans for power-of-2 VF's between \p MinVF and \p MaxVF inclusive,; /// according to the information gathered by Legal when it checked if it is; /// legal to vectorize the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:21,Energy Efficiency,power,power-of-,21,"/// Build VPlans for power-of-2 VF's between \p MinVF and \p MaxVF inclusive,; /// according to the information gathered by Legal when it checked if it is; /// legal to vectorize the loop. This method creates VPlans using VPRecipes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:1945,Modifiability,variab,variable,1945,"bility of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has three parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:2066,Modifiability,Variab,Variable,2066,"bility of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has three parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:1089,Performance,perform,performs,1089," the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the LLVM loop vectorizer. This pass modifies 'vectorizable' loops; // and generates target-independent LLVM-IR.; // The vectorizer uses the TargetTransformInfo analysis to estimate the costs; // of instructions in order to estimate the profitability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has three parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:2196,Security,access,access,2196,"bility of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has three parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:348,Integrability,depend,depending,348,"// Option prefer-predicate-over-epilogue indicates that an epilogue is undesired,; // that predication is preferred, and this lists all options. I.e., the; // vectorizer will try to fold the tail-loop (epilogue) into the vector body; // and predicate the instructions accordingly. If tail-folding fails, there are; // different fallback strategies depending on these values:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,mask,masking,33,"/// An interleave-group may need masking if it resides in a block that needs; /// predication, or in order to mask away gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:110,Availability,mask,mask,110,"/// An interleave-group may need masking if it resides in a block that needs; /// predication, or in order to mask away gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:32,Performance,load,load,32,// Runtime interleave loops for load/store throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Performance,throughput,throughput,43,// Runtime interleave loops for load/store throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:32,Testability,test,testing,32,// This flag enables the stress testing of the VPlan H-CFG construction in the; // VPlan-native vectorization path. It must be used in conjuction with; // -enable-vplan-native-path. -vplan-verify-hcfg can also be used to enable the; // verification of the H-CFGs built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Modifiability,variab,variables,82,// Likelyhood of bypassing the vectorized loop because assumptions about SCEV; // variables not overflowing do not hold. See `emitSCEVChecks`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:106,Energy Efficiency,allocate,allocated,106,/// A helper function that returns true if the given type is irregular. The; /// type is irregular if its allocated size doesn't equal the store size of an; /// element of the corresponding vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:285,Availability,avail,available,285,"/// A helper function that returns the reciprocal of the block probability of; /// predicated blocks. If we return X, we are assuming the predicated block; /// will execute once for every X iterations of the loop header.; ///; /// TODO: We should use actual block probability here, if available. Currently,; /// we always assume predicated blocks have a 50% chance of executing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Availability,avail,available,44,// Check if there is an expected trip count available from profile data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot use arbitrary shufflevectors (only splats), so; // must use intrinsics to interleave.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:468,Modifiability,variab,variables,468,"/// InnerLoopVectorizer vectorizes loops which contain only one basic; /// block to a specified vectorization factor (VF).; /// This class performs the widening of scalars into vectors, or multiple; /// scalars. This class also implements the following features:; /// * It inserts an epilogue loop for handling loops that don't have iteration; /// counts that are known to be a multiple of the vectorization factor.; /// * It handles the code generation for reduction variables.; /// * Scalarization (implementation using scalars) of un-vectorizable; /// instructions.; /// InnerLoopVectorizer does not perform any vectorization-legality; /// checks, and relies on the caller to check for the different legality; /// aspects. The InnerLoopVectorizer relies on the; /// LoopVectorizationLegality class to provide information about the induction; /// and reduction variables that were found to a given vectorization factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:863,Modifiability,variab,variables,863,"/// InnerLoopVectorizer vectorizes loops which contain only one basic; /// block to a specified vectorization factor (VF).; /// This class performs the widening of scalars into vectors, or multiple; /// scalars. This class also implements the following features:; /// * It inserts an epilogue loop for handling loops that don't have iteration; /// counts that are known to be a multiple of the vectorization factor.; /// * It handles the code generation for reduction variables.; /// * Scalarization (implementation using scalars) of un-vectorizable; /// instructions.; /// InnerLoopVectorizer does not perform any vectorization-legality; /// checks, and relies on the caller to check for the different legality; /// aspects. The InnerLoopVectorizer relies on the; /// LoopVectorizationLegality class to provide information about the induction; /// and reduction variables that were found to a given vectorization factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:139,Performance,perform,performs,139,"/// InnerLoopVectorizer vectorizes loops which contain only one basic; /// block to a specified vectorization factor (VF).; /// This class performs the widening of scalars into vectors, or multiple; /// scalars. This class also implements the following features:; /// * It inserts an epilogue loop for handling loops that don't have iteration; /// counts that are known to be a multiple of the vectorization factor.; /// * It handles the code generation for reduction variables.; /// * Scalarization (implementation using scalars) of un-vectorizable; /// instructions.; /// InnerLoopVectorizer does not perform any vectorization-legality; /// checks, and relies on the caller to check for the different legality; /// aspects. The InnerLoopVectorizer relies on the; /// LoopVectorizationLegality class to provide information about the induction; /// and reduction variables that were found to a given vectorization factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:603,Performance,perform,perform,603,"/// InnerLoopVectorizer vectorizes loops which contain only one basic; /// block to a specified vectorization factor (VF).; /// This class performs the widening of scalars into vectors, or multiple; /// scalars. This class also implements the following features:; /// * It inserts an epilogue loop for handling loops that don't have iteration; /// counts that are known to be a multiple of the vectorization factor.; /// * It handles the code generation for reduction variables.; /// * Scalarization (implementation using scalars) of un-vectorizable; /// instructions.; /// InnerLoopVectorizer does not perform any vectorization-legality; /// checks, and relies on the caller to check for the different legality; /// aspects. The InnerLoopVectorizer relies on the; /// LoopVectorizationLegality class to provide information about the induction; /// and reduction variables that were found to a given vectorization factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:111,Availability,mask,masking,111,"/// Try to vectorize interleaved access group \p Group with the base address; /// given in \p Addr, optionally masking the vector operations if \p; /// BlockInMask is non-null. Use \p State to translate given VPValues to IR; /// values in the vectorized loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Security,access,access,33,"/// Try to vectorize interleaved access group \p Group with the base address; /// given in \p Addr, optionally masking the vector operations if \p; /// BlockInMask is non-null. Use \p State to translate given VPValues to IR; /// values in the vectorized loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Modifiability,variab,variable,44,"/// Create a new phi node for the induction variable \p OrigPhi to resume; /// iteration count in the scalar epilogue, from where the vectorized loop; /// left off. \p Step is the SCEV-expanded induction step to use. In cases; /// where the loop skeleton is more complicated (i.e., epilogue vectorization); /// and the resume values can come from an additional bypass block, the \p; /// AdditionalBypass pair provides information about the bypass block and the; /// end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:67,Usability,resume,resume,67,"/// Create a new phi node for the induction variable \p OrigPhi to resume; /// iteration count in the scalar epilogue, from where the vectorized loop; /// left off. \p Step is the SCEV-expanded induction step to use. In cases; /// where the loop skeleton is more complicated (i.e., epilogue vectorization); /// and the resume values can come from an additional bypass block, the \p; /// AdditionalBypass pair provides information about the bypass block and the; /// end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:319,Usability,resume,resume,319,"/// Create a new phi node for the induction variable \p OrigPhi to resume; /// iteration count in the scalar epilogue, from where the vectorized loop; /// left off. \p Step is the SCEV-expanded induction step to use. In cases; /// where the loop skeleton is more complicated (i.e., epilogue vectorization); /// and the resume values can come from an additional bypass block, the \p; /// AdditionalBypass pair provides information about the bypass block and the; /// end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Deployability,update,update,82,/// Create the exit value of first order recurrences in the middle block and; /// update their users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variables,43,"/// Create new phi nodes for the induction variables to resume iteration count; /// in the scalar epilogue, from where the vectorized loop left off.; /// In cases where the loop skeleton is more complicated (eg. epilogue; /// vectorization) and the resume values can come from an additional bypass; /// block, the \p AdditionalBypass pair provides information about the bypass; /// block and the end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,Usability,resume,resume,56,"/// Create new phi nodes for the induction variables to resume iteration count; /// in the scalar epilogue, from where the vectorized loop left off.; /// In cases where the loop skeleton is more complicated (eg. epilogue; /// vectorization) and the resume values can come from an additional bypass; /// block, the \p AdditionalBypass pair provides information about the bypass; /// block and the end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:249,Usability,resume,resume,249,"/// Create new phi nodes for the induction variables to resume iteration count; /// in the scalar epilogue, from where the vectorized loop left off.; /// In cases where the loop skeleton is more complicated (eg. epilogue; /// vectorization) and the resume values can come from an additional bypass; /// block, the \p AdditionalBypass pair provides information about the bypass; /// block and the end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:289,Performance,load,load,289,"/// Collect poison-generating recipes that may generate a poison value that is; /// used after vectorization, even when their operands are not poison. Those; /// recipes meet the following conditions:; /// * Contribute to the address computation of a recipe generating a widen; /// memory load/store (VPWidenMemoryInstructionRecipe or; /// VPInterleaveRecipe).; /// * Such a widen memory load/store has at least one underlying Instruction; /// that is in a basic block that needs predication and after vectorization; /// the generated instruction won't be predicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:388,Performance,load,load,388,"/// Collect poison-generating recipes that may generate a poison value that is; /// used after vectorization, even when their operands are not poison. Those; /// recipes meet the following conditions:; /// * Contribute to the address computation of a recipe generating a widen; /// memory load/store (VPWidenMemoryInstructionRecipe or; /// VPInterleaveRecipe).; /// * Such a widen memory load/store has at least one underlying Instruction; /// that is in a basic block that needs predication and after vectorization; /// the generated instruction won't be predicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around ScalarEvolution used to add runtime SCEV checks. Applies; /// dynamic knowledge to simplify SCEV expressions and converts them to a; /// more usable form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:104,Usability,simpl,simplify,104,/// A wrapper around ScalarEvolution used to add runtime SCEV checks. Applies; /// dynamic knowledge to simplify SCEV expressions and converts them to a; /// more usable form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Usability,usab,usable,163,/// A wrapper around ScalarEvolution used to add runtime SCEV checks. Applies; /// dynamic knowledge to simplify SCEV expressions and converts them to a; /// more usable form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:15,Performance,Cache,Cache,15,/// Assumption Cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Holds the end values for each induction variable. We save the end values; // so we can later fix-up the external users of the induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:139,Modifiability,variab,variables,139,// Holds the end values for each induction variable. We save the end values; // so we can later fix-up the external users of the induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,Performance,optimiz,optimizations,58,/// BFI and PSI are used to check for profile guided size optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:46,Usability,guid,guided,46,/// BFI and PSI are used to check for profile guided size optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:31,Performance,optimiz,optimized,31,// Whether this loop should be optimized for size based on profile guided size; // optimizatios.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:83,Performance,optimiz,optimizatios,83,// Whether this loop should be optimized for size based on profile guided size; // optimizatios.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:67,Usability,guid,guided,67,// Whether this loop should be optimized for size based on profile guided size; // optimizatios.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:13,Usability,resume,resume,13,"// Holds the resume values for reductions in the loops, used to set the; // correct start value of reduction PHIs when vectorizing the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:117,Deployability,update,updated,117,/// Encapsulate information regarding vectorization of a loop and its epilogue.; /// This information is meant to be updated and used across two stages of; /// epilogue vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:8,Integrability,interface,interface,8,"/// The interface for creating a vectorized skeleton using one of two; /// different strategies, each corresponding to one execution of the vplan; /// as described above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:14,Deployability,update,updates,14,/// Holds and updates state information required to vectorize the main loop; /// and its epilogue in two separate passes. This setup helps us avoid; /// regenerating and recomputing runtime safety checks. It also helps us to; /// shorten the iteration-count-check path length for the cases where the; /// iteration count of the loop is so small that the main vector loop is; /// completely skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:142,Safety,avoid,avoid,142,/// Holds and updates state information required to vectorize the main loop; /// and its epilogue in two separate passes. This setup helps us avoid; /// regenerating and recomputing runtime safety checks. It also helps us to; /// shorten the iteration-count-check path length for the cases where the; /// iteration count of the loop is so small that the main vector loop is; /// completely skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:190,Safety,safe,safety,190,/// Holds and updates state information required to vectorize the main loop; /// and its epilogue in two separate passes. This setup helps us avoid; /// regenerating and recomputing runtime safety checks. It also helps us to; /// shorten the iteration-count-check path length for the cases where the; /// iteration count of the loop is so small that the main vector loop is; /// completely skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:62,Performance,perform,performs,62,/// A specialized derived class of inner loop vectorizer that performs; /// vectorization of *main* loops in the process of vectorizing loops and their; /// epilogues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Integrability,interface,interface,19,/// Implements the interface for creating a vectorized skeleton using the; /// *main loop* strategy (ie the first pass of vplan execution).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:61,Performance,perform,performs,61,// A specialized derived class of inner loop vectorizer that performs; // vectorization of *epilogue* loops in the process of vectorizing loops and; // their epilogues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Integrability,interface,interface,19,/// Implements the interface for creating a vectorized skeleton using the; /// *epilogue loop* strategy (ie the second pass of vplan execution).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:100,Integrability,message,message,100,"/// Write a \p DebugMsg about vectorization to the debug output stream. If \p I; /// is passed, the message relates to that particular instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:69,Performance,load,load,69,"// This recipe contributes to the address computation of a widen; // load/store. If the underlying instruction has poison-generating flags,; // drop them directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:232,Safety,predict,predict,232,/// LoopVectorizationCostModel - estimates the expected speedups due to; /// vectorization.; /// In many cases vectorization is not profitable. This can happen because of; /// a number of reasons. In this class we mainly attempt to predict the; /// expected speedup/slowdowns due to the supported instruction set. We use the; /// TargetTransformInfo to query the different backends for the cost of; /// different operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Performance,scalab,scalable,78,"/// \return An upper bound for the vectorization factors (both fixed and; /// scalable). If the factors are 0, vectorization and interleaving should be; /// avoided up front.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:157,Safety,avoid,avoided,157,"/// \return An upper bound for the vectorization factors (both fixed and; /// scalable). If the factors are 0, vectorization and interleaving should be; /// avoided up front.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:420,Availability,redundant,redundant,420,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:115,Integrability,depend,depends,115,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:182,Performance,Load,Load,182,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:414,Safety,avoid,avoid,414,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:420,Safety,redund,redundant,420,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Security,access,access,11,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:101,Availability,avail,available,101,"/// A call may be vectorized in different ways depending on whether we have; /// vectorized variants available and whether the target supports masking.; /// This function analyzes all calls in the function at the supplied VF,; /// makes a decision based on the costs of available options, and stores that; /// decision in a map for use in planning and plan execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:143,Availability,mask,masking,143,"/// A call may be vectorized in different ways depending on whether we have; /// vectorized variants available and whether the target supports masking.; /// This function analyzes all calls in the function at the supplied VF,; /// makes a decision based on the costs of available options, and stores that; /// decision in a map for use in planning and plan execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:270,Availability,avail,available,270,"/// A call may be vectorized in different ways depending on whether we have; /// vectorized variants available and whether the target supports masking.; /// This function analyzes all calls in the function at the supplied VF,; /// makes a decision based on the costs of available options, and stores that; /// decision in a map for use in planning and plan execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:47,Integrability,depend,depending,47,"/// A call may be vectorized in different ways depending on whether we have; /// vectorized variants available and whether the target supports masking.; /// This function analyzes all calls in the function at the supplied VF,; /// makes a decision based on the costs of available options, and stores that; /// decision in a map for use in planning and plan execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:32,Performance,concurren,concurrent,32,/// Holds the maximum number of concurrent live intervals in the loop.; /// The key is ClassID of target-provided register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Security,access,accesses,19,// For consecutive accesses with stride +1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Security,access,accesses,19,// For consecutive accesses with stride -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:98,Modifiability,variab,variable,98,/// Return True if instruction \p I is an optimizable truncate whose operand; /// is an induction variable. Such a truncate will be removed by adding a new; /// induction variable with the destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:171,Modifiability,variab,variable,171,/// Return True if instruction \p I is an optimizable truncate whose operand; /// is an induction variable. Such a truncate will be removed by adding a new; /// induction variable with the destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Performance,optimiz,optimizable,42,/// Return True if instruction \p I is an optimizable truncate whose operand; /// is an induction variable. Such a truncate will be removed by adding a new; /// induction variable with the destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:155,Deployability,update,update,155,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:289,Deployability,update,update,289,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:110,Modifiability,variab,variable,110,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:142,Modifiability,variab,variable,142,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:258,Modifiability,variab,variable,258,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:46,Modifiability,variab,variable,46,"// If the truncated value is not an induction variable, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:73,Integrability,depend,depend,73,"/// Collect Uniform and Scalar values for the given \p VF.; /// The sets depend on CM decision for Load/Store instructions; /// that may be vectorized as interleave, gather-scatter or scalarized.; /// Also make a decision on what to do about call instructions in the loop; /// at that VF -- scalarize, call a known vector routine, or call a; /// vector intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:322,Integrability,rout,routine,322,"/// Collect Uniform and Scalar values for the given \p VF.; /// The sets depend on CM decision for Load/Store instructions; /// that may be vectorized as interleave, gather-scatter or scalarized.; /// Also make a decision on what to do about call instructions in the loop; /// at that VF -- scalarize, call a known vector routine, or call a; /// vector intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:99,Performance,Load,Load,99,"/// Collect Uniform and Scalar values for the given \p VF.; /// The sets depend on CM decision for Load/Store instructions; /// that may be vectorized as interleave, gather-scatter or scalarized.; /// Also make a decision on what to do about call instructions in the loop; /// at that VF -- scalarize, call a known vector routine, or call a; /// vector intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,Availability,mask,masked,48,/// Returns true if the target machine supports masked store operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:114,Security,access,access,114,/// Returns true if the target machine supports masked store operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,Availability,mask,masked,48,/// Returns true if the target machine supports masked load operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:55,Performance,load,load,55,/// Returns true if the target machine supports masked load operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:113,Security,access,access,113,/// Returns true if the target machine supports masked load operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:63,Availability,mask,masked,63,/// Returns true if the target machine can represent \p V as a masked gather; /// or scatter operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:74,Modifiability,variab,variables,74,/// Returns true if the target machine supports all of the reduction; /// variables found for the given VF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:172,Usability,simpl,simply,172,"/// Given costs for both strategies, return true if the scalar predication; /// lowering should be used for div/rem. This incorporates an override; /// option so it is not simply a cost comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:193,Availability,mask,masking,193,/// Returns true if \p I is an instruction which requires predication and; /// for which our chosen predication strategy is scalarization (i.e. we; /// don't have an alternate strategy such as masking available).; /// \p VF is the vectorization factor that will be used to vectorize \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:201,Availability,avail,available,201,/// Returns true if \p I is an instruction which requires predication and; /// for which our chosen predication strategy is scalarization (i.e. we; /// don't have an alternate strategy such as masking available).; /// \p VF is the vectorization factor that will be used to vectorize \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,avail,available,33,/// Return the costs for our two available strategies for lowering a; /// div/rem operation which requires speculating at least one lane.; /// First result is for scalarization (will be invalid for scalable; /// vectors); second is for the safe-divisor strategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:198,Performance,scalab,scalable,198,/// Return the costs for our two available strategies for lowering a; /// div/rem operation which requires speculating at least one lane.; /// First result is for scalarization (will be invalid for scalable; /// vectors); second is for the safe-divisor strategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:240,Safety,safe,safe-divisor,240,/// Return the costs for our two available strategies for lowering a; /// div/rem operation which requires speculating at least one lane.; /// First result is for scalarization (will be invalid for scalable; /// vectors); second is for the safe-divisor strategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Security,access,access,78,/// Returns true if \p I is a memory instruction with consecutive memory; /// access that can be widened.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:137,Performance,load,loads,137,/// Returns true if \p I is a memory instruction in an interleaved-group; /// of memory accesses that can be vectorized with wide vector loads/stores; /// and shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:88,Security,access,accesses,88,/// Returns true if \p I is a memory instruction in an interleaved-group; /// of memory accesses that can be vectorized with wide vector loads/stores; /// and shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:49,Security,access,access,49,/// Check if \p Instr belongs to any interleaved access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Security,access,access,24,/// Get the interleaved access group that \p Instr belongs to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:46,Availability,mask,masked,46,/// Returns true if all loop blocks should be masked to fold tail loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:158,Energy Efficiency,power,power-of-,158,"/// \return An upper bound for the vectorization factors for both; /// fixed and scalable vectorization, where the minimum-known number of; /// elements is a power-of-2 larger than zero. If scalable vectorization is; /// disabled or unsupported, then the scalable part will be equal to; /// ElementCount::getScalable(0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:81,Performance,scalab,scalable,81,"/// \return An upper bound for the vectorization factors for both; /// fixed and scalable vectorization, where the minimum-known number of; /// elements is a power-of-2 larger than zero. If scalable vectorization is; /// disabled or unsupported, then the scalable part will be equal to; /// ElementCount::getScalable(0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:190,Performance,scalab,scalable,190,"/// \return An upper bound for the vectorization factors for both; /// fixed and scalable vectorization, where the minimum-known number of; /// elements is a power-of-2 larger than zero. If scalable vectorization is; /// disabled or unsupported, then the scalable part will be equal to; /// ElementCount::getScalable(0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:255,Performance,scalab,scalable,255,"/// \return An upper bound for the vectorization factors for both; /// fixed and scalable vectorization, where the minimum-known number of; /// elements is a power-of-2 larger than zero. If scalable vectorization is; /// disabled or unsupported, then the scalable part will be equal to; /// ElementCount::getScalable(0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:133,Safety,safe,safe,133,"/// \return the maximized element count based on the targets vector; /// registers and the loop trip-count, but limited to a maximum safe VF.; /// This is a helper function of computeFeasibleMaxVF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:30,Performance,scalab,scalable,30,"/// \return the maximum legal scalable VF, based on the safe max number; /// of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,Safety,safe,safe,56,"/// \return the maximum legal scalable VF, based on the safe max number; /// of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,Testability,log,logic,25,/// The cost-computation logic from getInstructionCost which provides; /// the vector type as an output parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:84,Security,access,access,84,/// The cost computation for widening instruction \p I with consecutive; /// memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Performance,Load,Load,29,/// The cost calculation for Load/Store instruction \p I with uniform pointer -; /// Load: scalar load + broadcast.; /// Store: scalar store + (loop invariant value stored? 0 : extract of last; /// element),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:85,Performance,Load,Load,85,/// The cost calculation for Load/Store instruction \p I with uniform pointer -; /// Load: scalar load + broadcast.; /// Store: scalar store + (loop invariant value stored? 0 : extract of last; /// element),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:98,Performance,load,load,98,/// The cost calculation for Load/Store instruction \p I with uniform pointer -; /// Load: scalar load + broadcast.; /// Store: scalar store + (loop invariant value stored? 0 : extract of last; /// element),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:84,Integrability,wrap,wrapper,84,/// Estimate the overhead of scalarizing an instruction. This is a; /// convenience wrapper for the type-based getScalarizationOverhead API.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:59,Availability,mask,masked,59,/// Returns true if an artificially high cost for emulated masked memrefs; /// should be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Integrability,depend,dependence,163,"/// Records whether it is allowed to have the original scalar loop execute at; /// least once. This may be needed as a fallback loop in case runtime; /// aliasing/dependence checks fail, or to handle the tail/remainder; /// iterations when the trip count is unknown or doesn't divide by the VF,; /// or as a peel-loop to handle gaps in interleave-groups.; /// Under optsize and when the trip count is very small we don't allow any; /// iterations to execute in the scalar loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,mask,masked,33,/// All blocks of loop are to be masked to fold tail of scalar iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:317,Security,access,accesses,317,"/// Collect the instructions that are uniform after vectorization. An; /// instruction is uniform if we represent it with a single scalar value in; /// the vectorized loop corresponding to each vector iteration. Examples of; /// uniform instructions include pointer operands of consecutive or; /// interleaved memory accesses. Note that although uniformity implies an; /// instruction will be scalar, the reverse is not true. In general, a; /// scalarized instruction will be represented by VF scalar values in the; /// vectorized loop, each corresponding to an iteration of the original; /// scalar loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:266,Performance,load,load,266,"/// Collect the instructions that are scalar after vectorization. An; /// instruction is scalar if it is known to be uniform or will be scalarized; /// during vectorization. collectLoopScalars should only add non-uniform nodes; /// to the list if they are used by a load/store instruction that is marked as; /// CM_Scalarize. Non-uniform scalarized instructions will be represented by; /// VF values in the vectorized loop, each corresponding to an iteration of; /// the original scalar loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:262,Safety,safe,safe,262,"// Assume we can vectorize V (and hence we need extraction) if the; // scalars are not computed yet. This can happen, because it is called; // via getScalarizationOverhead from setCostBasedWideningDecision, before; // the scalars are collected. That should be a safe assumption in most; // cases, because we check if the operands have vectorizable types; // beforehand in LoopVectorizationLegality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:15,Performance,cache,cache,15,/// Assumption cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Security,access,access,19,/// The interleave access information contains groups of interleaved accesses; /// with the same stride and close to each other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:69,Security,access,accesses,69,/// The interleave access information contains groups of interleaved accesses; /// with the same stride and close to each other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:47,Deployability,update,update,47,"// Unhook the temporary block with the checks, update various places; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:220,Energy Efficiency,reduce,reduce,220,"// If the runtime memory checks are being created inside an outer loop; // we should find out if these checks are outer loop invariant. If so,; // the checks will likely be hoisted out and so the effective cost will; // reduce according to the outer loop trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:45,Energy Efficiency,reduce,reduce,45,// It seems reasonable to assume that we can reduce the effective; // cost of the checks even when we know nothing about the trip; // count. Assume that the outer loop executes at least twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:28,Availability,avail,available,28,// Else use profile data if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:151,Integrability,depend,depending,151,"/// Adds the generated SCEVCheckBlock before \p LoopVectorPreHeader and; /// adjusts the branches to branch to the vector preheader or \p Bypass,; /// depending on the generated condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:145,Integrability,depend,depending,145,"/// Adds the generated MemCheckBlock before \p LoopVectorPreHeader and adjusts; /// the branches to branch to the vector preheader or \p Bypass, depending on; /// the generated condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:172,Testability,test,testing,172,"// Collect inner loops and outer loops without irreducible control flow. For; // now, only collect outer loops that have explicit vectorization hints. If we; // are stress testing the VPlan H-CFG construction, we collect the outermost; // loop of every loop nest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:244,Modifiability,inherit,inherited,244,// TODO: Collect inner loops inside marked outer loops in case; // vectorization fails for the outer loop. Do not invoke; // 'containsIrreducibleCFG' again for inner loops when the outer loop is; // already known to be reducible. We can use an inherited attribute for; // that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:124,Usability,simpl,simplification,124,"// Note: the IR at this point is broken. We cannot use SE to create any new; // SCEV and then expand it, hoping that SCEV's simplification will give us; // a more optimal code. Unfortunately, attempt of doing so on invalid IR may; // lead to various SCEV crashes. So all we can do is to use builder and rely; // on InstCombine for future simplifications. Here we handle some trivial; // cases only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:338,Usability,simpl,simplifications,338,"// Note: the IR at this point is broken. We cannot use SE to create any new; // SCEV and then expand it, hoping that SCEV's simplification will give us; // a more optimal code. Unfortunately, attempt of doing so on invalid IR may; // lead to various SCEV crashes. So all we can do is to use builder and rely; // on InstCombine for future simplifications. Here we handle some trivial; // cases only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:108,Modifiability,variab,variable,108,"/// For the given VF and UF and maximum trip count computed for the loop, return; /// whether the induction variable might overflow in the vectorized loop. If not,; /// then we know a runtime overflow check always evaluates to false and can be; /// removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:187,Modifiability,variab,variable,187,// We know the runtime overflow check is known false iff the (max) trip-count; // is known and (max) trip-count + (VF * UF) does not overflow in the type of; // the vector loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,mask,masked,33,"// Return whether we allow using masked interleave-groups (for dealing with; // strided loads/stores that reside in predicated blocks, or for dealing; // with gaps).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:88,Performance,load,loads,88,"// Return whether we allow using masked interleave-groups (for dealing with; // strided loads/stores that reside in predicated blocks, or for dealing; // with gaps).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:60,Security,access,accesses,60,"// If an override option has been passed in for interleaved accesses, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:112,Performance,load,load,112,"// Try to vectorize the interleave group that \p Instr belongs to.; //; // E.g. Translate following interleaved load group (factor = 3):; // for (i = 0; i < N; i+=3) {; // R = Pic[i]; // Member of index 0; // G = Pic[i+1]; // Member of index 1; // B = Pic[i+2]; // Member of index 2; // ... // do something to R, G, B; // }; // To:; // %wide.vec = load <12 x i32> ; Read 4 tuples of R,G,B; // %R.vec = shuffle %wide.vec, poison, <0, 3, 6, 9> ; R elements; // %G.vec = shuffle %wide.vec, poison, <1, 4, 7, 10> ; G elements; // %B.vec = shuffle %wide.vec, poison, <2, 5, 8, 11> ; B elements; //; // Or translate following interleaved store group (factor = 3):; // for (i = 0; i < N; i+=3) {; // ... do something to R, G, B; // Pic[i] = R; // Member of index 0; // Pic[i+1] = G; // Member of index 1; // Pic[i+2] = B; // Member of index 2; // }; // To:; // %R_G.vec = shuffle %R.vec, %G.vec, <0, 1, 2, ..., 7>; // %B_U.vec = shuffle %B.vec, poison, <0, 1, 2, 3, u, u, u, u>; // %interleaved.vec = shuffle %R_G.vec, %B_U.vec,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11> ; Interleave R,G,B elements; // store <12 x i32> %interleaved.vec ; Write 4 tuples of R,G,B",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:348,Performance,load,load,348,"// Try to vectorize the interleave group that \p Instr belongs to.; //; // E.g. Translate following interleaved load group (factor = 3):; // for (i = 0; i < N; i+=3) {; // R = Pic[i]; // Member of index 0; // G = Pic[i+1]; // Member of index 1; // B = Pic[i+2]; // Member of index 2; // ... // do something to R, G, B; // }; // To:; // %wide.vec = load <12 x i32> ; Read 4 tuples of R,G,B; // %R.vec = shuffle %wide.vec, poison, <0, 3, 6, 9> ; R elements; // %G.vec = shuffle %wide.vec, poison, <1, 4, 7, 10> ; G elements; // %B.vec = shuffle %wide.vec, poison, <2, 5, 8, 11> ; B elements; //; // Or translate following interleaved store group (factor = 3):; // for (i = 0; i < N; i+=3) {; // ... do something to R, G, B; // Pic[i] = R; // Member of index 0; // Pic[i+1] = G; // Member of index 1; // Pic[i+2] = B; // Member of index 2; // }; // To:; // %R_G.vec = shuffle %R.vec, %G.vec, <0, 1, 2, ..., 7>; // %B_U.vec = shuffle %B.vec, poison, <0, 1, 2, 3, u, u, u, u>; // %interleaved.vec = shuffle %R_G.vec, %B_U.vec,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11> ; Interleave R,G,B elements; // store <12 x i32> %interleaved.vec ; Write 4 tuples of R,G,B",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:50,Performance,load,load,50,// Prepare for the vector type of the interleaved load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Availability,mask,masked,20,// TODO: extend the masked interleaved-group support to reversed access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:9,Modifiability,extend,extend,9,// TODO: extend the masked interleaved-group support to reversed access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:65,Security,access,access,65,// TODO: extend the masked interleaved-group support to reversed access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:265,Security,access,access,265,"// If the group is reverse, adjust the index to refer to the last vector lane; // instead of the first. We adjust the index from the first vector lane,; // rather than directly getting the pointer for lane VF - 1, because the; // pointer operand of the interleaved access is supposed to be uniform. For; // uniform instructions, we're only required to generate a value for the; // first vector lane in each unroll iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Performance,load,load,29,// Vectorize the interleaved load group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:39,Performance,load,load,39,"// For each unroll part, create a wide load for the group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot use arbitrary shufflevectors (only splats),; // so must use intrinsics to deinterleave.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:84,Performance,load,loads,84,"// For each member in the group, shuffle out the appropriate data from the; // wide loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:61,Performance,cache,cache,61,"// If we just cloned a new assumption, add it the assumption cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Availability,mask,masking,34,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:125,Availability,down,down,125,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:189,Availability,down,down,189,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:355,Energy Efficiency,power,power,355,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:524,Energy Efficiency,power,power,524,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:291,Integrability,wrap,wrap,291,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:266,Modifiability,variab,variable,266,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:474,Performance,scalab,scalable,474,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:31,Energy Efficiency,power,power-of-,31,"// vscale is not necessarily a power-of-2, which means we cannot guarantee; // an overflow to zero when updating induction variables and so an; // additional overflow check is required before entering the vector loop.; // Get the maximum unsigned value for the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:123,Modifiability,variab,variables,123,"// vscale is not necessarily a power-of-2, which means we cannot guarantee; // an overflow to zero when updating induction variables and so an; // additional overflow check is required before entering the vector loop.; // Get the maximum unsigned value for the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Deployability,Update,Update,3,// Update dominator for Bypass & LoopExit (if needed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Deployability,update,update,120,"// If there is an epilogue which must run, there's no edge from the; // middle block to exit blocks and thus no need to update the immediate; // dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Deployability,Update,Update,3,// Update dominator only if this is first RT check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Deployability,update,update,120,"// If there is an epilogue which must run, there's no edge from the; // middle block to exit blocks and thus no need to update the immediate; // dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:404,Deployability,update,update,404,"// Set up the middle block terminator. Two cases:; // 1) If we know that we must execute the scalar epilogue, emit an; // unconditional branch.; // 2) Otherwise, we must have a single unique exit block (due to how we; // implement the multiple exit case). In this case, set up a conditional; // branch from the middle block to the loop scalar preheader, and the; // exit block. completeLoopSkeleton will update the condition to use an; // iteration check, if required to decide whether to execute the remainder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Deployability,Update,Update,3,"// Update dominator for loop exit. During skeleton creation, only the vector; // pre-header and the middle block are created. The vector loop is entirely; // created during VPlan exection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Deployability,update,update,120,"// If there is an epilogue which must run, there's no edge from the; // middle block to exit blocks and thus no need to update the immediate; // dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:224,Integrability,depend,depend,224,// We are going to resume the execution of the scalar loop.; // Go over all of the induction variables that we found and fix the; // PHIs that are left in the scalar version of the loop.; // The starting values of PHI nodes depend on the counter of the last; // iteration in the vectorized loop.; // If we come from a bypass edge then we need to start from the original; // start value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:93,Modifiability,variab,variables,93,// We are going to resume the execution of the scalar loop.; // Go over all of the induction variables that we found and fix the; // PHIs that are left in the scalar version of the loop.; // The starting values of PHI nodes depend on the counter of the last; // iteration in the vectorized loop.; // If we come from a bypass edge then we need to start from the original; // start value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Usability,resume,resume,19,// We are going to resume the execution of the scalar loop.; // Go over all of the induction variables that we found and fix the; // PHIs that are left in the scalar version of the loop.; // The starting values of PHI nodes depend on the counter of the last; // iteration in the vectorized loop.; // If we come from a bypass edge then we need to start from the original; // start value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Performance,cache,cached,29,// The trip counts should be cached by now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:386,Performance,Perform,Perform,386,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:188,Safety,avoid,avoid,188,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:338,Usability,simpl,simplify,338,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:394,Usability,simpl,simplification,394,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Modifiability,variab,variable,42,"// Fix up external users of the induction variable. At this point, we are; // in LCSSA form, with all external PHIs that use the IV having one input value,; // coming from the remainder loop. We need those PHIs to also have a correct; // value for the IV when arriving directly from the middle block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Usability,simpl,simplest,82,"// An external user of the penultimate value need to see EndValue - Step.; // The simplest way to get this is to recompute it from the constituent SCEVs,; // that is Start + (Step * (CRD - 1)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:174,Safety,avoid,avoid,174,"// One corner case we have to handle is two IVs ""chasing"" each-other,; // that is %IV2 = phi [...], [ %IV1, %latch ]; // In this case, if IV1 has an external use, we need to avoid adding both; // ""last value of IV1"" and ""penultimate value of IV2"". So, verify that we; // don't already have an incoming value for the middle block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,Modifiability,variab,variable,56,// end anonymous namespace; ///Perform cse of induction variable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:31,Performance,Perform,Perform,31,// end anonymous namespace; ///Perform cse of induction variable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Perform,Perform,3,// Perform simple cse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Usability,simpl,simple,11,// Perform simple cse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:176,Deployability,update,update,176,"// TODO: Check VPLiveOuts to see if IV users need fixing instead of checking; // the cost model.; // If we inserted an edge from the middle block to the unique exit block,; // update uses outside the loop (phis) to account for the newly inserted; // edge.; // Fix-up external users of the induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:299,Modifiability,variab,variables,299,"// TODO: Check VPLiveOuts to see if IV users need fixing instead of checking; // the cost model.; // If we inserted an edge from the middle block to the unique exit block,; // update uses outside the loop (phis) to account for the newly inserted; // edge.; // Fix-up external users of the induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:105,Deployability,update,update,105,"// Fix LCSSA phis not already fixed earlier. Extracts may need to be generated; // in the exit block, so update the builder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,Availability,redundant,redundant,10,// Remove redundant induction instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,Safety,redund,redundant,10,// Remove redundant induction instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Deployability,update,update,7,"// Set/update profile weights for the vector and remainder loops as original; // loop iterations are now distributed among them. Note that original loop; // represented by LoopScalarBody becomes remainder loop after vectorization.; //; // For cases like foldTailByMasking() and requiresScalarEpiloque() we may; // end up getting slightly roughened result but that should be OK since; // profile is not inherently precise anyway. Note also possible bypass of; // vector code caused by legality checks is ignored, assigning all the weight; // to the vector loop, optimistically.; //; // For scalable vectorization we can't know at compile time how many iterations; // of the loop are handled in one vector iteration, so instead assume a pessimistic; // vscale of '1'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:589,Performance,scalab,scalable,589,"// Set/update profile weights for the vector and remainder loops as original; // loop iterations are now distributed among them. Note that original loop; // represented by LoopScalarBody becomes remainder loop after vectorization.; //; // For cases like foldTailByMasking() and requiresScalarEpiloque() we may; // end up getting slightly roughened result but that should be OK since; // profile is not inherently precise anyway. Note also possible bypass of; // vector code caused by legality checks is ignored, assigning all the weight; // to the vector loop, optimistically.; //; // For scalable vectorization we can't know at compile time how many iterations; // of the loop are handled in one vector iteration, so instead assume a pessimistic; // vscale of '1'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:638,Integrability,depend,depends,638,"// This is the second phase of vectorizing first-order recurrences. An; // overview of the transformation is described below. Suppose we have the; // following loop.; //; // for (int i = 0; i < n; ++i); // b[i] = a[i] - a[i - 1];; //; // There is a first-order recurrence on ""a"". For this loop, the shorthand; // scalar IR looks like:; //; // scalar.ph:; // s_init = a[-1]; // br scalar.body; //; // scalar.body:; // i = phi [0, scalar.ph], [i+1, scalar.body]; // s1 = phi [s_init, scalar.ph], [s2, scalar.body]; // s2 = a[i]; // b[i] = s2 - s1; // br cond, scalar.body, ...; //; // In this example, s1 is a recurrence because it's value depends on the; // previous iteration. In the first phase of vectorization, we created a; // vector phi v1 for s1. We now complete the vectorization and produce the; // shorthand vector IR shown below (for VF = 4, UF = 1).; //; // vector.ph:; // v_init = vector(..., ..., ..., a[-1]); // br vector.body; //; // vector.body; // i = phi [0, vector.ph], [i+4, vector.body]; // v1 = phi [v_init, vector.ph], [v2, vector.body]; // v2 = a[i, i+1, i+2, i+3];; // v3 = vector(v1(3), v2(0, 1, 2)); // b[i, i+1, i+2, i+3] = v2 - v3; // br cond, vector.body, middle.block; //; // middle.block:; // x = v2(3); // br scalar.ph; //; // scalar.ph:; // s_init = phi [x, middle.block], [a[-1], otherwise]; // br scalar.body; //; // After execution completes the vector loop, we extract the next value of; // the recurrence (x) to use as the initial value in the scalar loop.; // Extract the last vector element in the middle block. This will be the; // initial value for the recurrence when jumping to the scalar loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:168,Deployability,update,update,168,"// Extract the second last element in the middle block if the; // Phi is used outside the loop. We need to extract the phi itself; // and not the last element (the phi update in the current iteration). This; // will be the value when jumping to the exit block from the; // LoopMiddleBlock, when the scalar loop is not run at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:185,Performance,load,load,185,"// We can't sink an instruction if it is a phi node, is not in the loop,; // may have side effects or may read from memory.; // TODO Could dor more granular checking to allow sinking a load past non-store instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:184,Performance,scalab,scalable,184,"// This avoids any chances of creating a REPLICATE recipe during planning; // since that would result in generation of scalarized code during execution,; // which is not supported for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:8,Safety,avoid,avoids,8,"// This avoids any chances of creating a REPLICATE recipe during planning; // since that would result in generation of scalarized code during execution,; // which is not supported for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:77,Security,access,accesses,77,// These sets are used to seed the analysis with pointers used by memory; // accesses that will remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:105,Performance,load,loads,105,// A helper that returns true if the use of Ptr by MemAccess will be scalar.; // The pointer operands of loads and stores will be scalar as long as the; // memory access is not a gather or scatter operation. The value operand of a; // store will remain scalar if the store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Security,access,access,163,// A helper that returns true if the use of Ptr by MemAccess will be scalar.; // The pointer operands of loads and stores will be scalar as long as the; // memory access is not a gather or scatter operation. The value operand of a; // store will remain scalar if the store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:36,Security,access,access,36,"// A helper that evaluates a memory access's use of a pointer. If the use will; // be a scalar use and the pointer is only used by memory accesses, we place; // the pointer in ScalarPtrs. Otherwise, the pointer is placed in; // PossibleNonScalarPtrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:138,Security,access,accesses,138,"// A helper that evaluates a memory access's use of a pointer. If the use will; // be a scalar use and the pointer is only used by memory accesses, we place; // the pointer in ScalarPtrs. Otherwise, the pointer is placed in; // PossibleNonScalarPtrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:95,Security,access,accesses,95,"// If the use of the pointer will be a scalar use, and all users of the; // pointer are memory accesses, place the pointer in ScalarPtrs. Otherwise,; // place the pointer in PossibleNonScalarPtrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:205,Security,access,accesses,205,"// We seed the scalars analysis with three classes of instructions: (1); // instructions marked uniform-after-vectorization and (2) bitcast,; // getelementptr and (pointer) phi instructions used by memory accesses; // requiring a scalar use.; //; // (1) Add to the worklist all instructions that have been identified as; // uniform-after-vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:146,Performance,load,loads,146,// (2) Add to the worklist all bitcast and getelementptr instructions used by; // memory accesses requiring a scalar use. The pointer operands of loads and; // stores will be scalar as long as the memory accesses is not a gather or; // scatter operation. The value operand of a store will remain scalar if the; // store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,Security,access,accesses,89,// (2) Add to the worklist all bitcast and getelementptr instructions used by; // memory accesses requiring a scalar use. The pointer operands of loads and; // stores will be scalar as long as the memory accesses is not a gather or; // scatter operation. The value operand of a store will remain scalar if the; // store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:204,Security,access,accesses,204,// (2) Add to the worklist all bitcast and getelementptr instructions used by; // memory accesses requiring a scalar use. The pointer operands of loads and; // stores will be scalar as long as the memory accesses is not a gather or; // scatter operation. The value operand of a store will remain scalar if the; // store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:112,Modifiability,variab,variable,112,// Insert the forced scalars.; // FIXME: Currently VPWidenPHIRecipe() often creates a dead vector; // induction variable when the PHI user is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:110,Deployability,update,update,110,// An induction variable will remain scalar if all users of the induction; // variable and induction variable update remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:16,Modifiability,variab,variable,16,// An induction variable will remain scalar if all users of the induction; // variable and induction variable update remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Modifiability,variab,variable,78,// An induction variable will remain scalar if all users of the induction; // variable and induction variable update remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:101,Modifiability,variab,variable,101,// An induction variable will remain scalar if all users of the induction; // variable and induction variable update remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:53,Modifiability,variab,variable,53,"// If tail-folding is applied, the primary induction variable will be used; // to feed a vector compare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:81,Performance,load,load,81,// Returns true if \p Indvar is a pointer induction that is used directly by; // load/store instruction \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Determine if all users of the induction variable are scalar after; // vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:52,Deployability,update,update,52,// Determine if all users of the induction variable update instruction are; // scalar after vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Determine if all users of the induction variable update instruction are; // scalar after vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Deployability,update,update,34,// The induction variable and its update instruction will remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:17,Modifiability,variab,variable,17,// The induction variable and its update instruction will remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:147,Performance,scalab,scalable,147,// We have the option to use the safe-divisor idiom to avoid predication.; // The cost based decision here will always select safe-divisor for; // scalable vectors as scalarization isn't legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Safety,safe,safe-divisor,33,// We have the option to use the safe-divisor idiom to avoid predication.; // The cost based decision here will always select safe-divisor for; // scalable vectors as scalarization isn't legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:55,Safety,avoid,avoid,55,// We have the option to use the safe-divisor idiom to avoid predication.; // The cost based decision here will always select safe-divisor for; // scalable vectors as scalarization isn't legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:126,Safety,safe,safe-divisor,126,// We have the option to use the safe-divisor idiom to avoid predication.; // The cost based decision here will always select safe-divisor for; // scalable vectors as scalarization isn't legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:36,Safety,safe,safe,36,"// Can we prove this instruction is safe to unconditionally execute?; // If not, we must use some form of predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Performance,load,load,20,"// When we know the load's address is loop invariant and the instruction; // in the original scalar loop was unconditionally executed then we; // don't need to mark it as a predicated instruction. Tail folding may; // introduce additional predication, but we're guaranteed to always have; // at least one active lane. We call Legal->blockNeedsPredication here; // because it doesn't query tail-folding. For stores, we need to prove; // both speculation safety (which follows from the same argument as loads),; // but also must prove the value being stored is correct. The easiest; // form of the later is to require that all values stored are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:501,Performance,load,loads,501,"// When we know the load's address is loop invariant and the instruction; // in the original scalar loop was unconditionally executed then we; // don't need to mark it as a predicated instruction. Tail folding may; // introduce additional predication, but we're guaranteed to always have; // at least one active lane. We call Legal->blockNeedsPredication here; // because it doesn't query tail-folding. For stores, we need to prove; // both speculation safety (which follows from the same argument as loads),; // but also must prove the value being stored is correct. The easiest; // form of the later is to require that all values stored are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:453,Safety,safe,safety,453,"// When we know the load's address is loop invariant and the instruction; // in the original scalar loop was unconditionally executed then we; // don't need to mark it as a predicated instruction. Tail folding may; // introduce additional predication, but we're guaranteed to always have; // at least one active lane. We call Legal->blockNeedsPredication here; // because it doesn't query tail-folding. For stores, we need to prove; // both speculation safety (which follows from the same argument as loads),; // but also must prove the value being stored is correct. The easiest; // form of the later is to require that all values stored are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Performance,scalab,scalable,33,// Scalarization isn't legal for scalable vector types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Energy Efficiency,allocate,allocated,24,"// If the instruction's allocated size doesn't equal it's type size, it; // requires padding and will be scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:12,Availability,mask,masking,12,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:54,Availability,mask,masking,54,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:161,Availability,mask,masking,161,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:221,Performance,load,load-access,221,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:270,Performance,load,load,270,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:226,Security,access,access,226,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:299,Security,access,access,299,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,Availability,mask,masked,6,"// If masked interleaving is required, we expect that the user/target had; // enabled it, because otherwise it either wouldn't have been created or; // it should have been invalidated by the CostModel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Energy Efficiency,allocate,allocated,24,"// If the instruction's allocated size doesn't equal it's type size, it; // requires padding and will be scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:297,Performance,optimiz,optimize,297,"// Add uniform instructions demanding lane 0 to the worklist. Instructions; // that are scalar with predication must not be considered uniform after; // vectorization, because that would create an erroneous replicating region; // where only a single instance out of VF should be formed.; // TODO: optimize such seldom cases if found important, see PR40816.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:28,Performance,perform,perform,28,"// Return true if all lanes perform the same memory operation, and we can; // thus chose to execute only one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Load,Loading,3,// Loading the same address always produces the same result - at least; // assuming aliasing and ordering which have already been checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,Security,access,access,58,"// Returns true if Ptr is the pointer operand of a memory access instruction; // I, I is known to not require scalarization, and the pointer is not also; // stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:355,Deployability,update,update,355,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:193,Integrability,depend,dependence,193,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:260,Modifiability,variab,variable,260,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:323,Modifiability,variab,variable,323,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:346,Modifiability,variab,variable,346,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:444,Modifiability,variab,variables,444,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Determine if all users of the induction variable are uniform after; // vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:52,Deployability,update,update,52,// Determine if all users of the induction variable update instruction are; // uniform after vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Determine if all users of the induction variable update instruction are; // uniform after vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Deployability,update,update,34,// The induction variable and its update instruction will remain uniform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:17,Modifiability,variab,variable,17,// The induction variable and its update instruction will remain uniform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid specializing for stride==1 instead of bailing out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:98,Performance,scalab,scalable,98,"// Test that the loop-vectorizer can legalize all operations for this MaxVF.; // FIXME: While for scalable vectors this is currently sufficient, this should; // be replaced by a more detailed mechanism that filters out specific VFs,; // instead of invalidating vectorization for a whole set of VFs based on the; // MaxVF.; // Disable scalable vectorization if the loop contains unsupported reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:334,Performance,scalab,scalable,334,"// Test that the loop-vectorizer can legalize all operations for this MaxVF.; // FIXME: While for scalable vectors this is currently sufficient, this should; // be replaced by a more detailed mechanism that filters out specific VFs,; // instead of invalidating vectorization for a whole set of VFs based on the; // MaxVF.; // Disable scalable vectorization if the loop contains unsupported reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Testability,Test,Test,3,"// Test that the loop-vectorizer can legalize all operations for this MaxVF.; // FIXME: While for scalable vectors this is currently sufficient, this should; // be replaced by a more detailed mechanism that filters out specific VFs,; // instead of invalidating vectorization for a whole set of VFs based on the; // MaxVF.; // Disable scalable vectorization if the loop contains unsupported reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Performance,scalab,scalable,11,// Disable scalable vectorization if the loop contains any instructions; // with element types not supported for scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:113,Performance,scalab,scalable,113,// Disable scalable vectorization if the loop contains any instructions; // with element types not supported for scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Integrability,depend,dependence,43,// Limit MaxScalableVF by the maximum safe dependence distance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:38,Safety,safe,safe,38,// Limit MaxScalableVF by the maximum safe dependence distance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Integrability,depend,dependence,24,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:221,Integrability,depend,dependence,221,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Safety,safe,safe,19,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:157,Security,access,accesses,157,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,Safety,safe,safe,25,"// If `VF=vscale x N` is safe, then so is `VF=N`",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:35,Performance,scalab,scalable,35,"// Only clamp if the UserVF is not scalable. If the UserVF is scalable, it; // is better to ignore the hint and let the compiler choose a suitable VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:62,Performance,scalab,scalable,62,"// Only clamp if the UserVF is not scalable. If the UserVF is scalable, it; // is better to ignore the hint and let the compiler choose a suitable VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:244,Availability,mask,mask,244,"// The only loops we can vectorize without a scalar epilogue, are loops with; // a bottom-test and a single exiting block. We'd have to handle the fact; // that not every instruction executes on the last iteration. This will; // require a lane mask which varies through the vector loop body. (TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:90,Testability,test,test,90,"// The only loops we can vectorize without a scalar epilogue, are loops with; // a bottom-test and a single exiting block. We'd have to handle the fact; // that not every instruction executes on the last iteration. This will; // require a lane mask which varies through the vector loop body. (TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Availability,mask,masking,78,"// If there was a tail-folding hint/switch, but we can't fold the tail by; // masking, fallback to a vectorization with a scalar epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:98,Availability,mask,mask,98,// Now try the tail folding; // Invalidate interleave groups that require an epilogue if we can't mask; // the interleave-group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Safety,Avoid,Avoid,3,// Avoid tail folding if the trip count is known to be a multiple of any VF; // we choose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:156,Availability,mask,masking,156,"// If we don't know the precise trip count, or if the trip count that we; // found modulo the vectorization factor is not zero, try to fold the tail; // by masking.; // FIXME: look for a smaller MaxVF that does divide TC rather than masking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:233,Availability,mask,masking,233,"// If we don't know the precise trip count, or if the trip count that we; // found modulo the vectorization factor is not zero, try to fold the tail; // by masking.; // FIXME: look for a smaller MaxVF that does divide TC rather than masking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Availability,mask,masking,78,"// If there was a tail-folding hint/switch, but we can't fold the tail by; // masking, fallback to a vectorization with a scalar epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:21,Energy Efficiency,power,power,21,// Ensure MaxVF is a power of 2; the dependence distance bound may not be.; // Note that both WidestRegister and WidestType may not be a powers of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:137,Energy Efficiency,power,powers,137,// Ensure MaxVF is a power of 2; the dependence distance bound may not be.; // Note that both WidestRegister and WidestType may not be a powers of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:37,Integrability,depend,dependence,37,// Ensure MaxVF is a power of 2; the dependence distance bound may not be.; // Note that both WidestRegister and WidestType may not be a powers of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:136,Safety,avoid,avoid,136,"// When a scalar epilogue is required, at least one iteration of the scalar; // loop has to execute. Adjust MaxTripCount accordingly to avoid picking a; // max VF that results in a dead vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:165,Energy Efficiency,power,power,165,"// If upper bound loop trip count (TC) is known at compile time there is no; // point in choosing VF greater than TC (as done in the loop below). Select; // maximum power of two which doesn't exceed TC. If MaxVectorElementCount is; // scalable, we only fall back on a fixed VF when the TC is less than or; // equal to the known number of lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:235,Performance,scalab,scalable,235,"// If upper bound loop trip count (TC) is known at compile time there is no; // point in choosing VF greater than TC (as done in the loop below). Select; // maximum power of two which doesn't exceed TC. If MaxVectorElementCount is; // scalable, we only fall back on a fixed VF when the TC is less than or; // equal to the known number of lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:149,Performance,load,load,149,"// Invalidate any widening decisions we might have made, in case the loop; // requires prediction (decided later), but we have already made some; // load/store widening decisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:87,Safety,predict,prediction,87,"// Invalidate any widening decisions we might have made, in case the loop; // requires prediction (decided later), but we have already made some; // load/store widening decisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:50,Performance,scalab,scalable,50,// Improve estimate for the vector width if it is scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,Performance,tune,tuned,58,"// Assume vscale may be larger than 1 (or the value being tuned for),; // so that scalable vectorization is slightly favorable over fixed-width; // vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Performance,scalab,scalable,82,"// Assume vscale may be larger than 1 (or the value being tuned for),; // so that scalable vectorization is slightly favorable over fixed-width; // vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,Safety,avoid,avoid,6,// To avoid the need for FP division:; // (CostA / A.Width) < (CostB / B.Width); // <=> (CostA * B.Width) < (CostB * A.Width),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:53,Performance,load,load,53,"// For a list of ordered instruction-vf pairs:; // [(load, vf1), (load, vf2), (store, vf1)]; // Group the instructions together to emit separate remarks for:; // load (vf1, vf2); // store (vf1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:66,Performance,load,load,66,"// For a list of ordered instruction-vf pairs:; // [(load, vf1), (load, vf2), (store, vf1)]; // Group the instructions together to emit separate remarks for:; // load (vf1, vf2); // store (vf1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:162,Performance,load,load,162,"// For a list of ordered instruction-vf pairs:; // [(load, vf1), (load, vf2), (store, vf1)]; // Group the instructions together to emit separate remarks for:; // load (vf1, vf2); // store (vf1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:127,Performance,load,load,127,"// If the next instruction is different, or if there are no other pairs,; // emit a remark for the collated subset. e.g.; // [(load, vf1), (load, vf2))]; // to emit:; // remark: invalid costs for 'load' at VF=(vf, vf2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:140,Performance,load,load,140,"// If the next instruction is different, or if there are no other pairs,; // emit a remark for the collated subset. e.g.; // [(load, vf1), (load, vf2))]; // to emit:; // remark: invalid costs for 'load' at VF=(vf, vf2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:197,Performance,load,load,197,"// If the next instruction is different, or if there are no other pairs,; // emit a remark for the collated subset. e.g.; // [(load, vf1), (load, vf2))]; // to emit:; // remark: invalid costs for 'load' at VF=(vf, vf2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Security,audit,auditted,44,"// Epilogue vectorization code has not been auditted to ensure it handles; // non-latch exits properly. It may be fine, but it needs auditted and; // tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:133,Security,audit,auditted,133,"// Epilogue vectorization code has not been auditted to ensure it handles; // non-latch exits properly. It may be fine, but it needs auditted and; // tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:150,Testability,test,tested,150,"// Epilogue vectorization code has not been auditted to ensure it handles; // non-latch exits properly. It may be fine, but it needs auditted and; // tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:93,Testability,log,logic,93,"// Not really a cost consideration, but check for unsupported cases here to; // simplify the logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:80,Usability,simpl,simplify,80,"// Not really a cost consideration, but check for unsupported cases here to; // simplify the logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:62,Performance,scalab,scalable,62,// Skip candidate VFs with widths >= the estimate runtime VF (scalable; // vectors) or the VF of the main loop (fixed vectors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:9,Modifiability,extend,extend,9,// TODO: extend to support scalable VFs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,Performance,scalab,scalable,27,// TODO: extend to support scalable VFs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:168,Modifiability,variab,variables,168,"// For in-loop reductions, no element types are added to ElementTypesInLoop; // if there are no loads/stores in the loop. In this case, check through the; // reduction variables to determine the maximum width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:96,Performance,load,loads,96,"// For in-loop reductions, no element types are added to ElementTypesInLoop; // if there are no loads/stores in the loop. In this case, check through the; // reduction variables to determine the maximum width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:16,Performance,Load,Loads,16,"// Only examine Loads, Stores and PHINodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:51,Deployability,Update,Update,51,// Examine PHI nodes that are reduction variables. Update the type to; // account for the recurrence type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:40,Modifiability,variab,variables,40,// Examine PHI nodes that are reduction variables. Update the type to; // account for the recurrence type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,Energy Efficiency,reduce,reduce,89,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:568,Energy Efficiency,reduce,reduce,568,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:498,Integrability,depend,dependency,498,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:183,Safety,predict,predict,183,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:74,Security,expose,expose,74,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:322,Integrability,depend,dependences,322,"// Do not interleave loops with a relatively small known or estimated trip; // count. But we will interleave when InterleaveSmallLoopScalarReduction is; // enabled, and the code has scalar reductions(HasReductions && VF = 1),; // because with the above conditions interleaving can expose ILP and break; // cross iteration dependences for reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:281,Security,expose,expose,281,"// Do not interleave loops with a relatively small known or estimated trip; // count. But we will interleave when InterleaveSmallLoopScalarReduction is; // enabled, and the code has scalar reductions(HasReductions && VF = 1),; // because with the above conditions interleaving can expose ILP and break; // cross iteration dependences for reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:128,Availability,avail,available,128,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:421,Availability,down,down,421,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:721,Availability,mask,masking,721,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:451,Energy Efficiency,power,power,451,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:473,Energy Efficiency,power,power,473,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:591,Energy Efficiency,power,power,591,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:683,Integrability,wrap,wraps,683,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:655,Modifiability,variab,variable,655,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:506,Usability,simpl,simplify,506,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Modifiability,variab,variable,29,// Don't count the induction variable as interleaved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:49,Energy Efficiency,reduce,reduce,49,// We want to interleave small loops in order to reduce the loop overhead and; // potentially expose ILP opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:94,Security,expose,expose,94,// We want to interleave small loops in order to reduce the loop overhead and; // potentially expose ILP opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:26,Performance,load,load,26,// Interleave until store/load ports (estimated by max interleave count) are; // saturated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Security,expose,expose,120,"// If there are scalar reductions and TTI has enabled aggressive; // interleaving for reductions, we will interleave to expose ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:102,Availability,alive,alive,102,"// This function calculates the register usage by measuring the highest number; // of values that are alive at a single location. Obviously, this is a very; // rough estimation. We scan the loop in a topological order in order and; // assign a number to each instruction. We use RPO to ensure that defs are; // met before their users. We assume that each instruction that has in-loop; // users starts an interval. We record every time that an in-loop value is; // used, so we have a list of the first and last occurrences of each; // instruction. Next, we transpose this data structure into a multi map that; // holds the list of intervals that *end* at a specific location. This multi; // map allows us to perform a linear search. We scan the instructions linearly; // and record each time that a new interval starts, by placing it in a set.; // If we find this value in the multi-map then we remove it from the set.; // The max register usage is the maximum size of the set.; // We also search for instructions that are defined outside the loop, but are; // used inside the loop. We need this number separately from the max-interval; // usage number because when we unroll, loop-invariant values do not take; // more register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:707,Performance,perform,perform,707,"// This function calculates the register usage by measuring the highest number; // of values that are alive at a single location. Obviously, this is a very; // rough estimation. We scan the loop in a topological order in order and; // assign a number to each instruction. We use RPO to ensure that defs are; // met before their users. We assume that each instruction that has in-loop; // users starts an interval. We record every time that an in-loop value is; // used, so we have a list of the first and last occurrences of each; // instruction. Next, we transpose this data structure into a multi map that; // holds the list of intervals that *end* at a specific location. This multi; // map allows us to perform a linear search. We scan the instructions linearly; // and record each time that a new interval starts, by placing it in a set.; // If we find this value in the multi-map then we remove it from the set.; // The max register usage is the maximum size of the set.; // We also search for instructions that are defined outside the loop, but are; // used inside the loop. We need this number separately from the max-interval; // usage number because when we unroll, loop-invariant values do not take; // more register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,mask,masked,33,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:364,Availability,mask,masked,364,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:422,Availability,Mask,Masked,422,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:503,Availability,Mask,Masked,503,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:241,Deployability,deploy,deployed,241,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:40,Performance,load,load,40,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:371,Performance,load,load,371,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:429,Performance,Load,Load,429,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:315,Safety,avoid,avoid,315,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:87,Usability,guid,guides,87,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:340,Usability,simpl,simply,340,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:172,Availability,mask,masked,172,"// Do not apply discount if scalable, because that would lead to; // invalid scalarization costs.; // Do not apply discount logic if hacked cost is needed; // for emulated masked memrefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:28,Performance,scalab,scalable,28,"// Do not apply discount if scalable, because that would lead to; // invalid scalarization costs.; // Do not apply discount logic if hacked cost is needed; // for emulated masked memrefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:124,Testability,log,logic,124,"// Do not apply discount if scalable, because that would lead to; // invalid scalarization costs.; // Do not apply discount logic if hacked cost is needed; // for emulated masked memrefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:249,Safety,avoid,avoid,249,"// We only attempt to scalarize instructions forming a single-use chain; // from the original predicated block that would otherwise be vectorized.; // Although not strictly necessary, we give up on instructions we know will; // already be scalar to avoid traversing chains that are unlikely to be; // beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:149,Availability,mask,masked,149,"// If any of the instruction's operands are uniform after vectorization,; // the instruction cannot be scalarized. This prevents, for example, a; // masked load from being scalarized.; //; // We assume we will only emit a value for lane zero of an instruction; // marked uniform after vectorization, rather than VF identical values.; // Thus, if we scalarize an instruction that uses a uniform, we would; // create uses of values corresponding to the lanes we aren't emitting code; // for. This behavior can be changed by allowing getScalarValue to clone; // the lane zero values for uniforms rather than asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:156,Performance,load,load,156,"// If any of the instruction's operands are uniform after vectorization,; // the instruction cannot be scalarized. This prevents, for example, a; // masked load from being scalarized.; //; // We assume we will only emit a value for lane zero of an instruction; // marked uniform after vectorization, rather than VF identical values.; // Thus, if we scalarize an instruction that uses a uniform, we would; // create uses of values corresponding to the lanes we aren't emitting code; // for. This behavior can be changed by allowing getScalarValue to clone; // the lane zero values for uniforms rather than asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:605,Testability,assert,asserting,605,"// If any of the instruction's operands are uniform after vectorization,; // the instruction cannot be scalarized. This prevents, for example, a; // masked load from being scalarized.; //; // We assume we will only emit a value for lane zero of an instruction; // marked uniform after vectorization, rather than VF identical values.; // Thus, if we scalarize an instruction that uses a uniform, we would; // create uses of values corresponding to the lanes we aren't emitting code; // for. This behavior can be changed by allowing getScalarValue to clone; // the lane zero values for uniforms rather than asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:122,Integrability,depend,dependence,122,/// Gets Address Access SCEV after verifying that the access pattern; /// is loop invariant except the induction variable dependence.; ///; /// This SCEV can be sent to the Target in order to estimate the address; /// calculation cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:113,Modifiability,variab,variable,113,/// Gets Address Access SCEV after verifying that the access pattern; /// is loop invariant except the induction variable dependence.; ///; /// This SCEV can be sent to the Target in order to estimate the address; /// calculation cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:17,Security,Access,Access,17,/// Gets Address Access SCEV after verifying that the access pattern; /// is loop invariant except the induction variable dependence.; ///; /// This SCEV can be sent to the Target in order to estimate the address; /// calculation cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:54,Security,access,access,54,/// Gets Address Access SCEV after verifying that the access pattern; /// is loop invariant except the induction variable dependence.; ///; /// This SCEV can be sent to the Target in order to estimate the address; /// calculation cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:108,Modifiability,variab,variable,108,// We are looking for a gep with all loop invariant indices except for one; // which should be an induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:151,Security,access,access,151,// NOTE: PtrTy is a vector to signal `TTI::getAddressComputationCost`; // that it is being called from this specific place.; // Figure out whether the access is strided and get the stride value; // if it's known in compile time,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,Performance,load,load,27,"// If we have a predicated load/store, it will need extra i1 extracts and; // conditional branches, but may not be executed for each vector lane. Scale; // the cost by the probability of executing the predicated block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Availability,mask,masked,34,// TODO: Add support for reversed masked interleaved access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:53,Security,access,access,53,// TODO: Add support for reversed masked interleaved access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:209,Availability,down,down,209,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:81,Energy Efficiency,reduce,reduce,81,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:116,Energy Efficiency,reduce,reduce,116,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:141,Energy Efficiency,reduce,reduce,141,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Energy Efficiency,reduce,reduce,163,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:363,Testability,test,test,363,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Testability,Test,Test,3,"// Test if the found instruction is a reduction, and if not return an invalid; // cost specifying the parent to use the original cost modelling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Energy Efficiency,reduce,reduce,11,"// Matched reduce.add(ext(mul(ext(A), ext(B))); // Note that the extend opcodes need to all match, or if A==B they will have; // been converted to zext(mul(sext(A), sext(A))) as it is known positive,; // which is equally fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:65,Modifiability,extend,extend,65,"// Matched reduce.add(ext(mul(ext(A), ext(B))); // Note that the extend opcodes need to all match, or if A==B they will have; // been converted to zext(mul(sext(A), sext(A))) as it is known positive,; // which is equally fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Energy Efficiency,reduce,reduce,11,// Matched reduce(ext(A)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Energy Efficiency,reduce,reduce,11,"// Matched reduce.add(mul(ext(A), ext(B))), where the two ext may be of; // different sizes. We take the largest type as the ext to reduce, and add; // the remaining cost as, for example reduce(mul(ext(ext(A)), ext(B))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:132,Energy Efficiency,reduce,reduce,132,"// Matched reduce.add(mul(ext(A), ext(B))), where the two ext may be of; // different sizes. We take the largest type as the ext to reduce, and add; // the remaining cost as, for example reduce(mul(ext(ext(A)), ext(B))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:187,Energy Efficiency,reduce,reduce,187,"// Matched reduce.add(mul(ext(A), ext(B))), where the two ext may be of; // different sizes. We take the largest type as the ext to reduce, and add; // the remaining cost as, for example reduce(mul(ext(ext(A)), ext(B))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Energy Efficiency,reduce,reduce,11,// Matched reduce.add(mul()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:238,Deployability,update,update,238,"// <vscale x 1 x iN> is assumed to be profitable over iN because; // scalable registers are a distinct register class from scalar ones.; // If we ever find a target which wants to lower scalable vectors; // back to scalars, we'll need to update this code to explicitly; // ask TTI about the register class uses for each part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:69,Performance,scalab,scalable,69,"// <vscale x 1 x iN> is assumed to be profitable over iN because; // scalable registers are a distinct register class from scalar ones.; // If we ever find a target which wants to lower scalable vectors; // back to scalars, we'll need to update this code to explicitly; // ask TTI about the register class uses for each part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:186,Performance,scalab,scalable,186,"// <vscale x 1 x iN> is assumed to be profitable over iN because; // scalable registers are a distinct register class from scalar ones.; // If we ever find a target which wants to lower scalable vectors; // back to scalars, we'll need to update this code to explicitly; // ask TTI about the register class uses for each part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:41,Performance,scalab,scalable,41,"// There is no mechanism yet to create a scalable scalarization loop,; // so this is currently Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Energy Efficiency,efficient,efficient,24,// Some targets support efficient element stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Deployability,update,update,44,// TODO: We should generate better code and update the cost model for; // predicated uniform stores. Today they are treated as any other; // predicated store (see added test cases in; // invariant-store-vectorization.ll).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:169,Testability,test,test,169,// TODO: We should generate better code and update the cost model for; // predicated uniform stores. Today they are treated as any other; // predicated store (see added test cases in; // invariant-store-vectorization.ll).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:232,Integrability,depend,depends,232,"// We have dedicated lowering for unpredicated uniform loads and; // stores. Note that even with tail folding we know that at least; // one lane is active (i.e. generalized predication is not possible; // here), and the logic below depends on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:55,Performance,load,loads,55,"// We have dedicated lowering for unpredicated uniform loads and; // stores. Note that even with tail folding we know that at least; // one lane is active (i.e. generalized predication is not possible; // here), and the logic below depends on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:220,Testability,log,logic,220,"// We have dedicated lowering for unpredicated uniform loads and; // stores. Note that even with tail folding we know that at least; // one lane is active (i.e. generalized predication is not possible; // here), and the logic below depends on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Performance,scalab,scalable,7,"// For scalable vectors, a uniform memop load is always; // uniform-by-parts and we know how to scalarize that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:41,Performance,load,load,41,"// For scalable vectors, a uniform memop load is always; // uniform-by-parts and we know how to scalarize that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Load,Load,3,// Load: Scalar load + broadcast; // Store: Scalar store + isLoopInvariantStoreValue ? 0 : extract; // FIXME: This cost is a significant under-estimate for tail folded; // memory ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:16,Performance,load,load,16,// Load: Scalar load + broadcast; // Store: Scalar store + isLoopInvariantStoreValue ? 0 : extract; // FIXME: This cost is a significant under-estimate for tail folded; // memory ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:167,Availability,failure,failure,167,"// Choose better solution for the current VF, Note that Invalid; // costs compare as maximumal large. If both are invalid, we get; // scalable invalid which signals a failure and a vectorization abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:134,Performance,scalab,scalable,134,"// Choose better solution for the current VF, Note that Invalid; // costs compare as maximumal large. If both are invalid, we get; // scalable invalid which signals a failure and a vectorization abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:195,Safety,abort,abort,195,"// Choose better solution for the current VF, Note that Invalid; // costs compare as maximumal large. If both are invalid, we get; // scalable invalid which signals a failure and a vectorization abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,Availability,down,down,56,"// Choose better solution for the current VF,; // write down this decision and use it during vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Performance,load,load,22,"// Make sure that any load of address and any other address computation; // remains scalar unless there is gather/scatter support. This avoids; // inevitable extracts into address registers, and also has the benefit of; // activating LSR more, since that pass can't optimize vectorized; // addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:266,Performance,optimiz,optimize,266,"// Make sure that any load of address and any other address computation; // remains scalar unless there is gather/scatter support. This avoids; // inevitable extracts into address registers, and also has the benefit of; // activating LSR more, since that pass can't optimize vectorized; // addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:136,Safety,avoid,avoids,136,"// Make sure that any load of address and any other address computation; // remains scalar unless there is gather/scatter support. This avoids; // inevitable extracts into address registers, and also has the benefit of; // activating LSR more, since that pass can't optimize vectorized; // addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:152,Performance,load,loaded,152,"// Setting the desired widening decision should ideally be handled in; // by cost functions, but since this involves the task of finding out; // if the loaded register is involved in an address computation, it is; // instead changed here when we know this is the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:23,Performance,load,load,23,// Scalarize a widened load of address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Performance,load,loads,44,// Scalarize an interleave group of address loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Availability,avail,available,22,// Search through any available variants for one we can use at this VF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:15,Availability,mask,mask,15,// Must take a mask argument if one is required,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:37,Availability,mask,mask,37,// Add in the cost of synthesizing a mask if one wasn't required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Performance,perform,perform,78,// Find the cost of an intrinsic; some targets may have instructions that; // perform the operation without needing an actual call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,Integrability,depend,depends,89,"// We mark this instruction as zero-cost because the cost of GEPs in; // vectorized code depends on whether the corresponding memory instruction; // is scalarized or not. Therefore, we handle GEPs with the memory; // instruction cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Performance,scalab,scalable,29,// Not possible to scalarize scalable vector with predicated instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:26,Safety,safe,safe,26,"// We've proven all lanes safe to speculate, fall through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Safety,Detect,Detect,3,// Detect reduction patterns,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:39,Performance,Load,Load,39,// Computes the CastContextHint from a Load/Store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:59,Performance,Load,LoadInst,59,"// For Z/Sext, the context is the operand, which must be a LoadInst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variables,43,// We optimize the truncation of induction variables having constant; // integer steps. The cost of these truncations is the same as the scalar; // operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,Performance,optimiz,optimize,6,// We optimize the truncation of induction variables having constant; // integer steps. The cost of these truncations is the same as the scalar; // operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Safety,Detect,Detect,3,// Detect reduction patterns,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:38,Performance,scalab,scalable,38,"// We cannot easily widen alloca to a scalable alloca, as; // the result would need to be a vector of pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:32,Modifiability,variab,variables,32,// Find all stores to invariant variables. Since they are going to sink; // outside the loop we do not need calculate cost for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:73,Safety,detect,detection,73,// Ignore type-promoting instructions we identified during reduction; // detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:71,Safety,detect,detection,71,// Ignore type-casting instructions we identified during induction; // detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:31,Performance,scalab,scalable,31,"// This function will select a scalable VF if the target supports scalable; // vectors and a fixed one otherwise.; // TODO: we could return a pair of values that specify the max VF and; // min VF, to be used in `buildVPlans(MinVF, MaxVF)` instead of; // `buildVPlans(VF, VF)`. We cannot do it because VPLAN at the moment; // doesn't have a cost model that can choose which plan to execute if; // more than one is generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:66,Performance,scalab,scalable,66,"// This function will select a scalable VF if the target supports scalable; // vectors and a fixed one otherwise.; // TODO: we could return a pair of values that specify the max VF and; // min VF, to be used in `buildVPlans(MinVF, MaxVF)` instead of; // `buildVPlans(VF, VF)`. We cannot do it because VPLAN at the moment; // doesn't have a cost model that can choose which plan to execute if; // more than one is generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:247,Deployability,pipeline,pipeline,247,"// Outer loop handling: They may require CFG and instruction level; // transformations before even evaluating whether vectorization is profitable.; // Since we cannot modify the incoming IR, we need to build VPlan upfront in; // the vectorization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:41,Testability,test,testing,41,// Make sure we have a VF > 1 for stress testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:26,Testability,test,testing,26,"// For VPlan build stress testing, we bail out after VPlan construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:90,Modifiability,variab,variable,90,// TODO: This fixup should instead be modeled in VPlan.; // Fix the scalar loop reduction variable with the incoming reduction sum; // from the vector body and from the backedge value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Perform,Perform,3,// Perform the actual loop transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Integrability,depend,dependent,20,"// 0. Generate SCEV-dependent code into the preheader, including TripCount,; // before making any changes to the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:79,Performance,optimiz,optimization,79,//===------------------------------------------------===//; //; // Notice: any optimization or new instruction that go; // into the code below should also be implemented in; // the cost-model.; //; //===------------------------------------------------===//; // 2. Copy and widen instructions from the old loop into the new loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,Usability,resume,resume,25,// 2.5 Collect reduction resume values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:349,Deployability,update,updated,349,"// Generate the iteration count check for the main loop, *after* the check; // for the epilogue loop, so that the path-length is shorter for the case; // that goes directly through the vector epilogue. The longer-path length for; // the main loop is compensated for, by the gain from vectorizing the larger; // trip count. Note: the branch will get updated later on when we vectorize; // the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:26,Modifiability,variab,variable,26,// Generate the induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:18,Usability,resume,resume,18,// Skip induction resume value creation here because they will be created in; // the second pass for the scalar loop. The induction resume values for the; // inductions in the epilogue loop are created before executing the plan for; // the epilogue loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:132,Usability,resume,resume,132,// Skip induction resume value creation here because they will be created in; // the second pass for the scalar loop. The induction resume values for the; // inductions in the epilogue loop are created before executing the plan for; // the epilogue loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Deployability,Update,Update,3,// Update dominator for Bypass & LoopExit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:138,Deployability,update,update,138,"// For loops with multiple exits, there's no edge from the middle block; // to exit blocks (as the epilogue must run) and thus no need to update; // the immediate dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:99,Safety,safe,safe,99,// Save the trip count so we don't have to regenerate it in the; // vec.epilog.iter.check. This is safe to do because the trip count; // generated here dominates the vector epilog iter check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Deployability,update,update,120,"// If there is an epilogue which must run, there's no edge from the; // middle block to exit blocks and thus no need to update the immediate; // dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Deployability,Update,Update,163,// The vec.epilog.iter.check block may contain Phi nodes from inductions or; // reductions which merge control-flow from the latch block and the middle; // block. Update the incoming values here and move the Phi into the preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:14,Usability,resume,resume,14,// Generate a resume induction for the vector epilogue and put it in the; // vector epilogue preheader,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variables,43,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:336,Modifiability,variab,variable,336,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:125,Testability,test,test,125,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Usability,resume,resume,22,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:305,Usability,resume,resume,305,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:201,Modifiability,extend,extending,201,"/// Build VPlans for the full range of feasible VF's = {\p MinVF, 2 * \p MinVF,; /// 4 * \p MinVF, ..., \p MaxVF} by repeatedly building a VPlan for a sub-range; /// of VF's starting at a given VF and extending it as much as possible. Each; /// vectorization decision can potentially shorten this sub-range during; /// buildVPlan().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:12,Performance,cache,cached,12,// Look for cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:139,Availability,mask,mask,139,"// If source is an exiting block, we know the exit edge is dynamically dead; // in the vector loop, and thus we don't need to restrict the mask. Avoid; // adding uses of an otherwise potentially dead instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:145,Safety,Avoid,Avoid,145,"// If source is an exiting block, we know the exit edge is dynamically dead; // in the vector loop, and thus we don't need to restrict the mask. Avoid; // adding uses of an otherwise potentially dead instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Availability,mask,mask,22,"// Otherwise block in-mask is all-one, no need to AND.; // The condition is 'SrcMask && EdgeMask', which is equivalent to; // 'select i1 SrcMask, i1 EdgeMask, i1 false'.; // The select version does not introduce new UB if SrcMask is false and; // EdgeMask is poison. Using 'and' here introduces undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:60,Availability,mask,mask,60,"// When not folding the tail, use nullptr to model all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:67,Availability,mask,mask,67,"// Introduce the early-exit compare IV <= BTC to form header block mask.; // This is used instead of IV < TC because TC may wrap, unlike BTC. Start by; // constructing the desired canonical IV in the header block as its first; // non-phi instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:124,Integrability,wrap,wrap,124,"// Introduce the early-exit compare IV <= BTC to form header block mask.; // This is used instead of IV < TC because TC may wrap, unlike BTC. Start by; // constructing the desired canonical IV in the header block as its first; // non-phi instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:14,Performance,cache,cached,14,// Return the cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Availability,mask,mask,11,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Availability,mask,mask,34,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:68,Availability,mask,masked,68,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:133,Availability,mask,mask,133,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:79,Performance,load,load,79,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:21,Availability,mask,mask,21,// This is the block mask. We OR all incoming edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Availability,Mask,Mask,3,// Mask of predecessor is all-one so mask of block is too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:37,Availability,mask,mask,37,// Mask of predecessor is all-one so mask of block is too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Security,access,access,43,// Determine if the pointer operand of the access is either consecutive or; // reverse consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:207,Integrability,wrap,wrap,207,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:237,Integrability,depend,depend,237,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Modifiability,variab,variable,82,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:326,Modifiability,variab,variable,326,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:116,Performance,optimiz,optimize,116,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:351,Performance,optimiz,optimized,351,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:299,Performance,optimiz,optimizations,299,"// We know that all PHIs in non-header blocks are converted into selects, so; // we don't have to worry about the insertion order and we can just use the; // builder. At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:261,Usability,simpl,simple,261,"// We know that all PHIs in non-header blocks are converted into selects, so; // we don't have to worry about the insertion order and we can just use the; // builder. At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:23,Performance,perform,perform,23,// Is it beneficial to perform intrinsic call compared to lib call?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:405,Availability,mask,mask,405,"// The following case may be scalarized depending on the VF.; // The flag shows whether we can use a usual Call for vectorized; // version of the instruction.; // If we've found a variant at a previous VF, then stop looking. A; // vectorized variant of a function expects input in a certain shape; // -- basically the number of input registers, the number of lanes; // per register, and whether there's a mask required.; // We store a pointer to the variant in the VPWidenCallRecipe, so; // once we have an appropriate variant it's only valid for that VF.; // This will force a different vplan to be generated for each VF that; // finds a valid variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:40,Integrability,depend,depending,40,"// The following case may be scalarized depending on the VF.; // The flag shows whether we can use a usual Call for vectorized; // version of the instruction.; // If we've found a variant at a previous VF, then stop looking. A; // vectorized variant of a function expects input in a certain shape; // -- basically the number of input registers, the number of lanes; // per register, and whether there's a mask required.; // We store a pointer to the variant in the VPWidenCallRecipe, so; // once we have an appropriate variant it's only valid for that VF.; // This will force a different vplan to be generated for each VF that; // finds a valid variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:40,Availability,mask,mask,40,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Availability,mask,mask,163,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:218,Availability,mask,mask,218,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:248,Availability,mask,mask,248,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:293,Availability,avail,available,293,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:344,Availability,mask,mask,344,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:383,Availability,mask,mask,383,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Safety,safe,safe,19,"// If not provably safe, use a select to form a safe divisor before widening the; // div/rem operation itself. Otherwise fall through to general handling below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,Safety,safe,safe,48,"// If not provably safe, use a select to form a safe divisor before widening the; // div/rem operation itself. Otherwise fall through to general handling below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:199,Performance,scalab,scalable,199,"// Even if the instruction is not marked as uniform, there are certain; // intrinsic calls that can be effectively treated as such, so we check for; // them here. Conservatively, we only do this for scalable vectors, since; // for fixed-width VFs we can always fall back on full scalarization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Performance,scalab,scalable,7,"// For scalable vectors if one of the operands is variant then we still; // want to mark as uniform, which will generate one instruction for just; // the first lane of the vector. We can't scalarize the call in the same; // way as for fixed-width vectors because we don't know how many lanes; // there are.; //; // The reasons for doing it this way for scalable vectors are:; // 1. For the assume intrinsic generating the instruction for the first; // lane is still be better than not generating any at all. For; // example, the input may be a splat across all lanes.; // 2. For the lifetime start/end intrinsics the pointer operand only; // does anything useful when the input comes from a stack object,; // which suggests it should always be uniform. For non-stack objects; // the effect is to poison the object, which still allows us to; // remove the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:353,Performance,scalab,scalable,353,"// For scalable vectors if one of the operands is variant then we still; // want to mark as uniform, which will generate one instruction for just; // the first lane of the vector. We can't scalarize the call in the same; // way as for fixed-width vectors because we don't know how many lanes; // there are.; //; // The reasons for doing it this way for scalable vectors are:; // 1. For the assume intrinsic generating the instruction for the first; // lane is still be better than not generating any at all. For; // example, the input may be a splat across all lanes.; // 2. For the lifetime start/end intrinsics the pointer operand only; // does anything useful when the input comes from a stack object,; // which suggests it should always be uniform. For non-stack objects; // the effect is to poison the object, which still allows us to; // remove the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:60,Availability,mask,mask,60,// Instructions marked for predication are replicated and a mask operand is; // added initially. Masked replicate recipes will later be placed under an; // if-then construct to prevent side-effects. Generate recipes to compute; // the block mask for this region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:97,Availability,Mask,Masked,97,// Instructions marked for predication are replicated and a mask operand is; // added initially. Masked replicate recipes will later be placed under an; // if-then construct to prevent side-effects. Generate recipes to compute; // the block mask for this region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:241,Availability,mask,mask,241,// Instructions marked for predication are replicated and a mask operand is; // added initially. Masked replicate recipes will later be placed under an; // if-then construct to prevent side-effects. Generate recipes to compute; // the block mask for this region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:242,Energy Efficiency,efficient,efficient,242,"// TODO: Currently fixed-order recurrences are modeled as chains of; // first-order recurrences. If there are no users of the intermediate; // recurrences in the chain, the fixed order recurrence should be modeled; // directly, enabling more efficient codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Performance,optimiz,optimize,7,// Now optimize the initial VPlan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Performance,scalab,scalable,7,"// For scalable vectors, the only interleave factor currently supported; // is 2 since we require the (de)interleave2 intrinsics instead of; // shufflevectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Usability,simpl,simplified,19,"// If Instr can be simplified to an existing VPValue, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:269,Availability,mask,mask,269,"// VPHeaderPHIRecipes must be kept in the phi section of HeaderVPBB. In; // the following cases, VPHeaderPHIRecipes may be created after non-phi; // recipes and need to be moved to the phi section of HeaderVPBB:; // * tail-folding (non-phi recipes computing the header mask are; // introduced earlier than regular header phi recipes, and should appear; // after them); // * Optimizing truncates to VPWidenIntOrFpInductionRecipe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:374,Performance,Optimiz,Optimizing,374,"// VPHeaderPHIRecipes must be kept in the phi section of HeaderVPBB. In; // the following cases, VPHeaderPHIRecipes may be created after non-phi; // recipes and need to be moved to the phi section of HeaderVPBB:; // * tail-folding (non-phi recipes computing the header mask are; // introduced earlier than regular header phi recipes, and should appear; // after them); // * Optimizing truncates to VPWidenIntOrFpInductionRecipe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:96,Security,access,accessing,96,"// From this point onwards, VPlan-to-VPlan transformations may change the plan; // in ways that accessing values using original IR values is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:247,Deployability,pipeline,pipeline,247,"// Outer loop handling: They may require CFG and instruction level; // transformations before even evaluating whether vectorization is profitable.; // Since we cannot modify the incoming IR, we need to build VPlan upfront in; // the vectorization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:102,Integrability,wrap,wrap,102,"// Tail folding is not supported for outer loops, so the induction increment; // is guaranteed to not wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:57,Availability,down,down,57,"// Visit operation ""Links"" along the reduction chain top-down starting from; // the phi until LoopExitValue. We keep track of the previous item; // (PreviousLink) to tell which of the two operands of a Link will remain; // scalar and which will be reduced. For minmax by select(cmp), Link will be; // the select instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:248,Energy Efficiency,reduce,reduced,248,"// Visit operation ""Links"" along the reduction chain top-down starting from; // the phi until LoopExitValue. We keep track of the previous item; // (PreviousLink) to tell which of the two operands of a Link will remain; // scalar and which will be reduced. For minmax by select(cmp), Link will be; // the select instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,Availability,mask,mask,48,// Index of the first operand which holds a non-mask vector operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Availability,mask,masking,24,"// If tail is folded by masking, introduce selects between the phi; // and the live-out instruction of each reduction, at the beginning of the; // dedicated latch block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:84,Modifiability,extend,extend,84,"// If the vector reduction can be performed in a smaller type, we truncate; // then extend the loop exit value to enable InstCombine to evaluate the; // entire expression in the smaller type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Performance,perform,performed,34,"// If the vector reduction can be performed in a smaller type, we truncate; // then extend the loop exit value to enable InstCombine to evaluate the; // entire expression in the smaller type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:205,Usability,resume,resume,205,"// TODO: At the moment ComputeReductionResult also drives creation of the; // bc.merge.rdx phi nodes, hence it needs to be created unconditionally here; // even for in-loop reductions, until the reduction resume value handling is; // also modeled in VPlan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Performance,perform,performed,24,"// A pointer induction, performed by using a gep",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:17,Deployability,update,update,17,"// Add induction update using an incorrect block temporarily. The phi node; // will be fixed after VPlan execution. Note that at this point the latch; // block cannot be used, as it does not exist yet.; // TODO: Model increment value in VPlan, by turning the recipe into a; // multi-def and a subclass of VPHeaderPHIRecipe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,Performance,load,load,27,// Attempt to issue a wide load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Availability,Mask,Mask,3,"// Mask reversal is only needed for non-all-one (null) masks, as reverse of; // a null all-one mask is a null mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:55,Availability,mask,masks,55,"// Mask reversal is only needed for non-all-one (null) masks, as reverse of; // a null all-one mask is a null mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:95,Availability,mask,mask,95,"// Mask reversal is only needed for non-all-one (null) masks, as reverse of; // a null all-one mask is a null mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:110,Availability,mask,mask,110,"// Mask reversal is only needed for non-all-one (null) masks, as reverse of; // a null all-one mask is a null mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Deployability,update,update,20,// We don't want to update the value in the map as it might be used in; // another expression. So don't call resetVectorValue(StoredVal).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,Performance,load,loads,10,// Handle loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:23,Performance,load,load,23,"// Add metadata to the load, but setVectorValue to the reverse shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:53,Integrability,depend,depends,53,"// Determine how to lower the scalar epilogue, which depends on 1) optimising; // for minimum code-size, 2) predicate compiler options, 3) loop hints forcing; // predication, and 4) a TTI hook that analyses whether the loop is suitable; // for predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:286,Availability,reliab,reliably,286,"// 1) OptSize takes precedence over all other options, i.e. if this is set,; // don't look at hints or options, and don't request a scalar epilogue.; // (For PGSO, as shouldOptimizeForSize isn't currently accessible from; // LoopAccessInfo (due to code dependency and not being able to reliably get; // PSI/BFI from a loop analysis under NPM), we cannot suppress the collection; // of strides in LoopAccessInfo::analyzeLoop() and vectorize without; // versioning when the vectorization is forced, unlike hasOptSize. So revert; // back to the old way and vectorize with versioning when forced. See D81345.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:253,Integrability,depend,dependency,253,"// 1) OptSize takes precedence over all other options, i.e. if this is set,; // don't look at hints or options, and don't request a scalar epilogue.; // (For PGSO, as shouldOptimizeForSize isn't currently accessible from; // LoopAccessInfo (due to code dependency and not being able to reliably get; // PSI/BFI from a loop analysis under NPM), we cannot suppress the collection; // of strides in LoopAccessInfo::analyzeLoop() and vectorize without; // versioning when the vectorization is forced, unlike hasOptSize. So revert; // back to the old way and vectorize with versioning when forced. See D81345.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:205,Security,access,accessible,205,"// 1) OptSize takes precedence over all other options, i.e. if this is set,; // don't look at hints or options, and don't request a scalar epilogue.; // (For PGSO, as shouldOptimizeForSize isn't currently accessible from; // LoopAccessInfo (due to code dependency and not being able to reliably get; // PSI/BFI from a loop analysis under NPM), we cannot suppress the collection; // of strides in LoopAccessInfo::analyzeLoop() and vectorize without; // versioning when the vectorization is forced, unlike hasOptSize. So revert; // back to the old way and vectorize with versioning when forced. See D81345.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:116,Deployability,pipeline,pipeline,116,"// Process the loop in the VPlan-native vectorization path. This path builds; // VPlan upfront in the vectorization pipeline, which allows to apply; // VPlan-to-VPlan transformations from the very beginning without modifying the; // input LLVM IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:86,Availability,Mask,Masked,86,"// If we are stress testing VPlan builds, do not attempt to generate vector; // code. Masked vector code generation support will follow soon.; // Also, do not attempt to vectorize if no vector code will be produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Testability,test,testing,20,"// If we are stress testing VPlan builds, do not attempt to generate vector; // code. Masked vector code generation support will follow soon.; // Also, do not attempt to vectorize if no vector code will be produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Safety,avoid,avoid,42,// Mark the loop as already vectorized to avoid vectorizing again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:170,Performance,perform,performance,170,// Emit a remark if there are stores to floats that required a floating point; // extension. If the vectorized loop was generated with floating point there; // will be a performance penalty from the conversion overhead and the change in; // the vector width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:1043,Performance,perform,performed,1043,"// First, compute the minimum iteration count required so that the vector; // loop outperforms the scalar loop.; // The total cost of the scalar loop is; // ScalarC * TC; // where; // * TC is the actual trip count of the loop.; // * ScalarC is the cost of a single scalar iteration.; //; // The total cost of the vector loop is; // RtC + VecC * (TC / VF) + EpiC; // where; // * RtC is the cost of the generated runtime checks; // * VecC is the cost of a single vector iteration.; // * TC is the actual trip count of the loop; // * VF is the vectorization factor; // * EpiCost is the cost of the generated epilogue, including the cost; // of the remaining scalar operations.; //; // Vectorization is profitable once the total vector cost is less than the; // total scalar cost:; // RtC + VecC * (TC / VF) + EpiC < ScalarC * TC; //; // Now we can compute the minimum required trip count TC as; // (RtC + EpiC) / (ScalarC - (VecC / VF)) < TC; //; // For now we assume the epilogue cost EpiC = 0 for simplicity. Note that; // the computations are performed on doubles, not integers and the result; // is rounded up, hence we get an upper estimate of the TC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:996,Usability,simpl,simplicity,996,"// First, compute the minimum iteration count required so that the vector; // loop outperforms the scalar loop.; // The total cost of the scalar loop is; // ScalarC * TC; // where; // * TC is the actual trip count of the loop.; // * ScalarC is the cost of a single scalar iteration.; //; // The total cost of the vector loop is; // RtC + VecC * (TC / VF) + EpiC; // where; // * RtC is the cost of the generated runtime checks; // * VecC is the cost of a single vector iteration.; // * TC is the actual trip count of the loop; // * VF is the vectorization factor; // * EpiCost is the cost of the generated epilogue, including the cost; // of the remaining scalar operations.; //; // Vectorization is profitable once the total vector cost is less than the; // total scalar cost:; // RtC + VecC * (TC / VF) + EpiC < ScalarC * TC; //; // Now we can compute the minimum required trip count TC as; // (RtC + EpiC) / (ScalarC - (VecC / VF)) < TC; //; // For now we assume the epilogue cost EpiC = 0 for simplicity. Note that; // the computations are performed on doubles, not integers and the result; // is rounded up, hence we get an upper estimate of the TC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:159,Integrability,depend,dependent,159,"// Second, compute a minimum iteration count so that the cost of the; // runtime checks is only a fraction of the total scalar loop cost. This; // adds a loop-dependent bound on the overhead incurred if the runtime; // checks fail. In case the runtime checks fail, the cost is RtC + ScalarC; // * TC. To bound the runtime check to be a fraction 1/X of the scalar; // cost, compute; // RtC < ScalarC * TC * (1 / X) ==> RtC * X / ScalarC < TC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:233,Integrability,message,messages,233,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:180,Performance,optimiz,optimization,180,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:259,Performance,Optimiz,OptimizationRemarkAnalysis,259,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:312,Performance,Optimiz,OptimizationRemark,312,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:335,Performance,Optimiz,OptimizationRemarkMissed,335,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:311,Deployability,pipeline,pipeline,311,"// Entrance to the VPlan-native vectorization path. Outer loops are processed; // here. They may require CFG and instruction level transformations before; // even evaluating whether vectorization is profitable. Since we cannot modify; // the incoming IR, we need to build VPlan upfront in the vectorization; // pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:60,Security,access,accesses,60,"// If an override option has been passed in for interleaved accesses, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:30,Security,access,accesses,30,// Analyze interleaved memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,Performance,optimiz,optimized,89,// Check the function attributes and profiles to find out if this function; // should be optimized for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:92,Performance,optimiz,optimizing,92,"// Check the loop for a trip count threshold: vectorize loops with a tiny trip; // count by optimizing for size, to minimize overheads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:35,Energy Efficiency,efficient,efficient,35,"// Predicate tail-folded loops are efficient even when the loop; // iteration count is low. However, setting the epilogue policy to; // `CM_ScalarEpilogueNotAllowedLowTripLoop` prevents vectorizing loops; // with runtime checks. It's more effective to let; // `areRuntimeChecksProfitable` determine if vectorization is beneficial; // for the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Safety,unsafe,unsafe,44,"// Check if the target supports potentially unsafe FP vectorization.; // FIXME: Add a check for the type of safety issue (denormal, signaling); // for the target we're vectorizing for, to make sure none of the; // additional fp-math flags can help.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:108,Safety,safe,safety,108,"// Check if the target supports potentially unsafe FP vectorization.; // FIXME: Add a check for the type of safety issue (denormal, signaling); // for the target we're vectorizing for, to make sure none of the; // additional fp-math flags can help.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,Integrability,message,messages,27,// Identify the diagnostic messages that should be produced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Safety,avoid,avoided,34,"// Tell the user interleaving was avoided up-front, despite being explicitly; // requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Integrability,message,messages,19,"// Emit diagnostic messages, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:278,Usability,resume,resume,278,"// Re-use the trip count and steps expanded for the main loop, as; // skeleton creation needs it as a value that dominates both the scalar; // and vector epilogue loops; // TODO: This is a workaround needed for epilogue vectorization and it; // should be removed once induction resume value creation is done; // directly in VPlan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:135,Deployability,update,updated,135,"// Ensure that the start values for any VPWidenIntOrFpInductionRecipe,; // VPWidenPointerInductionRecipe and VPReductionPHIRecipes are updated; // before vectorizing the epilogue loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,Usability,resume,resume,25,// TODO: Move setting of resume values to prepareToExecute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:93,Deployability,update,update,93,// Create induction resume values for both widened pointer and; // integer/fp inductions and update the start value of the induction; // recipes to use the resume value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Usability,resume,resume,20,// Create induction resume values for both widened pointer and; // integer/fp inductions and update the start value of the induction; // recipes to use the resume value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:156,Usability,resume,resume,156,// Create induction resume values for both widened pointer and; // integer/fp inductions and update the start value of the induction; // recipes to use the resume value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Safety,avoid,avoid,42,// Mark the loop as already vectorized to avoid vectorizing again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Usability,simpl,simplified,42,"// The vectorizer requires loops to be in simplified form.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop vectorizer; // will simplify all loops, regardless of whether anything end up being; // vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:69,Usability,simpl,simplification,69,"// The vectorizer requires loops to be in simplified form.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop vectorizer; // will simplify all loops, regardless of whether anything end up being; // vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:221,Usability,simpl,simplify,221,"// The vectorizer requires loops to be in simplified form.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop vectorizer; // will simplify all loops, regardless of whether anything end up being; // vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,Usability,simpl,simplify,58,"// For the inner loops we actually process, form LCSSA to simplify the; // transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Usability,simpl,simplification,82,// Making CFG changes likely means a loop got vectorized. Indicate that; // extra simplification passes should be run.; // TODO: MadeCFGChanges is not a prefect proxy. Extra passes should only; // be run if runtime checks have been added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:647,Performance,perform,performs,647,"//===- SLPVectorizer.cpp - A bottom up SLP Vectorizer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:437,Safety,detect,detects,437,"//===- SLPVectorizer.cpp - A bottom up SLP Vectorizer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,Performance,optimiz,optimization,56,"// NOTE: If AllowHorRdxIdenityOptimization is true, the optimization will run; // even if we match a reduction but do not vectorize in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,Energy Efficiency,schedul,scheduling,23,/// Limits the size of scheduling regions in a block.; /// It avoid long compile times for _very_ large blocks where vector; /// instructions are spread over a wide range.; /// This limit is way higher than needed by real-world functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:62,Safety,avoid,avoid,62,/// Limits the size of scheduling regions in a block.; /// It avoid long compile times for _very_ large blocks where vector; /// instructions are spread over a wide range.; /// This limit is way higher than needed by real-world functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,Testability,benchmark,benchmarks,107,// Limit the number of alias checks. The limit is chosen so that; // it has no negative effect on the llvm benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:68,Performance,load,load,68,// Another limit for the alias checks: The maximum distance between load/store; // instructions where alias checks are done.; // This limit is useful for very large basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Energy Efficiency,Schedul,ScheduleRegionSizeBudget,11,"/// If the ScheduleRegionSizeBudget is exhausted, we allow small scheduling; /// regions to be handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,Energy Efficiency,schedul,scheduling,65,"/// If the ScheduleRegionSizeBudget is exhausted, we allow small scheduling; /// regions to be handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:313,Safety,avoid,avoids,313,/// Predicate for the element types that the SLP vectorizer supports.; ///; /// The most important thing to filter here are types which are invalid in LLVM; /// vectors. We also filter target specific types which have absolutely no; /// meaningful vectorization path such as x86_fp80 and ppc_f128. This just; /// avoids spending time checking the cost model and realizing that they will; /// be inevitably scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,mask,26,/// Specifies the way the mask should be analyzed for undefs/poisonous elements; /// in the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:100,Availability,mask,mask,100,/// Specifies the way the mask should be analyzed for undefs/poisonous elements; /// in the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Availability,mask,mask,9,"///< The mask is expected to be for permutation of 1-2 vectors,; ///< check for the mask elements for the first argument (mask; ///< indices are in range [0:VF)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:84,Availability,mask,mask,84,"///< The mask is expected to be for permutation of 1-2 vectors,; ///< check for the mask elements for the first argument (mask; ///< indices are in range [0:VF)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:122,Availability,mask,mask,122,"///< The mask is expected to be for permutation of 1-2 vectors,; ///< check for the mask elements for the first argument (mask; ///< indices are in range [0:VF)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Availability,mask,mask,9,"///< The mask is expected to be for permutation of 2 vectors, check; ///< for the mask elements for the second argument (mask indices; ///< are in range [VF:2*VF))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:82,Availability,mask,mask,82,"///< The mask is expected to be for permutation of 2 vectors, check; ///< for the mask elements for the second argument (mask indices; ///< are in range [VF:2*VF))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Availability,mask,mask,121,"///< The mask is expected to be for permutation of 2 vectors, check; ///< for the mask elements for the second argument (mask indices; ///< are in range [VF:2*VF))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Availability,mask,mask,20,///< Consider undef mask elements (-1) as placeholders for; ///< future shuffle elements and mark them as ones as being used; ///< in future. Non-undef elements are considered as unused since; ///< they're already marked as used in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:236,Availability,mask,mask,236,///< Consider undef mask elements (-1) as placeholders for; ///< future shuffle elements and mark them as ones as being used; ///< in future. Non-undef elements are considered as unused since; ///< they're already marked as used in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:54,Availability,mask,mask,54,// namespace; /// Prepares a use bitset for the given mask either for the first argument or; /// for the second.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:141,Availability,mask,masked,141,"/// Checks if the given value is actually an undefined constant vector.; /// Also, if the \p UseMask is not empty, tries to check if the non-masked; /// elements actually mask the insertelement buildvector, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:171,Availability,mask,mask,171,"/// Checks if the given value is actually an undefined constant vector.; /// Also, if the \p UseMask is not empty, tries to check if the non-masked; /// elements actually mask the insertelement buildvector, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:817,Availability,Mask,Mask,817,"/// Checks if the vector of instructions can be represented as a shuffle, like:; /// %x0 = extractelement <4 x i8> %x, i32 0; /// %x3 = extractelement <4 x i8> %x, i32 3; /// %y1 = extractelement <4 x i8> %y, i32 1; /// %y2 = extractelement <4 x i8> %y, i32 2; /// %x0x0 = mul i8 %x0, %x0; /// %x3x3 = mul i8 %x3, %x3; /// %y1y1 = mul i8 %y1, %y1; /// %y2y2 = mul i8 %y2, %y2; /// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0; /// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1; /// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2; /// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3; /// ret <4 x i8> %ins4; /// can be transformed into:; /// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,; /// i32 6>; /// %2 = mul <4 x i8> %1, %1; /// ret <4 x i8> %2; /// Mask will return the Shuffle Mask equivalent to the extracted elements.; /// TODO: Can we split off and reuse the shuffle mask detection from; /// ShuffleVectorInst/getShuffleCost?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:846,Availability,Mask,Mask,846,"/// Checks if the vector of instructions can be represented as a shuffle, like:; /// %x0 = extractelement <4 x i8> %x, i32 0; /// %x3 = extractelement <4 x i8> %x, i32 3; /// %y1 = extractelement <4 x i8> %y, i32 1; /// %y2 = extractelement <4 x i8> %y, i32 2; /// %x0x0 = mul i8 %x0, %x0; /// %x3x3 = mul i8 %x3, %x3; /// %y1y1 = mul i8 %y1, %y1; /// %y2y2 = mul i8 %y2, %y2; /// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0; /// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1; /// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2; /// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3; /// ret <4 x i8> %ins4; /// can be transformed into:; /// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,; /// i32 6>; /// %2 = mul <4 x i8> %1, %1; /// ret <4 x i8> %2; /// Mask will return the Shuffle Mask equivalent to the extracted elements.; /// TODO: Can we split off and reuse the shuffle mask detection from; /// ShuffleVectorInst/getShuffleCost?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:939,Availability,mask,mask,939,"/// Checks if the vector of instructions can be represented as a shuffle, like:; /// %x0 = extractelement <4 x i8> %x, i32 0; /// %x3 = extractelement <4 x i8> %x, i32 3; /// %y1 = extractelement <4 x i8> %y, i32 1; /// %y2 = extractelement <4 x i8> %y, i32 2; /// %x0x0 = mul i8 %x0, %x0; /// %x3x3 = mul i8 %x3, %x3; /// %y1y1 = mul i8 %y1, %y1; /// %y2y2 = mul i8 %y2, %y2; /// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0; /// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1; /// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2; /// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3; /// ret <4 x i8> %ins4; /// can be transformed into:; /// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,; /// i32 6>; /// %2 = mul <4 x i8> %1, %1; /// ret <4 x i8> %2; /// Mask will return the Shuffle Mask equivalent to the extracted elements.; /// TODO: Can we split off and reuse the shuffle mask detection from; /// ShuffleVectorInst/getShuffleCost?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:944,Safety,detect,detection,944,"/// Checks if the vector of instructions can be represented as a shuffle, like:; /// %x0 = extractelement <4 x i8> %x, i32 0; /// %x3 = extractelement <4 x i8> %x, i32 3; /// %y1 = extractelement <4 x i8> %y, i32 1; /// %y2 = extractelement <4 x i8> %y, i32 2; /// %x0x0 = mul i8 %x0, %x0; /// %x3x3 = mul i8 %x3, %x3; /// %y1y1 = mul i8 %y1, %y1; /// %y2y2 = mul i8 %y2, %y2; /// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0; /// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1; /// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2; /// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3; /// ret <4 x i8> %ins4; /// can be transformed into:; /// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,; /// i32 6>; /// %2 = mul <4 x i8> %1, %1; /// ret <4 x i8> %2; /// Mask will return the Shuffle Mask equivalent to the extracted elements.; /// TODO: Can we split off and reuse the shuffle mask detection from; /// ShuffleVectorInst/getShuffleCost?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Energy Efficiency,schedul,scheduling,60,"// end anonymous namespace; /// Chooses the correct key for scheduling data. If \p Op has the same (or; /// alternate) opcode as \p OpValue, the key is \p Op. Otherwise the key is \p; /// OpValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:97,Performance,perform,perform,97,// Check for compatible operands. If the corresponding operands are not; // compatible - need to perform alternate vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,Security,access,access,43,/// \returns the AA location that is being access by the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,Performance,load,load,65,/// \returns True if the instruction is not a volatile or atomic load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Availability,Mask,Mask,16,/// Shuffles \p Mask in accordance with the given \p SubMask.; /// \param ExtendingManyInputs Supports reshuffling of the mask with not only; /// one but two input vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:122,Availability,mask,mask,122,/// Shuffles \p Mask in accordance with the given \p SubMask.; /// \param ExtendingManyInputs Supports reshuffling of the mask with not only; /// one but two input vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:74,Modifiability,Extend,ExtendingManyInputs,74,/// Shuffles \p Mask in accordance with the given \p SubMask.; /// \param ExtendingManyInputs Supports reshuffling of the mask with not only; /// one but two input vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Modifiability,extend,extended,31,// Check if input scalars were extended to match the size of other node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:215,Safety,avoid,avoid,215,/// Order may have elements assigned special value (size) which is out of; /// bounds. Such indices only appear on places which correspond to undef values; /// (see canReuseExtract for details) and used in order to avoid undef values; /// have effect on operands ordering.; /// The first loop below simply finds all unused indices and then the next loop; /// nest assigns these indices for undef values positions.; /// As an example below Order has two undef positions and they have assigned; /// values 3 and 7 respectively:; /// before: 6 9 5 4 9 2 1 0; /// after: 6 3 5 4 7 2 1 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:299,Usability,simpl,simply,299,/// Order may have elements assigned special value (size) which is out of; /// bounds. Such indices only appear on places which correspond to undef values; /// (see canReuseExtract for details) and used in order to avoid undef values; /// have effect on operands ordering.; /// The first loop below simply finds all unused indices and then the next loop; /// nest assigns these indices for undef values positions.; /// As an example below Order has two undef positions and they have assigned; /// values 3 and 7 respectively:; /// before: 6 9 5 4 9 2 1 0; /// after: 6 3 5 4 7 2 1 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,Availability,Mask,Mask,65,/// Reorders the list of scalars in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Energy Efficiency,schedul,scheduling,50,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all operands are either not instructions; /// or phi nodes or instructions from different blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:87,Energy Efficiency,schedul,scheduling,87,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all operands are either not instructions; /// or phi nodes or instructions from different blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Energy Efficiency,schedul,scheduling,50,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all users are phi nodes or instructions; /// from the different blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:87,Energy Efficiency,schedul,scheduling,87,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all users are phi nodes or instructions; /// from the different blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:51,Energy Efficiency,schedul,scheduling,51,/// Checks if the specified value does not require scheduling. It does not; /// require scheduling if all operands and all users do not need to be scheduled; /// in the current basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Energy Efficiency,schedul,scheduling,88,/// Checks if the specified value does not require scheduling. It does not; /// require scheduling if all operands and all users do not need to be scheduled; /// in the current basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:147,Energy Efficiency,schedul,scheduled,147,/// Checks if the specified value does not require scheduling. It does not; /// require scheduling if all operands and all users do not need to be scheduled; /// in the current basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:67,Energy Efficiency,schedul,scheduling,67,/// Checks if the specified array of instructions does not require scheduling.; /// It is so if all either instructions have operands that do not require; /// scheduling or their users do not require scheduling since they are phis or; /// in other basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:159,Energy Efficiency,schedul,scheduling,159,/// Checks if the specified array of instructions does not require scheduling.; /// It is so if all either instructions have operands that do not require; /// scheduling or their users do not require scheduling since they are phis or; /// in other basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:200,Energy Efficiency,schedul,scheduling,200,/// Checks if the specified array of instructions does not require scheduling.; /// It is so if all either instructions have operands that do not require; /// scheduling or their users do not require scheduling since they are phis or; /// in other basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:98,Energy Efficiency,schedul,scheduling,98,"/// Construct a vectorizable tree that starts at \p Roots, ignoring users for; /// the purpose of scheduling and extraction in the \p UserIgnoreLst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clear,4,/// Clear the internal data structures that are created by 'buildTree'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Performance,Perform,Perform,4,/// Perform LICM and CSE on the newly generated gather sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:213,Performance,Load,Loads,213,"/// Checks if the specified gather tree entry \p TE can be represented as a; /// shuffled vector entry + (possibly) permutation with other gathers. It; /// implements the checks only for possibly ordered scalars (Loads,; /// ExtractElement, ExtractValue), which can be part of the graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Performance,load,loads,9,/// Sort loads into increasing pointers offsets to allow greater clustering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:354,Modifiability,extend,extend,354,/// Reorders the current graph to the most profitable order starting from the; /// root node to the leaf nodes. The best order is chosen only from the nodes; /// of the same size (vectorization factor). Smaller nodes are considered; /// parts of subgraph with smaller VF and they are reordered independently. We; /// can make it because we still need to extend smaller nodes to the wider VF; /// and we can merge reordering shuffles with the widening shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:139,Energy Efficiency,reduce,reduce,139,"/// Reorders the current graph to the most profitable order starting from; /// leaves to the root. It allows to rotate small subgraphs and reduce the; /// number of reshuffles if the leaf nodes use the same order. In this case we; /// can merge the orders and just shuffle user node instead of shuffling its; /// operands. Plus, even the leaf nodes have different orders, it allows to; /// sink reordering in the graph closer to the root node and merge it later; /// during analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:222,Performance,load,loaded,222,"/// \return The vector element size in bits to use when vectorizing the; /// expression tree ending at \p V. If V is a store, the size is the width of; /// the stored value. Otherwise, the size is the width of the largest loaded; /// value reaching V. This method is used by the vectorizer to calculate; /// vectorization factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,Performance,load,loaded,63,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:89,Performance,load,load,89,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:119,Performance,Load,Load,119,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:168,Performance,optimiz,optimizer,168,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:372,Performance,load,load,372,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:408,Performance,optimiz,optimizer,408,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:352,Usability,undo,undo,352,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:64,Performance,load,loaded,64,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,Performance,load,load,90,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:120,Performance,Load,Load,120,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:169,Performance,optimiz,optimizer,169,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:373,Performance,load,load,373,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:409,Performance,optimiz,optimizer,409,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:353,Usability,undo,undo,353,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:466,Performance,load,loads,466,"// The hard-coded scores listed here are not very important, though it shall; // be higher for better matches to improve the resulting cost. When; // computing the scores of matching one sub-tree with another, we are; // basically counting the number of values that are matching. So even if all; // scores are set to 1, we would still get a decent matching result.; // However, sometimes we have to break ties. For example we may have to; // choose between matching loads vs matching opcodes. This is what these; // scores are helping us with: they provide the order of preference. Also,; // this is important if the scalar is externally used or used in another; // tree entry node in the different lane.; /// Loads from consecutive memory addresses, e.g. load(A[i]), load(A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:710,Performance,Load,Loads,710,"// The hard-coded scores listed here are not very important, though it shall; // be higher for better matches to improve the resulting cost. When; // computing the scores of matching one sub-tree with another, we are; // basically counting the number of values that are matching. So even if all; // scores are set to 1, we would still get a decent matching result.; // However, sometimes we have to break ties. For example we may have to; // choose between matching loads vs matching opcodes. This is what these; // scores are helping us with: they provide the order of preference. Also,; // this is important if the scalar is externally used or used in another; // tree entry node in the different lane.; /// Loads from consecutive memory addresses, e.g. load(A[i]), load(A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:756,Performance,load,load,756,"// The hard-coded scores listed here are not very important, though it shall; // be higher for better matches to improve the resulting cost. When; // computing the scores of matching one sub-tree with another, we are; // basically counting the number of values that are matching. So even if all; // scores are set to 1, we would still get a decent matching result.; // However, sometimes we have to break ties. For example we may have to; // choose between matching loads vs matching opcodes. This is what these; // scores are helping us with: they provide the order of preference. Also,; // this is important if the scalar is externally used or used in another; // tree entry node in the different lane.; /// Loads from consecutive memory addresses, e.g. load(A[i]), load(A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:768,Performance,load,load,768,"// The hard-coded scores listed here are not very important, though it shall; // be higher for better matches to improve the resulting cost. When; // computing the scores of matching one sub-tree with another, we are; // basically counting the number of values that are matching. So even if all; // scores are set to 1, we would still get a decent matching result.; // However, sometimes we have to break ties. For example we may have to; // choose between matching loads vs matching opcodes. This is what these; // scores are helping us with: they provide the order of preference. Also,; // this is important if the scalar is externally used or used in another; // tree entry node in the different lane.; /// Loads from consecutive memory addresses, e.g. load(A[i]), load(A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Performance,load,load,13,"/// The same load multiple times. This should have a better score than; /// `ScoreSplat` because it in x86 for a 2-lane vector we can represent it; /// with `movddup (%reg), xmm0` which has a throughput of 0.5 versus 0.5 for; /// a vector load and 1.0 for a broadcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:192,Performance,throughput,throughput,192,"/// The same load multiple times. This should have a better score than; /// `ScoreSplat` because it in x86 for a 2-lane vector we can represent it; /// with `movddup (%reg), xmm0` which has a throughput of 0.5 versus 0.5 for; /// a vector load and 1.0 for a broadcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:239,Performance,load,load,239,"/// The same load multiple times. This should have a better score than; /// `ScoreSplat` because it in x86 for a 2-lane vector we can represent it; /// with `movddup (%reg), xmm0` which has a throughput of 0.5 versus 0.5 for; /// a vector load and 1.0 for a broadcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Performance,Load,Loads,4,"/// Loads from reversed memory addresses, e.g. load(A[i+1]), load(A[i]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Performance,load,load,47,"/// Loads from reversed memory addresses, e.g. load(A[i+1]), load(A[i]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:61,Performance,load,load,61,"/// Loads from reversed memory addresses, e.g. load(A[i+1]), load(A[i]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:25,Availability,mask,masked,25,/// A load candidate for masked gather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:6,Performance,load,load,6,/// A load candidate for masked gather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Performance,load,load,20,// A broadcast of a load can be cheaper on some targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:62,Availability,mask,masked,62,// The distance is too large - still may be profitable to use masked; // loads/gathers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,Performance,load,loads,73,// The distance is too large - still may be profitable to use masked; // loads/gathers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,Energy Efficiency,power,power-,107,"// This still will detect consecutive loads, but we might have ""holes""; // in some cases. It is ok for non-power-2 vectorization and may produce; // better results. It should not affect current vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Performance,load,loads,38,"// This still will detect consecutive loads, but we might have ""holes""; // in some cases. It is ok for non-power-2 vectorization and may produce; // better results. It should not affect current vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Safety,detect,detect,19,"// This still will detect consecutive loads, but we might have ""holes""; // in some cases. It is ok for non-power-2 vectorization and may produce; // better results. It should not affect current vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:98,Performance,optimiz,optimized,98,// Extracts from consecutive indexes of the same vector better score as; // the extracts could be optimized away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,Safety,avoid,avoid,58,// Note: Only consider instructions with <= 2 operands to avoid; // complexity explosion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:673,Performance,load,loads,673,"/// Go through the operands of \p LHS and \p RHS recursively until; /// MaxLevel, and return the cummulative score. \p U1 and \p U2 are; /// the users of \p LHS and \p RHS (that is \p LHS and \p RHS are operands; /// of \p U1 and \p U2), except at the beginning of the recursion where; /// these are set to nullptr.; ///; /// For example:; /// \verbatim; /// A[0] B[0] A[1] B[1] C[0] D[0] B[1] A[1]; /// \ / \ / \ / \ /; /// + + + +; /// G1 G2 G3 G4; /// \endverbatim; /// The getScoreAtLevelRec(G1, G2) function will try to match the nodes at; /// each level recursively, accumulating the score. It starts from matching; /// the additions at level 0, then moves on to the loads (level 1). The; /// score of G1 and G2 is higher than G1 and G3, because {A[0],A[1]} and; /// {B[0],B[1]} match with LookAheadHeuristics::ScoreConsecutiveLoads, while; /// {A[0],C[0]} has a score of LookAheadHeuristics::ScoreFail.; /// Please note that the order of the operands does not matter, as we; /// evaluate the score of all profitable combinations of operands. In; /// other words the score of G1 and G4 is the same as G1 and G2. This; /// heuristic is based on ideas described in:; /// Look-ahead SLP: Auto-vectorization in the presence of commutative; /// operations, CGO 2018 by Vasileios Porpodas, Rodrigo C. O. Rocha,; /// Lus F. W. Ges",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:162,Performance,load,loads,162,"// If reached MaxLevel,; // or if V1 and V2 are not instructions,; // or if they are SPLAT,; // or if they are not consecutive,; // or if profitable to vectorize loads or extractelements, early return; // the current cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:172,Safety,avoid,avoid,172,"/// For each operand we need (i) the value, and (ii) the opcode that it; /// would be attached to if the expression was in a left-linearized form.; /// This is required to avoid illegal operand reordering.; /// For example:; /// \verbatim; /// 0 Op1; /// |/; /// Op1 Op2 Linearized + Op2; /// \ / ----------> |/; /// - -; ///; /// Op1 - Op2 (0 + Op1) - Op2; /// \endverbatim; ///; /// Value Op1 is attached to a '+' operation, and Op2 to a '-'.; ///; /// Another way to think of this is to track all the operations across the; /// path from the operand all the way to the root of the tree and to; /// calculate the operation that corresponds to this path. For example, the; /// path from Op2 to the root crosses the RHS of the '-', therefore the; /// corresponding operation is a '-' (which matches the one in the; /// linearized tree, as shown above).; ///; /// For lack of a better term, we refer to this operation as Accumulated; /// Path Operation (APO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:113,Safety,safe,safely,113,"/// TreeEntries only allow a single opcode, or an alternate sequence of; /// them (e.g, +, -). Therefore, we can safely use a boolean value for the; /// APO. It is set to 'true' if 'V' is attached to an inverse operation; /// in the left-linearized form (e.g., Sub/Div), and 'false' otherwise; /// (e.g., Add/Mul)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:257,Performance,load,load,257,"/// During operand reordering, we are trying to select the operand at lane; /// that matches best with the operand at the neighboring lane. Our; /// selection is based on the type of value we are looking for. For example,; /// if the neighboring lane has a load, we need to look for a load that is; /// accessing a consecutive address. These strategies are summarized in the; /// 'ReorderingMode' enumerator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:285,Performance,load,load,285,"/// During operand reordering, we are trying to select the operand at lane; /// that matches best with the operand at the neighboring lane. Our; /// selection is based on the type of value we are looking for. For example,; /// if the neighboring lane has a load, we need to look for a load that is; /// accessing a consecutive address. These strategies are summarized in the; /// 'ReorderingMode' enumerator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:303,Security,access,accessing,303,"/// During operand reordering, we are trying to select the operand at lane; /// that matches best with the operand at the neighboring lane. Our; /// selection is based on the type of value we are looking for. For example,; /// if the neighboring lane has a load, we need to look for a load that is; /// accessing a consecutive address. These strategies are summarized in the; /// 'ReorderingMode' enumerator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Performance,load,loads,14,///< Matching loads to consecutive memory addresses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clears,4,/// Clears the used flag for all entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:334,Energy Efficiency,power,power-of-,334,"/// \param Lane lane of the operands under analysis.; /// \param OpIdx operand index in \p Lane lane we're looking the best; /// candidate for.; /// \param Idx operand index of the current candidate value.; /// \returns The additional score due to possible broadcasting of the; /// elements in the lane. It is more profitable to have power-of-2 unique; /// elements in the lane, it will be vectorized with higher probability; /// after removing duplicates. Currently the SLP vectorizer supports only; /// vectorization of the power-of-2 number of unique scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:526,Energy Efficiency,power,power-of-,526,"/// \param Lane lane of the operands under analysis.; /// \param OpIdx operand index in \p Lane lane we're looking the best; /// candidate for.; /// \param Idx operand index of the current candidate value.; /// \returns The additional score due to possible broadcasting of the; /// elements in the lane. It is more profitable to have power-of-2 unique; /// elements in the lane, it will be vectorized with higher probability; /// after removing duplicates. Currently the SLP vectorizer supports only; /// vectorization of the power-of-2 number of unique scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:52,Safety,avoid,avoid,52,// Set the minimum score for splat-like sequence to avoid setting; // failed state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:112,Energy Efficiency,power,power-of-,112,"// Track if the operand must be marked as used. If the operand is set to; // Score 1 explicitly (because of non power-of-2 unique scalars, we may; // want to reestimate the operands again on the following iterations).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,Usability,simpl,simple,56,"// std::pair<unsigned, unsigned> is used to implement a simple voting; // algorithm and choose the lane with the least number of operands that; // can freely move about or less profitable because it already has the; // most optimal set of operands. The first unsigned is a counter for; // voting, the second unsigned is the counter of lanes with instructions; // with same/alternate opcodes and same parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Security,Hash,Hash,4,"/// Hash for the actual operands ordering.; /// Used to count operands, actually their position id and opcode; /// value. It is used in the voting mechanism to find the lane with the; /// least number of operands that can freely move about or less profitable; /// because it already has the most optimal set of operands. Can be; /// replaced with SmallVector<unsigned> instead but hash code is faster; /// and requires less memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:381,Security,hash,hash,381,"/// Hash for the actual operands ordering.; /// Used to count operands, actually their position id and opcode; /// value. It is used in the voting mechanism to find the lane with the; /// least number of operands that can freely move about or less profitable; /// because it already has the most optimal set of operands. Can be; /// replaced with SmallVector<unsigned> instead but hash code is faster; /// and requires less memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:206,Safety,avoid,avoid,206,"// Operands with the same APO can be reordered. We therefore need to count; // how many of them we have for each APO, like this: Cnt[APO] = x.; // Since we only have two APOs, namely true and false, we can avoid using; // a map. Instead we can simply count the number of operands that; // correspond to one of them (in this case the 'true' APO), and calculate; // the other by subtracting it from the total number of operands.; // Operands with the same instruction opcode and parent are more; // profitable since we don't need to move them in many cases, with a high; // probability such lane already can be vectorized effectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:244,Usability,simpl,simply,244,"// Operands with the same APO can be reordered. We therefore need to count; // how many of them we have for each APO, like this: Cnt[APO] = x.; // Since we only have two APOs, namely true and false, we can avoid using; // a map. Instead we can simply count the number of operands that; // correspond to one of them (in this case the 'true' APO), and calculate; // the other by subtracting it from the total number of operands.; // Operands with the same instruction opcode and parent are more; // profitable since we don't need to move them in many cases, with a high; // probability such lane already can be vectorized effectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:444,Performance,perform,performed,444,"// Our tree has just 3 nodes: the root and two operands.; // It is therefore trivial to get the APO. We only need to check the; // opcode of VL[Lane] and whether the operand at OpIdx is the LHS or; // RHS operand. The LHS operand of both add and sub is never attached; // to an inversese operation in the linearized form, therefore its APO; // is false. The RHS is true only if VL[Lane] is an inverse operation.; // Since operand reordering is performed on groups of commutative; // operations or alternating sequences (e.g., +, -), we can safely; // tell the inverse operations by checking commutativity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:540,Safety,safe,safely,540,"// Our tree has just 3 nodes: the root and two operands.; // It is therefore trivial to get the APO. We only need to check the; // opcode of VL[Lane] and whether the operand at OpIdx is the LHS or; // RHS operand. The LHS operand of both add and sub is never attached; // to an inversese operation in the linearized form, therefore its APO; // is false. The RHS is true only if VL[Lane] is an inverse operation.; // Since operand reordering is performed on groups of commutative; // operations or alternating sequences (e.g., +, -), we can safely; // tell the inverse operations by checking commutativity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clears,4,/// Clears the data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Performs,3,// Performs operand reordering for 2 or more operands.; // The original operands are in OrigOps[OpIdx][Lane].; // The reordered operands are returned in 'SortedOps[OpIdx][Lane]'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:183,Energy Efficiency,power,power,183,// Check that we don't have same operands. No need to reorder if operands; // are just perfect diamond or shuffled diamond match. Do not do it only; // for possible broadcasts or non-power of 2 number of scalars (just for; // now).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:48,Energy Efficiency,power,power-,48,// TODO: Check if we can remove a check for non-power-2 number of; // scalars after full support of non-power-2 vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:104,Energy Efficiency,power,power-,104,// TODO: Check if we can remove a check for non-power-2 number of; // scalars after full support of non-power-2 vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:77,Performance,perform,perform,77,"// If the initial strategy fails for any of the operand indexes, then we; // perform reordering again in a second pass. This helps avoid assigning; // high priority to the failed strategy, and should improve reordering for; // the non-failed operand indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:131,Safety,avoid,avoid,131,"// If the initial strategy fails for any of the operand indexes, then we; // perform reordering again in a second pass. This helps avoid assigning; // high priority to the failed strategy, and should improve reordering for; // the non-failed operand indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,Safety,avoid,avoid,118,"// Check if no need to reorder operands since they're are perfect or; // shuffled diamond match.; // Need to do it to avoid extra external use cost counting for; // shuffled matches, which may cause regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Energy Efficiency,reduce,reduced,35,/// Checks if the provided list of reduced values was checked already for; /// vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Energy Efficiency,reduce,reduced,21,/// Adds the list of reduced values to list of already checked values for the; /// vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clear,4,/// Clear the list of the analyzed reduction root instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:322,Performance,load,loads,322,"/// Check if the operands on the edges \p Edges of the \p UserTE allows; /// reordering (i.e. the operands can be reordered because they have only one; /// user and reordarable).; /// \param ReorderableGathers List of all gather nodes that require reordering; /// (e.g., gather of extractlements or partially vectorizable loads).; /// \param GatherOps List of gather operand nodes for \p UserTE that require; /// reordering, subset of \p NonVectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:111,Availability,Mask,Mask,111,/// Checks if the given \p TE is a gather node with clustered reused scalars; /// and reorders it per given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,Safety,avoid,avoid,124,"/// Vectorize a single entry in the tree.; /// \param PostponedPHIs true, if need to postpone emission of phi nodes to; /// avoid issues with def-use order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:170,Safety,avoid,avoid,170,"/// Vectorize a single entry in the tree, the \p Idx-th operand of the entry; /// \p E.; /// \param PostponedPHIs true, if need to postpone emission of phi nodes to; /// avoid issues with def-use order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:170,Performance,optimiz,optimization,170,"/// Create a new vector from a list of scalar values. Produces a sequence; /// which exploits values reused across lanes, and arranges the inserts; /// for ease of later optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:170,Performance,optimiz,optimization,170,"/// Create a new vector from a list of scalar values. Produces a sequence; /// which exploits values reused across lanes, and arranges the inserts; /// for ease of later optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Energy Efficiency,schedul,scheduling,86,"/// Returns the instruction in the bundle, which can be used as a base point; /// for scheduling. Usually it is the last instruction in the bundle, except; /// for the case when all operands are external (in this case, it is the first; /// instruction in the list).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,Safety,detect,detected,173,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt; /// was successful, the matched scalars are replaced by poison values in \p VL; /// for future analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,Safety,detect,detected,173,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt; /// was successful, the matched scalars are replaced by poison values in \p VL; /// for future analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:413,Availability,Mask,Mask,413,"/// Checks if the gathered \p VL can be represented as a single register; /// shuffle(s) of previous tree entries.; /// \param TE Tree entry checked for permutation.; /// \param VL List of scalars (a subset of the TE scalar), checked for; /// permutations. Must form single-register vector.; /// \returns ShuffleKind, if gathered values can be represented as shuffles of; /// previous tree entries. \p Part of \p Mask is filled with the shuffle mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:445,Availability,mask,mask,445,"/// Checks if the gathered \p VL can be represented as a single register; /// shuffle(s) of previous tree entries.; /// \param TE Tree entry checked for permutation.; /// \param VL List of scalars (a subset of the TE scalar), checked for; /// permutations. Must form single-register vector.; /// \returns ShuffleKind, if gathered values can be represented as shuffles of; /// previous tree entries. \p Part of \p Mask is filled with the shuffle mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:388,Availability,Mask,Mask,388,"/// Checks if the gathered \p VL can be represented as multi-register; /// shuffle(s) of previous tree entries.; /// \param TE Tree entry checked for permutation.; /// \param VL List of scalars (a subset of the TE scalar), checked for; /// permutations.; /// \returns per-register series of ShuffleKind, if gathered values can be; /// represented as shuffles of previous tree entries. \p Mask is filled with; /// the shuffle mask (also on per-register base).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:425,Availability,mask,mask,425,"/// Checks if the gathered \p VL can be represented as multi-register; /// shuffle(s) of previous tree entries.; /// \param TE Tree entry checked for permutation.; /// \param VL List of scalars (a subset of the TE scalar), checked for; /// permutations.; /// \returns per-register series of ShuffleKind, if gathered values can be; /// represented as shuffles of previous tree entries. \p Mask is filled with; /// the shuffle mask (also on per-register base).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Availability,mask,mask,20,/// \returns Common mask for reorder indices and reused scalars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:141,Performance,load,load,141,/// Do we need to gather this sequence or vectorize it; /// (either with vector instruction or with scatter/gather; /// intrinsics for store/load)?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:137,Performance,perform,performs,137,/// The operands of each instruction in each lane Operands[op_index][lane].; /// Note: This helps avoid the replication of the code that performs the; /// reordering of operands during buildTree_rec() and vectorizeTree().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:98,Safety,avoid,avoid,98,/// The operands of each instruction in each lane Operands[op_index][lane].; /// Note: This helps avoid the replication of the code that performs the; /// reordering of operands during buildTree_rec() and vectorizeTree().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,mask,mask,47,/// Reorders operands of the node to the given mask \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:55,Availability,Mask,Mask,55,/// Reorders operands of the node to the given mask \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Energy Efficiency,schedul,scheduling,32,"/// Chooses the correct key for scheduling data. If \p Op has the same (or; /// alternate) opcode as \p OpValue, the key is \p Op. Otherwise the key is; /// \p OpValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Availability,mask,mask,20,/// Build a shuffle mask for graph entry which represents a merge of main; /// and alternate operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Availability,mask,mask,35,// Reorder scalars and build final mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update the scheduler bundle to point to this TreeEntry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,scheduler,14,// Update the scheduler bundle to point to this TreeEntry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Energy Efficiency,schedul,scheduling,121,/// Checks if the specified list of the instructions/values can be vectorized; /// and fills required data before actual scheduling of the instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Integrability,depend,depending,26,"/// List of gather nodes, depending on other gather/vector nodes, which should; /// be emitted after the vector instruction emission process to correctly; /// handle order of the vector instructions and shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Security,access,access,35,/// Checks if two instructions may access the same memory.; ///; /// \p Loc1 is the location of \p Inst1. It is passed explicitly because it; /// is invariant in the calling loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Performance,cache,cache,47,// First check if the result is already in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,cache,cache,27,// Store the result in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Performance,Cache,Cache,4,/// Cache for alias results.; /// TODO: consider moving this to the AliasAnalysis itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Cache,Cache,3,// Cache for pointerMayBeCaptured calls inside AA. This is preserved; // globally through SLP because we don't perform any action which; // invalidates capture results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:111,Performance,perform,perform,111,// Cache for pointerMayBeCaptured calls inside AA. This is preserved; // globally through SLP because we don't perform any action which; // invalidates capture results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:267,Energy Efficiency,allocate,allocated,267,"/// Temporary store for deleted instructions. Instructions will be deleted; /// eventually when the BoUpSLP is destructed. The deferral is required to; /// ensure that there are no incorrect collisions in the AliasCache, which; /// can happen if a new instruction is allocated at the same address as a; /// previously deleted instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Security,hash,hashes,11,/// Set of hashes for the list of reduction values already being analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,schedul,scheduling,17,/// Contains all scheduling relevant data for an instruction.; /// A ScheduleData either represents a single instruction or a member of an; /// instruction bundle (= a group of instructions which is combined into a; /// vector instruction).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:69,Energy Efficiency,Schedul,ScheduleData,69,/// Contains all scheduling relevant data for an instruction.; /// A ScheduleData either represents a single instruction or a member of an; /// instruction bundle (= a group of instructions which is combined into a; /// vector instruction).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,Integrability,depend,dependency,29,// The initial value for the dependency counters. It means that the; // dependencies are not calculated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:72,Integrability,depend,dependencies,72,// The initial value for the dependency counters. It means that the; // dependencies are not calculated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Integrability,depend,dependency,24,/// Returns true if the dependency information has been calculated.; /// Note that depenendency validity can vary between instructions within; /// a single bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,Energy Efficiency,schedul,scheduling,36,"/// Returns true if it is ready for scheduling, i.e. it has no more; /// unscheduled depending instructions/bundles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:85,Integrability,depend,depending,85,"/// Returns true if it is ready for scheduling, i.e. it has no more; /// unscheduled depending instructions/bundles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:39,Integrability,depend,dependencies,39,"/// Modifies the number of unscheduled dependencies for this instruction,; /// and returns the number of remaining dependencies for the containing; /// bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:115,Integrability,depend,dependencies,115,"/// Modifies the number of unscheduled dependencies for this instruction,; /// and returns the number of remaining dependencies for the containing; /// bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Integrability,depend,dependencies,35,/// Sets the number of unscheduled dependencies to the number of; /// dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:70,Integrability,depend,dependencies,70,/// Sets the number of unscheduled dependencies to the number of; /// dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Integrability,depend,dependency,15,/// Clears all dependency information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clears,4,/// Clears all dependency information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:45,Energy Efficiency,schedul,schedule,45,/// Opcode of the current instruction in the schedule data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:116,Energy Efficiency,schedul,scheduling,116,"/// Single linked list of all memory instructions (e.g. load, store, call); /// in the block - until the end of the scheduling region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,Performance,load,load,56,"/// Single linked list of all memory instructions (e.g. load, store, call); /// in the block - until the end of the scheduling region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:8,Integrability,depend,dependent,8,/// The dependent memory instructions.; /// This list is derived on demand in calculateDependencies().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:166,Availability,fault,fault,166,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:110,Energy Efficiency,schedul,scheduled,110,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,Integrability,depend,dependent,65,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:235,Performance,load,load,235,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Energy Efficiency,Schedul,ScheduleData,9,/// This ScheduleData is in the current scheduling region if this matches; /// the current SchedulingRegionID of BlockScheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Energy Efficiency,schedul,scheduling,40,/// This ScheduleData is in the current scheduling region if this matches; /// the current SchedulingRegionID of BlockScheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:91,Energy Efficiency,Schedul,SchedulingRegionID,91,/// This ScheduleData is in the current scheduling region if this matches; /// the current SchedulingRegionID of BlockScheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Integrability,depend,dependencies,18,"/// The number of dependencies. Constitutes of the number of users of the; /// instruction plus the number of dependent memory instructions (if any).; /// This value is calculated on demand.; /// If InvalidDeps, the number of dependencies is not calculated yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:110,Integrability,depend,dependent,110,"/// The number of dependencies. Constitutes of the number of users of the; /// instruction plus the number of dependent memory instructions (if any).; /// This value is calculated on demand.; /// If InvalidDeps, the number of dependencies is not calculated yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:226,Integrability,depend,dependencies,226,"/// The number of dependencies. Constitutes of the number of users of the; /// instruction plus the number of dependent memory instructions (if any).; /// This value is calculated on demand.; /// If InvalidDeps, the number of dependencies is not calculated yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:67,Energy Efficiency,schedul,scheduled,67,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:164,Energy Efficiency,schedul,scheduling,164,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Integrability,depend,dependencies,18,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:51,Integrability,depend,dependencies,51,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:219,Integrability,Depend,Dependencies,219,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Energy Efficiency,schedul,scheduled,32,/// True if this instruction is scheduled (or considered as scheduled in the; /// dry-run).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Energy Efficiency,schedul,scheduled,60,/// True if this instruction is scheduled (or considered as scheduled in the; /// dry-run).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,schedul,scheduling,17,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:69,Energy Efficiency,schedul,schedules,69,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:400,Energy Efficiency,schedul,scheduling,400,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:449,Energy Efficiency,schedul,scheduled,449,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:608,Energy Efficiency,Schedul,ScheduleData,608,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:858,Energy Efficiency,schedul,scheduling,858,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:874,Energy Efficiency,Schedul,ScheduleData,874,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:894,Energy Efficiency,allocate,allocated,894,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:952,Energy Efficiency,schedul,scheduling,952,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:797,Integrability,depend,dependencies,797,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the maximum schedule region size by the size of the; // previous scheduling run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Energy Efficiency,schedul,schedule,22,// Reduce the maximum schedule region size by the size of the; // previous scheduling run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Energy Efficiency,schedul,scheduling,75,// Reduce the maximum schedule region size by the size of the; // previous scheduling run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,scheduling,14,"// Make a new scheduling region, i.e. all existing ScheduleData is not; // in the new region yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:51,Energy Efficiency,Schedul,ScheduleData,51,"// Make a new scheduling region, i.e. all existing ScheduleData is not; // in the new region yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid lookup if can't possibly be in map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Energy Efficiency,schedul,scheduled,28,/// Marks an instruction as scheduled and puts all dependent ready; /// instructions into the ready-list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:51,Integrability,depend,dependent,51,/// Marks an instruction as scheduled and puts all dependent ready; /// instructions into the ready-list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Integrability,depend,dependencies,28,// Handle the def-use chain dependencies.; // Decrement the unscheduled counter and insert to ready list if ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Integrability,depend,dependencies,33,"// There are no more unscheduled dependencies after; // decrementing, so we can put the dependent instruction; // into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Integrability,depend,dependent,88,"// There are no more unscheduled dependencies after; // decrementing, so we can put the dependent instruction; // into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:300,Energy Efficiency,schedul,scheduler,300,// Since vectorization tree is being built recursively this assertion; // ensures that the tree entry has all operands set before reaching; // this code. Couple of exceptions known at the moment are extracts; // where their second (immediate) operand is not added. Since; // immediates do not affect scheduler behavior this is considered; // okay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Testability,assert,assertion,60,// Since vectorization tree is being built recursively this assertion; // ensures that the tree entry has all operands set before reaching; // this code. Couple of exceptions known at the moment are extracts; // where their second (immediate) operand is not added. Since; // immediates do not affect scheduler behavior this is considered; // okay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Availability,failure,failure,27,// fake use to avoid build failure when assertions disabled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Safety,avoid,avoid,15,// fake use to avoid build failure when assertions disabled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Testability,assert,assertions,40,// fake use to avoid build failure when assertions disabled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,Security,access,access,107,"// If BundleMember is a stand-alone instruction, no operand reordering; // has taken place, so we directly access its operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Integrability,depend,dependencies,21,// Handle the memory dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Integrability,depend,dependencies,33,"// There are no more unscheduled dependencies after decrementing,; // so we can put the dependent instruction into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Integrability,depend,dependent,88,"// There are no more unscheduled dependencies after decrementing,; // so we can put the dependent instruction into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Integrability,depend,dependencies,22,// Handle the control dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Integrability,depend,dependencies,33,"// There are no more unscheduled dependencies after decrementing,; // so we can put the dependent instruction into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Integrability,depend,dependent,88,"// There are no more unscheduled dependencies after decrementing,; // so we can put the dependent instruction into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:64,Energy Efficiency,schedul,scheduling,64,/// Put all instructions into the ReadyList which are ready for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Energy Efficiency,Schedul,ScheduleData,28,/// Build a bundle from the ScheduleData nodes corresponding to the; /// scalar instruction for each lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:46,Energy Efficiency,schedul,scheduled,46,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:192,Energy Efficiency,schedul,scheduling,192,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:290,Energy Efficiency,schedul,scheduled,290,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:81,Integrability,depend,dependencies,81,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates schedule data chunk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,schedule,14,/// Allocates schedule data chunk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Energy Efficiency,schedul,scheduling,16,/// Extends the scheduling region so that V is inside the region.; /// \returns true if the region size is within the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Modifiability,Extend,Extends,4,/// Extends the scheduling region so that V is inside the region.; /// \returns true if the region size is within the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Energy Efficiency,Schedul,ScheduleData,19,/// Initialize the ScheduleData structures for new instructions in the; /// scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:76,Energy Efficiency,schedul,scheduling,76,/// Initialize the ScheduleData structures for new instructions in the; /// scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Deployability,Update,Updates,4,/// Updates the dependency information of a bundle and of all instructions/; /// bundles which depend on the original bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Integrability,depend,dependency,16,/// Updates the dependency information of a bundle and of all instructions/; /// bundles which depend on the original bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:95,Integrability,depend,depend,95,/// Updates the dependency information of a bundle and of all instructions/; /// bundles which depend on the original bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Energy Efficiency,schedul,scheduling,32,/// Sets all instruction in the scheduling region to un-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,Energy Efficiency,schedul,scheduled,56,/// Sets all instruction in the scheduling region to un-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Energy Efficiency,Schedul,ScheduleData,33,/// Simple memory allocation for ScheduleData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Simpl,Simple,4,/// Simple memory allocation for ScheduleData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,Schedul,ScheduleData,18,/// The size of a ScheduleData array in ScheduleDataChunks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Energy Efficiency,Schedul,ScheduleDataChunks,40,/// The size of a ScheduleData array in ScheduleDataChunks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:81,Energy Efficiency,Schedul,ScheduleDataChunks,81,"/// The allocator position in the current chunk, which is the last entry; /// of ScheduleDataChunks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Energy Efficiency,Schedul,ScheduleData,13,"/// Attaches ScheduleData to Instruction.; /// Note that the mapping survives during all vectorization iterations, i.e.; /// ScheduleData structures are recycled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:125,Energy Efficiency,Schedul,ScheduleData,125,"/// Attaches ScheduleData to Instruction.; /// Note that the mapping survives during all vectorization iterations, i.e.; /// ScheduleData structures are recycled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Energy Efficiency,Schedul,ScheduleData,13,/// Attaches ScheduleData to Instruction with the leading key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,Energy Efficiency,schedul,scheduling,23,/// The ready-list for scheduling (only used for the dry-run).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Energy Efficiency,schedul,scheduling,33,/// The first instruction of the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Energy Efficiency,schedul,scheduling,38,/// The first instruction _after_ the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Energy Efficiency,schedul,scheduling,50,/// The first memory accessing instruction in the scheduling region; /// (can be null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Security,access,accessing,21,/// The first memory accessing instruction in the scheduling region; /// (can be null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:49,Energy Efficiency,schedul,scheduling,49,/// The last memory accessing instruction in the scheduling region; /// (can be null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Security,access,accessing,20,/// The last memory accessing instruction in the scheduling region; /// (can be null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:59,Energy Efficiency,schedul,scheduling,59,/// Is there an llvm.stacksave or llvm.stackrestore in the scheduling; /// region? Used to optimize the dependence calculation for the; /// common case where there isn't.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:104,Integrability,depend,dependence,104,/// Is there an llvm.stacksave or llvm.stackrestore in the scheduling; /// region? Used to optimize the dependence calculation for the; /// common case where there isn't.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:91,Performance,optimiz,optimize,91,/// Is there an llvm.stacksave or llvm.stackrestore in the scheduling; /// region? Used to optimize the dependence calculation for the; /// common case where there isn't.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Energy Efficiency,schedul,scheduling,28,/// The current size of the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Energy Efficiency,schedul,scheduling,37,/// The maximum size allowed for the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,schedul,scheduling,18,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:116,Energy Efficiency,Schedul,ScheduleData,116,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:178,Energy Efficiency,Schedul,SchedulingRegionID,178,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:230,Energy Efficiency,Schedul,SchedulingRegionID,230,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:252,Energy Efficiency,Schedul,ScheduleData,252,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Energy Efficiency,schedul,scheduling,24,"/// Performs the ""real"" scheduling. Done before vectorization is actually; /// performed in a basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Performance,Perform,Performs,4,"/// Performs the ""real"" scheduling. Done before vectorization is actually; /// performed in a basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:79,Performance,perform,performed,79,"/// Performs the ""real"" scheduling. Done before vectorization is actually; /// performed in a basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Energy Efficiency,schedul,scheduling,35,/// List of users to ignore during scheduling and that don't need extracting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:256,Modifiability,extend,extended,256,"/// A map of scalar integer values to the smallest bit width with which they; /// can legally be represented. The values map to (width, signed) pairs,; /// where ""width"" indicates the minimum bit width and ""signed"" is True if the; /// value must be signed-extended, rather than zero-extended, back to its; /// original width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Modifiability,extend,extended,283,"/// A map of scalar integer values to the smallest bit width with which they; /// can legally be represented. The values map to (width, signed) pairs,; /// where ""width"" indicates the minimum bit width and ""signed"" is True if the; /// value must be signed-extended, rather than zero-extended, back to its; /// original width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Availability,mask,mask,33,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:64,Availability,Mask,Mask,64,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:103,Availability,mask,mask,103,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:174,Availability,mask,mask,174,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:211,Availability,Mask,Mask,211,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,Availability,Mask,Mask,58,"/// Reorders the given \p Order according to the given \p Mask. \p Order - is; /// the original order of the scalars. Procedure transforms the provided order; /// in accordance with the given \p Mask. If the resulting \p Order is just an; /// identity order, \p Order is cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:195,Availability,Mask,Mask,195,"/// Reorders the given \p Order according to the given \p Mask. \p Order - is; /// the original order of the scalars. Procedure transforms the provided order; /// in accordance with the given \p Mask. If the resulting \p Order is just an; /// identity order, \p Order is cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:271,Usability,clear,cleared,271,"/// Reorders the given \p Order according to the given \p Mask. \p Order - is; /// the original order of the scalars. Procedure transforms the provided order; /// in accordance with the given \p Mask. If the resulting \p Order is just an; /// identity order, \p Order is cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Performance,load,loads,42,/// Tracks the state we can represent the loads in the given sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Performance,load,loads,33,"/// Checks if the given array of loads can be represented as a vectorized,; /// scatter or just simple gather.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:96,Usability,simpl,simple,96,"/// Checks if the given array of loads can be represented as a vectorized,; /// scatter or just simple gather.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,load,load,27,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Performance,load,load,38,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Performance,load,load,75,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Performance,load,loads,121,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:231,Performance,load,loading,231,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Performance,load,loads,283,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Performance,load,loads,17,// Make sure all loads in the bundle are simple - we can't vectorize; // atomic or volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:92,Performance,load,loads,92,// Make sure all loads in the bundle are simple - we can't vectorize; // atomic or volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,Usability,simpl,simple,41,// Make sure all loads in the bundle are simple - we can't vectorize; // atomic or volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:25,Performance,load,loads,25,// Check that the sorted loads are consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Security,access,access,33,// Simple check if not a strided access - clear order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Simpl,Simple,3,// Simple check if not a strided access - clear order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Usability,clear,clear,42,// Simple check if not a strided access - clear order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,Energy Efficiency,allocate,allocated,107,// For each of the bases sort the pointers by Offset and check if any of the; // base become consecutively allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:96,Availability,mask,mask,96,"// Check if reuse shuffle indices can be improved by reordering.; // For this, check that reuse mask is ""clustered"", i.e. each scalar values; // is used once in each submask of size <number_of_scalars>.; // Example: 4 scalar values.; // ReuseShuffleIndices mask: 0, 1, 2, 3, 3, 2, 0, 1 - clustered.; // 0, 1, 2, 3, 3, 3, 1, 0 - not clustered, because; // element 3 is used twice in the second submask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:257,Availability,mask,mask,257,"// Check if reuse shuffle indices can be improved by reordering.; // For this, check that reuse mask is ""clustered"", i.e. each scalar values; // is used once in each submask of size <number_of_scalars>.; // Example: 4 scalar values.; // ReuseShuffleIndices mask: 0, 1, 2, 3, 3, 2, 0, 1 - clustered.; // 0, 1, 2, 3, 3, 3, 1, 0 - not clustered, because; // element 3 is used twice in the second submask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Availability,mask,mask,24,"/// Checks if the given mask is a ""clustered"" mask with the same clusters of; /// size \p Sz, which are not identity submasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:46,Availability,mask,mask,46,"/// Checks if the given mask is a ""clustered"" mask with the same clusters of; /// size \p Sz, which are not identity submasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Availability,mask,mask,18,// Reorder reuses mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Availability,mask,mask,60,// Clear reorder since it is going to be applied to the new mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear reorder since it is going to be applied to the new mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,mask,19,// Fill the reuses mask with the identity submasks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Availability,error,error,32,// FIXME: Workaround for syntax error reported by MSVC buildbots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:89,Performance,load,loads,89,"// Find all reorderable nodes with the given VF.; // Currently the are vectorized stores,loads,extracts + some gathering of; // extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Availability,mask,mask,14,// The opcode mask selects between the two opcodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:48,Modifiability,extend,extend,48,"// No need to reorder this nodes, still need to extend and to use shuffle,; // just need to merge reordering shuffle and the reuse shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,Availability,mask,mask,29,"// Stores actually store the mask, not the order, need to invert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:30,Availability,mask,masks,30,// Need to reorder the reuses masks of the operands with smaller VF to; // be able to find the match between the graph nodes and scalar; // operands of the given node during vectorization/cost estimation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update ordering of the operands with the smaller VF than the given; // one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:52,Performance,load,loads,52,"// Build correct orders for extract{element,value}, loads and; // stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:84,Safety,avoid,avoid,84,// Apply reversed order to keep the original ordering of the reused; // elements to avoid extra reorder indices shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:284,Availability,mask,mask,284,"// Add ScatterVectorize nodes to the list of operands, where just; // reordering of the scalars is required. Similar to the gathers, so; // simply add to the list of gathered ops.; // If there are reused scalars, process this node as a regular vectorize; // node, just reorder reuses mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:140,Usability,simpl,simply,140,"// Add ScatterVectorize nodes to the list of operands, where just; // reordering of the scalars is required. Similar to the gathers, so; // simply add to the list of gathered ops.; // If there are reused scalars, process this node as a regular vectorize; // node, just reorder reuses mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:87,Performance,load,loads,87,"// Find all reorderable leaf nodes with the given VF.; // Currently the are vectorized loads,extracts without alternate operands +; // some gathering of extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,Integrability,depend,dependency,124,// Build a map between user nodes and their operands order to speedup; // search. The graph currently does not provide this dependency directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,Availability,mask,mask,29,"// Stores actually store the mask, not the order, need to invert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Safety,avoid,avoid,86,// Check if users allow reordering.; // Currently look up just 1 level of operands to avoid increase of; // the compile time.; // Profitable to reorder if definitely more operands allow; // reordering rather than those with natural order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:70,Modifiability,Extend,Extend,70,// For now just keep one store per pointer object per lane.; // TODO: Extend this to support multiple stores per pointer per lane,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:131,Safety,avoid,avoid,131,"// We check whether the stores in StoreVec can form a vector by sorting them; // and checking whether they are consecutive.; // To avoid calling getPointersDiff() while sorting we create a vector of; // pairs {store, offset from first} and sort this instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:93,Energy Efficiency,schedul,scheduling,93,"/// \return true if the specified list of values has only one instruction that; /// requires scheduling, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:109,Safety,detect,detection,109,/// Generates key/subkey pair for the given value to provide effective sorting; /// of the values and better detection of the vectorizable values sequences. The; /// keys/subkeys can be used for better sorting of the values themselves (keys); /// and in values subgroups (subkeys).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Performance,load,loads,12,// Sort the loads by the distance between the pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,load,load,27,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Performance,load,load,38,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Performance,load,load,75,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Performance,load,loads,121,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:231,Performance,load,loading,231,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Performance,load,loads,283,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Energy Efficiency,allocate,allocated,42,"// Avoid types that are padded when being allocated as scalars, while; // being packed together in a vector (such as i1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Safety,Avoid,Avoid,3,"// Avoid types that are padded when being allocated as scalars, while; // being packed together in a vector (such as i1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Usability,simpl,simple,42,// Make sure all stores in the bundle are simple - we can't vectorize; // atomic or volatile stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Performance,load,load,60,"// Gather if we hit the RecursionMaxDepth, unless this is a load (or z/sext of; // a load), in which case peek through to include it in the tree, without; // ballooning over-budget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:85,Performance,load,load,85,"// Gather if we hit the RecursionMaxDepth, unless this is a load (or z/sext of; // a load), in which case peek through to include it in the tree, without; // ballooning over-budget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Performance,scalab,scalable,16,// Don't handle scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:62,Usability,simpl,simple,62,"// If all of the operands are identical or constant we have a simple solution.; // If we deal with insert/extract instructions, they all must have constant; // indices, otherwise we should gather them, not try to vectorize.; // If alternate op node with 2 elements with gathered operands - do not; // vectorize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:80,Energy Efficiency,schedul,schedulable,80,// Check that all of the users of the scalars that we want to vectorize are; // schedulable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,Energy Efficiency,schedul,scheduling,118,// Don't go into unreachable blocks. They may contain instructions with; // dependency cycles which confuse the final scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:76,Integrability,depend,dependency,76,// Don't go into unreachable blocks. They may contain instructions with; // dependency cycles which confuse the final scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:186,Safety,avoid,avoid,186,"// Don't go into catchswitch blocks, which can happen with PHIs.; // Such blocks can only have PHIs and the catchswitch. There is no; // place to insert a shuffle if we need to, so just avoid that issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform specific checks for each particular instruction kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Safety,avoid,avoid,35,// Keeps the reordered operands to avoid code duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Modifiability,extend,extending,86,"// This is a special case, as it does not gather, but at the same time; // we are not extending buildTree_rec() towards the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Modifiability,extend,extending,86,"// This is a special case, as it does not gather, but at the same time; // we are not extending buildTree_rec() towards the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,load,load,27,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Performance,load,load,38,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Performance,load,load,75,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Performance,load,loads,121,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:231,Performance,load,loading,231,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Performance,load,loads,283,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Performance,load,loads,12,// Original loads are consecutive and does not require reordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:48,Availability,mask,masked,48,// Vectorizing non-consecutive loads with `llvm.masked.gather`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Performance,load,loads,31,// Vectorizing non-consecutive loads with `llvm.masked.gather`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:48,Availability,mask,masked,48,// Vectorizing non-consecutive loads with `llvm.masked.gather`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Performance,load,loads,31,// Vectorizing non-consecutive loads with `llvm.masked.gather`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,Safety,avoid,avoid,73,// Need to cast all indices to the same type before vectorization to; // avoid crash.; // Required to be able to find correct matches between different gather; // nodes and reuse the vectorized values rather than trying to gather them; // again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Performance,load,load,12,// Check if load can be rewritten as load of vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Performance,load,load,37,// Check if load can be rewritten as load of vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:207,Security,access,access,207,"// Assign to all items the initial value E + 1 so we can check if the extract; // instruction index was used already.; // Also, later we can check that all the indices are used and we have a; // consecutive access in the extract instructions, by checking that no; // element of CurrentOrder still has value E + 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Availability,mask,mask,18,/// Checks if the mask is an identity mask.; /// \param IsStrict if is true the function returns false if mask size does; /// not match vector size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Availability,mask,mask,38,/// Checks if the mask is an identity mask.; /// \param IsStrict if is true the function returns false if mask size does; /// not match vector size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:106,Availability,mask,mask,106,/// Checks if the mask is an identity mask.; /// \param IsStrict if is true the function returns false if mask size does; /// not match vector size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Availability,mask,masks,33,"/// Tries to combine 2 different masks into single one.; /// \param LocalVF Vector length of the permuted input vector. \p Mask may; /// change the size of the vector, \p LocalVF is the original size of the; /// shuffled vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:123,Availability,Mask,Mask,123,"/// Tries to combine 2 different masks into single one.; /// \param LocalVF Vector length of the permuted input vector. \p Mask may; /// change the size of the vector, \p LocalVF is the original size of the; /// shuffled vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:192,Availability,mask,mask,192,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:424,Availability,mask,mask,424,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:515,Availability,mask,mask,515,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:643,Availability,mask,mask,643,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:900,Availability,mask,mask,900,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:991,Availability,mask,mask,991,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1190,Availability,Mask,Mask,1190,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1295,Availability,Mask,Mask,1295,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1310,Availability,mask,mask,1310,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1415,Deployability,update,updated,1415,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Energy Efficiency,reduce,reduce,37,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1078,Usability,simpl,simple,1078,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Availability,mask,mask,38,"// Remember the identity or broadcast mask, if it is not a resizing; // shuffle. If no better candidates are found, this Op and Mask will be; // used in the final shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:128,Availability,Mask,Mask,128,"// Remember the identity or broadcast mask, if it is not a resizing; // shuffle. If no better candidates are found, this Op and Mask will be; // used in the final shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Availability,mask,mask,17,// Store current mask in the IdentityMask so later we did not lost; // this info if IdentityOp is selected as the best candidate for the; // permutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,mask,26,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,Availability,Mask,Mask,83,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:199,Availability,mask,mask,199,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:234,Availability,mask,mask,234,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:314,Availability,mask,mask,314,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:444,Availability,mask,mask,444,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:480,Availability,mask,mask,480,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,Availability,mask,mask,10,// Update mask and mark undef elems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update mask and mark undef elems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear known poison elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:126,Availability,Mask,Mask,126,"// namespace; /// Returns the cost of the shuffle instructions with the given \p Kind, vector; /// type \p Tp and optional \p Mask. Adds SLP-specifc cost estimation for insert; /// subvector pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,masks,19,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:346,Energy Efficiency,reduce,reduce,346,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Performance,load,loads,37,"// Improve gather cost for gather of loads, if we can group some of the; // loads into vector loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:76,Performance,load,loads,76,"// Improve gather cost for gather of loads, if we can group some of the; // loads into vector loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Performance,load,loads,94,"// Improve gather cost for gather of loads, if we can group some of the; // loads into vector loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,Performance,load,loads,23,// Mark the vectorized loads so that we don't vectorize them; // again.; // TODO: better handling of loads with reorders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:101,Performance,load,loads,101,// Mark the vectorized loads so that we don't vectorize them; // again.; // TODO: better handling of loads with reorders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,Performance,load,loads,29,// Get the cost for gathered loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:34,Performance,load,loads,34,// Exclude potentially vectorized loads from list of gathered; // scalars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,load,loads,27,// The cost for vectorized loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:2,Modifiability,Variab,VariableMask,2,/*VariableMask=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:2,Availability,Mask,Mask,2,/*Mask=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Availability,mask,mask,15,/// Transforms mask \p CommonMask per given \p Mask to make proper set after; /// shuffle emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,Mask,Mask,47,/// Transforms mask \p CommonMask per given \p Mask to make proper set after; /// shuffle emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:80,Availability,mask,mask,80,"/// Adds the cost of reshuffling \p E1 and \p E2 (if present), using given; /// mask \p Mask, register number \p Part, that includes \p SliceSize; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Availability,Mask,Mask,88,"/// Adds the cost of reshuffling \p E1 and \p E2 (if present), using given; /// mask \p Mask, register number \p Part, that includes \p SliceSize; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:187,Availability,Mask,Mask,187,"// Delay the cost estimation if the same nodes are reshuffling.; // If we already requested the cost of reshuffling of E1 and E2 before, no; // need to estimate another cost with the sub-Mask, instead include this; // sub-Mask into the CommonMask to estimate it later and avoid double cost; // estimation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:222,Availability,Mask,Mask,222,"// Delay the cost estimation if the same nodes are reshuffling.; // If we already requested the cost of reshuffling of E1 and E2 before, no; // need to estimate another cost with the sub-Mask, instead include this; // sub-Mask into the CommonMask to estimate it later and avoid double cost; // estimation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:272,Safety,avoid,avoid,272,"// Delay the cost estimation if the same nodes are reshuffling.; // If we already requested the cost of reshuffling of E1 and E2 before, no; // need to estimate another cost with the sub-Mask, instead include this; // sub-Mask into the CommonMask to estimate it later and avoid double cost; // estimation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,Availability,mask,mask,90,// Found non-matching nodes - need to estimate the cost for the matched; // and transform mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Availability,mask,mask,9,// Empty mask or identity mask are free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,mask,26,// Empty mask or identity mask are free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Availability,mask,mask,9,// Empty mask or identity mask are free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,mask,26,// Empty mask or identity mask are free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:237,Safety,avoid,avoid,237,"// If all users of instruction are going to be vectorized and this; // instruction itself is not going to be vectorized, consider this; // instruction as dead and remove its cost from the final cost of the; // vectorized tree.; // Also, avoid adjusting the cost for extractelements with multiple uses; // in different graph entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:79,Integrability,depend,dependency,79,/// Checks if the specified entry \p E needs to be delayed because of its; /// dependency nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Availability,mask,mask,33,/// Adds 2 input vectors and the mask for their shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Availability,mask,mask,42,/// Adds another one input vector and the mask for the shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Safety,avoid,avoid,32,// FIXME: Need to find a way to avoid use of getNullValue here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:2,Modifiability,Extend,ExtendingManyInputs,2,/*ExtendingManyInputs=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,Deployability,update,update,58,"// If we have computed a smaller type for the expression, update VecTy so; // that the costs will be accurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Availability,mask,mask,38,// For stores the order is actually a mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:146,Performance,load,loads,146,// Here we differentiate two cases: (1) when Ptrs represent a regular; // vectorization tree node (as they are pointer arguments of scattered; // loads) or (2) when Ptrs are the arguments of loads or stores being; // vectorized as plane wide unit-stride load/store since all the; // loads/stores are known to be from/to adjacent locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:191,Performance,load,loads,191,// Here we differentiate two cases: (1) when Ptrs represent a regular; // vectorization tree node (as they are pointer arguments of scattered; // loads) or (2) when Ptrs are the arguments of loads or stores being; // vectorized as plane wide unit-stride load/store since all the; // loads/stores are known to be from/to adjacent locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:254,Performance,load,load,254,// Here we differentiate two cases: (1) when Ptrs represent a regular; // vectorization tree node (as they are pointer arguments of scattered; // loads) or (2) when Ptrs are the arguments of loads or stores being; // vectorized as plane wide unit-stride load/store since all the; // loads/stores are known to be from/to adjacent locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Performance,load,loads,283,// Here we differentiate two cases: (1) when Ptrs represent a regular; // vectorization tree node (as they are pointer arguments of scattered; // loads) or (2) when Ptrs are the arguments of loads or stores being; // vectorized as plane wide unit-stride load/store since all the; // loads/stores are known to be from/to adjacent locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,Performance,load,load,83,// Case 2: estimate costs for pointer related costs when vectorizing to; // a wide load/store.; // Scalar cost is estimated as a set of pointers with known relationship; // between them.; // For vector code we will use BasePtr as argument for the wide load/store; // but we also need to account all the instructions which are going to; // stay in vectorized code due to uses outside of these scalar; // loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:252,Performance,load,load,252,// Case 2: estimate costs for pointer related costs when vectorizing to; // a wide load/store.; // Scalar cost is estimated as a set of pointers with known relationship; // between them.; // For vector code we will use BasePtr as argument for the wide load/store; // but we also need to account all the instructions which are going to; // stay in vectorized code due to uses outside of these scalar; // loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:403,Performance,load,loads,403,// Case 2: estimate costs for pointer related costs when vectorizing to; // a wide load/store.; // Scalar cost is estimated as a set of pointers with known relationship; // between them.; // For vector code we will use BasePtr as argument for the wide load/store; // but we also need to account all the instructions which are going to; // stay in vectorized code due to uses outside of these scalar; // loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:7,Usability,simpl,simplicity,7,// For simplicity assume Ptr to stay in vectorized code if it's not a; // GEP instruction. We don't care since it's cost considered free.; // TODO: We should check for any uses outside of vectorizable tree; // rather than just single use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,Availability,mask,masked,83,// Case 1: Ptrs are the arguments of loads that we are going to transform; // into masked gather load intrinsic.; // All the scalar GEPs will be removed as a result of vectorization.; // For any external uses of some lanes extract element instructions will; // be generated (which cost is estimated separately).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Performance,load,loads,37,// Case 1: Ptrs are the arguments of loads that we are going to transform; // into masked gather load intrinsic.; // All the scalar GEPs will be removed as a result of vectorization.; // For any external uses of some lanes extract element instructions will; // be generated (which cost is estimated separately).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:97,Performance,load,load,97,// Case 1: Ptrs are the arguments of loads that we are going to transform; // into masked gather load intrinsic.; // All the scalar GEPs will be removed as a result of vectorization.; // For any external uses of some lanes extract element instructions will; // be generated (which cost is estimated separately).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Safety,safe,safely,19,"// Check if we can safely insert a subvector. If it is not possible, just; // generate a whole-sized vector and shuffle the source vector and the new; // subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:39,Availability,mask,mask,39,// Align OffsetBeg to generate correct mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:2,Modifiability,Variab,VariableMask,2,/*VariableMask=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,masked,26,// If this node generates masked gather load then it is not a terminal node.; // Hence address operand cost is estimated separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Performance,load,load,40,// If this node generates masked gather load then it is not a terminal node.; // Hence address operand cost is estimated separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Availability,error,error,32,// FIXME: Workaround for syntax error reported by MSVC buildbots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Usability,clear,clear,11,// Need to clear CommonCost since the final shuffle cost is included into; // vector cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Availability,mask,mask,14,// The opcode mask selects between the two opcodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Modifiability,extend,extended,28,// Check if the input is an extended load of the required or/shift expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Performance,load,load,37,// Check if the input is an extended load of the required or/shift expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:204,Energy Efficiency,reduce,reduce,204,"// Require that the total load bit width is a legal integer type.; // For example, <8 x i8> --> i64 is a legal integer on a 64-bit target.; // But <16 x i8> --> i128 is not, so the backend probably can't reduce it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Performance,load,load,26,"// Require that the total load bit width is a legal integer type.; // For example, <8 x i8> --> i64 is a legal integer on a 64-bit target.; // But <16 x i8> --> i128 is not, so the backend probably can't reduce it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:77,Performance,load,load,77,// Everything matched - assume that we can fold the whole sequence using; // load combining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:92,Performance,load,load-combined,92,// Peek through a final sequence of stores and check if all operations are; // likely to be load-combined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update LiveValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Availability,mask,masks,60,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:144,Availability,mask,masks,144,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:264,Availability,mask,mask,264,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:378,Availability,mask,masks,378,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:541,Availability,mask,mask,541,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:604,Availability,mask,mask,604,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:641,Availability,mask,mask,641,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:662,Availability,mask,masks,662,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:748,Availability,mask,masks,748,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:70,Performance,perform,performs,70,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:296,Performance,perform,perform,296,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:547,Performance,perform,perform,547,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:678,Performance,perform,perform,678,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:103,Availability,mask,mask,103,"// Base is undef and only 1 vector is shuffled - perform the action only for; // single vector, if the mask is not the identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:128,Availability,mask,mask,128,"// Base is undef and only 1 vector is shuffled - perform the action only for; // single vector, if the mask is not the identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:49,Performance,perform,perform,49,"// Base is undef and only 1 vector is shuffled - perform the action only for; // single vector, if the mask is not the identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Availability,mask,mask,12,// Identity mask is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:57,Performance,perform,perform,57,"// Base is undef and at least 2 input vectors shuffled - perform 2 vectors; // shuffles step by step, combining shuffle between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,mask,masks,47,// Perform requested actions for the remaining masks/vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform requested actions for the remaining masks/vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,Safety,detect,detect,83,"// If found user is an insertelement, do not calculate extract cost but try; // to detect it as a final shuffled/identity match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Availability,mask,mask,13,// Build the mask for the vectorized insertelement instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Modifiability,rewrite,rewrite,17,"// If we plan to rewrite the tree in a smaller type, we will need to sign; // extend the extracted value back to the original type. Here, we account; // for the extract and the added cost of the sign extend if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:78,Modifiability,extend,extend,78,"// If we plan to rewrite the tree in a smaller type, we will need to sign; // extend the extracted value back to the original type. Here, we account; // for the extract and the added cost of the sign extend if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:200,Modifiability,extend,extend,200,"// If we plan to rewrite the tree in a smaller type, we will need to sign; // extend the extracted value back to the original type. Here, we account; // for the extract and the added cost of the sign extend if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:7,Energy Efficiency,reduce,reduced,7,"// Add reduced value cost, if resized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,Safety,detect,detected,173,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt was; /// successful, the matched scalars are replaced by poison values in \p VL for; /// future analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Performance,perform,perform,22,// Check if better to perform a shuffle of 2 vectors or just of a single; // vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Availability,mask,mask,31,"// Restore unused scalars from mask, if some of the extractelements were not; // selected for shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,Safety,detect,detected,173,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt was; /// successful, the matched scalars are replaced by poison values in \p VL for; /// future analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:389,Energy Efficiency,schedul,scheduled,389,"// Argument InsertPt is an instruction where vector code for some other; // tree entry (one that shares one or more scalars with TE) is going to be; // generated. This lambda returns true if insertion point of vector code; // for the TE dominates that point (otherwise dependency is the other way; // around). The other node is not limited to be of a gather kind. Gather; // nodes are not scheduled and their vector code is inserted before their; // first user. If user is PHI, that is supposed to be at the end of a; // predecessor block. Otherwise it is the last instruction among scalars of; // the user node. So, instead of checking dependency between instructions; // themselves, we check dependency between their insertion points for vector; // code (since each scalar instruction ends up as a lane of a vector; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:269,Integrability,depend,dependency,269,"// Argument InsertPt is an instruction where vector code for some other; // tree entry (one that shares one or more scalars with TE) is going to be; // generated. This lambda returns true if insertion point of vector code; // for the TE dominates that point (otherwise dependency is the other way; // around). The other node is not limited to be of a gather kind. Gather; // nodes are not scheduled and their vector code is inserted before their; // first user. If user is PHI, that is supposed to be at the end of a; // predecessor block. Otherwise it is the last instruction among scalars of; // the user node. So, instead of checking dependency between instructions; // themselves, we check dependency between their insertion points for vector; // code (since each scalar instruction ends up as a lane of a vector; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:637,Integrability,depend,dependency,637,"// Argument InsertPt is an instruction where vector code for some other; // tree entry (one that shares one or more scalars with TE) is going to be; // generated. This lambda returns true if insertion point of vector code; // for the TE dominates that point (otherwise dependency is the other way; // around). The other node is not limited to be of a gather kind. Gather; // nodes are not scheduled and their vector code is inserted before their; // first user. If user is PHI, that is supposed to be at the end of a; // predecessor block. Otherwise it is the last instruction among scalars of; // the user node. So, instead of checking dependency between instructions; // themselves, we check dependency between their insertion points for vector; // code (since each scalar instruction ends up as a lane of a vector; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:694,Integrability,depend,dependency,694,"// Argument InsertPt is an instruction where vector code for some other; // tree entry (one that shares one or more scalars with TE) is going to be; // generated. This lambda returns true if insertion point of vector code; // for the TE dominates that point (otherwise dependency is the other way; // around). The other node is not limited to be of a gather kind. Gather; // nodes are not scheduled and their vector code is inserted before their; // first user. If user is PHI, that is supposed to be at the end of a; // predecessor block. Otherwise it is the last instruction among scalars of; // the user node. So, instead of checking dependency between instructions; // themselves, we check dependency between their insertion points for vector; // code (since each scalar instruction ends up as a lane of a vector; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:95,Integrability,depend,depend,95,// If the user instruction is used for some reason in different; // vectorized nodes - make it depend on index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Integrability,depend,depends,88,"// Check if the user node of the TE comes after user node of TEPtr,; // otherwise TEPtr depends on TE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Safety,avoid,avoid,21,// Keep the order to avoid non-determinism.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear undef scalars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Safety,avoid,avoid,35,// Keep the order of tree nodes to avoid non-determinism.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Safety,avoid,avoid,27,"// Same, keep the order to avoid non-determinism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,mask,19,// Build a shuffle mask for better cost estimation and vector emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:205,Availability,mask,mask,205,"// Fix the entry number for the given scalar. If it is the first entry, set; // Pair.first to 0, otherwise to 1 (currently select at max 2 nodes).; // These indices are used when calculating final shuffle mask as the vector; // offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,mask,19,"// Build the final mask, check for the identity shuffle, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Availability,mask,mask,27,// Clear the corresponding mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear the corresponding mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear undef scalars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform operand reordering on the instructions in VL and return the reordered; // operands in Left and Right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:91,Energy Efficiency,schedul,scheduled,91,// Set the insert point to the beginning of the basic block if the entry; // should not be scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:77,Energy Efficiency,schedul,scheduled,77,"// Find the last instruction. The common case should be that BB has been; // scheduled, and the last instruction is VL.back(). So we start with; // VL.back() and iterate over schedule data until we reach the end of the; // bundle. The end of the bundle is marked by null ScheduleData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:175,Energy Efficiency,schedul,schedule,175,"// Find the last instruction. The common case should be that BB has been; // scheduled, and the last instruction is VL.back(). So we start with; // VL.back() and iterate over schedule data until we reach the end of the; // bundle. The end of the bundle is marked by null ScheduleData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:271,Energy Efficiency,Schedul,ScheduleData,271,"// Find the last instruction. The common case should be that BB has been; // scheduled, and the last instruction is VL.back(). So we start with; // VL.back() and iterate over schedule data until we reach the end of the; // bundle. The end of the bundle is marked by null ScheduleData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:132,Availability,avail,available,132,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:119,Energy Efficiency,Schedul,ScheduleData,119,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:324,Energy Efficiency,Schedul,ScheduleData,324,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:359,Energy Efficiency,schedul,scheduling,359,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:199,Safety,abort,aborts,199,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:181,Performance,optimiz,optimize,181,// List of instructions/lanes from current block and/or the blocks which are; // part of the current loop. These instructions will be inserted at the end to; // make it possible to optimize loops and hoist invariant instructions out of; // the loops body with better chances for success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,masks,19,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:547,Availability,mask,mask,547,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:779,Availability,mask,mask,779,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1028,Availability,mask,mask,1028,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1285,Availability,mask,mask,1285,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:346,Energy Efficiency,reduce,reduce,346,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Availability,mask,mask,13,/// Combined mask for all applied operands and masks. It is built during; /// analysis and actual emission of shuffle vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,mask,masks,47,/// Combined mask for all applied operands and masks. It is built during; /// analysis and actual emission of shuffle vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:184,Availability,mask,mask,184,"/// List of operands for the shuffle vector instruction. It hold at max 2; /// operands, if the 3rd is going to be added, the first 2 are combined into; /// shuffle with \p CommonMask mask, the first operand sets to be the; /// resulting shuffle and the second operand sets to be the newly added; /// operand. The \p CommonMask is transformed in the proper way after that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Availability,mask,mask,60,/// Creates shufflevector for the 2 operands with the given mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:68,Availability,mask,mask,68,"/// Creates permutation of the single vector operand with the given mask, if; /// it is not identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:101,Availability,mask,mask,101,"/// Creates permutation of the single vector operand with the given mask, if; /// it is not identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Availability,mask,mask,15,/// Transforms mask \p CommonMask per given \p Mask to make proper set after; /// shuffle emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,Mask,Mask,47,/// Transforms mask \p CommonMask per given \p Mask to make proper set after; /// shuffle emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,"// Perform multi-register vector shuffle, joining them into a single virtual; // long vector.; // Need to shuffle each part independently and then insert all this parts; // into a long virtual vector register, forming the original vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:79,Integrability,depend,dependency,79,/// Checks if the specified entry \p E needs to be delayed because of its; /// dependency nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:59,Availability,mask,mask,59,/// Adds 2 input vectors (in form of tree entries) and the mask for their; /// shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:61,Availability,mask,mask,61,/// Adds single input vector (in form of tree entry) and the mask for its; /// shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Availability,mask,mask,33,/// Adds 2 input vectors and the mask for their shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Availability,mask,mask,42,/// Adds another one input vector and the mask for the shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Availability,mask,mask,42,/// Adds another one input vector and the mask for the shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:139,Availability,mask,mask,139,/// Finalize emission of the shuffles.; /// \param Action the action (if any) to be performed before final applying of; /// the \p ExtMask mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:84,Performance,perform,performed,84,/// Finalize emission of the shuffles.; /// \param Action the action (if any) to be performed before final applying of; /// the \p ExtMask mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:171,Availability,mask,mask,171,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:370,Energy Efficiency,adapt,adapt,370,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:574,Energy Efficiency,reduce,reduced,574,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:370,Modifiability,adapt,adapt,370,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Deployability,update,update,11,"// Need to update the operand gather node, if actually the operand is not a; // vectorized node, but the buildvector/gather node, which matches one of; // the vectorized nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Availability,mask,mask,11,// Build a mask out of the reorder indices and reorder scalars per this; // mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:76,Availability,mask,mask,76,// Build a mask out of the reorder indices and reorder scalars per this; // mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Availability,mask,mask,15,// Restore the mask for previous partially matched values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Usability,simpl,simple,50,"// For undef values, try to replace them with the simple broadcast.; // We can do it if the broadcasted value is guaranteed to be; // non-poisonous, or by freezing the incoming scalar value first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,Availability,mask,mask,43,"// Replace the undef by the poison, in the mask it is replaced by; // non-poisoned scalar already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:52,Availability,mask,mask,52,// Generate constants for final shuffle and build a mask for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:97,Availability,down,down,97,// Loads are inserted at the head of the tree because we don't want to; // sink them all the way down past store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Load,Loads,3,// Loads are inserted at the head of the tree because we don't want to; // sink them all the way down past store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:45,Performance,load,loads,45,// Use the minimum alignment of the gathered loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Availability,mask,mask,35,/// The parent vectors and shuffle mask for the given list of inserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Energy Efficiency,schedul,scheduled,22,// All blocks must be scheduled before any instructions are inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:66,Energy Efficiency,schedul,scheduling,66,"// Clean Entry-to-LastInstruction table. It can be affected after scheduling,; // need to rebuild it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:54,Integrability,depend,dependencies,54,// Postpone emission of PHIs operands to avoid cyclic dependencies issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,Safety,avoid,avoid,41,// Postpone emission of PHIs operands to avoid cyclic dependencies issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:156,Integrability,depend,dependencies,156,"// If user is a PHI node, its vector code have to be inserted right before; // block terminator. Since the node was delayed, there were some unresolved; // dependencies at the moment when stab instruction was emitted. In a case; // when any of these dependencies turn out an operand of another PHI, coming; // from this same block, position of a stab instruction will become invalid.; // The is because source vector that supposed to feed this gather node was; // inserted at the end of the block [after stab instruction]. So we need; // to adjust insertion point again to the end of block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:250,Integrability,depend,dependencies,250,"// If user is a PHI node, its vector code have to be inserted right before; // block terminator. Since the node was delayed, there were some unresolved; // dependencies at the moment when stab instruction was emitted. In a case; // when any of these dependencies turn out an operand of another PHI, coming; // from this same block, position of a stab instruction will become invalid.; // The is because source vector that supposed to feed this gather node was; // inserted at the end of the block [after stab instruction]. So we need; // to adjust insertion point again to the end of block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Testability,stub,stub,15,"// Replace the stub vector node, if it was used before for one of the; // buildvector nodes already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Modifiability,extend,extend,22,"// If necessary, sign-extend or zero-extend ScalarRoot; // to the larger type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Modifiability,extend,extend,37,"// If necessary, sign-extend or zero-extend ScalarRoot; // to the larger type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:152,Deployability,update,update,152,"// If User == nullptr, the Scalar remains as scalar in vectorized; // instructions or is used as extra arg. Generate ExtractElement instruction; // and update the record for this scalar in ExternallyUsedValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Deployability,update,update,15,// Required to update internally referenced instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Availability,mask,mask,13,// Build the mask for the vectorized insertelement instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform shuffling of the vectorize tree entries for better handling of; // external extracts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Availability,mask,mask,32,// Do not create shuffle if the mask is a simple identity; // non-resizing mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Availability,mask,mask,75,// Do not create shuffle if the mask is a simple identity; // non-resizing mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Usability,simpl,simple,42,// Do not create shuffle if the mask is a simple identity; // non-resizing mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Performance,queue,queue,50,// Make a list of all reachable blocks in our CSE queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:161,Availability,mask,mask,161,"// Less defined shuffles can be replaced by the more defined copies.; // Between two shuffles one is less defined if it has the same vector operands; // and its mask indeces are the same as in the first one or undefs. E.g.; // shuffle %0, poison, <0, 0, 0, undef> is less defined than shuffle %0,; // poison, <0, 0, 0, 0>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Availability,mask,mask,32,// Count trailing undefs in the mask to check the final number of used; // registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform O(N^2) search over the gather/shuffle sequences and merge identical; // instructions. TODO: We can further optimize this scan if we split the; // instructions into different buckets based on the insert lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,Performance,optimiz,optimize,118,// Perform O(N^2) search over the gather/shuffle sequences and merge identical; // instructions. TODO: We can further optimize this scan if we split the; // instructions into different buckets based on the insert lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,Energy Efficiency,schedul,scheduling,63,// Groups the instructions to a bundle (which is then a single scheduling entity); // and schedules instructions until the bundle gets ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,Energy Efficiency,schedul,schedules,90,// Groups the instructions to a bundle (which is then a single scheduling entity); // and schedules instructions until the bundle gets ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,schedule,14,"// No need to schedule PHIs, insertelement, extractelement and extractvalue; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:7,Energy Efficiency,schedul,scheduling,7,// The scheduling region got new instructions at the lower end (or it is a; // new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // It is seldom that this needs to be done a second time after adding the; // initial bundle to the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:160,Integrability,depend,dependencies,160,// The scheduling region got new instructions at the lower end (or it is a; // new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // It is seldom that this needs to be done a second time after adding the; // initial bundle to the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,schedule,14,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:184,Energy Efficiency,schedul,schedule,184,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:238,Energy Efficiency,schedul,schedule,238,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Integrability,depend,dependencies,75,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:160,Integrability,depend,dependencies,160,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Energy Efficiency,schedul,scheduling,22,// Make sure that the scheduling region contains all; // instructions of the bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,Energy Efficiency,schedul,scheduling,10,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:321,Energy Efficiency,schedul,scheduling,321,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:163,Integrability,depend,dependencies,163,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:250,Integrability,depend,dependencies,250,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,Energy Efficiency,schedul,scheduled,23,// A bundle member was scheduled as single instruction before and now; // needs to be scheduled as part of the bundle. We just get rid of the; // existing schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Energy Efficiency,schedul,scheduled,86,// A bundle member was scheduled as single instruction before and now; // needs to be scheduled as part of the bundle. We just get rid of the; // existing schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:155,Energy Efficiency,schedul,schedule,155,// A bundle member was scheduled as single instruction before and now; // needs to be scheduled as part of the bundle. We just get rid of the; // existing schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new ScheduleData for the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,Schedul,ScheduleData,18,// Allocate a new ScheduleData for the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Availability,down,down,17,"// Search up and down at the same time, because we don't know if the new; // instruction is above or below the existing scheduling region.; // Ignore debug info (and other ""AssumeLike"" intrinsics) so that's not counted; // against the budget. Otherwise debug info could affect codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:120,Energy Efficiency,schedul,scheduling,120,"// Search up and down at the same time, because we don't know if the new; // instruction is above or below the existing scheduling region.; // Ignore debug info (and other ""AssumeLike"" intrinsics) so that's not counted; // against the budget. Otherwise debug info could affect codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,allocate,allocate,14,// No need to allocate data for non-schedulable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,Energy Efficiency,schedul,schedulable,36,// No need to allocate data for non-schedulable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update the linked list of memory accessing instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,Security,access,accessing,36,// Update the linked list of memory accessing instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Integrability,depend,dependencies,24,// Handle def-use chain dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Integrability,depend,dependend,94,// Any instruction which isn't safe to speculate at the beginning of the; // block is control dependend on any early exit or non-willreturn call; // which proceeds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Safety,safe,safe,31,// Any instruction which isn't safe to speculate at the beginning of the; // block is control dependend on any early exit or non-willreturn call; // which proceeds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Integrability,depend,dependency,11,// Add the dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Integrability,depend,dependent,40,// Everything past here must be control dependent on I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Energy Efficiency,schedul,scheduled,60,"// If we have an inalloc alloca instruction, it needs to be scheduled; // after any preceeding stacksave. We also need to prevent any alloca; // from reordering above a preceeding stackrestore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,Integrability,depend,dependent,41,"// Any allocas past here must be control dependent on I, and I; // must be memory dependend on BundleMember->Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:82,Integrability,depend,dependend,82,"// Any allocas past here must be control dependent on I, and I; // must be memory dependend on BundleMember->Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Integrability,depend,dependency,11,// Add the dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:82,Performance,load,loads,82,"// In addition to the cases handle just above, we need to prevent; // allocas and loads/stores from moving below a stacksave or a; // stackrestore. Avoiding moving allocas below stackrestore is currently; // thought to be conservatism. Moving loads/stores below a stackrestore; // can lead to incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:243,Performance,load,loads,243,"// In addition to the cases handle just above, we need to prevent; // allocas and loads/stores from moving below a stacksave or a; // stackrestore. Avoiding moving allocas below stackrestore is currently; // thought to be conservatism. Moving loads/stores below a stackrestore; // can lead to incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:148,Safety,Avoid,Avoiding,148,"// In addition to the cases handle just above, we need to prevent; // allocas and loads/stores from moving below a stacksave or a; // stackrestore. Avoiding moving allocas below stackrestore is currently; // thought to be conservatism. Moving loads/stores below a stackrestore; // can lead to incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Integrability,depend,dependency,11,// Add the dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Integrability,depend,dependencies,21,// Handle the memory dependencies (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:25,Energy Efficiency,reduce,reduce,25,"// We have two limits to reduce the complexity:; // 1) AliasedCheckLimit: It's a small limit to reduce calls to; // SLP->isAliased (which is the expensive part in this loop).; // 2) MaxMemDepDistance: It's for very large blocks and it aborts; // the whole loop (even if the loop is fast, it's quadratic).; // It's important for the loop break condition (see below) to; // check this limit even between two read-only instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:96,Energy Efficiency,reduce,reduce,96,"// We have two limits to reduce the complexity:; // 1) AliasedCheckLimit: It's a small limit to reduce calls to; // SLP->isAliased (which is the expensive part in this loop).; // 2) MaxMemDepDistance: It's for very large blocks and it aborts; // the whole loop (even if the loop is fast, it's quadratic).; // It's important for the loop break condition (see below) to; // check this limit even between two read-only instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:235,Safety,abort,aborts,235,"// We have two limits to reduce the complexity:; // 1) AliasedCheckLimit: It's a small limit to reduce calls to; // SLP->isAliased (which is the expensive part in this loop).; // 2) MaxMemDepDistance: It's for very large blocks and it aborts; // the whole loop (even if the loop is fast, it's quadratic).; // It's important for the loop break condition (see below) to; // check this limit even between two read-only instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:146,Energy Efficiency,reduce,reduced,146,// We increment the counter only if the locations are aliased; // (instead of counting all alias checks). This gives a better; // balance between reduced runtime and accurate dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:175,Integrability,depend,dependencies,175,// We increment the counter only if the locations are aliased; // (instead of counting all alias checks). This gives a better; // balance between reduced runtime and accurate dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:275,Integrability,depend,dependencies,275,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:372,Integrability,depend,dependencies,372,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:455,Integrability,depend,dependency,455,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:504,Integrability,depend,dependencies,504,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:552,Safety,abort,abort,552,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Energy Efficiency,schedul,scheduling,37,"// A key point - if we got here, pre-scheduling was able to find a valid; // scheduling of the sub-graph of the scheduling window which consists; // of all vector bundles and their transitive users. As such, we do not; // need to reschedule anything *outside of* that subgraph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:77,Energy Efficiency,schedul,scheduling,77,"// A key point - if we got here, pre-scheduling was able to find a valid; // scheduling of the sub-graph of the scheduling window which consists; // of all vector bundles and their transitive users. As such, we do not; // need to reschedule anything *outside of* that subgraph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:112,Energy Efficiency,schedul,scheduling,112,"// A key point - if we got here, pre-scheduling was able to find a valid; // scheduling of the sub-graph of the scheduling window which consists; // of all vector bundles and their transitive users. As such, we do not; // need to reschedule anything *outside of* that subgraph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Energy Efficiency,schedul,scheduling,16,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:142,Energy Efficiency,schedul,schedule,142,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:338,Energy Efficiency,schedul,schedule,338,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:315,Integrability,depend,dependence,315,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Deployability,update,updated,38,// Ensure that all dependency data is updated (for nodes in the sub-graph); // and fill the ready-list with initial instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Integrability,depend,dependency,19,// Ensure that all dependency data is updated (for nodes in the sub-graph); // and fill the ready-list with initial instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,schedul,scheduling,17,"// Do the ""real"" scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Energy Efficiency,schedul,scheduled,12,"// Move the scheduled instruction(s) to their dedicated places, if not; // there yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,schedul,schedulable,18,// Check that all schedulable entities got scheduled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,Energy Efficiency,schedul,scheduled,43,// Check that all schedulable entities got scheduled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Energy Efficiency,schedul,scheduling,19,// Avoid duplicate scheduling of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid duplicate scheduling of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:68,Performance,load,loads,68,"// If V is not a store, we can traverse the expression tree to find loads; // that feed it. The type of the loaded value may indicate a more suitable; // width than V's type. We want to base the vector element size on the width; // of memory operations where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:108,Performance,load,loaded,108,"// If V is not a store, we can traverse the expression tree to find loads; // that feed it. The type of the loaded value may indicate a more suitable; // width than V's type. We want to base the vector element size on the width; // of memory operations where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,Performance,load,loads,63,"// Traverse the expression tree in bottom-up order looking for loads. If we; // encounter an instruction we don't yet handle, we give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,Deployability,update,update,41,"// If the current instruction is a load, update MaxWidth to reflect the; // width of the loaded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Performance,load,load,35,"// If the current instruction is a load, update MaxWidth to reflect the; // width of the loaded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:89,Performance,load,loaded,89,"// If the current instruction is a load, update MaxWidth to reflect the; // width of the loaded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Security,access,access,35,"// If we didn't encounter a memory access in the expression tree, or if we; // gave up for some reason, just return the width of V. Otherwise, return the; // maximum width we found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:125,Safety,safe,safe,125,// The maximum bit width required to represent all the values that can be; // demoted without loss of precision. It would be safe to truncate the roots; // of the expression to this width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Modifiability,extend,extended,33,"// True if the roots can be zero-extended back to their original type, rather; // than sign-extended. We know that if the leading bits are not demanded, we; // can safely zero-extend. So we initialize IsKnownPositive to True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:92,Modifiability,extend,extended,92,"// True if the roots can be zero-extended back to their original type, rather; // than sign-extended. We know that if the leading bits are not demanded, we; // can safely zero-extend. So we initialize IsKnownPositive to True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:176,Modifiability,extend,extend,176,"// True if the roots can be zero-extended back to their original type, rather; // than sign-extended. We know that if the leading bits are not demanded, we; // can safely zero-extend. So we initialize IsKnownPositive to True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:164,Safety,safe,safely,164,"// True if the roots can be zero-extended back to their original type, rather; // than sign-extended. We know that if the leading bits are not demanded, we; // can safely zero-extend. So we initialize IsKnownPositive to True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:193,Modifiability,extend,extend,193,"// If we can't prove that the sign bit is zero, we must add one to the; // maximum bit width to account for the unknown sign bit. This preserves; // the existing sign bit so we can safely sign-extend the root back to the; // original type. Otherwise, if we know the sign bit is zero, we will; // zero-extend the root instead.; //; // FIXME: This is somewhat suboptimal, as there will be cases where adding; // one to the maximum bit width will yield a larger-than-necessary; // type. In general, we need to add an extra bit only if we can't; // prove that the upper bit of the original type is equal to the; // upper bit of the proposed smaller type. If these two bits are the; // same (either zero or one) we know that sign-extending from the; // smaller type will result in the same value. Here, since we can't; // yet prove this, we are just making the proposed smaller type; // larger to ensure correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:301,Modifiability,extend,extend,301,"// If we can't prove that the sign bit is zero, we must add one to the; // maximum bit width to account for the unknown sign bit. This preserves; // the existing sign bit so we can safely sign-extend the root back to the; // original type. Otherwise, if we know the sign bit is zero, we will; // zero-extend the root instead.; //; // FIXME: This is somewhat suboptimal, as there will be cases where adding; // one to the maximum bit width will yield a larger-than-necessary; // type. In general, we need to add an extra bit only if we can't; // prove that the upper bit of the original type is equal to the; // upper bit of the proposed smaller type. If these two bits are the; // same (either zero or one) we know that sign-extending from the; // smaller type will result in the same value. Here, since we can't; // yet prove this, we are just making the proposed smaller type; // larger to ensure correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:725,Modifiability,extend,extending,725,"// If we can't prove that the sign bit is zero, we must add one to the; // maximum bit width to account for the unknown sign bit. This preserves; // the existing sign bit so we can safely sign-extend the root back to the; // original type. Otherwise, if we know the sign bit is zero, we will; // zero-extend the root instead.; //; // FIXME: This is somewhat suboptimal, as there will be cases where adding; // one to the maximum bit width will yield a larger-than-necessary; // type. In general, we need to add an extra bit only if we can't; // prove that the upper bit of the original type is equal to the; // upper bit of the proposed smaller type. If these two bits are the; // same (either zero or one) we know that sign-extending from the; // smaller type will result in the same value. Here, since we can't; // yet prove this, we are just making the proposed smaller type; // larger to ensure correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:181,Safety,safe,safely,181,"// If we can't prove that the sign bit is zero, we must add one to the; // maximum bit width to account for the unknown sign bit. This preserves; // the existing sign bit so we can safely sign-extend the root back to the; // original type. Otherwise, if we know the sign bit is zero, we will; // zero-extend the root instead.; //; // FIXME: This is somewhat suboptimal, as there will be cases where adding; // one to the maximum bit width will yield a larger-than-necessary; // type. In general, we need to add an extra bit only if we can't; // prove that the upper bit of the original type is equal to the; // upper bit of the proposed smaller type. If these two bits are the; // same (either zero or one) we know that sign-extending from the; // smaller type will result in the same value. Here, since we can't; // yet prove this, we are just making the proposed smaller type; // larger to ensure correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,Energy Efficiency,power,power-of-two,36,// Round MaxBitWidth up to the next power-of-two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:103,Deployability,Update,Update,103,// A general note: the vectorizer must use BoUpSLP::eraseInstruction() to; // delete instructions.; // Update DFS numbers now so that we can use them for ordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Usability,clear,clear,21,// Start new block - clear the list of reduction roots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:156,Performance,load,loads,156,// Vectorize the index computations of getelementptr instructions. This; // is primarily intended to catch gather-like idioms ending at; // non-consecutive loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Energy Efficiency,power,power-of-,94,// FIXME: Is division-by-2 the correct step? Should we assert that the; // register size is a power-of-2?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:55,Testability,assert,assert,55,// FIXME: Is division-by-2 the correct step? Should we assert that the; // register size is a power-of-2?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:439,Energy Efficiency,reduce,reduce,439,"// Stores pair (first: index of the store into Stores array ref, address of; // which taken as base, second: sorted set of pairs {index, dist}, which are; // indices of stores in the set and their store location distances relative to; // the base address).; // Need to store the index of the very first store separately, since the set; // may be reordered after the insertion and the first store may be moved. This; // container allows to reduce number of calls of getPointersDiff() function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1594,Integrability,depend,dependencies,1594,"// Inserts the specified store SI with the given index Idx to the set of the; // stores. If the store with the same distance is found already - stop; // insertion, try to vectorize already found stores. If some stores from this; // sequence were not vectorized - try to vectorize them with the new store; // later. But this logic is applied only to the stores, that come before the; // previous store with the same distance.; // Example:; // 1. store x, %p; // 2. store y, %p+1; // 3. store z, %p+2; // 4. store a, %p; // 5. store b, %p+3; // - Scan this from the last to first store. The very first bunch of stores is; // {5, {{4, -3}, {2, -2}, {3, -1}, {5, 0}}} (the element in SortedStores; // vector).; // - The next store in the list - #1 - has the same distance from store #5 as; // the store #4.; // - Try to vectorize sequence of stores 4,2,3,5.; // - If all these stores are vectorized - just drop them.; // - If some of them are not vectorized (say, #3 and #5), do extra analysis.; // - Start new stores sequence.; // The new bunch of stores is {1, {1, 0}}.; // - Add the stores from previous sequence, that were not vectorized.; // Here we consider the stores in the reversed order, rather they are used in; // the IR (Stores are reversed already, see vectorizeStoreChains() function).; // Store #3 can be added -> comes after store #4 with the same distance as; // store #1.; // Store #5 cannot be added - comes before store #4.; // This logic allows to improve the compile time, we assume that the stores; // after previous store with the same distance most likely have memory; // dependencies and no need to waste compile time to try to vectorize them.; // - Try to vectorize the sequence {1, {1, 0}, {3, 2}}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:324,Testability,log,logic,324,"// Inserts the specified store SI with the given index Idx to the set of the; // stores. If the store with the same distance is found already - stop; // insertion, try to vectorize already found stores. If some stores from this; // sequence were not vectorized - try to vectorize them with the new store; // later. But this logic is applied only to the stores, that come before the; // previous store with the same distance.; // Example:; // 1. store x, %p; // 2. store y, %p+1; // 3. store z, %p+2; // 4. store a, %p; // 5. store b, %p+3; // - Scan this from the last to first store. The very first bunch of stores is; // {5, {{4, -3}, {2, -2}, {3, -1}, {5, 0}}} (the element in SortedStores; // vector).; // - The next store in the list - #1 - has the same distance from store #5 as; // the store #4.; // - Try to vectorize sequence of stores 4,2,3,5.; // - If all these stores are vectorized - just drop them.; // - If some of them are not vectorized (say, #3 and #5), do extra analysis.; // - Start new stores sequence.; // The new bunch of stores is {1, {1, 0}}.; // - Add the stores from previous sequence, that were not vectorized.; // Here we consider the stores in the reversed order, rather they are used in; // the IR (Stores are reversed already, see vectorizeStoreChains() function).; // Store #3 can be added -> comes after store #4 with the same distance as; // store #1.; // Store #5 cannot be added - comes before store #4.; // This logic allows to improve the compile time, we assume that the stores; // after previous store with the same distance most likely have memory; // dependencies and no need to waste compile time to try to vectorize them.; // - Try to vectorize the sequence {1, {1, 0}, {3, 2}}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1450,Testability,log,logic,1450,"// Inserts the specified store SI with the given index Idx to the set of the; // stores. If the store with the same distance is found already - stop; // insertion, try to vectorize already found stores. If some stores from this; // sequence were not vectorized - try to vectorize them with the new store; // later. But this logic is applied only to the stores, that come before the; // previous store with the same distance.; // Example:; // 1. store x, %p; // 2. store y, %p+1; // 3. store z, %p+2; // 4. store a, %p; // 5. store b, %p+3; // - Scan this from the last to first store. The very first bunch of stores is; // {5, {{4, -3}, {2, -2}, {3, -1}, {5, 0}}} (the element in SortedStores; // vector).; // - The next store in the list - #1 - has the same distance from store #5 as; // the store #4.; // - Try to vectorize sequence of stores 4,2,3,5.; // - If all these stores are vectorized - just drop them.; // - If some of them are not vectorized (say, #3 and #5), do extra analysis.; // - Start new stores sequence.; // The new bunch of stores is {1, {1, 0}}.; // - Add the stores from previous sequence, that were not vectorized.; // Here we consider the stores in the reversed order, rather they are used in; // the IR (Stores are reversed already, see vectorizeStoreChains() function).; // Store #3 can be added -> comes after store #4 with the same distance as; // store #1.; // Store #5 cannot be added - comes before store #4.; // This logic allows to improve the compile time, we assume that the stores; // after previous store with the same distance most likely have memory; // dependencies and no need to waste compile time to try to vectorize them.; // - Try to vectorize the sequence {1, {1, 0}, {3, 2}}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,Safety,avoid,avoid,43,// Try to vectorize the first found set to avoid duplicate analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Energy Efficiency,reduce,reduced,21,/// List of possibly reduced values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Energy Efficiency,reduce,reduced,9,/// Maps reduced value to the corresponding reduction operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Performance,optimiz,optimization,18,/// Checks if the optimization of original scalar identity operations on; /// matched horizontal reductions is enabled and allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Safety,safe,safe,33,"// And/or are potentially poison-safe logical patterns like:; // select x, y, false; // select x, true, y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Testability,log,logical,38,"// And/or are potentially poison-safe logical patterns like:; // select x, y, false; // select x, true, y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,Safety,safe,safe,10,"// Poison-safe 'or' takes the form: select X, true, Y; // To make that work with the normal operand processing, we skip the; // true value operand.; // TODO: Change the code and data structures to handle this without a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Testability,Log,Logical,3,// Logical or/and.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:237,Performance,optimiz,optimizeGatherSequence,237,"// Try harder: look for min/max pattern based on instructions producing; // same values such as: select ((cmp Inst1, Inst2), Inst1, Inst2).; // During the intermediate stages of SLP, it's very common to have; // pattern like this (since optimizeGatherSequence is run only once; // at the end):; // %1 = extractelement <2 x i32> %a, i32 0; // %2 = extractelement <2 x i32> %a, i32 1; // %cond = icmp sgt i32 %1, %2; // %3 = extractelement <2 x i32> %a, i32 0; // %4 = extractelement <2 x i32> %a, i32 1; // %select = select i1 %cond, i32 %3, i32 %4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:53,Energy Efficiency,reduce,reduced,53,/// Expected number of uses for reduction operations/reduced values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,Energy Efficiency,reduce,reduced,90,"// Iterate through all the operands of the possible reduction tree and; // gather all the reduced values, sorting them by their value id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:112,Energy Efficiency,reduce,reduced,112,"// Checks if the operands of the \p TreeN instruction are also reduction; // operations or should be treated as reduced values or an extra argument,; // which is not part of the reduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,Energy Efficiency,reduce,reduced,124,"// If the edge is not an instruction, or it is different from the main; // reduction opcode or has too many uses - possible reduced value.; // Also, do not try to reduce const values, if the operation is not; // foldable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:163,Energy Efficiency,reduce,reduce,163,"// If the edge is not an instruction, or it is different from the main; // reduction opcode or has too many uses - possible reduced value.; // Also, do not try to reduce const values, if the operation is not; // foldable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,reduce,reduced,18,"// Try to regroup reduced values so that it gets more profitable to try to; // reduce them. Values are grouped by their value ids, instructions - by; // instruction op id and/or alternate op id, plus do extra analysis for; // loads (grouping them by the distabce between pointers) and cmp; // instructions (grouping them by the predicate).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:79,Energy Efficiency,reduce,reduce,79,"// Try to regroup reduced values so that it gets more profitable to try to; // reduce them. Values are grouped by their value ids, instructions - by; // instruction op id and/or alternate op id, plus do extra analysis for; // loads (grouping them by the distabce between pointers) and cmp; // instructions (grouping them by the predicate).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:226,Performance,load,loads,226,"// Try to regroup reduced values so that it gets more profitable to try to; // reduce them. Values are grouped by their value ids, instructions - by; // instruction op id and/or alternate op id, plus do extra analysis for; // loads (grouping them by the distabce between pointers) and cmp; // instructions (grouping them by the predicate).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:104,Energy Efficiency,reduce,reduced,104,// Sort values by the total number of values kinds to start the reduction; // from the longest possible reduced values sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Energy Efficiency,reduce,reduced,12,// Sort the reduced values by number of same/alternate opcode and/or pointer; // operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:57,Energy Efficiency,reduce,reduce,57,"// If there are a sufficient number of reduction values, reduce; // to a nearby power-of-2. We can safely generate oversized; // vectors and rely on the backend to split them to legal sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:80,Energy Efficiency,power,power-of-,80,"// If there are a sufficient number of reduction values, reduce; // to a nearby power-of-2. We can safely generate oversized; // vectors and rely on the backend to split them to legal sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:99,Safety,safe,safely,99,"// If there are a sufficient number of reduction values, reduce; // to a nearby power-of-2. We can safely generate oversized; // vectors and rely on the backend to split them to legal sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Energy Efficiency,reduce,reduced,13,// Track the reduced values in case if they are replaced by extractelement; // because of the vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:57,Testability,log,log,57,"// The same extra argument may be used several times, so log each attempt; // to use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update the final value in the reduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,reduce,reduced,17,"// Need to track reduced vals, they may be changed during vectorization of; // subvectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Energy Efficiency,reduce,reduced,32,// List of the values that were reduced in other trees as part of gather; // nodes and thus requiring extract if fully vectorized in other trees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,Performance,optimiz,optimization,58,// Check if we support repeated scalar values processing (optimization of; // original scalar identity operations on matched horizontal reductions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Energy Efficiency,reduce,reduced,24,"// Used to check if the reduced values used same number of times. In this; // case the compiler may produce better code. E.g. if reduced values are; // aabbccdd (8 x values), then the first node of the tree will have a node; // for 4 x abcd + shuffle <4 x abcd>, <0, 0, 1, 1, 2, 2, 3, 3>.; // Plus, the final reduction will be performed on <8 x aabbccdd>.; // Instead compiler may build <4 x abcd> tree immediately, + reduction (4; // x abcd) * 2.; // Currently it only handles add/fadd/xor. and/or/min/max do not require; // this analysis, other operations may require an extra estimation of; // the profitability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:129,Energy Efficiency,reduce,reduced,129,"// Used to check if the reduced values used same number of times. In this; // case the compiler may produce better code. E.g. if reduced values are; // aabbccdd (8 x values), then the first node of the tree will have a node; // for 4 x abcd + shuffle <4 x abcd>, <0, 0, 1, 1, 2, 2, 3, 3>.; // Plus, the final reduction will be performed on <8 x aabbccdd>.; // Instead compiler may build <4 x abcd> tree immediately, + reduction (4; // x abcd) * 2.; // Currently it only handles add/fadd/xor. and/or/min/max do not require; // this analysis, other operations may require an extra estimation of; // the profitability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:327,Performance,perform,performed,327,"// Used to check if the reduced values used same number of times. In this; // case the compiler may produce better code. E.g. if reduced values are; // aabbccdd (8 x values), then the first node of the tree will have a node; // for 4 x abcd + shuffle <4 x abcd>, <0, 0, 1, 1, 2, 2, 3, 3>.; // Plus, the final reduction will be performed on <8 x aabbccdd>.; // Instead compiler may build <4 x abcd> tree immediately, + reduction (4; // x abcd) * 2.; // Currently it only handles add/fadd/xor. and/or/min/max do not require; // this analysis, other operations may require an extra estimation of; // the profitability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Integrability,Depend,Dependency,3,"// Dependency in tree of the reduction ops - drop this attempt, try; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,"// Update LocalExternallyUsedValues for the scalar, replaced by; // extractelement instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,Safety,safe,safe,73,"// To prevent poison from leaking across what used to be sequential,; // safe, scalar boolean logic operations, the reduction operand must be; // frozen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Testability,log,logic,94,"// To prevent poison from leaking across what used to be sequential,; // safe, scalar boolean logic operations, the reduction operand must be; // frozen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Energy Efficiency,reduce,reduced,40,"// Emit code to correctly handle reused reduced values, if required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Energy Efficiency,reduce,reduced,20,// Count vectorized reduced values to exclude them from final reduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,Safety,avoid,avoid,63,"// Reorder operands of bool logical op in the natural order to avoid; // possible problem with poison propagation. If not possible to reorder; // (both operands are originally RHS), emit an extra freeze instruction; // for the LHS operand.; // I.e., if we have original code like this:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 RHS, i1 ?, i1 false; // Then, we swap LHS/RHS to create a new op that matches the poison; // semantics of the original code.; // If we have original code like this and both values could be poison:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 ?, i1 RHS, i1 false; // Then, we must freeze LHS in the new op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Testability,log,logical,28,"// Reorder operands of bool logical op in the natural order to avoid; // possible problem with poison propagation. If not possible to reorder; // (both operands are originally RHS), emit an extra freeze instruction; // for the LHS operand.; // I.e., if we have original code like this:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 RHS, i1 ?, i1 false; // Then, we swap LHS/RHS to create a new op that matches the poison; // semantics of the original code.; // If we have original code like this and both values could be poison:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 ?, i1 RHS, i1 false; // Then, we must freeze LHS in the new op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,Integrability,depend,dependencies,124,// Finish the reduction.; // Need to add extra arguments and not vectorized possible reduction; // values.; // Try to avoid dependencies between the scalar remainders after; // reductions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,Safety,avoid,avoid,118,// Finish the reduction.; // Need to add extra arguments and not vectorized possible reduction; // values.; // Try to avoid dependencies between the scalar remainders after; // reductions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,Safety,safe,safe,73,"// To prevent poison from leaking across what used to be; // sequential, safe, scalar boolean logic operations, the; // reduction operand must be frozen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Testability,log,logic,94,"// To prevent poison from leaking across what used to be; // sequential, safe, scalar boolean logic operations, the; // reduction operand must be frozen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:110,Testability,Assert,Assert,110,"// The original scalar reduction is expected to have no remaining; // uses outside the reduction tree itself. Assert that we got this; // correct, replace internal uses with undef, and mark for eventual; // deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,reduce,reduced,17,"// If all of the reduced values are constant, the vector cost is 0, since; // the reduction value can be calculated at the compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,Performance,optimiz,optimized,10,/// Emits optimized code for unique scalar value reused \p Cnt times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:518,Testability,test,test,518,"/// Recognize construction of vectors like; /// %ra = insertelement <4 x float> poison, float %s0, i32 0; /// %rb = insertelement <4 x float> %ra, float %s1, i32 1; /// %rc = insertelement <4 x float> %rb, float %s2, i32 2; /// %rd = insertelement <4 x float> %rc, float %s3, i32 3; /// starting from the last insertelement or insertvalue instruction.; ///; /// Also recognize homogeneous aggregates like {<2 x float>, <2 x float>},; /// {{float, float}, {float, float}}, [2 x {float, float}] and so on.; /// See llvm/test/Transforms/SLPVectorizer/X86/pr42022.ll for examples.; ///; /// Assume LastInsertInst is of InsertElementInst or InsertValueInst type.; ///; /// \return true if it matches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Performance,scalab,scalable,26,// Skip instructions with scalable type. The num of elements is unknown at; // compile-time for scalable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:96,Performance,scalab,scalable,96,// Skip instructions with scalable type. The num of elements is unknown at; // compile-time for scalable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:111,Safety,avoid,avoid,111,"// Skip if the incoming block is the current BB for now. Also, bypass; // unreachable IR for efficiency and to avoid crashing.; // TODO: Collect the skipped incoming values and try to vectorize them; // after processing BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:197,Safety,safe,safely,197,"// Try to vectorize chain in store, if this is the only store to the; // address in the block.; // TODO: This is just a temporarily solution to save compile time. Need; // to investigate if we can safely turn on slp-vectorize-hor-store; // instead to allow lookup for reduction chains in all non-vectorized; // stores (need to check side effects and compile time).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:175,Performance,load,loads,175,"// Initialize a set a candidate getelementptrs. Note that we use a; // SetVector here to preserve program order. If the index computations; // are vectorizable and begin with loads, we want to minimize the chance; // of having to reorder them later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:115,Performance,optimiz,optimized,115,"// Some of the candidates may have already been vectorized after we; // initially collected them or their index is optimized to constant value.; // If so, they are marked as deleted, so remove them from the set of; // candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:394,Availability,down,down,394,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:175,Performance,load,loads,175,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:193,Performance,load,loads,193,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:239,Performance,perform,performed,239,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:434,Performance,load,loads,434,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:279,Safety,detect,detecting,279,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:335,Usability,simpl,simpler,335,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:210,Integrability,depend,dependecies,210,"// Reverse stores to do bottom-to-top analysis. This is important if the; // values are stores to the same addresses several times, in this case need; // to follow the stores order (reversed to meet the memory dependecies).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:33,Performance,Optimiz,Optimize,33,"//===------- VectorCombine.cpp - Optimize partial vector operations -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:393,Performance,optimiz,optimizes,393,"//===------- VectorCombine.cpp - Optimize partial vector operations -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:18,Performance,perform,perform,18,"/// If true, only perform beneficial early IR transforms. Do not introduce new; /// vector operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:108,Deployability,update,updated,108,"// TODO: Direct calls from the top-level ""run"" loop use a plain ""Instruction""; // parameter. That should be updated to specific sub-classes because the; // run loop was changed to dispatch on opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:16,Performance,load,load,16,// Do not widen load if atomic/volatile or under asan/hwasan/memtag/tsan.; // The widened load may load data from dirty regions or create data races; // non-existent in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:90,Performance,load,load,90,// Do not widen load if atomic/volatile or under asan/hwasan/memtag/tsan.; // The widened load may load data from dirty regions or create data races; // non-existent in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:99,Performance,load,load,99,// Do not widen load if atomic/volatile or under asan/hwasan/memtag/tsan.; // The widened load may load data from dirty regions or create data races; // non-existent in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:61,Security,access,accesses,61,"// We are potentially transforming byte-sized (8-bit) memory accesses, so make; // sure we have all of our type-based constraints in place for this target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:40,Performance,load,load,40,"// Check safety of replacing the scalar load with a larger vector load.; // We use minimal alignment (maximum flexibility) because we only care about; // the dereferenceable region. When calculating cost and creating a new op,; // we may use a larger value based on alignment attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:66,Performance,load,load,66,"// Check safety of replacing the scalar load with a larger vector load.; // We use minimal alignment (maximum flexibility) because we only care about; // the dereferenceable region. When calculating cost and creating a new op,; // we may use a larger value based on alignment attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,Safety,safe,safety,9,"// Check safety of replacing the scalar load with a larger vector load.; // We use minimal alignment (maximum flexibility) because we only care about; // the dereferenceable region. When calculating cost and creating a new op,; // we may use a larger value based on alignment attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:157,Deployability,update,updated,157,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:21,Performance,load,load,21,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:123,Performance,load,load,123,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:237,Performance,load,loading,237,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:13,Safety,safe,safe,13,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:115,Safety,safe,safe,115,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:33,Availability,down,down,33,"// We want to shuffle the result down from a high element of a vector, so; // the offset must be positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,Performance,load,load,9,"// If we load MinVecNumElts, will our target element still be loaded?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:62,Performance,load,loaded,62,"// If we load MinVecNumElts, will our target element still be loaded?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:3,Deployability,Update,Update,3,"// Update alignment with offset value. Note that the offset could be negated; // to more accurately represent ""(new) SrcPtr - Offset = (old) SrcPtr"", but; // negation does not change the result of the alignment calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:38,Performance,load,load,38,"// Original pattern: insertelt undef, load [free casts of] PtrOp, 0; // Use the greater of the alignment on the load or its source pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:112,Performance,load,load,112,"// Original pattern: insertelt undef, load [free casts of] PtrOp, 0; // Use the greater of the alignment on the load or its source pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:16,Performance,load,load,16,// New pattern: load VecPtr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:85,Availability,mask,mask,85,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:36,Performance,load,loaded,36,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:182,Performance,load,loaded,182,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:259,Performance,load,loaded,259,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:404,Safety,avoid,avoid,404,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:127,Performance,perform,performance,127,// We can aggressively convert to the vector form because the backend can; // invert this transform if it does not result in a performance win.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:44,Performance,load,load,44,"// It is safe and potentially profitable to load a vector directly:; // inselt undef, load Scalar, 0 --> load VecPtr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:86,Performance,load,load,86,"// It is safe and potentially profitable to load a vector directly:; // inselt undef, load Scalar, 0 --> load VecPtr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:105,Performance,load,load,105,"// It is safe and potentially profitable to load a vector directly:; // inselt undef, load Scalar, 0 --> load VecPtr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,Safety,safe,safe,9,"// It is safe and potentially profitable to load a vector directly:; // inselt undef, load Scalar, 0 --> load VecPtr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:14,Performance,load,loading,14,"/// If we are loading a vector and then inserting it into a larger vector with; /// undefined elements, try to load the larger vector and eliminate the insert.; /// This removes a shuffle in IR and may allow combining of other loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:111,Performance,load,load,111,"/// If we are loading a vector and then inserting it into a larger vector with; /// undefined elements, try to load the larger vector and eliminate the insert.; /// This removes a shuffle in IR and may allow combining of other loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:227,Performance,load,loaded,227,"/// If we are loading a vector and then inserting it into a larger vector with; /// undefined elements, try to load the larger vector and eliminate the insert.; /// This removes a shuffle in IR and may allow combining of other loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:33,Availability,mask,mask,33,// Allow a non-canonical shuffle mask that is choosing elements from op1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:39,Performance,load,load,39,// Original pattern: insert_subvector (load PtrOp); // This conservatively assumes that the cost of a subvector insert into an; // undef value is 0. We could add that cost if the cost model accurately; // reflects the real cost of that operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:16,Performance,load,load,16,// New pattern: load PtrOp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:127,Performance,perform,performance,127,// We can aggressively convert to the vector form because the backend can; // invert this transform if it does not result in a performance win.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:90,Performance,perform,performing,90,"// We are extracting from 2 different indexes, so one operand must be shuffled; // before performing a vector operation and/or extract. The more expensive; // extract will be replaced by a shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:118,Energy Efficiency,charge,charge,118,"// Handle a special case. If the 2 extracts are identical, adjust the; // formulas to account for that. The extra use charge allows for either the; // CSE'd pattern or an unoptimized form with identical values:; // opcode (extelt V, C), (extelt V, C) --> extelt (opcode V, V), C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:140,Availability,mask,mask,140,"// If we are extracting from 2 different indexes, then one operand must be; // shuffled before performing the vector operation. The shuffle mask is; // poison except for 1 lane that is being translated to the remaining; // extraction lane. Therefore, it is a splat shuffle. Ex:; // ShufMask = { poison, poison, 0, poison }; // TODO: The cost model has an option for a ""broadcast"" shuffle; // (splat-from-element-0), but no option for a more general splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:95,Performance,perform,performing,95,"// If we are extracting from 2 different indexes, then one operand must be; // shuffled before performing the vector operation. The shuffle mask is; // poison except for 1 lane that is being translated to the remaining; // extraction lane. Therefore, it is a splat shuffle. Ex:; // ShufMask = { poison, poison, 0, poison }; // TODO: The cost model has an option for a ""broadcast"" shuffle; // (splat-from-element-0), but no option for a more general splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:99,Performance,optimiz,optimization,99,// Aggressively form a vector op if the cost is equal because the transform; // may enable further optimization.; // Codegen can reverse this transform (scalarize) if it was not profitable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:15,Availability,mask,mask,15,"// The shuffle mask is poison except for 1 lane that is being translated; // to the new element index. Example for OldIndex == 2 and NewIndex == 0:; // ShufMask = { 2, poison, poison, poison }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:11,Energy Efficiency,reduce,reduce,11,"/// Try to reduce extract element costs by converting scalar compares to vector; /// compares followed by extract.; /// cmp (ext0 V0, C), (ext1 V1, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:11,Energy Efficiency,reduce,reduce,11,"/// Try to reduce extract element costs by converting scalar binops to vector; /// binops followed by extract.; /// bo (ext0 V0, C), (ext1 V1, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:20,Safety,safe,safe,20,// All IR flags are safe to back-propagate because any potential poison; // created in unused vector elements is discarded by the extract.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:13,Safety,safe,safe,13,"// It is not safe to transform things like div, urem, etc. because we may; // create undefined behavior when executing those on unknown vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:155,Energy Efficiency,reduce,reduced,155,"// If the scalar value 'I' is going to be re-inserted into a vector, then try; // to create an extract to that same element. The extract/insert can be; // reduced to a ""select shuffle"".; // TODO: If we add a larger pattern match that starts from an insert, this; // probably becomes unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:103,Availability,Mask,Mask,103,"// insertelt DestVec, (fneg (extractelt SrcVec, Index)), Index -->; // shuffle DestVec, (fneg SrcVec), Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:160,Availability,mask,mask,160,"// 1) Do not fold bitcast shuffle for scalable type. First, shuffle cost for; // scalable type is unknown; Second, we cannot reason if the narrowed shuffle; // mask for scalable type is a splat or not.; // 2) Disallow non-vector casts.; // TODO: We could allow any shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:38,Performance,scalab,scalable,38,"// 1) Do not fold bitcast shuffle for scalable type. First, shuffle cost for; // scalable type is unknown; Second, we cannot reason if the narrowed shuffle; // mask for scalable type is a splat or not.; // 2) Disallow non-vector casts.; // TODO: We could allow any shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:81,Performance,scalab,scalable,81,"// 1) Do not fold bitcast shuffle for scalable type. First, shuffle cost for; // scalable type is unknown; Second, we cannot reason if the narrowed shuffle; // mask for scalable type is a splat or not.; // 2) Disallow non-vector casts.; // TODO: We could allow any shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:169,Performance,scalab,scalable,169,"// 1) Do not fold bitcast shuffle for scalable type. First, shuffle cost for; // scalable type is unknown; Second, we cannot reason if the narrowed shuffle; // mask for scalable type is a splat or not.; // 2) Disallow non-vector casts.; // TODO: We could allow any shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:66,Availability,mask,mask,66,// The bitcast is from wide to narrow/equal elements. The shuffle mask can; // always be expanded to the equivalent form choosing narrower elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:69,Availability,mask,mask,69,// The bitcast is from narrow elements to wide elements. The shuffle mask; // must choose consecutive elements to allow casting first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:20,Availability,Mask,MaskC,20,"// bitcast (shuf V, MaskC) --> shuf (bitcast V), MaskC'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:49,Availability,Mask,MaskC,49,"// bitcast (shuf V, MaskC) --> shuf (bitcast V), MaskC'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:187,Availability,down,down,187,/// VP Intrinsics whose vector operands are both splat values may be simplified; /// into the scalar version of the operation and the result splatted. This; /// can lead to scalarization down the line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:69,Usability,simpl,simplified,69,/// VP Intrinsics whose vector operands are both splat values may be simplified; /// into the scalar version of the operation and the result splatted. This; /// can lead to scalarization down the line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:50,Safety,avoid,avoid,50,"// Check getSplatValue early in this function, to avoid doing unnecessary; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:122,Usability,simpl,simplification,122,"// For the binary VP intrinsics supported here, the result on disabled lanes; // is a poison value. For now, only do this simplification if all lanes; // are active.; // TODO: Relax the condition that all lanes are active by using insertelement; // on inactive lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:288,Modifiability,variab,variable,288,"// Match against one or both scalar values being inserted into constant; // vectors:; // vec_op VecC0, (inselt VecC1, V1, Index); // vec_op (inselt VecC0, V0, Index), VecC1; // vec_op (inselt VecC0, V0, Index), (inselt VecC1, V1, Index); // TODO: Deal with mismatched index constants and variable indexes?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:40,Performance,load,load,40,// Bail for single insertion if it is a load.; // TODO: Handle this once getVectorInstrCost can cost for load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:105,Performance,load,load,105,// Bail for single insertion if it is a load.; // TODO: Handle this once getVectorInstrCost can cost for load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:20,Safety,safe,safe,20,// All IR flags are safe to back-propagate. There is no potential for extra; // poison to be created by the scalar instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:98,Performance,optimiz,optimization,98,// Aggressively form vector ops if the cost is equal because the transform; // may enable further optimization.; // Codegen can reverse this transform (scalarize) if it was not profitable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:59,Safety,safe,safely,59,/// Helper class to indicate whether a vector index can be safely scalarized and; /// if a freeze needs to be inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:23,Safety,Unsafe,Unsafe,23,/// Reset the state of Unsafe and clear ToFreze if set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:34,Usability,clear,clear,34,/// Reset the state of Unsafe and clear ToFreze if set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:28,Deployability,update,update,28,/// Freeze the ToFreeze and update the use in \p User to use it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:61,Security,access,access,61,// namespace; /// Check if it is legal to scalarize a memory access to \p VecTy at index \p; /// Idx. \p Idx must access a valid vector element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:114,Security,access,access,114,// namespace; /// Check if it is legal to scalarize a memory access to \p VecTy at index \p; /// Idx. \p Idx must access a valid vector element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:48,Performance,scalab,scalable,48,"// We do checks for both fixed vector types and scalable vector types.; // This is the number of elements of fixed vector types,; // or the minimum number of elements of scalable vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:170,Performance,scalab,scalable,170,"// We do checks for both fixed vector types and scalable vector types.; // This is the number of elements of fixed vector types,; // or the minimum number of elements of scalable vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:35,Performance,load,load,35,"// Combine patterns like:; // %0 = load <4 x i32>, <4 x i32>* %a; // %1 = insertelement <4 x i32> %0, i32 %b, i32 1; // store <4 x i32> %1, <4 x i32>* %a; // to:; // %0 = bitcast <4 x i32>* %a to i32*; // %1 = getelementptr inbounds i32, i32* %0, i64 0, i64 1; // store i32 %b, i32* %1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,Performance,optimiz,optimize,9,"// Don't optimize for atomic/volatile load or store. Ensure memory is not; // modified between, vector type matches store size, and index is inbounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:38,Performance,load,load,38,"// Don't optimize for atomic/volatile load or store. Ensure memory is not; // modified between, vector type matches store size, and index is inbounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:28,Performance,load,loads,28,/// Try to scalarize vector loads feeding extractelement instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:23,Safety,abort,aborted,23,"// If the transform is aborted, discard the ScalarizationResults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:29,Performance,load,load,29,// Check if all users of the load are extracts with no memory modifications; // between the load and the extract. Compute the cost of both the original; // code and the scalarized version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:92,Performance,load,load,92,// Check if all users of the load are extracts with no memory modifications; // between the load and the extract. Compute the cost of both the original; // code and the scalarized version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:40,Performance,load,load,40,// Check if any instruction between the load and the extract may modify; // memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:39,Performance,load,loads,39,// Replace extracts with narrow scalar loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:44,Safety,safe,safely,44,"// Splats don't change the order, so can be safely ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:12,Availability,mask,mask,12,// Find the mask from sorting the lanes into order. This is most likely to; // become a identity or concat mask. Undef elements are pushed to the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:107,Availability,mask,mask,107,// Find the mask from sorting the lanes into order. This is most likely to; // become a identity or concat mask. Undef elements are pushed to the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:61,Availability,mask,mask,61,// In the case of a truncating shuffle it's possible for the mask; // to have an index greater than the size of the resulting vector.; // This requires special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:57,Energy Efficiency,reduce,reduce,57,"// See if we can re-use foldSelectShuffle, getting it to reduce the size of; // the shuffle into a nicer order, as it can ignore the order of the shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:418,Energy Efficiency,reduce,reduce,418,"/// This method looks for groups of shuffles acting on binops, of the form:; /// %x = shuffle ...; /// %y = shuffle ...; /// %a = binop %x, %y; /// %b = binop %x, %y; /// shuffle %a, %b, selectmask; /// We may, especially if the shuffle is wider than legal, be able to convert; /// the shuffle to a form where only parts of a and b need to be computed. On; /// architectures with no obvious ""select"" shuffle, this can reduce the total; /// number of operations if the target reports them as cheaper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:280,Availability,mask,mask,280,"// For each of the output shuffles, we try to sort all the first vector; // elements to the beginning, followed by the second array elements at the; // end. If the binops are legalized to smaller vectors, this may reduce total; // number of binops. We compute the ReconstructMask mask needed to convert; // back to the original lane order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:214,Energy Efficiency,reduce,reduce,214,"// For each of the output shuffles, we try to sort all the first vector; // elements to the beginning, followed by the second array elements at the; // end. If the binops are legalized to smaller vectors, this may reduce total; // number of binops. We compute the ReconstructMask mask needed to convert; // back to the original lane order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:106,Availability,mask,mask,106,"// Check the operands are the same as the original, or reversed (in which; // case we need to commute the mask).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:32,Availability,mask,mask,32,"// Calculate the reconstruction mask for this shuffle, as the mask needed to; // take the packed values from Op0/Op1 and reconstructing to the original; // order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:62,Availability,mask,mask,62,"// Calculate the reconstruction mask for this shuffle, as the mask needed to; // take the packed values from Op0/Op1 and reconstructing to the original; // order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:102,Usability,simpl,simplify,102,"// For reductions, we know that the lane ordering out doesn't alter the; // result. In-order can help simplify the shuffle away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:122,Performance,perform,performing,122,"// If the Maximum element used from V1 and V2 are not larger than the new; // vectors, the vectors are already packes and performing the optimization; // again will likely not help any further. This also prevents us from getting; // stuck in a cycle in case the costs do not also rule it out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:137,Performance,optimiz,optimization,137,"// If the Maximum element used from V1 and V2 are not larger than the new; // vectors, the vectors are already packes and performing the optimization; // again will likely not help any further. This also prevents us from getting; // stuck in a cycle in case the costs do not also rule it out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:43,Availability,mask,mask,43,"// Attempt to sort the inputs my ascending mask values to make simpler input; // shuffles and push complex shuffles down to the uses. We sort on the first; // of the two input shuffle orders, to try and get at least one input into a; // nice order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:116,Availability,down,down,116,"// Attempt to sort the inputs my ascending mask values to make simpler input; // shuffles and push complex shuffles down to the uses. We sort on the first; // of the two input shuffle orders, to try and get at least one input into a; // nice order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:63,Usability,simpl,simpler,63,"// Attempt to sort the inputs my ascending mask values to make simpler input; // shuffles and push complex shuffles down to the uses. We sort on the first; // of the two input shuffle orders, to try and get at least one input into a; // nice order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:17,Availability,mask,masks,17,"// Calculate the masks needed for the new input shuffles, which get padded; // with undef",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:84,Availability,mask,masks,84,// Get the costs of the shuffles + binops before and after with the new; // shuffle masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:96,Deployability,pipeline,pipeline,96,// These folds should be beneficial regardless of when this pass is run; // in the optimization pipeline.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:83,Performance,optimiz,optimization,83,// These folds should be beneficial regardless of when this pass is run; // in the optimization pipeline.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:163,Safety,avoid,avoid,163,// These folds should be beneficial regardless of when this pass is run; // in the optimization pipeline.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:29,Performance,scalab,scalable,29,// This transform works with scalable and fixed vectors; // TODO: Identify and allow other scalable transforms,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:91,Performance,scalab,scalable,91,// This transform works with scalable and fixed vectors; // TODO: Identify and allow other scalable transforms,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:23,Deployability,pipeline,pipeline,23,"// If this is an early pipeline invocation of this pass, we are done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:157,Safety,avoid,avoid,157,"// Otherwise, try folds that improve codegen but may interfere with; // early IR canonicalizations.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:504,Performance,optimiz,optimize,504,"//===- VPlan.cpp - Vectorizer Plan ----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the LLVM vectorization plan. It represents a candidate for; /// vectorization, allowing to plan and optimize how to vectorize a given loop; /// before generating LLVM-IR.; /// The vectorizer uses vectorization plans to estimate the costs of potential; /// candidates and if profitable to execute the desired plan, generating vector; /// LLVM-IR code.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:9,Performance,Cache,Cache,9,// TODO: Cache created scalar values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:45,Modifiability,variab,variables,45,// Place the code for broadcasting invariant variables in the new preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:45,Modifiability,variab,variables,45,// Place the code for broadcasting invariant variables in the new preheader.; // Broadcast the scalar into all locations in the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:14,Performance,scalab,scalable,14,"// FIXME: For scalable vectors, assume vscale=1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:3,Deployability,Update,Update,3,// Update the branch instruction in the predecessor to branch to ExitBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:53,Performance,optimiz,optimization,53,"/* C */; // The last IR basic block is reused, as an optimization, in three cases:; // A. the first VPBB reuses the loop pre-header BB - when PrevVPBB is null;; // B. when the current VPBB has a single (hierarchical) predecessor which; // is PrevVPBB and the latter has a single (hierarchical) successor which; // both are in the same non-replicator region; and; // C. when the current VPBB is an entry of a region replica - where PrevVPBB; // is the exiting VPBB of this region from a previous instance, or the; // predecessor of this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:108,Deployability,update,updates,108,// Move the last step to the end of the latch block. This ensures; // consistent placement of all induction updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:76,Deployability,Update,Update,76,"// The vector body may be more than a single basic-block by this point.; // Update the dominator tree information inside the vector body by propagating; // it from header to latch, expecting only triangular control-flow, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:35,Performance,perform,performing,35,// Implement dot-formatted dump by performing plain-text dump into the; // temporary storage followed by some post-processing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:36,Integrability,wrap,wrap,36,// Use no indentation as we need to wrap the lines into quotes ourselves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:79,Deployability,update,update,79,"// If a user got removed after updating the current user, the next user to; // update will be moved to the current position, so we only need to; // increment the index if the number of users did not change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:515,Modifiability,inherit,inherit,515,"//===- VPlan.h - Represent A Vectorizer Plan --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains the declarations of the Vectorization Plan base classes:; /// 1. VPBasicBlock and VPRegionBlock that inherit from a common pure virtual; /// VPBlockBase, together implementing a Hierarchical CFG;; /// 2. Pure virtual VPRecipeBase serving as the base class for recipes contained; /// within VPBasicBlocks;; /// 3. Pure virtual VPSingleDefRecipe serving as a base class for recipes that; /// also inherit from VPValue.; /// 4. VPInstruction, a concrete Recipe and VPUser modeling a single planned; /// instruction;; /// 5. The VPlan class holding a candidate for vectorization;; /// 6. The VPlanPrinter class providing a way to print a plan in dot format;; /// These are documented in docs/VectorizationPlan.rst.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:809,Modifiability,inherit,inherit,809,"//===- VPlan.h - Represent A Vectorizer Plan --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains the declarations of the Vectorization Plan base classes:; /// 1. VPBasicBlock and VPRegionBlock that inherit from a common pure virtual; /// VPBlockBase, together implementing a Hierarchical CFG;; /// 2. Pure virtual VPRecipeBase serving as the base class for recipes contained; /// within VPBasicBlocks;; /// 3. Pure virtual VPSingleDefRecipe serving as a base class for recipes that; /// also inherit from VPValue.; /// 4. VPInstruction, a concrete Recipe and VPUser modeling a single planned; /// instruction;; /// 5. The VPlan class holding a candidate for vectorization;; /// 6. The VPlanPrinter class providing a way to print a plan in dot format;; /// These are documented in docs/VectorizationPlan.rst.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:145,Performance,scalab,scalable,145,"/// Returns a calculation for the total number of elements for a given \p VF.; /// For fixed width vectors this value is a constant, whereas for scalable; /// vectors it is an expression determined at runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Energy Efficiency,power,powers-of-,15,"/// A range of powers-of-2 vectorization factors with fixed start and; /// adjustable end. The range includes start and excludes end, e.g.,:; /// [1, 16) = {1, 2, 4, 8}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:5,Energy Efficiency,power,power,5,// A power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:5,Energy Efficiency,power,power,5,// A power of 2. If End <= Start range is empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:246,Performance,scalab,scalable,246,"/// In what follows, the term ""input IR"" refers to code that is fed into the; /// vectorizer whereas the term ""output IR"" refers to code that is generated by; /// the vectorizer.; /// VPLane provides a way to access lanes in both fixed width and scalable; /// vectors, where for the latter the lane index sometimes needs calculating; /// as a runtime expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:209,Security,access,access,209,"/// In what follows, the term ""input IR"" refers to code that is fed into the; /// vectorizer whereas the term ""output IR"" refers to code that is generated by; /// the vectorizer.; /// VPLane provides a way to access lanes in both fixed width and scalable; /// vectors, where for the latter the lane index sometimes needs calculating; /// as a runtime expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:100,Performance,scalab,scalable,100,"/// For First, Lane is the index into the first N elements of a; /// fixed-vector <N x <ElTy>> or a scalable vector <vscale x N x <ElTy>>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:8,Performance,Scalab,ScalableLast,8,"/// For ScalableLast, Lane is the offset from the start of the last; /// N-element subvector in a scalable vector <vscale x N x <ElTy>>. For; /// example, a Lane of 0 corresponds to lane `(vscale - 1) * N`, a Lane of; /// 1 corresponds to `((vscale - 1) * N) + 1`, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:98,Performance,scalab,scalable,98,"/// For ScalableLast, Lane is the offset from the start of the last; /// N-element subvector in a scalable vector <vscale x N x <ElTy>>. For; /// example, a Lane of 0 corresponds to lane `(vscale - 1) * N`, a Lane of; /// 1 corresponds to `((vscale - 1) * N) + 1`, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:62,Testability,assert,asserts,62,/// Returns a compile-time known value for the lane index and asserts if the; /// lane can only be calculated at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:23,Performance,cache,cache,23,/// Maps the lane to a cache index based on \p VF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:46,Availability,down,down,46,"/// VPTransformState holds information passed down when ""executing"" a VPlan,; /// needed for generating the output IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:196,Performance,perform,performed,196,/// LoopVersioning. It's only set up (non-null) if memchecks were; /// used.; ///; /// This is currently only used to add no-alias metadata based on the; /// memchecks. The actually versioning is performed manually.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:192,Modifiability,evolve,evolves,192,"/// \return an ID for the concrete type of this object.; /// This is used to implement the classof checks. This should not be used; /// for any other purpose, as the values may change as LLVM evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:14,Integrability,wrap,wrapped,14,"/// Fixup the wrapped LCSSA phi node in the unique exit block. This simply; /// means we need to add the appropriate incoming value from the middle; /// block as exiting edges from the scalar epilogue loop (if present) are; /// already in place, and we exit the vector loop exclusively to the middle; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:68,Usability,simpl,simply,68,"/// Fixup the wrapped LCSSA phi node in the unique exit block. This simply; /// means we need to add the appropriate incoming value from the middle; /// block as exiting edges from the scalar epilogue loop (if present) are; /// already in place, and we exit the vector loop exclusively to the middle; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:241,Modifiability,inherit,inherit,241,/// VPRecipeBase is a base class modeling a sequence of one or more output IR; /// instructions. VPRecipeBase owns the VPValues it defines through VPDef; /// and is responsible for deleting its defined values. Single-value; /// recipes must inherit from VPSingleDef instead of inheriting from both; /// VPRecipeBase and VPValue separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:277,Modifiability,inherit,inheriting,277,/// VPRecipeBase is a base class modeling a sequence of one or more output IR; /// instructions. VPRecipeBase owns the VPValues it defines through VPDef; /// and is responsible for deleting its defined values. Single-value; /// recipes must inherit from VPSingleDef instead of inheriting from both; /// VPRecipeBase and VPValue separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:171,Modifiability,inherit,inherited,171,/// VPSingleDef is a base class for recipes for modeling a sequence of one or; /// more output IR that define a single result VPValue.; /// Note that VPRecipeBase must be inherited from before VPValue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:58,Performance,load,loads,58,"// TODO: Widened stores don't define a value, but widened loads do. Split; // the recipes to be able to make widened loads VPSingleDefRecipes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:117,Performance,load,loads,117,"// TODO: Widened stores don't define a value, but widened loads do. Split; // the recipes to be able to make widened loads VPSingleDefRecipes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:19,Modifiability,extend,extending,19,"/// VPlan opcodes, extending LLVM IR with idiomatics instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:42,Integrability,depend,depending,42,"// CallInst may or may not have a result, depending on the called function.; // Conservatively return calls have results for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:56,Security,access,accesses,56,"/// A recipe to compute the pointers for widened memory accesses of IndexTy for; /// all parts. If IsReverse is true, compute pointers for accessing the input in; /// reverse order per part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:139,Security,access,accessing,139,"/// A recipe to compute the pointers for widened memory accesses of IndexTy for; /// all parts. If IsReverse is true, compute pointers for accessing the input in; /// reverse order per part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:492,Usability,resume,resume,492,"/// A pure virtual base class for all recipes modeling header phis, including; /// phis for first order recurrences, pointer inductions and reductions. The; /// start value is the first operand of the recipe and the incoming value from; /// the backedge is the second operand.; ///; /// Inductions are modeled using the following sub-classes:; /// * VPCanonicalIVPHIRecipe: Canonical scalar induction of the vector loop,; /// starting at a specified value (zero for the main vector loop, the resume; /// value for the epilogue vector loop) and stepping by 1. The induction; /// controls exiting of the vector loop by comparing against the vector trip; /// count. Produces a single scalar PHI for the induction value per; /// iteration.; /// * VPWidenIntOrFpInductionRecipe: Generates vector values for integer and; /// floating point inductions with arbitrary start and step values. Produces; /// a vector PHI per-part.; /// * VPDerivedIVRecipe: Converts the canonical IV value to the corresponding; /// value of an IV with different start and step values. Produces a single; /// scalar value per iteration; /// * VPScalarIVStepsRecipe: Generates scalar values per-lane based on a; /// canonical or derived induction.; /// * VPWidenPointerInductionRecipe: Generate vector and scalar values for a; /// pointer induction. Produces either a vector PHI per-part or scalar values; /// per-lane based on the canonical induction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:4,Deployability,Update,Update,4,/// Update the start value of the recipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:57,Availability,mask,mask-based,57,/// A recipe for vectorizing a phi-node as a sequence of mask-based select; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:86,Availability,mask,masks,86,"/// The blend operation is a User of the incoming values and of their; /// respective masks, ordered [I0, M0, I1, M1, ...]. Note that a single value; /// might be incoming with a full mask for which there is no VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:184,Availability,mask,mask,184,"/// The blend operation is a User of the incoming values and of their; /// respective masks, ordered [I0, M0, I1, M1, ...]. Note that a single value; /// might be incoming with a full mask for which there is no VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:103,Availability,mask,mask,103,"/// Return the number of incoming values, taking into account that a single; /// incoming value has no mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:11,Availability,mask,mask,11,/// Return mask number \p Idx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:258,Availability,mask,mask,258,"/// VPInterleaveRecipe is a recipe for transforming an interleave group of load; /// or stores into one wide load/store and shuffles. The first operand of a; /// VPInterleave recipe is the address, followed by the stored values, followed; /// by an optional mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:75,Performance,load,load,75,"/// VPInterleaveRecipe is a recipe for transforming an interleave group of load; /// or stores into one wide load/store and shuffles. The first operand of a; /// VPInterleave recipe is the address, followed by the stored values, followed; /// by an optional mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:109,Performance,load,load,109,"/// VPInterleaveRecipe is a recipe for transforming an interleave group of load; /// or stores into one wide load/store and shuffles. The first operand of a; /// VPInterleave recipe is the address, followed by the stored values, followed; /// by an optional mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:84,Availability,mask,mask,84,/// Indicates if the interleave group is in a conditional block and requires a; /// mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:62,Availability,mask,masked,62,/// Indicates if gaps between members of the group need to be masked out or if; /// unusued gaps can be loaded speculatively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:104,Performance,load,loaded,104,/// Indicates if gaps between members of the group need to be masked out or if; /// unusued gaps can be loaded speculatively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:23,Security,access,accessed,23,/// Return the address accessed by this recipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Availability,mask,mask,15,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:58,Availability,mask,mask,58,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Availability,Mask,Mask,3,"// Mask is optional and therefore the last, currently 2nd operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:68,Performance,load,load,68,"/// Return the VPValues stored by this interleave group. If it is a load; /// interleave group, return an empty ArrayRef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:96,Availability,mask,mask,96,"// The first operand is the address, followed by the stored values, followed; // by an optional mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:22,Performance,load,load,22,"/// Generate the wide load or store, and shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:87,Performance,load,load,87,/// Returns the number of stored operands of this interleave group. Returns 0; /// for load interleave groups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:55,Performance,perform,performing,55,"/// A recipe to represent inloop reduction operations, performing a reduction on; /// a vector operand into a scalar value, and adding the result to a chain.; /// The Operands are {ChainOp, VecOp, [Condition]}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:42,Energy Efficiency,reduce,reduced,42,/// The VPValue of the vector value to be reduced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Availability,mask,mask,15,/// Return the mask of a predicated VPReplicateRecipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:66,Availability,mask,mask,66,/// A recipe for generating conditional branches on the bits of a mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:25,Availability,mask,mask,25,// nullptr means all-one mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:66,Availability,mask,mask,66,/// Generate the extraction of the appropriate bit from the block mask and the; /// conditional branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Availability,mask,mask,15,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:58,Availability,mask,mask,58,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Availability,Mask,Mask,3,// Mask is optional.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:122,Availability,Mask,Mask,122,/// VPPredInstPHIRecipe is a recipe for generating the phi nodes needed when; /// control converges back from a Branch-on-Mask. The phi nodes are needed in; /// order to merge values that are set under such a branch and feed their uses.; /// The phi nodes can be scalar or vector depending on the users of the value.; /// This recipe works in concert with VPBranchOnMaskRecipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:280,Integrability,depend,depending,280,/// VPPredInstPHIRecipe is a recipe for generating the phi nodes needed when; /// control converges back from a Branch-on-Mask. The phi nodes are needed in; /// order to merge values that are set under such a branch and feed their uses.; /// The phi nodes can be scalar or vector depending on the users of the value.; /// This recipe works in concert with VPBranchOnMaskRecipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:125,Availability,Mask,Mask,125,/// Construct a VPPredInstPHIRecipe given \p PredInst whose value needs a phi; /// nodes after merging back from a Branch-on-Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:129,Availability,mask,mask,129,"/// A Recipe for widening load/store operations.; /// The recipe uses the following VPValues:; /// - For load: Address, optional mask; /// - For store: Address, stored value, optional mask; /// TODO: We currently execute only per-part unless a specific instance is; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:184,Availability,mask,mask,184,"/// A Recipe for widening load/store operations.; /// The recipe uses the following VPValues:; /// - For load: Address, optional mask; /// - For store: Address, stored value, optional mask; /// TODO: We currently execute only per-part unless a specific instance is; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:26,Performance,load,load,26,"/// A Recipe for widening load/store operations.; /// The recipe uses the following VPValues:; /// - For load: Address, optional mask; /// - For store: Address, stored value, optional mask; /// TODO: We currently execute only per-part unless a specific instance is; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:105,Performance,load,load,105,"/// A Recipe for widening load/store operations.; /// The recipe uses the following VPValues:; /// - For load: Address, optional mask; /// - For store: Address, stored value, optional mask; /// TODO: We currently execute only per-part unless a specific instance is; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Performance,load,loaded-from,15,// Whether the loaded-from / stored-to addresses are consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:27,Performance,load,loaded,27,// Whether the consecutive loaded/stored addresses are in reverse order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:23,Security,access,accessed,23,/// Return the address accessed by this recipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Availability,mask,mask,15,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:58,Availability,mask,mask,58,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Availability,Mask,Mask,3,// Mask is optional and therefore the last operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:23,Security,access,accessed,23,/// Return the address accessed by this recipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:22,Performance,load,loaded-from,22,// Return whether the loaded-from / stored-to addresses are consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:34,Performance,load,loaded,34,// Return whether the consecutive loaded/stored addresses are in reverse; // order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:22,Performance,load,load,22,/// Generate the wide load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:42,Modifiability,variab,variable,42,"/// Generate a canonical vector induction variable of the vector loop, with",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:257,Modifiability,variab,variable,257,/// Canonical scalar induction phi of the vector loop. Starting at the specified; /// start value (either 0 or the resume value when vectorizing the epilogue; /// loop). VPWidenCanonicalIVRecipe represents the vector version of the; /// canonical induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:115,Usability,resume,resume,115,/// Canonical scalar induction phi of the vector loop. Starting at the specified; /// start value (either 0 or the resume value when vectorizing the epilogue; /// loop). VPWidenCanonicalIVRecipe represents the vector version of the; /// canonical induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:44,Availability,mask,mask,44,/// A recipe for generating the active lane mask for the vector loop that is; /// used to predicate the vector operations.; /// TODO: It would be good to use the existing VPWidenPHIRecipe instead and; /// remove VPActiveLaneMaskPHIRecipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:29,Availability,mask,mask,29,/// Generate the active lane mask phi of the vector loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:50,Modifiability,variab,variable,50,/// A Recipe for widening the canonical induction variable of the vector loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:42,Modifiability,variab,variable,42,"/// Generate a canonical vector induction variable of the vector loop, with; /// start = {<Part*VF, Part*VF+1, ..., Part*VF+VF-1> for 0 <= Part < UF}, and; /// step = <VF*UF, VF*UF, ..., VF*UF>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:112,Deployability,Update,Update,112,"/// Create an IR BasicBlock to hold the output instructions generated by this; /// VPBasicBlock, and return it. Update the CFGState accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:96,Energy Efficiency,efficient,efficient,96,"/// VPlan models a candidate for vectorization, encoding various decisions take; /// to produce efficient output IR, including which branches, basic-blocks and; /// output IR instructions to generate, and their cost. VPlan holds a; /// Hierarchical-CFG of VPBasicBlocks and VPRegionBlocks rooted at an Entry; /// VPBasicBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:28,Safety,safe,safe,28,"/// Indicates whether it is safe use the Value2VPValue mapping or if the; /// mapping cannot be used any longer, because it is stale.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:67,Integrability,wrap,wrapping,67,"/// Create initial VPlan skeleton, having an ""entry"" VPBasicBlock (wrapping; /// original scalar pre-header) which contains SCEV expansions that need to; /// happen before the CFG is modified; a VPBasicBlock for the vector; /// pre-header, followed by a region for the vector loop, followed by the; /// middle VPBasicBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:62,Safety,safe,safe,62,"/// Mark the plan to indicate that using Value2VPValue is not safe any; /// longer, because it may be stale.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:108,Safety,safe,safe,108,/// Returns the VPValue for \p V. \p OverrideAllowed can be used to disable; /// /// checking whether it is safe to query VPValues using IR Values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:91,Security,access,accesses,91,/// Return an iterator range over \p Range which only includes \p BlockTy; /// blocks. The accesses are casted to \p BlockTy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Safety,Avoid,Avoid,3,// Avoid releasing a pointer twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:69,Security,access,access,69,/// Reorder operands in the multi node to maximize sequential memory access; /// and commutative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:160,Performance,load,loads,160,/// Choose the best candidate to use for the lane after \p Last. The set of; /// candidates to choose from are values with an opcode matching \p Last's; /// or loads consecutive to \p Last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:141,Integrability,wrap,wrapping,141,"/// Get or create a VPValue that corresponds to the expansion of \p Expr. If \p; /// Expr is a SCEVConstant or SCEVUnknown, return a VPValue wrapping the live-in; /// value. Otherwise return a VPExpandSCEVRecipe to expand \p Expr. If \p Plan's; /// pre-header already contains a recipe expanding \p Expr, return it. If not,; /// create a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h:272,Availability,down,down,272,/// An analysis for type-inference for VPValues.; /// It infers the scalar type for a given VPValue by bottom-up traversing; /// through defining recipes until root nodes with known types are reached (e.g.; /// live-ins or load recipes). The types are then propagated top down through; /// operations.; /// Note that the analysis caches the inferred types. A new analysis object must; /// be constructed once a VPlan has been modified in a way that invalidates any; /// of the previously inferred types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h:223,Performance,load,load,223,/// An analysis for type-inference for VPValues.; /// It infers the scalar type for a given VPValue by bottom-up traversing; /// through defining recipes until root nodes with known types are reached (e.g.; /// live-ins or load recipes). The types are then propagated top down through; /// operations.; /// Note that the analysis caches the inferred types. A new analysis object must; /// be constructed once a VPlan has been modified in a way that invalidates any; /// of the previously inferred types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h:330,Performance,cache,caches,330,/// An analysis for type-inference for VPValues.; /// It infers the scalar type for a given VPValue by bottom-up traversing; /// through defining recipes until root nodes with known types are reached (e.g.; /// live-ins or load recipes). The types are then propagated top down through; /// operations.; /// Note that the analysis caches the inferred types. A new analysis object must; /// be constructed once a VPlan has been modified in a way that invalidates any; /// of the previously inferred types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h:65,Usability,simpl,simply,65,"/// Index of the current successor. For VPBasicBlock nodes, this simply is the; /// index for the successor array. For VPRegionBlock, SuccessorIdx == 0 is; /// used for the region's entry block, and SuccessorIdx - 1 are the indices; /// for the successor array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h:301,Security,access,access,301,"// The following set of template specializations implement GraphTraits to treat; // any VPBlockBase as a node in a graph of VPBlockBases. It's important to note; // that VPBlockBase traits don't recurse into VPRegioBlocks, i.e., if the; // VPBlockBase is a VPRegionBlock, this specialization provides access to its; // successors/predecessors but not to the blocks inside the region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:32,Usability,simpl,simplify,32,"// The input IR must be in loop-simplify form, ensuring a single predecessor; // for exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:8,Integrability,interface,interface,8,// Main interface to build the plain CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:176,Deployability,update,update,176,"// 0. Reuse the top-level region, vector-preheader and exit VPBBs from the; // skeleton. These were created directly rather than via getOrCreateVPBB(),; // revisit them now to update BB2VPBB. Note that header/entry and; // latch/exiting VPBB's of top-level region have yet to be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:82,Integrability,wrap,wraps,82,// ThePreheaderBB conceptually corresponds to both Plan.getPreheader() (which; // wraps the original preheader BB) and Plan.getEntry() (which represents the; // new vector preheader); here we're interested in setting BB2VPBB to the; // latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:10,Integrability,interface,interface,10,// Public interface to build a H-CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h:472,Integrability,interface,interface,472,"//===-- VPlanHCFGBuilder.h --------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the VPlanHCFGBuilder class which contains the public; /// interface (buildHierarchicalCFG) to build a VPlan-based Hierarchical CFG; /// (H-CFG) for an incoming IR.; ///; /// A H-CFG in VPlan is a control-flow graph whose nodes are VPBasicBlocks; /// and/or VPRegionBlocks (i.e., other H-CFGs). The outermost H-CFG of a VPlan; /// consists of a VPRegionBlock, denoted Top Region, which encloses any other; /// VPBlockBase in the H-CFG. This guarantees that any VPBlockBase in the H-CFG; /// other than the Top Region will have a parent VPRegionBlock and allows us; /// to easily add more nodes before/after the main vector loop (such as the; /// reduction epilogue).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h:32,Deployability,update,update,32,/// Build H-CFG for TheLoop and update Plan accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:38,Modifiability,variab,variable,38,// Get first lane of vector induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:27,Integrability,depend,dependency,27,// FIXME: The cross-recipe dependency on VPReductionPHIRecipe is temporary; // and will be removed by breaking up the recipe further.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:21,Modifiability,variab,variable,21,// Get its reduction variable descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:84,Modifiability,extend,extend,84,"// If the vector reduction can be performed in a smaller type, we truncate; // then extend the loop exit value to enable InstCombine to evaluate the; // entire expression in the smaller type.; // TODO: Handle this in truncateToMinBW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:34,Performance,perform,performed,34,"// If the vector reduction can be performed in a smaller type, we truncate; // then extend the loop exit value to enable InstCombine to evaluate the; // entire expression in the smaller type.; // TODO: Handle this in truncateToMinBW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce all of the unrolled parts into a single vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:67,Modifiability,extend,extend,67,"// If the reduction can be performed in a smaller type, we need to extend; // the reduction to the wider type before we branch to the original loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:27,Performance,perform,performed,27,"// If the reduction can be performed in a smaller type, we need to extend; // the reduction to the wider type before we branch to the original loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:41,Usability,simpl,simple,41,// This instruction is not vectorized by simple widening.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:212,Modifiability,variab,variable,212,"/// This function adds; /// (StartIdx * Step, (StartIdx + 1) * Step, (StartIdx + 2) * Step, ...); /// to each vector element of Val. The sequence starts at StartIndex.; /// \p Opcode is relevant for FP induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:82,Modifiability,variab,variable,82,// The value from the original loop to which we are mapping the new induction; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:80,Modifiability,variab,variables,80,"// We create vector phi nodes for both integer and floating-point induction; // variables. Here, we determine the kind of arithmetic we will perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:141,Performance,perform,perform,141,"// We create vector phi nodes for both integer and floating-point induction; // variables. Here, we determine the kind of arithmetic we will perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:49,Deployability,update,update,49,"// Create a vector splat to use in the induction update.; //; // FIXME: If the step is non-constant, we create the vector splat with; // IRBuilder. IRBuilder can constant-fold the multiply, but it doesn't; // handle a constant vector splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:50,Integrability,depend,depending,50,"// We may need to add the step a number of times, depending on the unroll; // factor. The last of those goes into the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:17,Deployability,update,update,17,"// Add induction update using an incorrect block temporarily. The phi node; // will be fixed after VPlan execution. Note that at this point the latch; // block cannot be used, as it does not exist yet.; // TODO: Model increment value in VPlan, by turning the recipe into a; // multi-def and a subclass of VPHeaderPHIRecipe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:77,Modifiability,variab,variable,77,"/// Compute scalar induction steps. \p ScalarIV is the scalar induction; /// variable on which to base the steps, \p Step is the size of the step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:80,Safety,avoid,avoid,80,"// TODO: Also use VPDerivedIVRecipe when only the step needs truncating, to; // avoid separate truncate here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:75,Modifiability,variab,variables,75,"// We build scalar steps for both integer and floating-point induction; // variables. Here, we determine the kind of arithmetic we will perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:136,Performance,perform,perform,136,"// We build scalar steps for both integer and floating-point induction; // variables. Here, we determine the kind of arithmetic we will perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:86,Performance,scalab,scalable,86,"// The step returned by `createStepForVF` is a runtime-evaluated value; // when VF is scalable. Otherwise, it should be folded into a Constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:303,Performance,optimiz,optimizations,303,"// We know that all PHIs in non-header blocks are converted into; // selects, so we don't have to worry about the insertion order and we; // can just use the builder.; // At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:265,Usability,simpl,simple,265,"// We know that all PHIs in non-header blocks are converted into; // selects, so we don't have to worry about the insertion order and we; // can just use the builder.; // At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:93,Availability,mask,mask,93,// Select between the current value and the previous incoming edge; // based on the incoming mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:21,Availability,mask,mask,21,"// Not a User of any mask: not really blending, this is a; // single-predecessor phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:12,Availability,mask,mask,12,// Block in mask is all-one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:26,Testability,log,logic,26,"// By current pack/unpack logic we need to generate only a single phi node: if; // a vector value for the predicated instruction exists at this point it means; // the instruction has vector users only, and a phi for the vector value is; // needed. In this case the recipe of the predicated instruction is marked to; // also do that packing, thereby ""hoisting"" the insert-element sequence.; // Otherwise, a phi node for the scalar value is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:30,Deployability,update,update,30,"// NOTE: Currently we need to update the value of the operand, so the next; // predicated iteration inserts its generated value in the correct vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:30,Deployability,update,update,30,"// NOTE: Currently we need to update the value of the operand, so the next; // predicated iteration inserts its generated value in the correct vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:7,Performance,load,loads,7,"// For loads, check that there are no instructions writing to memory in; // between them.; // TODO: we only have to forbid instructions writing to memory that could; // interfere with any of the loads in the bundle",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:195,Performance,load,loads,195,"// For loads, check that there are no instructions writing to memory in; // between them.; // TODO: we only have to forbid instructions writing to memory that could; // interfere with any of the loads in the bundle",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:65,Performance,load,loads,65,/// Returns true if A and B access sequential memory if they are loads or; /// stores or if they have identical opcodes otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:28,Security,access,access,28,/// Returns true if A and B access sequential memory if they are loads or; /// stores or if they have identical opcodes otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid visiting the same operands multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:45,Performance,load,loads,45,// Create VPWidenMemoryInstructionRecipe for loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:2,Availability,Mask,Mask,2,/*Mask*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:2,Availability,Mask,Mask,2,/*Mask*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:88,Availability,mask,mask,88,"/// If \p R is a region with a VPBranchOnMaskRecipe in the entry block, return; /// the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:112,Availability,mask,masks,112,"// Collect replicate regions followed by an empty block, followed by another; // replicate region with matching masks to process front. This is to avoid; // iterator invalidation issues while merging regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:147,Safety,avoid,avoid,147,"// Collect replicate regions followed by an empty block, followed by another; // replicate region with matching masks to process front. This is to avoid; // iterator invalidation issues while merging regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:37,Integrability,depend,dependencies,37,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:90,Integrability,depend,dependencies,90,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:137,Integrability,depend,dependence,137,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:176,Security,access,accesses,176,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:93,Deployability,Update,Update,93,// Move VPPredInstPHIRecipes from the merge block to the successor region's; // merge block. Update all users inside the successor region to use the; // original values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:77,Availability,mask,mask,77,// Replace predicated replicate recipe with a replicate recipe without a; // mask but in the replicate region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:52,Performance,optimiz,optimizations,52,// Record predicated instructions for above packing optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:11,Availability,mask,masked,11,// Convert masked VPReplicateRecipes to if-then region blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:18,Availability,alive,alive,18,// A user keeps R alive:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:31,Availability,alive,alive,31,"// Having side effects keeps R alive, but do remove conditional assume; // instructions as their conditions may be flattened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:3,Deployability,Update,Update,3,// Update scalar users of IV to use Step instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:10,Usability,simpl,simplify,10,"// Try to simplify the branch condition if TC <= VF * UF when preparing to; // execute the plan for the main vector loop. We only do this if the; // terminator is:; // 1. BranchOnCount, or; // 2. BranchOnCond where the input is Not(ActiveLaneMask).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:17,Usability,simpl,simplifications,17,// TODO: Further simplifications are possible; // 1. Replace inductions with constants.; // 2. Replace vector loop region with VPBasicBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:31,Integrability,depend,depend,31,"// The previous value must not depend on the users of the recurrence phi. In; // that case, FOR is not a fixed order recurrence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:11,Usability,simpl,simplify,11,/// Try to simplify recipe \p R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:19,Performance,cache,cached,19,// Verify that the cached type info is for both A and its users is still; // accurate by comparing it to freshly computed types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:11,Usability,simpl,simplify,11,/// Try to simplify the recipes in \p Plan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:215,Availability,redundant,redundant,215,"// If the value wasn't vectorized, we must maintain the original scalar; // type. Skip those here, after incrementing NumProcessedRecipes. Also; // skip casts which do not need to be handled explicitly here, as; // redundant casts will be removed during recipe simplification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:215,Safety,redund,redundant,215,"// If the value wasn't vectorized, we must maintain the original scalar; // type. Skip those here, after incrementing NumProcessedRecipes. Also; // skip casts which do not need to be handled explicitly here, as; // redundant casts will be removed during recipe simplification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:261,Usability,simpl,simplification,261,"// If the value wasn't vectorized, we must maintain the original scalar; // type. Skip those here, after incrementing NumProcessedRecipes. Also; // skip casts which do not need to be handled explicitly here, as; // redundant casts will be removed during recipe simplification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:38,Safety,avoid,avoid,38,// Add an entry to ProcessedTruncs to avoid counting the same; // operand multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:7,Integrability,wrap,wrapping,7,"// Any wrapping introduced by shrinking this operation shouldn't be; // considered undefined behavior. So, we can't unconditionally copy; // arithmetic wrapping flags to VPW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:152,Integrability,wrap,wrapping,152,"// Any wrapping introduced by shrinking this operation shouldn't be; // considered undefined behavior. So, we can't unconditionally copy; // arithmetic wrapping flags to VPW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:3,Modifiability,Extend,Extend,3,// Extend result to original width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:164,Availability,mask,mask,164,"// Add a VPActiveLaneMaskPHIRecipe and related recipes to \p Plan and replace; // the loop terminator with a branch-on-cond recipe with the negated; // active-lane-mask as operand. Note that this turns the loop into an; // uncountable one. Only the existing terminator is replaced, all other existing; // recipes/users remain unchanged, except for poison-generating flags being; // dropped from the canonical IV increment. Return the created; // VPActiveLaneMaskPHIRecipe.; //; // The function uses the following definitions:; //; // %TripCount = DataWithControlFlowWithoutRuntimeCheck ?; // calculate-trip-count-minus-VF (original TC) : original TC; // %IncrementValue = DataWithControlFlowWithoutRuntimeCheck ?; // CanonicalIVPhi : CanonicalIVIncrement; // %StartV is the canonical induction start value.; //; // The function adds the following recipes:; //; // vector.ph:; // %TripCount = calculate-trip-count-minus-VF (original TC); // [if DataWithControlFlowWithoutRuntimeCheck]; // %EntryInc = canonical-iv-increment-for-part %StartV; // %EntryALM = active-lane-mask %EntryInc, %TripCount; //; // vector.body:; // ...; // %P = active-lane-mask-phi [ %EntryALM, %vector.ph ], [ %ALM, %vector.body ]; // ...; // %InLoopInc = canonical-iv-increment-for-part %IncrementValue; // %ALM = active-lane-mask %InLoopInc, TripCount; // %Negated = Not %ALM; // branch-on-cond %Negated; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:1068,Availability,mask,mask,1068,"// Add a VPActiveLaneMaskPHIRecipe and related recipes to \p Plan and replace; // the loop terminator with a branch-on-cond recipe with the negated; // active-lane-mask as operand. Note that this turns the loop into an; // uncountable one. Only the existing terminator is replaced, all other existing; // recipes/users remain unchanged, except for poison-generating flags being; // dropped from the canonical IV increment. Return the created; // VPActiveLaneMaskPHIRecipe.; //; // The function uses the following definitions:; //; // %TripCount = DataWithControlFlowWithoutRuntimeCheck ?; // calculate-trip-count-minus-VF (original TC) : original TC; // %IncrementValue = DataWithControlFlowWithoutRuntimeCheck ?; // CanonicalIVPhi : CanonicalIVIncrement; // %StartV is the canonical induction start value.; //; // The function adds the following recipes:; //; // vector.ph:; // %TripCount = calculate-trip-count-minus-VF (original TC); // [if DataWithControlFlowWithoutRuntimeCheck]; // %EntryInc = canonical-iv-increment-for-part %StartV; // %EntryALM = active-lane-mask %EntryInc, %TripCount; //; // vector.body:; // ...; // %P = active-lane-mask-phi [ %EntryALM, %vector.ph ], [ %ALM, %vector.body ]; // ...; // %InLoopInc = canonical-iv-increment-for-part %IncrementValue; // %ALM = active-lane-mask %InLoopInc, TripCount; // %Negated = Not %ALM; // branch-on-cond %Negated; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:1145,Availability,mask,mask-phi,1145,"// Add a VPActiveLaneMaskPHIRecipe and related recipes to \p Plan and replace; // the loop terminator with a branch-on-cond recipe with the negated; // active-lane-mask as operand. Note that this turns the loop into an; // uncountable one. Only the existing terminator is replaced, all other existing; // recipes/users remain unchanged, except for poison-generating flags being; // dropped from the canonical IV increment. Return the created; // VPActiveLaneMaskPHIRecipe.; //; // The function uses the following definitions:; //; // %TripCount = DataWithControlFlowWithoutRuntimeCheck ?; // calculate-trip-count-minus-VF (original TC) : original TC; // %IncrementValue = DataWithControlFlowWithoutRuntimeCheck ?; // CanonicalIVPhi : CanonicalIVIncrement; // %StartV is the canonical induction start value.; //; // The function adds the following recipes:; //; // vector.ph:; // %TripCount = calculate-trip-count-minus-VF (original TC); // [if DataWithControlFlowWithoutRuntimeCheck]; // %EntryInc = canonical-iv-increment-for-part %StartV; // %EntryALM = active-lane-mask %EntryInc, %TripCount; //; // vector.body:; // ...; // %P = active-lane-mask-phi [ %EntryALM, %vector.ph ], [ %ALM, %vector.body ]; // ...; // %InLoopInc = canonical-iv-increment-for-part %IncrementValue; // %ALM = active-lane-mask %InLoopInc, TripCount; // %Negated = Not %ALM; // branch-on-cond %Negated; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:1300,Availability,mask,mask,1300,"// Add a VPActiveLaneMaskPHIRecipe and related recipes to \p Plan and replace; // the loop terminator with a branch-on-cond recipe with the negated; // active-lane-mask as operand. Note that this turns the loop into an; // uncountable one. Only the existing terminator is replaced, all other existing; // recipes/users remain unchanged, except for poison-generating flags being; // dropped from the canonical IV increment. Return the created; // VPActiveLaneMaskPHIRecipe.; //; // The function uses the following definitions:; //; // %TripCount = DataWithControlFlowWithoutRuntimeCheck ?; // calculate-trip-count-minus-VF (original TC) : original TC; // %IncrementValue = DataWithControlFlowWithoutRuntimeCheck ?; // CanonicalIVPhi : CanonicalIVIncrement; // %StartV is the canonical induction start value.; //; // The function adds the following recipes:; //; // vector.ph:; // %TripCount = calculate-trip-count-minus-VF (original TC); // [if DataWithControlFlowWithoutRuntimeCheck]; // %EntryInc = canonical-iv-increment-for-part %StartV; // %EntryALM = active-lane-mask %EntryInc, %TripCount; //; // vector.body:; // ...; // %P = active-lane-mask-phi [ %EntryALM, %vector.ph ], [ %ALM, %vector.body ]; // ...; // %InLoopInc = canonical-iv-increment-for-part %IncrementValue; // %ALM = active-lane-mask %InLoopInc, TripCount; // %Negated = Not %ALM; // branch-on-cond %Negated; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:167,Availability,mask,mask,167,"// When the loop is guarded by a runtime overflow check for the loop; // induction variable increment by VF, we can increment the value before; // the get.active.lane mask and use the unmodified tripcount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:83,Modifiability,variab,variable,83,"// When the loop is guarded by a runtime overflow check for the loop; // induction variable increment by VF, we can increment the value before; // the get.active.lane mask and use the unmodified tripcount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:50,Availability,mask,mask,50,"// When avoiding a runtime check, the active.lane.mask inside the loop; // uses a modified trip count and the induction variable increment is; // done after the active.lane.mask intrinsic is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:173,Availability,mask,mask,173,"// When avoiding a runtime check, the active.lane.mask inside the loop; // uses a modified trip count and the induction variable increment is; // done after the active.lane.mask intrinsic is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:120,Modifiability,variab,variable,120,"// When avoiding a runtime check, the active.lane.mask inside the loop; // uses a modified trip count and the induction variable increment is; // done after the active.lane.mask intrinsic is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:8,Safety,avoid,avoiding,8,"// When avoiding a runtime check, the active.lane.mask inside the loop; // uses a modified trip count and the induction variable increment is; // done after the active.lane.mask intrinsic is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:26,Availability,mask,mask,26,// Create the active lane mask instruction in the VPlan preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:26,Availability,mask,mask,26,// Create the active lane mask for the next iteration of the loop before the; // original terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:80,Availability,mask,mask,80,// Replace the original terminator with BranchOnCond. We have to invert the; // mask here because a true condition means jumping to the exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:148,Availability,mask,mask,148,"// Walk users of WideCanonicalIV and replace all compares of the form; // (ICMP_ULE, WideCanonicalIV, backedge-taken-count) with an; // active-lane-mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:4,Usability,Clear,Clear,4,/// Clear NSW/NUW flags from reduction instructions if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:4,Performance,Optimiz,Optimize,4,/// Optimize \p Plan based on \p BestVF and \p BestUF. This may restrict the; /// resulting plan to \p BestVF and \p BestUF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:25,Performance,optimiz,optimizations,25,"/// Apply VPlan-to-VPlan optimizations to \p Plan, including induction recipe; /// optimizations, dead recipe removal, replicate region optimizations and; /// block merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:83,Performance,optimiz,optimizations,83,"/// Apply VPlan-to-VPlan optimizations to \p Plan, including induction recipe; /// optimizations, dead recipe removal, replicate region optimizations and; /// block merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:136,Performance,optimiz,optimizations,136,"/// Apply VPlan-to-VPlan optimizations to \p Plan, including induction recipe; /// optimizations, dead recipe removal, replicate region optimizations and; /// block merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:46,Availability,mask,mask,46,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:106,Availability,mask,mask,106,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:4,Integrability,Wrap,Wrap,4,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:120,Performance,Optimiz,Optimize,120,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:97,Availability,mask,mask,97,"/// Replace (ICMP_ULE, wide canonical IV, backedge-taken-count) checks with an; /// (active-lane-mask recipe, wide canonical IV, trip-count). If \p; /// UseActiveLaneMaskForControlFlow is true, introduce an; /// VPActiveLaneMaskPHIRecipe. If \p DataAndControlFlowWithoutRuntimeCheck is; /// true, no minimum-iteration runtime check will be created (during skeleton; /// creation) and instead it is handled using active-lane-mask. \p; /// DataAndControlFlowWithoutRuntimeCheck implies \p; /// UseActiveLaneMaskForControlFlow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:424,Availability,mask,mask,424,"/// Replace (ICMP_ULE, wide canonical IV, backedge-taken-count) checks with an; /// (active-lane-mask recipe, wide canonical IV, trip-count). If \p; /// UseActiveLaneMaskForControlFlow is true, introduce an; /// VPActiveLaneMaskPHIRecipe. If \p DataAndControlFlowWithoutRuntimeCheck is; /// true, no minimum-iteration runtime check will be created (during skeleton; /// creation) and instead it is handled using active-lane-mask. \p; /// DataAndControlFlowWithoutRuntimeCheck implies \p; /// UseActiveLaneMaskForControlFlow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:59,Availability,Redundant,Redundant,59,/// Insert truncates and extends for any truncated recipe. Redundant casts; /// will be folded later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:25,Modifiability,extend,extends,25,/// Insert truncates and extends for any truncated recipe. Redundant casts; /// will be folded later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:59,Safety,Redund,Redundant,59,/// Insert truncates and extends for any truncated recipe. Redundant casts; /// will be folded later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Availability,redundant,redundant,11,/// Remove redundant VPBasicBlocks by merging them into their predecessor if; /// the predecessor has a single successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Safety,redund,redundant,11,/// Remove redundant VPBasicBlocks by merging them into their predecessor if; /// the predecessor has a single successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Availability,redundant,redundant,11,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:57,Availability,redundant,redundant,57,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:96,Modifiability,variab,variables,96,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Safety,redund,redundant,11,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:57,Safety,redund,redundant,57,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:155,Deployability,update,update,155,"/// If any user of a VPWidenIntOrFpInductionRecipe needs scalar values,; /// provide them by building scalar steps off of the canonical scalar IV and; /// update the original IV's users. This is an optional optimization to reduce; /// the needs of vector extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:223,Energy Efficiency,reduce,reduce,223,"/// If any user of a VPWidenIntOrFpInductionRecipe needs scalar values,; /// provide them by building scalar steps off of the canonical scalar IV and; /// update the original IV's users. This is an optional optimization to reduce; /// the needs of vector extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:207,Performance,optimiz,optimization,207,"/// If any user of a VPWidenIntOrFpInductionRecipe needs scalar values,; /// provide them by building scalar steps off of the canonical scalar IV and; /// update the original IV's users. This is an optional optimization to reduce; /// the needs of vector extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Availability,redundant,redundant,11,/// Remove redundant EpxandSCEVRecipes in \p Plan's entry block by replacing; /// them with already existing recipes expanding the same SCEV expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Safety,redund,redundant,11,/// Remove redundant EpxandSCEVRecipes in \p Plan's entry block by replacing; /// them with already existing recipes expanding the same SCEV expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:21,Security,Access,Access,21,"// DESIGN PRINCIPLE: Access to the underlying IR must be strictly limited to; // the front-end and back-end of VPlan so that the middle-end is as; // independent as possible of the underlying IR. We grant access to the; // underlying IR using friendship. In that way, we should be able to use VPlan; // for multiple underlying IRs (Polly?) by providing a new VPlan front-end,; // back-end and analysis information for the new IR.; // Set \p Val as the underlying Value of this VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:205,Security,access,access,205,"// DESIGN PRINCIPLE: Access to the underlying IR must be strictly limited to; // the front-end and back-end of VPlan so that the middle-end is as; // independent as possible of the underlying IR. We grant access to the; // underlying IR using friendship. In that way, we should be able to use VPlan; // for multiple underlying IRs (Polly?) by providing a new VPlan front-end,; // back-end and analysis information for the new IR.; // Set \p Val as the underlying Value of this VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:192,Modifiability,evolve,evolves,192,"/// \return an ID for the concrete type of this object.; /// This is used to implement the classof checks. This should not be used; /// for any other purpose, as the values may change as LLVM evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:273,Modifiability,inherit,inherit,273,"/// This class augments a recipe with a set of VPValues defined by the recipe.; /// It allows recipes to define zero, one or multiple VPValues. A VPDef owns; /// the VPValues it defines and is responsible for deleting its defined values.; /// Single-value VPDefs that also inherit from VPValue must make sure to inherit; /// from VPDef before VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:312,Modifiability,inherit,inherit,312,"/// This class augments a recipe with a set of VPValues defined by the recipe.; /// It allows recipes to define zero, one or multiple VPValues. A VPDef owns; /// the VPValues it defines and is responsible for deleting its defined values.; /// Single-value VPDefs that also inherit from VPValue must make sure to inherit; /// from VPDef before VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:38,Modifiability,inherit,inherit,38,// START: SubclassID for recipes that inherit VPHeaderPHIRecipe.; // VPHeaderPHIRecipe need to be kept together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:36,Modifiability,inherit,inherit,36,// END: SubclassID for recipes that inherit VPHeaderPHIRecipe; // END: Phi-like recipes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:192,Modifiability,evolve,evolves,192,"/// \return an ID for the concrete type of this object.; /// This is used to implement the classof checks. This should not be used; /// for any other purpose, as the values may change as LLVM evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:46,Availability,mask,masks,46,"/// When we if-convert we need to create edge masks. We have to cache values; /// so that we don't end up with exponential recursion/IR. Note that; /// if-conversion currently takes place during VPlan-construction, so these; /// caches are only used at that stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:64,Performance,cache,cache,64,"/// When we if-convert we need to create edge masks. We have to cache values; /// so that we don't end up with exponential recursion/IR. Note that; /// if-conversion currently takes place during VPlan-construction, so these; /// caches are only used at that stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:229,Performance,cache,caches,229,"/// When we if-convert we need to create edge masks. We have to cache values; /// so that we don't end up with exponential recursion/IR. Note that; /// if-conversion currently takes place during VPlan-construction, so these; /// caches are only used at that stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:103,Availability,mask,masked,103,/// Check if the load or store instruction \p I should widened for \p; /// Range.Start and potentially masked. Such instructions are handled by a; /// recipe that takes an additional VPInstruction for the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:205,Availability,mask,mask,205,/// Check if the load or store instruction \p I should widened for \p; /// Range.Start and potentially masked. Such instructions are handled by a; /// recipe that takes an additional VPInstruction for the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:17,Performance,load,load,17,/// Check if the load or store instruction \p I should widened for \p; /// Range.Start and potentially masked. Such instructions are handled by a; /// recipe that takes an additional VPInstruction for the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:93,Modifiability,variab,variable,93,/// Optimize the special case where the operand of \p I is a constant integer; /// induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:4,Performance,Optimiz,Optimize,4,/// Optimize the special case where the operand of \p I is a constant integer; /// induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:234,Performance,perform,performs,234,"/// Handle non-loop phi nodes. Return a VPValue, if all incoming values match; /// or a new VPBlendRecipe otherwise. Currently all such phi nodes are turned; /// into a sequence of select instructions as the vectorizer currently; /// performs full if-conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:187,Performance,perform,performed,187,/// Check if \p I has an opcode that can be widened and return a VPWidenRecipe; /// if it can. The function should only be called if the cost-model indicates; /// that widening should be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:144,Modifiability,inherit,inherit,144,/// Return a VPRecipeOrValueTy with VPRecipeBase * being set. This can be used to force the use as VPRecipeBase* for recipe sub-types that also inherit from VPValue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:15,Availability,mask,mask,15,/// Create the mask for the vector loop header block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:142,Availability,mask,mask,142,"/// A helper function that computes the predicate of the block BB, assuming; /// that the header block of the loop is set to True or the loop mask when; /// tail folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:24,Availability,mask,mask,24,/// Returns the *entry* mask for the block \p BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:71,Availability,mask,mask,71,"/// Build a VPReplicationRecipe for \p I. If it is predicated, add the mask as; /// last operand. Range.End may be decreased to ensure same recipe behavior; /// from \p Range.Start to \p Range.End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:30,Availability,error,error,30,// tryParse() returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:9,Security,validat,validate,9,// Don't validate the input; trust the value supplied by the user.; // The motivation is to prevent unnecessary file and registry access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:130,Security,access,access,130,// Don't validate the input; trust the value supplied by the user.; // The motivation is to prevent unnecessary file and registry access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:181,Usability,Simpl,Simply,181,"// The destination buffer must be empty as an invariant of the conversion; // function; but this function is sometimes called in a loop that passes in; // the same buffer, however. Simply clear it out so we can overwrite it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:188,Usability,clear,clear,188,"// The destination buffer must be empty as an invariant of the conversion; // function; but this function is sometimes called in a loop that passes in; // the same buffer, however. Simply clear it out so we can overwrite it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:13,Deployability,Install,InstallDir,13,// Test that InstallDir is indeed there before keeping this index.; // Open the chosen key path remainder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:3,Testability,Test,Test,3,// Test that InstallDir is indeed there before keeping this index.; // Open the chosen key path remainder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:19,Deployability,install,installs,19,"// Windows SDK 8.x installs libraries in a folder whose names depend on the; // version of the OS you're targeting. By default choose the newest, which; // usually corresponds to the version of the OS you've installed the SDK on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:208,Deployability,install,installed,208,"// Windows SDK 8.x installs libraries in a folder whose names depend on the; // version of the OS you're targeting. By default choose the newest, which; // usually corresponds to the version of the OS you've installed the SDK on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:62,Integrability,depend,depend,62,"// Windows SDK 8.x installs libraries in a folder whose names depend on the; // version of the OS you're targeting. By default choose the newest, which; // usually corresponds to the version of the OS you've installed the SDK on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:9,Security,validat,validate,9,// Don't validate the input; trust the value supplied by the user.; // The primary motivation is to prevent unnecessary file and registry access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:138,Security,access,access,138,// Don't validate the input; trust the value supplied by the user.; // The primary motivation is to prevent unnecessary file and registry access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:9,Modifiability,variab,variables,9,// These variables are typically set by vcvarsall.bat; // when launching a developer command prompt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:19,Modifiability,variab,variable,19,"// If the previous variable isn't set but this one is, then we've found; // an older Visual Studio. This variable is set by newer Visual Studios too,; // so this check has to appear second.; // In older Visual Studios, the VC directory is the toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:105,Modifiability,variab,variable,105,"// If the previous variable isn't set but this one is, then we've found; // an older Visual Studio. This variable is set by newer Visual Studios too,; // so this check has to appear second.; // In older Visual Studios, the VC directory is the toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:39,Modifiability,variab,variables,39,"// We couldn't find any VC environment variables. Let's walk through PATH and; // see if it leads us to a VC toolchain bin directory. If it does, pick the; // first one that we find.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:38,Testability,test,test,38,// cl.exe existing isn't a conclusive test for a VC toolchain; clang also; // has a cl.exe. So let's check for link.exe too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:225,Availability,error,error,225,"// _com_ptr_t will throw a _com_error if a COM calls fail.; // The LLVM coding standards forbid exception handling, so we'll have to; // stop them from being thrown in the first place.; // The destructor will put the regular error handler back when we leave; // this scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:26,Modifiability,inherit,inheritable,26,"// Search for the closest inheritable default namespace, starting on (and; // including) the Node and traveling upwards through parent nodes. Returns; // nullptr if there are no inheritable default namespaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:178,Modifiability,inherit,inheritable,178,"// Search for the closest inheritable default namespace, starting on (and; // including) the Node and traveling upwards through parent nodes. Returns; // nullptr if there are no inheritable default namespaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:191,Availability,error,error,191,"// Merge the attributes of AdditionalNode into OriginalNode. If attributes; // with identical types are present, they are not duplicated but rather if; // their values are not consistent and error is thrown. In addition, the; // higher priority namespace is used for each attribute, EXCEPT in the case; // of merging two default namespaces and the lower priority namespace; // definition occurs closer than the higher priority one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:187,Modifiability,inherit,inherited,187,"// This covers the case where the incoming attribute has the higher; // priority. The higher priority namespace is applied in all cases; // EXCEPT when both of the namespaces are default inherited, and the; // closest inherited default is the lower priority one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:218,Modifiability,inherit,inherited,218,"// This covers the case where the incoming attribute has the higher; // priority. The higher priority namespace is applied in all cases; // EXCEPT when both of the namespaces are default inherited, and the; // closest inherited default is the lower priority one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:38,Modifiability,inherit,inherited,38,// Checks if this Node's namespace is inherited or one it defined itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:65,Modifiability,inherit,inherited,65,"// Check if this Node's namespace is a default namespace that it inherited, as; // opposed to defining itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:67,Availability,down,downwards,67,"// For the given explicit prefix-definition of a namespace, travel downwards; // from a node recursively, and for every implicit, inherited default usage of; // that namespace replace it with that explicit prefix use. This is important; // when namespace overriding occurs when merging, so that elements unique to a; // namespace will still stay in that namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:130,Modifiability,inherit,inherited,130,"// For the given explicit prefix-definition of a namespace, travel downwards; // from a node recursively, and for every implicit, inherited default usage of; // that namespace replace it with that explicit prefix use. This is important; // when namespace overriding occurs when merging, so that elements unique to a; // namespace will still stay in that namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:80,Modifiability,inherit,inherited,80,"// If a node as its own default namespace definition it clearly cannot have; // inherited the given default namespace, and neither will any of its; // children.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:56,Usability,clear,clearly,56,"// If a node as its own default namespace definition it clearly cannot have; // inherited the given default namespace, and neither will any of its; // children.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:3,Performance,Perform,Perform,3,// Perform the namespace merge between two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:187,Availability,down,down,187,"// Check whether the original node or the incoming node has the higher; // priority namespace. Depending on which one is dominant, we will have; // to recursively apply namespace changes down to children of the original; // node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:95,Integrability,Depend,Depending,95,"// Check whether the original node or the incoming node has the higher; // priority namespace. Depending on which one is dominant, we will have; // to recursively apply namespace changes down to children of the original; // node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:462,Modifiability,inherit,inherited,462,"// In this case the node with a higher priority namespace did not have a; // default namespace definition, but the lower priority node did. In this; // case the new default namespace definition is copied. A side effect of; // this is that all children will suddenly find themselves in a different; // default namespace. To maintain correctness we need to ensure that all; // children now explicitly refer to the namespace that they had previously; // implicitly inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:89,Modifiability,inherit,inherited,89,"// This covers the case where the incoming node either has a prefix; // namespace, or an inherited default namespace. Since the namespace; // may not yet be defined in the original tree we do a searchOrDefine; // for it, and then set the namespace equal to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:158,Deployability,update,updated,158,"// In this case, the incoming node's default definition overrides; // the original default definition, all children who relied on that; // definition must be updated accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:143,Deployability,update,updated,143,"// The original did not define a default definition, however the new; // default definition still applies to all children, so they must be; // updated to explicitly refer to the namespace they had previously; // been inheriting implicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:217,Modifiability,inherit,inheriting,217,"// The original did not define a default definition, however the new; // default definition still applies to all children, so they must be; // updated to explicitly refer to the namespace they had previously; // been inheriting implicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:19,Modifiability,inherit,inherited,19,// Ensure a node's inherited namespace is actually defined in the tree it; // resides in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:51,Integrability,depend,depending,51,"// Recursively merge the two given manifest trees, depending on which elements; // are of a mergeable type, and choose namespaces according to which have; // higher priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:42,Modifiability,inherit,inherit,42,"// libxml2 assumes that attributes do not inherit default namespaces, whereas; // the original mt.exe does make this assumption. This function reconciles; // this by setting all attributes to have the inherited default namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:201,Modifiability,inherit,inherited,201,"// libxml2 assumes that attributes do not inherit default namespaces, whereas; // the original mt.exe does make this assumption. This function reconciles; // this by setting all attributes to have the inherited default namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp:133,Testability,log,logs,133,"// Before we do any further reading, we should check whether we're at the end; // of the current buffer we're been consuming. In FDR logs version >= 3, we; // rely on the buffer extents record to determine how many bytes we should be; // considering as valid records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp:336,Performance,load,loaded,336,"//; // At the top level, we read one byte to determine the type of the record to; // create. This byte will comprise of the following bits:; //; // - offset 0: A '1' indicates a metadata record, a '0' indicates a function; // record.; // - offsets 1-7: For metadata records, this will indicate the kind of; // metadata record should be loaded.; //; // We read first byte, then create the appropriate type of record to consume; // the rest of the bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRTraceWriter.cpp:383,Testability,Test,Test,383,"//===- FDRTraceWriter.cpp - XRay FDR Trace Writer ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Test a utility that can write out XRay FDR Mode formatted trace files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/FDRTraceWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRTraceWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:17,Availability,error,error,17,// FIXME: Create error types that encapsulate a bit more information than what; // StringError instances contain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:119,Modifiability,Extend,Extend,119,"// At this point we assume the file is an object file -- and if that doesn't; // work, we treat it as YAML.; // FIXME: Extend to support non-ELF and non-x86_64 binaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:13,Performance,load,load,13,// We try to load it as YAML if the ELF load didn't work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:40,Performance,load,load,40,// We try to load it as YAML if the ELF load didn't work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:23,Availability,error,error,23,// Report the ELF load error if YAML failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:18,Performance,load,load,18,// Report the ELF load error if YAML failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:48,Availability,error,error,48,"// If the file is empty, we return the original error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:26,Availability,error,errors,26,"// From this point on the errors will be only for the YAML parts, so we; // consume the errors at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:88,Availability,error,errors,88,"// From this point on the errors will be only for the YAML parts, so we; // consume the errors at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/LogBuilderConsumer.cpp:58,Availability,error,errors,58,"// We apply all of the visitors in order, and concatenate errors; // appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/LogBuilderConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/LogBuilderConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Profile.cpp:431,Performance,latency,latency,431,"//===- Profile.cpp - XRay Profile Abstraction -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the XRay Profile class representing the latency profile generated by; // XRay's profiling mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Profile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Profile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/RecordInitializer.cpp:37,Testability,log,log,37,"// For version 4 onwards, of the FDR log, we want to also capture the CPU ID; // of the custom event.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/RecordInitializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/RecordInitializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:30,Performance,Load,Loading,30,"//===- Trace.cpp - XRay Trace Loading implementation. ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // XRay log reader implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:388,Testability,log,log,388,"//===- Trace.cpp - XRay Trace Loading implementation. ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // XRay log reader implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:90,Testability,log,logs,90,// Advance the offset pointer enough bytes to align to 32-byte records for; // basic mode logs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:12,Testability,log,log,12,"/// Reads a log in FDR mode for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:164,Testability,log,log,164,"/// Reads a log in FDR mode for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:664,Testability,log,logic,664,"/// Reads a log in FDR mode for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:961,Testability,log,log,961,"/// Reads a log in FDR mode for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:1059,Testability,log,log,1059,"for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how many usable bytes are; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:2007,Usability,usab,usable,2007,"onsistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how many usable bytes are; /// in the buffer. This is measured from the start of the buffer; /// and must always be at least 48 (bytes).; ///; /// In Version 3, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime Pid NewCPUId; /// FunctionSequence; /// EOB: *deprecated*; ///; /// In Version 4, we make the following changes:; ///; /// CustomEventRecord now includes the CPU data.; ///; /// In Version 5, we make the following changes:; ///; /// CustomEventRecord and TypedEventRecord now use TSC delta encoding similar to; /// what FunctionRecord instances use, and we no longer need to include the CPU; /// id in the CustomEventRecord.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:12,Performance,load,load,12,// First we load the records into memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:58,Security,access,access,58,// Map the opened file into memory and use a StringRef to access it later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:721,Availability,error,error,721,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:256,Performance,load,loading,256,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:581,Performance,load,loading,581,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:658,Performance,load,load,658,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:14,Safety,detect,detect,14,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:490,Availability,down,down,490,"//===- BugDriver.cpp - Top-Level BugPoint class implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:495,Availability,error,errors,495,"//===- BugDriver.cpp - Top-Level BugPoint class implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:505,Performance,optimiz,optimizations,505,"//===- BugDriver.cpp - Top-Level BugPoint class implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:20,Deployability,update,update,20,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:68,Deployability,update,update,68,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:10,Energy Efficiency,reduce,reduce,10,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:61,Modifiability,config,configure,61,"// If we don't have an override triple, use the first one to configure; // bugpoint, or use the host triple if none provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:167,Availability,failure,failure,167,"// This method takes the specified list of LLVM input files, attempts to load; // them, either as assembly or bitcode, then link them together. It returns; // true on failure (if, for example, an input bitcode file could not be; // parsed), and false on success.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:73,Performance,load,load,73,"// This method takes the specified list of LLVM input files, attempts to load; // them, either as assembly or bitcode, then link them together. It returns; // true on failure (if, for example, an input bitcode file could not be; // parsed), and false on success.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:3,Performance,Load,Load,3,// Load the first input file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:78,Modifiability,variab,variables,78,/// run - The top level method that is invoked after all of the instance; /// variables are set up from command line arguments.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:115,Performance,optimiz,optimization,115,"// If we're not running as a child, the first thing that we must do is; // determine what the problem is. Does the optimization series crash the; // compiler, or does it produce illegal code? We make the top-level; // decision by trying to run all of the passes on the input program,; // which should generate a bitcode file. If it does generate a bitcode; // file, then we know the compiler didn't crash, so try to diagnose a; // miscompilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:3,Testability,Test,Test,3,// Test to see if we have a code generator crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:490,Availability,down,down,490,"//===- BugDriver.h - Top-Level BugPoint class -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:495,Availability,error,errors,495,"//===- BugDriver.h - Top-Level BugPoint class -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:505,Performance,optimiz,optimizations,505,"//===- BugDriver.h - Top-Level BugPoint class -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:115,Modifiability,variab,variables,115,// Set up methods... these methods are used to copy information about the; // command line arguments into instance variables of BugDriver.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:78,Modifiability,variab,variables,78,/// run - The top level method that is invoked after all of the instance; /// variables are set up from command line arguments. The \p as_child argument; /// indicates whether the driver is to run in parent mode or child mode.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:117,Availability,down,down,117,"/// debugOptimizerCrash - This method is called when some optimizer pass; /// crashes on input. It attempts to prune down the testcase to something; /// reasonable, and figure out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:58,Performance,optimiz,optimizer,58,"/// debugOptimizerCrash - This method is called when some optimizer pass; /// crashes on input. It attempts to prune down the testcase to something; /// reasonable, and figure out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:126,Testability,test,testcase,126,"/// debugOptimizerCrash - This method is called when some optimizer pass; /// crashes on input. It attempts to prune down the testcase to something; /// reasonable, and figure out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:117,Energy Efficiency,reduce,reduce,117,/// debugCodeGeneratorCrash - This method is called when the code generator; /// crashes on an input. It attempts to reduce the input as much as possible; /// while still causing the code generator to crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:45,Availability,down,down,45,"/// debugCodeGenerator - This method narrows down a module to a function or; /// set of functions, using the CBE as a ``safe'' code generator for other; /// functions that are not under consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:120,Safety,safe,safe,120,"/// debugCodeGenerator - This method narrows down a module to a function or; /// set of functions, using the CBE as a ``safe'' code generator for other; /// functions that are not under consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:59,Testability,test,testing,59,/// isExecutingJIT - Returns true if bugpoint is currently testing the JIT; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:20,Deployability,update,update,20,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:68,Deployability,update,update,68,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:10,Energy Efficiency,reduce,reduce,10,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:85,Testability,test,testing,85,/// Try to compile the specified module. This is used for code generation; /// crash testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:206,Availability,Error,Error,206,"/// Used to create reference output with the ""safe"" backend, if reference; /// output is not provided. If there is a problem with the code generator; /// (e.g., llc crashes), this will return false and set Error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:46,Safety,safe,safe,46,"/// Used to create reference output with the ""safe"" backend, if reference; /// output is not provided. If there is a problem with the code generator; /// (e.g., llc crashes), this will return false and set Error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:271,Availability,Error,Error,271,"/// This method executes the specified module and diffs the output against the; /// file specified by ReferenceOutputFile. If the output is different, 1 is; /// returned. If there is a problem with the code generator (e.g., llc; /// crashes), this will return -1 and set Error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:206,Integrability,depend,depends,206,/// This method clones the current Program and deletes the specified; /// instruction from the cloned module. It then runs a series of cleanup; /// passes (ADCE and SimplifyCFG) to eliminate any code which depends on the; /// value. The modified module is then returned.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:165,Usability,Simpl,SimplifyCFG,165,/// This method clones the current Program and deletes the specified; /// instruction from the cloned module. It then runs a series of cleanup; /// passes (ADCE and SimplifyCFG) to eliminate any code which depends on the; /// value. The modified module is then returned.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:47,Performance,perform,performs,47,"/// This method clones the current Program and performs a series of cleanups; /// intended to get rid of extra cruft on the module. If the; /// MayModifySemantics argument is true, then the cleanups is allowed to; /// modify how the code behaves.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:194,Performance,perform,performed,194,"/// Extract all but the specified basic blocks into their own functions. The; /// only detail is that M is actually a module cloned from the one the BBs are; /// in, so some mapping needs to be performed. If this operation fails for; /// some reason (ie the implementation is buggy), this function should return; /// null, otherwise it returns a new Module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:141,Availability,failure,failure,141,"/// Carefully run the specified set of pass on the specified/ module,; /// returning the transformed module on success, or a null pointer on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:402,Integrability,message,message,402,"/// runPasses - Run the specified passes on Program, outputting a bitcode; /// file and writting the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed, unless Quiet is set. ExtraArgs specifies additional arguments; /// to pass to the child bugpoint instance.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:153,Performance,optimiz,optimizations,153,"/// runPasses - Run the specified passes on Program, outputting a bitcode; /// file and writting the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed, unless Quiet is set. ExtraArgs specifies additional arguments; /// to pass to the child bugpoint instance.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:189,Performance,optimiz,optimizer,189,"/// runPasses - Run the specified passes on Program, outputting a bitcode; /// file and writting the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed, unless Quiet is set. ExtraArgs specifies additional arguments; /// to pass to the child bugpoint instance.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:115,Performance,optimiz,optimizer,115,"/// runPasses - Just like the method above, but this just returns true or; /// false indicating whether or not the optimizer crashed on the specified; /// input (true = crashed). Does not produce any output.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:388,Availability,failure,failure,388,"/// Take the specified pass list and create different combinations of passes; /// to compile the program with. Compile the program with each set and mark; /// test to see if it compiled correctly. If the passes compiled correctly; /// output nothing and rearrange the passes into a new order. If the passes; /// did not compile correctly, output the command required to recreate the; /// failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:159,Testability,test,test,159,"/// Take the specified pass list and create different combinations of passes; /// to compile the program with. Compile the program with each set and mark; /// test to see if it compiled correctly. If the passes compiled correctly; /// output nothing and rearrange the passes into a new order. If the passes; /// did not compile correctly, output the command required to recreate the; /// failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:71,Availability,error,error,71,"/// This writes the current ""Program"" to the named bitcode file. If an error; /// occurs, true is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:68,Modifiability,variab,variables,68,/// PrintGlobalVariableList - prints out list of problematic global variables; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:49,Modifiability,variab,variable,49,"// DeleteGlobalInitializer - ""Remove"" the global variable by deleting its; // initializer, making it external.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:461,Availability,down,down,461,"//===- bugpoint.cpp - The LLVM Bugpoint utility ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is an automated compiler debugger tool. It is used to narrow; // down miscompilations and crash problems to a specific pass in the compiler,; // and the specific Module or Function input that is causing the problem.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:43,Deployability,update,update,43,// Set the default MemoryLimit. Be sure to update the flag's description if; // you change this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:35,Energy Efficiency,allocate,allocated,35,// Starting from kernel 4.9 memory allocated with mmap is counted against; // RLIMIT_DATA. Sanitizers need to allocate tens of terabytes for shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:110,Energy Efficiency,allocate,allocate,110,// Starting from kernel 4.9 memory allocated with mmap is counted against; // RLIMIT_DATA. Sanitizers need to allocate tens of terabytes for shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:91,Security,Sanitiz,Sanitizers,91,// Starting from kernel 4.9 memory allocated with mmap is counted against; // RLIMIT_DATA. Sanitizers need to allocate tens of terabytes for shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:78,Safety,avoid,avoid,78,"// Bugpoint has the ability of generating a plethora of core files, so to; // avoid filling up the disk, we prevent it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:436,Availability,down,down,436,"//===- CrashDebugger.cpp - Debug compilation crashes ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the bugpoint internals that narrow down compilation crashes; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:171,Deployability,update,update,171,"// Return true iff running the ""removed"" passes succeeds, and running the; // ""Kept"" passes fail when run on the output of the ""removed"" passes. If we; // return true, we update the current module of bugpoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingGlobalInitializers,4,"/// ReduceCrashingGlobalInitializers - This works by removing global variable; /// initializers and seeing if the program still crashes. If it does, then we; /// keep that program and try again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:69,Modifiability,variab,variable,69,"/// ReduceCrashingGlobalInitializers - This works by removing global variable; /// initializers and seeing if the program still crashes. If it does, then we; /// keep that program and try again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:35,Modifiability,variab,variables,35,// Loop over and delete any global variables which we aren't supposed to be; // playing with...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:71,Modifiability,variab,variable,71,"// It crashed, keep the trimmed version...; // Make sure to use global variable pointers that point into the now-current; // module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingFunctions,4,"/// ReduceCrashingFunctions reducer - This works by removing functions and; /// seeing if the program still crashes. If it does, then keep the newer,; /// smaller program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:28,Energy Efficiency,reduce,reducer,28,"/// ReduceCrashingFunctions reducer - This works by removing functions and; /// seeing if the program still crashes. If it does, then keep the newer,; /// smaller program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingFunctionAttributes,4,"/// ReduceCrashingFunctionAttributes reducer - This works by removing; /// attributes on a particular function and seeing if the program still crashes.; /// If it does, then keep the newer, smaller program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:37,Energy Efficiency,reduce,reducer,37,"/// ReduceCrashingFunctionAttributes reducer - This works by removing; /// attributes on a particular function and seeing if the program still crashes.; /// If it does, then keep the newer, smaller program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:77,Energy Efficiency,reduce,reducer,77,// Build up an AttributeList from the attributes we've been given by the; // reducer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:130,Availability,failure,failure,130,"// If the attribute list includes ""optnone"" we need to make sure it also; // includes ""noinline"" otherwise we will get a verifier failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:106,Availability,down,down,106,"/// Simplify the CFG without completely destroying it.; /// This is not well defined, but basically comes down to ""try to eliminate; /// unreachable blocks and constant fold terminators without deciding that; /// certain undefined behavior cuts off the program at the legs"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Usability,Simpl,Simplify,4,"/// Simplify the CFG without completely destroying it.; /// This is not well defined, but basically comes down to ""try to eliminate; /// unreachable blocks and constant fold terminators without deciding that; /// certain undefined behavior cuts off the program at the legs"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingBlocks,4,"/// ReduceCrashingBlocks reducer - This works by setting the terminators of; /// all terminators except the specified basic blocks to a 'ret' instruction,; /// then running the simplifycfg pass. This has the effect of chopping up; /// the CFG really fast which can reduce large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:25,Energy Efficiency,reduce,reducer,25,"/// ReduceCrashingBlocks reducer - This works by setting the terminators of; /// all terminators except the specified basic blocks to a 'ret' instruction,; /// then running the simplifycfg pass. This has the effect of chopping up; /// the CFG really fast which can reduce large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:265,Energy Efficiency,reduce,reduce,265,"/// ReduceCrashingBlocks reducer - This works by setting the terminators of; /// all terminators except the specified basic blocks to a 'ret' instruction,; /// then running the simplifycfg pass. This has the effect of chopping up; /// the CFG really fast which can reduce large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:177,Usability,simpl,simplifycfg,177,"/// ReduceCrashingBlocks reducer - This works by setting the terminators of; /// all terminators except the specified basic blocks to a 'ret' instruction,; /// then running the simplifycfg pass. This has the effect of chopping up; /// the CFG really fast which can reduce large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:296,Safety,risk,risk,296,"// The CFG Simplifier pass may delete one of the basic blocks we are; // interested in. If it does we need to take the block out of the list. Make; // a ""persistent mapping"" by turning basic blocks into <function, name> pairs.; // This won't work well if blocks are unnamed, but that is just the risk we; // have to take. FIXME: Can we just name the blocks?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:11,Usability,Simpl,Simplifier,11,"// The CFG Simplifier pass may delete one of the basic blocks we are; // interested in. If it does we need to take the block out of the list. Make; // a ""persistent mapping"" by turning basic blocks into <function, name> pairs.; // This won't work well if blocks are unnamed, but that is just the risk we; // have to take. FIXME: Can we just name the blocks?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingConditionals,4,"/// ReduceCrashingConditionals reducer - This works by changing; /// conditional branches to unconditional ones, then simplifying the CFG; /// This has the effect of chopping up the CFG really fast which can reduce; /// large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:31,Energy Efficiency,reduce,reducer,31,"/// ReduceCrashingConditionals reducer - This works by changing; /// conditional branches to unconditional ones, then simplifying the CFG; /// This has the effect of chopping up the CFG really fast which can reduce; /// large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:208,Energy Efficiency,reduce,reduce,208,"/// ReduceCrashingConditionals reducer - This works by changing; /// conditional branches to unconditional ones, then simplifying the CFG; /// This has the effect of chopping up the CFG really fast which can reduce; /// large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:118,Usability,simpl,simplifying,118,"/// ReduceCrashingConditionals reducer - This works by changing; /// conditional branches to unconditional ones, then simplifying the CFG; /// This has the effect of chopping up the CFG really fast which can reduce; /// large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:16,Energy Efficiency,reduce,reducer,16,/// SimplifyCFG reducer - This works by calling SimplifyCFG on each basic block; /// in the program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Usability,Simpl,SimplifyCFG,4,/// SimplifyCFG reducer - This works by calling SimplifyCFG on each basic block; /// in the program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:48,Usability,Simpl,SimplifyCFG,48,/// SimplifyCFG reducer - This works by calling SimplifyCFG on each basic block; /// in the program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingInstructions,4,/// ReduceCrashingInstructions reducer - This works by removing the specified; /// non-terminator instructions and replacing them with undef.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:31,Energy Efficiency,reduce,reducer,31,/// ReduceCrashingInstructions reducer - This works by removing the specified; /// non-terminator instructions and replacing them with undef.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingMetadata,4,/// ReduceCrashingMetadata reducer - This works by removing all metadata from; /// the specified instructions.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:27,Energy Efficiency,reduce,reducer,27,/// ReduceCrashingMetadata reducer - This works by removing all metadata from; /// the specified instructions.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the list of Named Metadata nodes. We keep this as a list of; // names to avoid having to convert back and forth every time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:83,Safety,avoid,avoid,83,// Reduce the list of Named Metadata nodes. We keep this as a list of; // names to avoid having to convert back and forth every time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:93,Safety,avoid,avoid,93,"// First collect all the metadata to delete in a vector, then; // delete them all at once to avoid invalidating the iterator",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the list of operands to named metadata nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:14,Energy Efficiency,reduce,reduce,14,// Now try to reduce the number of global variable initializers in the; // module to something small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:42,Modifiability,variab,variable,42,// Now try to reduce the number of global variable initializers in the; // module to something small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:57,Availability,error,error,57,"// TODO: Should we distinguish this with an ""interrupted error""?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:387,Availability,failure,failure,387,"// Now that we have deleted the functions that are unnecessary for the; // program, try to remove instructions that are not necessary to cause the; // crash. To do this, we loop through all of the instructions in the; // remaining functions, deleting them (replacing any values produced with; // nulls), and then running ADCE and SimplifyCFG. If the transformed input; // still triggers failure, keep deleting until we cannot trigger failure; // anymore.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:434,Availability,failure,failure,434,"// Now that we have deleted the functions that are unnecessary for the; // program, try to remove instructions that are not necessary to cause the; // crash. To do this, we loop through all of the instructions in the; // remaining functions, deleting them (replacing any values produced with; // nulls), and then running ADCE and SimplifyCFG. If the transformed input; // still triggers failure, keep deleting until we cannot trigger failure; // anymore.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:330,Usability,Simpl,SimplifyCFG,330,"// Now that we have deleted the functions that are unnecessary for the; // program, try to remove instructions that are not necessary to cause the; // crash. To do this, we loop through all of the instructions in the; // remaining functions, deleting them (replacing any values produced with; // nulls), and then running ADCE and SimplifyCFG. If the transformed input; // still triggers failure, keep deleting until we cannot trigger failure; // anymore.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:49,Availability,error,error,49,// TODO: Should this be some kind of interrupted error?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:70,Energy Efficiency,reduce,reduce,70,"// Yup, it does, we delete the old module, and continue trying; // to reduce the testcase...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:81,Testability,test,testcase,81,"// Yup, it does, we delete the old module, and continue trying; // to reduce the testcase...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:120,Energy Efficiency,reduce,reduce,120,"/// DebugACrash - Given a predicate that determines whether a component crashes; /// on a program, try to destructively reduce the program while still keeping; /// the predicate true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:57,Modifiability,variab,variable,57,// See if we can get away with nuking some of the global variable initializers; // in the program...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:14,Energy Efficiency,reduce,reduce,14,// Now try to reduce the number of functions in the module to something small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:39,Energy Efficiency,reduce,reduce,39,"// For each remaining function, try to reduce that function's attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:183,Usability,simpl,simplifycfg,183,"// Attempt to delete entire basic blocks at a time to speed up; // convergence... this actually works by setting the terminator of the blocks; // to a return instruction then running simplifycfg, which can potentially; // shrinks the code dramatically quickly; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:10,Energy Efficiency,reduce,reduce,10,"// Try to reduce the amount of global metadata (particularly debug info),; // by dropping global named metadata that anchors them",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:23,Testability,test,testcase,23,// Try to clean up the testcase by running funcresolve and globaldce...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:26,Energy Efficiency,reduce,reduced,26,"// Yup, it does, keep the reduced version...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:107,Availability,down,down,107,"/// debugOptimizerCrash - This method is called when some pass crashes on input.; /// It attempts to prune down the testcase to something reasonable, and figure; /// out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:116,Testability,test,testcase,116,"/// debugOptimizerCrash - This method is called when some pass crashes on input.; /// It attempts to prune down the testcase to something reasonable, and figure; /// out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the list of passes which causes the optimizer to crash...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:46,Performance,optimiz,optimizer,46,// Reduce the list of passes which causes the optimizer to crash...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:10,Energy Efficiency,reduce,reduce,10,"// Try to reduce the pass list again. This covers additional cases; // we failed to reduce earlier, because of more complex pass dependencies; // triggering the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:84,Energy Efficiency,reduce,reduce,84,"// Try to reduce the pass list again. This covers additional cases; // we failed to reduce earlier, because of more complex pass dependencies; // triggering the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:129,Integrability,depend,dependencies,129,"// Try to reduce the pass list again. This covers additional cases; // we failed to reduce earlier, because of more complex pass dependencies; // triggering the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:117,Energy Efficiency,reduce,reduce,117,/// debugCodeGeneratorCrash - This method is called when the code generator; /// crashes on an input. It attempts to reduce the input as much as possible; /// while still causing the code generator to crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:73,Testability,test,test,73,"// OutputType - Allow the user to specify the way code should be run, to test; // for miscompilation.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:49,Integrability,interface,interface,49,// Create an instance of the AbstractInterpreter interface as specified on; // the command line,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:25,Integrability,message,messages,25,// Display informational messages on stdout instead of stderr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:11,Safety,safe,safe,11,"// In ""llc-safe"" mode, default to using LLC as the ""safe"" backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:52,Safety,safe,safe,52,"// In ""llc-safe"" mode, default to using LLC as the ""safe"" backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:19,Availability,error,error,19,"// If there was an error creating the selected interpreter, quit with error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:70,Availability,error,error,70,"// If there was an error creating the selected interpreter, quit with error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:69,Availability,Error,Error,69,"/// Try to compile the specified module, returning false and setting Error if an; /// error occurs. This is used for code generation crash testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:86,Availability,error,error,86,"/// Try to compile the specified module, returning false and setting Error if an; /// error occurs. This is used for code generation crash testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:139,Testability,test,testing,139,"/// Try to compile the specified module, returning false and setting Error if an; /// error occurs. This is used for code generation crash testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:46,Safety,safe,safe,46,"/// Used to create reference output with the ""safe"" backend, if reference output; /// is not provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:156,Safety,avoid,avoid,156,"// Check to see if we created any new functions. If not, no loops were; // extracted and we should return null. Limit the number of loops we extract; // to avoid taking forever.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:53,Modifiability,variab,variable,53,"//; // DeleteGlobalInitializer - ""Remove"" the global variable by deleting its; // initializer,; // making it external.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:111,Modifiability,variab,variables,111,"/// SplitStaticCtorDtor - A module was recently split into two parts, M1/M2, and; /// M1 has all of the global variables. If M2 contains any functions that are; /// static ctors/dtors, we need to add an llvm.global_[cd]tors global to M2, and; /// prune appropriate entries out of M1s list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:38,Safety,Safe,Safe,38,// Remove the Test functions from the Safe module,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:14,Testability,Test,Test,14,// Remove the Test functions from the Safe module,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:14,Safety,Safe,Safe,14,// Remove the Safe functions from the Test module,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:38,Testability,Test,Test,38,// Remove the Safe functions from the Test module,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:24,Safety,safe,safe,24,"// If we keep it in the safe module, then delete it in the test module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:59,Testability,test,test,59,"// If we keep it in the safe module, then delete it in the test module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:584,Availability,failure,failure,584,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:404,Integrability,interface,interface,404,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:42,Performance,Optimiz,Optimizations,42,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:475,Performance,optimiz,optimizations,475,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:547,Performance,optimiz,optimizations,547,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:648,Performance,optimiz,optimizations,648,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:42,Performance,optimiz,optimizer,42,//; // Step 1: Randomize the order of the optimizer passes.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:19,Performance,optimiz,optimizer,19,//; // Step 2: Run optimizer passes on the program and check for success.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:27,Performance,optimiz,optimized,27,//; // Step 3: Compile the optimized code.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:28,Availability,down,down,28,"//===- ListReducer.h - Trim down list while retaining property --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class is to be used as a base class for operations that want to zero in; // on a subset of the input which still causes the bug we are tracking.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:6,Availability,failure,failure,6,// No failure of the predicate was detected,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:35,Safety,detect,detected,35,// No failure of the predicate was detected,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:82,Testability,test,test,82,"/// This virtual function should be overriden by subclasses to implement the; /// test desired. The testcase is only required to test to see if the Kept; /// list still satisfies the property, but if it is going to check the prefix; /// anyway, it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:100,Testability,test,testcase,100,"/// This virtual function should be overriden by subclasses to implement the; /// test desired. The testcase is only required to test to see if the Kept; /// list still satisfies the property, but if it is going to check the prefix; /// anyway, it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:129,Testability,test,test,129,"/// This virtual function should be overriden by subclasses to implement the; /// test desired. The testcase is only required to test to see if the Kept; /// list still satisfies the property, but if it is going to check the prefix; /// anyway, it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:30,Energy Efficiency,reduce,reduce,30,"/// This function attempts to reduce the length of the specified list while; /// still maintaining the ""test"" property. This is the core of the ""work""; /// that bugpoint does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:104,Testability,test,test,104,"/// This function attempts to reduce the length of the specified list while; /// still maintaining the ""test"" property. This is the core of the ""work""; /// that bugpoint does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:25,Availability,error,error,25,"// there's definitely an error, but we need to narrow it down",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:57,Availability,down,down,57,"// there's definitely an error, but we need to narrow it down",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:15,Availability,failure,failure,15,// there is no failure with the full set of passes/funcs!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:99,Safety,avoid,avoid,99,"// If the loop doesn't make satisfying progress, try shuffling.; // The purpose of shuffling is to avoid the heavy tails of the; // distribution (improving the speed of convergence).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:26,Availability,error,error,26,"// TODO: Previously, this error was ignored and we treated it as if; // shuffling hid the bug. This should really either be consumeError if; // that behaviour was sensible, or we should propagate the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:200,Availability,error,error,200,"// TODO: Previously, this error was ignored and we treated it as if; // shuffling hid the bug. This should really either be consumeError if; // that behaviour was sensible, or we should propagate the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:43,Safety,avoid,avoid,43,// Must increase the shuffling treshold to avoid the small; // probability of infinite looping without making progress.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:171,Testability,test,testing,171,"// Okay, we trimmed as much off the top and the bottom of the list as we; // could. If there is more than two elements in the list, try deleting; // interior elements and testing that.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:15,Availability,down,down,15,// We can trim down the list!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:18,Availability,failure,failure,18,// there are some failure and we've narrowed them down,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:50,Availability,down,down,50,// there are some failure and we've narrowed them down,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:404,Performance,optimiz,optimizer,404,"//===- Miscompilation.cpp - Debug program miscompilations -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements optimizer and code generation miscompilation debugging; // support.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:32,Testability,Test,TestResult,32,"// end anonymous namespace; /// TestResult - After passes have been split into a test group and a control; /// group, see if they still break the program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:81,Testability,test,test,81,"// end anonymous namespace; /// TestResult - After passes have been split into a test group and a control; /// group, see if they still break the program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:35,Availability,error,error,35,// TODO: This should propagate the error instead of exiting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:18,Safety,detect,detected,18,// Miscompilation detected!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:249,Deployability,update,update,249,"// If it is not broken with the kept passes, it's possible that the prefix; // passes must be run before the kept passes to break it. If the program; // WORKS after the prefix passes, but then fails if running the prefix AND; // kept passes, we can update our bitcode file to include the result of the; // prefix passes, then discard the prefix passes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:35,Availability,error,error,35,// TODO: This should propagate the error instead of exiting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:35,Availability,error,error,35,// TODO: This should propagate the error instead of exiting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:54,Testability,test,test,54,// No miscompilation!; // Restore orig program & free test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:160,Availability,error,error,160,"// end anonymous namespace; /// Given two modules, link them together and run the program, checking to see; /// if the program matches the diff. If there is an error, return NULL. If not,; /// return the merged module. The Broken argument will be set to true if the; /// output is different. If the DeleteInputs argument is set to true then this; /// function deletes both input modules before it returns.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:33,Availability,error,error,33,// TODO: Shouldn't we thread the error up instead of exiting?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:136,Testability,test,test,136,"/// split functions in a Module into two groups: those that are under; /// consideration for miscompilation vs. those that are not, and test; /// accordingly. Each group of functions becomes a separate Module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:3,Testability,Test,Test,3,// Test to see if the function is misoptimized if we ONLY run it on the; // functions listed in Funcs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:48,Performance,optimiz,optimization,48,"// Create a clone for two reasons:; // * If the optimization passes delete any function, the deleted function; // will be in the clone and Funcs will still point to valid memory; // * If the optimization passes use interprocedural information to break; // a function, we want to continue with the original function. Otherwise; // we can conclude that a function triggers the bug when in fact one; // needs a larger set of original functions to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:191,Performance,optimiz,optimization,191,"// Create a clone for two reasons:; // * If the optimization passes delete any function, the deleted function; // will be in the clone and Funcs will still point to valid memory; // * If the optimization passes use interprocedural information to break; // a function, we want to continue with the original function. Otherwise; // we can conclude that a function triggers the bug when in fact one; // needs a larger set of original functions to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:12,Energy Efficiency,reduce,reduced,12,"/// Given a reduced list of functions that still exposed the bug, check to see; /// if we can extract the loops in the region without obscuring the bug. If so,; /// it reduces the amount of code identified.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:168,Energy Efficiency,reduce,reduces,168,"/// Given a reduced list of functions that still exposed the bug, check to see; /// if we can extract the loops in the region without obscuring the bug. If so,; /// it reduces the amount of code identified.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:49,Security,expose,exposed,49,"/// Given a reduced list of functions that still exposed the bug, check to see; /// if we can extract the loops in the region without obscuring the bug. If so,; /// it reduces the amount of code identified.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:170,Testability,test,test,170,"// Bugpoint is intentionally not very trusting of LLVM transformations. In; // particular, we're not going to assume that the loop extractor works, so; // we're going to test the newly loop extracted program to make sure nothing; // has broken. If something broke, then we'll inform the user and stop; // extraction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:22,Testability,test,tester,22,"// Clone modules, the tester function will free them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:83,Availability,mask,masked,83,"// If the program is not still broken, then loop extraction did something; // that masked the error. Stop loop extraction now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:94,Availability,error,error,94,"// If the program is not still broken, then loop extraction did something; // that masked the error. Stop loop extraction now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:124,Availability,mask,mask,124,"// Okay, great! Now we know that we extracted a loop and that loop; // extraction both didn't break the program, and didn't mask the problem.; // Replace the current program with the loop extracted version, and try to; // extract another loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:86,Deployability,Update,Update,86,// All of the Function*'s in the MiscompiledFunctions list are in the old; // module. Update this list to include all of the functions in the; // optimized and loop extracted module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:146,Performance,optimiz,optimized,146,// All of the Function*'s in the MiscompiledFunctions list are in the old; // module. Update this list to include all of the functions in the; // optimized and loop extracted module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:32,Testability,Test,TestFuncs,32,"// end anonymous namespace; /// TestFuncs - Extract all blocks for the miscompiled functions except for the; /// specified blocks. If the problem still exists, return true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:3,Testability,Test,Test,3,// Test to see if the function is misoptimized if we ONLY run it on the; // functions listed in Funcs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:129,Availability,down,down,129,"// Try the extraction. If it doesn't work, then the block extractor crashed; // or something, in which case bugpoint can't chase down this possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:12,Energy Efficiency,reduce,reduced,12,"/// Given a reduced list of functions that still expose the bug, extract as many; /// basic blocks from the region as possible without obscuring the bug.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:49,Security,expose,expose,49,"/// Given a reduced list of functions that still expose the bug, extract as many; /// basic blocks from the region as possible without obscuring the bug.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:16,Energy Efficiency,reduce,reducer,16,// Use the list reducer to identify blocks that can be extracted without; // obscuring the bug. The Blocks list will end up containing blocks that must; // be retained from the original program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:3,Deployability,Update,Update,3,// Update the list of miscompiled functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:39,Availability,down,down,39,"/// This is a generic driver to narrow down miscompilations, either in an; /// optimization or a code generator.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:79,Performance,optimiz,optimization,79,"/// This is a generic driver to narrow down miscompilations, either in an; /// optimization or a code generator.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:79,Availability,failure,failure,79,"// Okay, now that we have reduced the list of passes which are causing the; // failure, see if we can pin down which functions are being; // miscompiled... first build a list of all of the non-external functions in; // the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:106,Availability,down,down,106,"// Okay, now that we have reduced the list of passes which are causing the; // failure, see if we can pin down which functions are being; // miscompiled... first build a list of all of the non-external functions in; // the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:26,Energy Efficiency,reduce,reduced,26,"// Okay, now that we have reduced the list of passes which are causing the; // failure, see if we can pin down which functions are being; // miscompiled... first build a list of all of the non-external functions in; // the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:64,Testability,Test,Test,64,"/// This is the predicate function used to check to see if the ""Test"" portion of; /// the program is misoptimized. If so, return true. In any case, both module; /// arguments are deleted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:11,Performance,optimiz,optimization,11,"// Run the optimization passes on ToOptimize, producing a transformed version; // of the functions being tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:105,Testability,test,tested,105,"// Run the optimization passes on ToOptimize, producing a transformed version; // of the functions being tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:55,Testability,test,testing,55,/// Get the specified modules ready for code generator testing.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:41,Safety,Safe,Safe,41,"// First, if the main function is in the Safe module, we must add a stub to; // the Test module to call into it. Thus, we create a new function `main'; // which just calls the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:68,Testability,stub,stub,68,"// First, if the main function is in the Safe module, we must add a stub to; // the Test module to call into it. Thus, we create a new function `main'; // which just calls the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:84,Testability,Test,Test,84,"// First, if the main function is in the Safe module, we must add a stub to; // the Test module to call into it. Thus, we create a new function `main'; // which just calls the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:54,Testability,test,test,54,// Create a NEW `main' function with same type in the test module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:40,Testability,test,test,40,"// Create an `oldmain' prototype in the test module, which will; // corresponds to the real main function in the same module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:67,Safety,Safe,Safe,67,"// The second nasty issue we must deal with in the JIT is that the Safe; // module cannot directly reference any functions defined in the test; // module. Instead, we use a JIT API call to dynamically resolve the; // symbol.; // Add the resolver to the Safe module.; // Prototype: void *getPointerToNamedFunction(const char* Name)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:253,Safety,Safe,Safe,253,"// The second nasty issue we must deal with in the JIT is that the Safe; // module cannot directly reference any functions defined in the test; // module. Instead, we use a JIT API call to dynamically resolve the; // symbol.; // Add the resolver to the Safe module.; // Prototype: void *getPointerToNamedFunction(const char* Name)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:138,Testability,test,test,138,"// The second nasty issue we must deal with in the JIT is that the Safe; // module cannot directly reference any functions defined in the test; // module. Instead, we use a JIT API call to dynamically resolve the; // symbol.; // Add the resolver to the Safe module.; // Prototype: void *getPointerToNamedFunction(const char* Name)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:53,Testability,test,test,53,// Don't forward functions which are external in the test module too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:63,Integrability,wrap,wrapper,63,"// Rewrite uses of F in global initializers, etc. to uses of a wrapper; // function that dynamically resolves the calls to F via our JIT API",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite uses of F in global initializers, etc. to uses of a wrapper; // function that dynamically resolves the calls to F via our JIT API",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:35,Performance,cache,cached,35,// Create a new global to hold the cached function pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:46,Integrability,rout,route,46,// Construct a new stub function that will re-route calls to F,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:19,Testability,stub,stub,19,// Construct a new stub function that will re-route calls to F,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:25,Performance,cache,cache,25,// Save the value in our cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:11,Integrability,wrap,wrapper,11,// Use the wrapper function instead of the old function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:64,Testability,Test,Test,64,"/// This is the predicate function used to check to see if the ""Test"" portion of; /// the program is miscompiled by the code generator under test. If so, return; /// true. In any case, both module arguments are deleted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:141,Testability,test,test,141,"/// This is the predicate function used to check to see if the ""Test"" portion of; /// the program is miscompiled by the code generator under test. If so, return; /// true. In any case, both module arguments are deleted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:46,Performance,load,loading,46,"// Run the code generator on the `Test' code, loading the shared library.; // The function returns whether or not the new output differs from reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:34,Testability,Test,Test,34,"// Run the code generator on the `Test' code, loading the shared library.; // The function returns whether or not the new output differs from reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:31,Availability,error,errors,31,"/// debugCodeGenerator - debug errors in LLC, LLI, or CBE.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:404,Integrability,interface,interface,404,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:7,Performance,Optimiz,OptimizerDriver,7,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:679,Performance,optimiz,optimizations,679,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:58,Safety,safe,safely,58,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:473,Security,threat,threat,473,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:71,Availability,error,error,71,"/// This writes the current ""Program"" to the named bitcode file. If an error; /// occurs, true is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:66,Integrability,message,message,66,"// Output the input to the current pass to a bitcode file, emit a message; // telling the user how to reproduce it: opt -foo blah.bc; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:401,Integrability,message,message,401,"/// runPasses - Run the specified passes on Program, outputting a bitcode file; /// and writing the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:152,Performance,optimiz,optimizations,152,"/// runPasses - Run the specified passes on Program, outputting a bitcode file; /// and writing the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:188,Performance,optimiz,optimizer,188,"/// runPasses - Run the specified passes on Program, outputting a bitcode file; /// and writing the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:408,Integrability,interface,interfaces,408,"//===-- ToolRunner.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interfaces described in the ToolRunner.h file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:64,Integrability,interface,interface,64,/// RunProgramWithTimeout - This function provides an alternate interface; /// to the sys::Program::ExecuteAndWait interface.; /// @see sys::Program::ExecuteAndWait,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:115,Integrability,interface,interface,115,/// RunProgramWithTimeout - This function provides an alternate interface; /// to the sys::Program::ExecuteAndWait interface.; /// @see sys::Program::ExecuteAndWait,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:224,Availability,error,error,224,/// RunProgramRemotelyWithTimeout - This function runs the given program; /// remotely using the given remote client and the sys::Program::ExecuteAndWait.; /// Returns the remote program exit code or reports a remote client error if it; /// fails. Remote client is required to return 255 if it failed or program exit; /// code otherwise.; /// @see sys::Program::ExecuteAndWait,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:7,Availability,error,error,7,"// The error message is in the output file, let's print it out from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:13,Integrability,message,message,13,"// The error message is in the output file, let's print it out from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:37,Availability,error,error,37,"// Rerun the compiler, capturing any error messages to print them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:43,Integrability,message,messages,43,"// Rerun the compiler, capturing any error messages to print them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:48,Availability,error,error,48,// FIXME: check return code ?; // Print out the error messages generated by CC if possible...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:54,Integrability,message,messages,54,// FIXME: check return code ?; // Print out the error messages generated by CC if possible...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:125,Integrability,interface,interface,125,//===---------------------------------------------------------------------===//; // LLI Implementation of AbstractIntepreter interface; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:371,Availability,error,errors,371,"//===---------------------------------------------------------------------===//; // Custom compiler command implementation of AbstractIntepreter interface; //; // Allows using a custom command for compiling the bitcode, thus allows, for; // example, to compile a bitcode fragment without linking or executing, then; // using a custom wrapper script to check for compiler errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:145,Integrability,interface,interface,145,"//===---------------------------------------------------------------------===//; // Custom compiler command implementation of AbstractIntepreter interface; //; // Allows using a custom command for compiling the bitcode, thus allows, for; // example, to compile a bitcode fragment without linking or executing, then; // using a custom wrapper script to check for compiler errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:334,Integrability,wrap,wrapper,334,"//===---------------------------------------------------------------------===//; // Custom compiler command implementation of AbstractIntepreter interface; //; // Allows using a custom command for compiling the bitcode, thus allows, for; // example, to compile a bitcode fragment without linking or executing, then; // using a custom wrapper script to check for compiler errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:146,Integrability,interface,interface,146,"//===---------------------------------------------------------------------===//; // Custom execution command implementation of AbstractIntepreter interface; //; // Allows using a custom command for executing the bitcode, thus allows,; // for example, to invoke a cross compiler for code generation followed by; // a simulator that executes the generated binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:476,Usability,Simpl,Simple,476,"// Tokenize the CommandLine to the command and the args to allow; // defining a full command line as the command instead of just the; // executed program. We cannot just pass the whole string after the command; // as a single argument because then the program sees only a single; // command line argument (with spaces in it: ""foo bar"" instead; // of ""foo"" and ""bar"").; //; // Spaces are used as a delimiter; however repeated, leading, and trailing; // whitespace are ignored. Simple escaping is allowed via the '\'; // character, as seen below:; //; // Two consecutive '\' evaluate to a single '\'.; // A space after a '\' evaluates to a space that is not interpreted as a; // delimiter.; // Any other instances of the '\' character are removed.; //; // Example:; // '\\' -> '\'; // '\ ' -> ' '; // 'exa\mple' -> 'example'; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:126,Integrability,interface,interface,126,//===----------------------------------------------------------------------===//; // LLC Implementation of AbstractIntepreter interface; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:125,Integrability,interface,interface,125,//===---------------------------------------------------------------------===//; // JIT Implementation of AbstractIntepreter interface; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:296,Safety,safe,safe,296,"// Output to the right file...; // Add any arguments intended for CC. We locate them here because this is; // most likely -L and -l options that need to come before other libraries but; // after the source. Other options won't be sensitive to placement on the; // command line, so this should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the program a bit...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:39,Safety,timeout,timeout,39,// Treat a signal (usually SIGSEGV) or timeout as part of the program output; // so that crash-causing miscompilation is handled seamlessly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:29,Energy Efficiency,Power,PowerPC,29,// `-dynamiclib' for MacOS X/PowerPC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the program a bit.; // Add any arguments intended for CC. We locate them here because this is; // most likely -L and -l options that need to come before other libraries but; // after the source. Other options won't be sensitive to placement on the; // command line, so this should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:296,Safety,safe,safe,296,"// Optimize the program a bit.; // Add any arguments intended for CC. We locate them here because this is; // most likely -L and -l options that need to come before other libraries but; // after the source. Other options won't be sensitive to placement on the; // command line, so this should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:531,Integrability,interface,interface,531,"//===-- tools/bugpoint/ToolRunner.h -----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an abstraction around a platform C compiler, used to; // compile C and assembly code. It also exposes an ""AbstractIntepreter""; // interface, which is used to execute code using one of the LLVM execution; // engines.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:393,Security,expose,exposes,393,"//===-- tools/bugpoint/ToolRunner.h -----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an abstraction around a platform C compiler, used to; // compile C and assembly code. It also exposes an ""AbstractIntepreter""; // interface, which is used to execute code using one of the LLVM execution; // engines.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:495,Security,expose,exposes,495,"//===-- tools/bugpoint/ToolRunner.h -----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an abstraction around a platform C compiler, used to; // compile C and assembly code. It also exposes an ""AbstractIntepreter""; // interface, which is used to execute code using one of the LLVM execution; // engines.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:373,Performance,load,loaded,373,"/// ExecuteProgram - Execute the program specified by ""ProgramFile"" (which is; /// either a .s file, or a .c file, specified by FileType), with the specified; /// arguments. Standard input is specified with InputFile, and standard; /// Output is captured to the specified OutputFile location. The SharedLibs; /// option specifies optional native shared objects that can be loaded into; /// the program for execution.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:212,Integrability,interface,interface,212,//===---------------------------------------------------------------------===//; /// AbstractInterpreter Class - Subclasses of this class are used to execute; /// LLVM bitcode in a variety of ways. This abstract interface hides this; /// complexity behind a simple interface.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:265,Integrability,interface,interface,265,//===---------------------------------------------------------------------===//; /// AbstractInterpreter Class - Subclasses of this class are used to execute; /// LLVM bitcode in a variety of ways. This abstract interface hides this; /// complexity behind a simple interface.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:258,Usability,simpl,simple,258,//===---------------------------------------------------------------------===//; /// AbstractInterpreter Class - Subclasses of this class are used to execute; /// LLVM bitcode in a variety of ways. This abstract interface hides this; /// complexity behind a simple interface.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:118,Availability,error,error,118,"/// Compile the specified program from bitcode to code understood by the CC; /// driver (either C or asm). Returns an error if the code generator fails,,; /// otherwise, the type of code emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:169,Availability,Error,Error,169,"/// ExecuteProgram - Run the specified bitcode file, emitting output to the; /// specified filename. This sets RetVal to the exit code of the program or; /// returns an Error if a problem was encountered that prevented execution of; /// the program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:125,Integrability,interface,interface,125,//===---------------------------------------------------------------------===//; // LLC Implementation of AbstractIntepreter interface; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:247,Availability,error,error,247,"/// Find the first executable file \ExeName, either in the user's PATH or,; /// failing that, in the same directory as argv[0]. This allows us to find; /// another LLVM tool if it is built in the same directory. If no executable is; /// found, an error is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:487,Availability,down,down,487,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:7,Testability,Test,TestPasses,7,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:47,Testability,test,test,47,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:438,Testability,test,test,438,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:492,Testability,test,testcases,492,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:40,Testability,test,test,40,/// CrashOnCalls - This pass is used to test bugpoint. It intentionally; /// crashes on any call instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:39,Testability,test,test,39,"/// DeleteCalls - This pass is used to test bugpoint. It intentionally; /// deletes some call instructions, ""misoptimizing"" the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:43,Testability,test,test,43,/// CrashOnDeclFunc - This pass is used to test bugpoint. It intentionally; /// crashes if the module has an undefined function (ie a function that is; /// defined in an external module).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:40,Testability,test,test,40,/// CrashOnOneCU - This pass is used to test bugpoint. It intentionally; /// crashes if the Module has two or more compile units,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:10,Performance,load,load,10,// Try to load archive and force it to be memory mapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:37,Integrability,depend,depending,37,"// Load one or more archive buffers, depending on whether we're dealing with; // a fat binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:3,Performance,Load,Load,3,"// Load one or more archive buffers, depending on whether we're dealing with; // a fat binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:19,Performance,load,load,19,"// Finally, try to load the archives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:10,Performance,load,load,10,// Try to load regular binary and force it to be memory mapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:36,Integrability,depend,depending,36,"// Load one or more object buffers, depending on whether we're dealing with a; // fat binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:3,Performance,Load,Load,3,"// Load one or more object buffers, depending on whether we're dealing with a; // fat binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:11,Performance,cache,cache,11,// Try the cache first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:53,Performance,cache,cache,53,"// Create a new ObjectEntry, but don't add it to the cache yet. Loading of; // the archive members might fail and we don't want to lock the whole archive; // during this operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:64,Performance,Load,Loading,64,"// Create a new ObjectEntry, but don't add it to the cache yet. Loading of; // the archive members might fail and we don't want to lock the whole archive; // during this operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:77,Performance,cache,cached,77,"// If this is an archive, we might have either the object or the archive; // cached. In this case we can load it without accessing the file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:105,Performance,load,load,105,"// If this is an archive, we might have either the object or the archive; // cached. In this case we can load it without accessing the file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:121,Security,access,accessing,121,"// If this is an archive, we might have either the object or the archive; // cached. In this case we can load it without accessing the file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:20,Availability,error,error,20,// Don't return the error here: maybe the file wasn't an archive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:42,Performance,cache,cached,42,"// If this is an object, we might have it cached. If not we'll have to load; // it from the file system and cache it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:71,Performance,load,load,71,"// If this is an object, we might have it cached. If not we'll have to load; // it from the file system and cache it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:108,Performance,cache,cache,108,"// If this is an object, we might have it cached. If not we'll have to load; // it from the file system and cache it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:43,Security,access,accessing,43,"//===-- BinaryHolder.h - Utility class for accessing binaries -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is a utility that aims to be a dropin replacement for; // Darwin's dsymutil.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:181,Security,access,accessing,181,/// The BinaryHolder class is responsible for creating and owning; /// ObjectFiles and their underlying MemoryBuffers. It differs from a simple; /// OwningBinary in that it handles accessing and caching of archives and its; /// members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:137,Usability,simpl,simple,137,/// The BinaryHolder class is responsible for creating and owning; /// ObjectFiles and their underlying MemoryBuffers. It differs from a simple; /// OwningBinary in that it handles accessing and caching of archives and its; /// members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:25,Performance,cache,cached,25,"/// Base class shared by cached entries, representing objects and archives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Cache,Cached,4,/// Cached entry holding one or more (in case of a fat binary) object files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Load,Load,4,/// Load the given object binary in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Security,Access,Access,4,/// Access all owned ObjectFiles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:127,Availability,Error,Error,127,"/// Access to a derived version of all the currently owned ObjectFiles. The; /// conversion might be invalid, in which case an Error is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Security,Access,Access,4,"/// Access to a derived version of all the currently owned ObjectFiles. The; /// conversion might be invalid, in which case an Error is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Security,Access,Access,4,/// Access the owned ObjectFile with architecture \p T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Security,Access,Access,4,/// Access to a derived version of the currently owned ObjectFile with; /// architecture \p T. The conversion must be known to be valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Cache,Cached,4,/// Cached entry holding one or more (in the of a fat binary) archive files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Load,Load,4,/// Load the given object binary in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Cache,Cache,4,"/// Cache of static archives. Objects that are part of a static archive are; /// stored under this object, rather than in the map below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp:142,Deployability,release,released,142,/// This helper owns any CoreFoundation pointer and will call CFRelease() on; /// any valid pointer it owns unless that pointer is explicitly released using; /// the release() member function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp:166,Deployability,release,release,166,/// This helper owns any CoreFoundation pointer and will call CFRelease() on; /// any valid pointer it owns unless that pointer is explicitly released using; /// the release() member function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp:9,Integrability,wrap,wrapper,9,/// RAII wrapper around CFBundleRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp:9,Integrability,wrap,wrapper,9,/// RAII wrapper around CFBundleRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:97,Testability,test,testing,97,"// Sort the symbols in alphabetical order, like llvm-nm (and to get; // deterministic output for testing).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:3,Integrability,Wrap,WrapColumn,3,/* WrapColumn = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:22,Availability,resilien,resilient,22,// FIXME: find a more resilient way,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:169,Availability,error,error,169,/// Return a list of input files. This function has logic for dealing with the; /// special case where we might have dSYM bundles as input. The function; /// returns an error when the directory structure doesn't match that of a dSYM; /// bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:52,Testability,log,logic,52,/// Return a list of input files. This function has logic for dealing with the; /// special case where we might have dSYM bundles as input. The function; /// returns an error when the directory structure doesn't match that of a dSYM; /// bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:37,Deployability,update,update,37,"// FIXME: We cannot use stdin for an update because stdin will be; // consumed by the BinaryHolder during the debugmap parsing, and; // then we will want to consume it again in DwarfLinker. If we; // used a unique BinaryHolder object that could cache multiple; // binaries this restriction would go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:245,Performance,cache,cache,245,"// FIXME: We cannot use stdin for an update because stdin will be; // consumed by the BinaryHolder during the debugmap parsing, and; // then we will want to consume it again in DwarfLinker. If we; // used a unique BinaryHolder object that could cache multiple; // binaries this restriction would go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:115,Availability,error,error,115,/// Parses the command line options into the LinkOptions struct and performs; /// some sanity checking. Returns an error in case the latter fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:68,Performance,perform,performs,68,/// Parses the command line options into the LinkOptions struct and performs; /// some sanity checking. Returns an error in case the latter fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:87,Safety,sanity check,sanity checking,87,/// Parses the command line options into the LinkOptions struct and performs; /// some sanity checking. Returns an error in case the latter fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:11,Availability,avail,available,11,// Use all available hardware threads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:56,Usability,simpl,simple,56,"// If a flat dSYM has been requested, things are pretty simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:21,Deployability,update,update,21,// We need to create/update a dSYM bundle.; // A bundle hierarchy looks like this:; // <bundle name>.dSYM/; // Contents/; // Info.plist; // Resources/; // DWARF/; // <DWARF file(s)>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:35,Deployability,update,update,35,// Compute the output location and update the resource directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:18,Availability,recover,recovery,18,// Set up a crash recovery context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:18,Safety,recover,recovery,18,// Set up a crash recovery context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:215,Availability,error,error,215,"// Universal Mach-O files can't have an archicture slice that starts; // beyond the 4GB boundary. ""lipo"" can create a 64 bit universal; // header, but not all tools can parse these files so we want to return; // an error if the file can't be encoded as a file with a 32 bit; // universal header. To detect this, we check the size of each; // architecture's skinny Mach-O file and add up the offsets. If they; // exceed 4GB, then we return an error.; // First we compute the right offset where the first architecture will; // fit followin the 32 bit universal header. The 32 bit universal header; // starts with a uint32_t magic and a uint32_t number of architecture; // infos. Then it is followed by 5 uint32_t values for each; // architecture. So we set the start offset to the right value so we can; // calculate the exact offset that the first architecture slice can; // start at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:442,Availability,error,error,442,"// Universal Mach-O files can't have an archicture slice that starts; // beyond the 4GB boundary. ""lipo"" can create a 64 bit universal; // header, but not all tools can parse these files so we want to return; // an error if the file can't be encoded as a file with a 32 bit; // universal header. To detect this, we check the size of each; // architecture's skinny Mach-O file and add up the offsets. If they; // exceed 4GB, then we return an error.; // First we compute the right offset where the first architecture will; // fit followin the 32 bit universal header. The 32 bit universal header; // starts with a uint32_t magic and a uint32_t number of architecture; // infos. Then it is followed by 5 uint32_t values for each; // architecture. So we set the start offset to the right value so we can; // calculate the exact offset that the first architecture slice can; // start at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:299,Safety,detect,detect,299,"// Universal Mach-O files can't have an archicture slice that starts; // beyond the 4GB boundary. ""lipo"" can create a 64 bit universal; // header, but not all tools can parse these files so we want to return; // an error if the file can't be encoded as a file with a 32 bit; // universal header. To detect this, we check the size of each; // architecture's skinny Mach-O file and add up the offsets. If they; // exceed 4GB, then we return an error.; // First we compute the right offset where the first architecture will; // fit followin the 32 bit universal header. The 32 bit universal header; // starts with a uint32_t magic and a uint32_t number of architecture; // infos. Then it is followed by 5 uint32_t values for each; // architecture. So we set the start offset to the right value so we can; // calculate the exact offset that the first architecture slice can; // start at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:28,Testability,log,logging,28,// FIXME: implement warning logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:20,Availability,error,error,20,// FIXME: implement error logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:26,Testability,log,logging,26,// FIXME: implement error logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:16,Availability,error,errors,16,// Don't report errors for missing remark files from static; // archives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:35,Availability,error,error,35,"// If ObjectEntry or Object has an error, no binary exists, therefore no; // reflection sections exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:7,Availability,error,errors,7,"// Any errors will be diagnosed later in the main loop, ignore them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:7,Availability,error,errors,7,"// Any errors will be diagnosed later in the main loop, ignore them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:3,Deployability,Update,Update,3,"// Update the section start with the current section's contribution, so; // the next section we copy from a different .o file points to the correct; // place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:74,Performance,cache,cache,74,"// If the module's parent directory exists, we assume that the; // module cache has expired and was pruned by clang. A more; // adventurous dsymutil would invoke clang to rebuild the module; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:17,Performance,cache,cache,17,"// If the module cache directory doesn't exist at all and the; // object file is inside a static library, we assume that the; // static library was built on a different machine. We don't want; // to discourage module debugging for convenience libraries within; // a project though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:23,Performance,load,loaded,23,// link debug info for loaded object files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:80,Integrability,depend,depending,80,/// Dispatch the valid relocation finding logic to the; /// appropriate handler depending on the object file format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:42,Testability,log,logic,42,/// Dispatch the valid relocation finding logic to the; /// appropriate handler depending on the object file format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:33,Integrability,depend,depending,33,// Dispatch to the right handler depending on the file type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:51,Testability,log,logic,51,/// DwarfLinkerForBinaryRelocationMap contains the logic to handle the; /// relocations and to store them inside an associated RelocationMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:404,Integrability,interface,interface,404,"/// The core of the Dsymutil Dwarf linking logic.; ///; /// The link of the dwarf information from the object files will be; /// driven by DWARFLinker. DwarfLinkerForBinary reads DebugMap objects; /// and pass information to the DWARFLinker. DWARFLinker; /// optimizes DWARF taking into account valid relocations.; /// Finally, optimized DWARF is passed to DwarfLinkerForBinary through; /// DWARFEmitter interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:259,Performance,optimiz,optimizes,259,"/// The core of the Dsymutil Dwarf linking logic.; ///; /// The link of the dwarf information from the object files will be; /// driven by DWARFLinker. DwarfLinkerForBinary reads DebugMap objects; /// and pass information to the DWARFLinker. DWARFLinker; /// optimizes DWARF taking into account valid relocations.; /// Finally, optimized DWARF is passed to DwarfLinkerForBinary through; /// DWARFEmitter interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:328,Performance,optimiz,optimized,328,"/// The core of the Dsymutil Dwarf linking logic.; ///; /// The link of the dwarf information from the object files will be; /// driven by DWARFLinker. DwarfLinkerForBinary reads DebugMap objects; /// and pass information to the DWARFLinker. DWARFLinker; /// optimizes DWARF taking into account valid relocations.; /// Finally, optimized DWARF is passed to DwarfLinkerForBinary through; /// DWARFEmitter interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:43,Testability,log,logic,43,"/// The core of the Dsymutil Dwarf linking logic.; ///; /// The link of the dwarf information from the object files will be; /// driven by DWARFLinker. DwarfLinkerForBinary reads DebugMap objects; /// and pass information to the DWARFLinker. DWARFLinker; /// optimizes DWARF taking into account valid relocations.; /// Finally, optimized DWARF is passed to DwarfLinkerForBinary through; /// DWARFEmitter interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:67,Availability,error,errors,67,/// Returns true if input verification is enabled and verification errors were; /// found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:17,Integrability,depend,dependencies,17,///< Walking the dependencies of a kept DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:31,Integrability,depend,dependents,31,///< Use the ODR while keeping dependents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:15,Performance,load,load,15,/// Attempt to load a debug object from disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h:4,Deployability,Update,Update,4,/// Update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h:29,Modifiability,variab,variable,29,/// Whether we want a static variable to force us to keep its enclosing; /// function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:148,Availability,error,error,148,/// Parses and returns the DebugMaps of the input binary. The binary contains; /// multiple maps in case it is a universal binary.; /// \returns an error in case the provided BinaryPath doesn't exist; /// or isn't of a supported type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:13,Performance,load,loaded,13,// Found and loaded new dSYM file,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:203,Safety,Detect,Detect,203,"// Static archives can contain multiple object files with identical names, in; // which case the timestamp is used to disambiguate. However, if both are; // identical, there's no way to tell them apart. Detect this and skip; // duplicate debug map objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:188,Integrability,interface,interface,188,"// Table that maps Darwin's Mach-O stab constants to strings to allow printing.; // llvm-nm has very similar code, the strings used here are however slightly; // different and part of the interface of dsymutil (some project's build-systems; // parse the ouptut of dsymutil -s), thus they shouldn't be changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:22,Integrability,rout,routine,22,/// This main parsing routine tries to open the main binary and if; /// successful iterates over the STAB entries. The real parsing is; /// done in handleStabSymbolTableEntry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:94,Deployability,update,update,94,"// If the last N_OSO object file wasn't found, CurrentDebugMapObject will be; // null. Do not update anything until we find the next valid N_OSO entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:20,Modifiability,variab,variable,20,// This is a global variable. We need to query the main binary; // symbol table to find its address as it might not be in the; // debug map (for common symbols).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:4,Performance,Load,Load,4,/// Load the current object file symbols into CurrentObjectAddresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:153,Availability,avail,available,153,"/// Lookup a symbol address in the main binary symbol table. The; /// parser only needs to query common symbols, thus not every symbol's; /// address is available through this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:4,Performance,Load,Load,4,/// Load the interesting main binary symbols' addresses into; /// MainBinarySymbolAddresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:58,Modifiability,variab,variables,58,"// In theory, the only symbols of interest are the global variables. These; // are the only ones that need to be queried because the address of common; // data won't be described in the debug map. All other addresses should be; // fetched for the debug map. In reality, by playing with 'ld -r' and; // export lists, you can get symbols described as N_GSYM in the debug map,; // but associated with a local symbol. Gather all the symbols, but prefer; // the global ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:121,Safety,avoid,avoid,121,// Return a MachO::segment_command_64 that holds the same values as the passed; // MachO::segment_command. We do that to avoid having to duplicate the logic; // for 32bits and 64bits segments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:151,Testability,log,logic,151,// Return a MachO::segment_command_64 that holds the same values as the passed; // MachO::segment_command. We do that to avoid having to duplicate the logic; // for 32bits and 64bits segments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:3,Integrability,Wrap,Wrapper,3,// Wrapper around transferSymbol to transfer all of \a Obj symbols; // to \a NewSymtab. This function does not write in the output file.; // \returns the number of symbols in \a NewSymtab.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:314,Deployability,update,updated,314,"// Transfer \a Segment from \a Obj to the output file. This calls into \a Writer; // to write these load commands directly in the output file at the current; // position.; //; // The function also tries to find a hole in the address map to fit the __DWARF; // segment of \a DwarfSegmentSize size. \a EndAddress is updated to point at the; // highest segment address.; //; // When the __LINKEDIT segment is transferred, its offset and size are set resp.; // to \a LinkeditOffset and \a LinkeditSize.; //; // When the eh_frame section is transferred, its offset and size are set resp.; // to \a EHFrameOffset and \a EHFrameSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:100,Performance,load,load,100,"// Transfer \a Segment from \a Obj to the output file. This calls into \a Writer; // to write these load commands directly in the output file at the current; // position.; //; // The function also tries to find a hole in the address map to fit the __DWARF; // segment of \a DwarfSegmentSize size. \a EndAddress is updated to point at the; // highest segment address.; //; // When the __LINKEDIT segment is transferred, its offset and size are set resp.; // to \a LinkeditOffset and \a LinkeditSize.; //; // When the eh_frame section is transferred, its offset and size are set resp.; // to \a EHFrameOffset and \a EHFrameSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:29,Performance,load,load,29,// Write the __DWARF segment load command to the output file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:25,Performance,load,load,25,// Compute the number of load commands we will need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:13,Performance,load,load,13,// Write the load commands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:13,Performance,load,load,13,// Write the load commands for the segments and sections we 'import' from; // the original binary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:13,Performance,load,load,13,// Write the load command for the __DWARF segment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:111,Integrability,depend,depend,111,"// Apply relocations to the contents of the DWARF segment.; // We do this here because the final value written depend on the DWARF vm; // addr, which is only calculated in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.h:45,Deployability,patch,patched,45,"// The position in the stream that should be patched, starting from the; // Dwarf's segment file address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/RelocationMap.cpp:3,Integrability,Wrap,WrapColumn,3,/* WrapColumn = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/RelocationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/RelocationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/SymbolMap.cpp:217,Safety,risk,risk,217,"// We need permanent storage for the string we are about to create. Just; // append it to the vector containing translations. This should only happen; // during MachO symbol table translation, thus there should be no risk on; // exponential growth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/SymbolMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/SymbolMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:460,Integrability,interface,interface,460,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:13,Modifiability,plugin,plugin,13,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:26,Modifiability,Plugin,Plugin,26,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:397,Modifiability,plugin,plugin,397,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:55,Performance,Optimiz,Optimization,55,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:3,Modifiability,plugin,plugin-api,3,// plugin-api.h requires HAVE_STDINT_H,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:9,Integrability,wrap,wrapper,9,/// RAII wrapper to manage opening and releasing of a ld_plugin_input_file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:20,Modifiability,plugin,plugin,20,"// When the thinlto plugin option is specified, only read the function; // the information from intermediate files and write a combined; // global index for the ThinLTO backends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:116,Modifiability,plugin,plugin,116,"// If false, all ThinLTO backend compilations through code gen are performed; // using multiple threads in the gold-plugin, before handing control back to; // gold. If true, write individual backend index files which reflect; // the import decisions, and exit afterwards. The assumption is; // that the build system will launch the backend processes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:67,Performance,perform,performed,67,"// If false, all ThinLTO backend compilations through code gen are performed; // using multiple threads in the gold-plugin, before handing control back to; // gold. If true, write individual backend index files which reflect; // the import decisions, and exit afterwards. The assumption is; // that the build system will launch the backend processes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:540,Safety,detect,detected,540,"// If non-empty, holds the name of a file in which to write the list of; // oject files gold selected for inclusion in the link after symbol; // resolution (i.e. they had selected symbols). This will only be non-empty; // in the thinlto_index_only case. It is used to identify files, which may; // have originally been within archive libraries specified via; // --start-lib/--end-lib pairs, that should be included in the final; // native link process (since intervening function importing and inlining; // may change the symbol resolution detected in the final link and which; // files to include out of --start-lib/--end-lib libraries as a result).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:39,Performance,cache,caches,39,// Optional pruning policy for ThinLTO caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:93,Modifiability,plugin,plugin,93,// Additional options to pass into the code generator.; // Note: This array will contain all plugin options which are not claimed; // as plugin exclusive to pass to the code generator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:137,Modifiability,plugin,plugin,137,// Additional options to pass into the code generator.; // Note: This array will contain all plugin options which are not claimed; // as plugin exclusive to pass to the code generator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:3,Testability,Assert,Asserts,3,// Asserts that LTO link has whole program visibility,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization remarks filename, accepted passes and hotness options",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:141,Modifiability,plugin,plugin-api,141,"// Cast tv_tag to int to allow values not in ""enum ld_plugin_tag"", like, for; // example, LDPT_GET_SYMBOLS_V3 when building against an older plugin-api.h; // header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:60,Modifiability,plugin,plugin,60,/// Called by gold to see whether this file is one that our plugin can handle.; /// We'll try to open it and register all the symbols with add_symbol if; /// possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:228,Deployability,release,released,228,"// Keep track of the first handle for each file descriptor, since there are; // multiple in the case of an archive. This is used later in the case of; // ThinLTO parallel backends to ensure that each file is only opened and; // released once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:16,Integrability,wrap,wrap,16,"// Handle any --wrap options passed to gold, which are than passed; // along to the plugin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:84,Modifiability,plugin,plugin,84,"// Handle any --wrap options passed to gold, which are than passed; // along to the plugin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:3,Deployability,Toggle,Toggle,3,// Toggle function/data sections.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:10,Performance,optimiz,optimization,10,// Set up optimization remarks handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:74,Integrability,interface,interfaces,74,"// Map to own RAII objects that manage the file opening and releasing; // interfaces with gold. This is needed only for ThinLTO mode, since; // unlike regular LTO, where addModule will result in the opened file; // being merged into a new combined module, we need to keep these files open; // through Lto->run().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:182,Performance,perform,perform,182,"/// gold informs us that all symbols have been read. At this point, we use; /// get_symbols to see if any of our definitions have been overridden by a; /// native object file. Then, perform optimization and codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:190,Performance,optimiz,optimization,190,"/// gold informs us that all symbols have been read. At this point, we use; /// get_symbols to see if any of our definitions have been overridden by a; /// native object file. Then, perform optimization and codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:9,Performance,cache,cache,9,// Prune cache,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:464,Integrability,interface,interface,464,"//===-- llc.cpp - Implement the LLVM Native Code Generator ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the llc code generator driver. It provides a convenient; // command-line interface for generating an assembly file or a relocatable file,; // given LLVM bitcode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:13,Performance,optimiz,optimization,13,// Determine optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:70,Deployability,pipeline,pipeline,70,"// This flag specifies a textual description of the optimization pass pipeline; // to run over the module. This flag switches opt to use the new pass manager; // infrastructure, completely disabling all of the flags specific to the old; // pass management.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:52,Performance,optimiz,optimization,52,"// This flag specifies a textual description of the optimization pass pipeline; // to run over the module. This flag switches opt to use the new pass manager; // infrastructure, completely disabling all of the flags specific to the old; // pass management.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:36,Testability,test,tests,36,"// RemoveDIs debug-info transition: tests may request that we /try/ to use the; // new debug-info format, if it's built in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:59,Availability,error,error,59,// Set a diagnostic handler that doesn't exit on the first error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:3,Performance,Load,Load,3,// Load the module to be compiled...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:34,Performance,load,loaded,34,// Set attributes on functions as loaded from MIR from command line arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:188,Modifiability,variab,variables,188,"// Since the storage mapping class is specified per csect,; // without using data sections, it is less effective to use read-only; // pointers. Using read-only pointers may cause other RO variables in the; // same csect to become RW when the linker acts upon `-bforceimprw`;; // therefore, we require that separate data sections are used in the; // presence of ReadOnlyPointers. We respect the setting of data-sections; // since we have not found reasons to do otherwise that overcome the user; // surprise of not respecting the setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:30,Availability,avail,available,30,"// If user just wants to list available options, skip module loading",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:61,Performance,load,loading,61,"// If user just wants to list available options, skip module loading",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:60,Availability,down,down,60,// If we don't have a module then just exit now. We do this down; // here since the CPU/Feature help is underneath the target machine; // creation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:33,Availability,down,down,33,// Ensure the filename is passed down to CodeViewDebug.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:16,Usability,simpl,simplify-libcalls,16,// The -disable-simplify-libcalls flag actually disables all builtin optzns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:27,Deployability,pipeline,pipeline,27,// Construct a custom pass pipeline that starts after instruction; // selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp:439,Testability,log,logically,439,"//===- NewPMDriver.cpp - Driver for llc using new PM ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file is just a split of the code that logically belongs in llc.cpp but; /// that includes the new pass manager headers.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp:7,Testability,test,testing,7,"// For testing purposes, we print the LocCookie here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp:27,Deployability,pipeline,pipeline,27,// Construct a custom pass pipeline that starts after instruction; // selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h:680,Integrability,rout,routines,680,"//===- NewPMDriver.h - Function to drive llc with the new PM ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// A single function which is called to drive the llc behavior for the new; /// PassManager.; ///; /// This is only in a separate TU with a header to avoid including all of the; /// old pass manager headers and the new pass manager headers into the same; /// file. Eventually all of the routines here will get folded back into; /// llc.cpp.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h:543,Safety,avoid,avoid,543,"//===- NewPMDriver.h - Function to drive llc with the new PM ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// A single function which is called to drive the llc behavior for the new; /// PassManager.; ///; /// This is only in a separate TU with a header to avoid including all of the; /// old pass manager headers and the new pass manager headers into the same; /// file. Eventually all of the routines here will get folded back into; /// llc.cpp.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h:18,Energy Efficiency,Adapt,Adapter,18,// ForwardingMM - Adapter to connect MCJIT to Orc's Remote; // memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h:18,Integrability,Adapter,Adapter,18,// ForwardingMM - Adapter to connect MCJIT to Orc's Remote; // memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h:18,Modifiability,Adapt,Adapter,18,// ForwardingMM - Adapter to connect MCJIT to Orc's Remote; // memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:587,Availability,avail,available,587,"//===- lli.cpp - LLVM Interpreter / Dynamic compiler ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple wrapper around the LLVM Execution Engines,; // which allow the direct execution of LLVM programs through a Just-In-Time; // compiler, or through an interpreter if no JIT is available for this platform.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:414,Integrability,wrap,wrapper,414,"//===- lli.cpp - LLVM Interpreter / Dynamic compiler ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple wrapper around the LLVM Execution Engines,; // which allow the direct execution of LLVM programs through a Just-In-Time; // compiler, or through an interpreter if no JIT is available for this platform.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:407,Usability,simpl,simple,407,"//===- lli.cpp - LLVM Interpreter / Dynamic compiler ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple wrapper around the LLVM Execution Engines,; // which allow the direct execution of LLVM programs through a Just-In-Time; // compiler, or through an interpreter if no JIT is available for this platform.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:115,Energy Efficiency,allocate,allocates,115,// Manually specify the child process for remote execution. This overrides; // the simulated remote execution that allocates address space for child; // execution. The child process will be executed and will communicate with; // lli via stdin/stdout pipes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:13,Performance,optimiz,optimization,13,// Determine optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:92,Performance,cache,cache,92,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:118,Performance,cache,cache,118,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:146,Performance,cache,cached,146,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:203,Performance,Cache,CacheDir,203,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:273,Performance,cache,cache,273,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:288,Performance,load,load,288,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:348,Performance,Cache,CacheDir,348,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:399,Performance,cache,cached,399,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:23,Performance,cache,cache,23,// Add trailing '/' to cache dir if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:23,Performance,cache,cache,23,// Create user-defined cache dir.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Performance,Load,Load,3,// Load the object from the cache filename,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:28,Performance,cache,cache,28,// Load the object from the cache filename,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:181,Deployability,release,released,181,"// MCJIT will want to write into this buffer, and we don't want that; // because the file has probably just been mmapped. Instead we make; // a copy. The filed-based buffer will be released when it goes; // out of scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:142,Safety,avoid,avoid,142,"// On Mingw and Cygwin, an external symbol named '__main' is called from the; // generated 'main' function to allow static initialization. To avoid linking; // problems with remote targets (because lli's remote target support does not; // currently handle external linking) we add a secondary module which defines; // an empty '__main' function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:79,Usability,usab,usable,79,"// If we have a native target, initialize it to ensure it is linked in and; // usable by the JIT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Performance,Load,Load,3,// Load the bitcode...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:26,Performance,load,load,26,"// If not jitting lazily, load the whole bitcode file eagerly too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Performance,Load,Load,3,// Load any additional modules specified on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:112,Deployability,configurat,configuration,112,// The following functions have no effect if their respective profiling; // support wasn't enabled in the build configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:112,Modifiability,config,configuration,112,// The following functions have no effect if their respective profiling; // support wasn't enabled in the build configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check use of remote-jit: LLI currently only supports use of the; // remote JIT on Unix platforms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:21,Performance,cache,cache,21,// Clear instruction cache before code will be executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Usability,Clear,Clear,3,// Clear instruction cache before code will be executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:146,Availability,down,down,146,"// Like static constructors, the remote target MCJIT support doesn't handle; // this yet. It could. FIXME.; // Delete the EE - we need to tear it down *before* we terminate the session; // with the remote, otherwise it'll crash when it tries to release resources; // on a remote that has already been disconnected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:245,Deployability,release,release,245,"// Like static constructors, the remote target MCJIT support doesn't handle; // this yet. It could. FIXME.; // Delete the EE - we need to tear it down *before* we terminate the session; // with the remote, otherwise it'll crash when it tries to release resources; // on a remote that has already been disconnected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:86,Integrability,Interface,Interface,86,// JITLink debug support plugins put information about JITed code in this GDB; // JIT Interface global from OrcTargetProcess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:25,Modifiability,plugin,plugins,25,// JITLink debug support plugins put information about JITed code in this GDB; // JIT Interface global from OrcTargetProcess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:387,Availability,error,error,387,"// Cygwin and MinGW insert calls from the main function to the runtime; // function __main. The __main function is responsible for setting up main's; // environment (e.g. running static constructors), however this is not needed; // when running under lli: the executor process will have run non-JIT ctors,; // and ORC will take care of running JIT'd ctors. To avoid a missing symbol; // error we just implement __main as a no-op.; //; // FIXME: Move this to ORC-RT (and the ORC-RT substitution library once it; // exists). That will allow it to work out-of-process, and for all; // ORC tools (the problem isn't lli specific).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:360,Safety,avoid,avoid,360,"// Cygwin and MinGW insert calls from the main function to the runtime; // function __main. The __main function is responsible for setting up main's; // environment (e.g. running static constructors), however this is not needed; // when running under lli: the executor process will have run non-JIT ctors,; // and ORC will take care of running JIT'd ctors. To avoid a missing symbol; // error we just implement __main as a no-op.; //; // FIXME: Move this to ORC-RT (and the ORC-RT substitution library once it; // exists). That will allow it to work out-of-process, and for all; // ORC tools (the problem isn't lli specific).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:144,Availability,error,error,144,// FIXME: Setting a dummy call-through manager in non-lazy mode prevents the; // JIT builder to instantiate a default (which would fail with an error for; // unsupported architectures).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:17,Performance,cache,cache,17,// If the object cache is enabled then set a custom compile function; // creator to use the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:92,Performance,cache,cache,92,// If the object cache is enabled then set a custom compile function; // creator to use the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:216,Testability,stub,stubs,216,// Regular modules are greedy: They materialize as a whole and trigger; // materialization for all required symbols recursively. Lazy modules go; // through partitioning and they replace outgoing calls with reexport stubs; // that resolve on call-through.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:12,Usability,Simpl,SimpleRemoteEPC,12,// Return a SimpleRemoteEPC instance connected to our end of the pipes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:739,Availability,avail,available,739,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:277,Deployability,configurat,configurations,277,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:326,Deployability,configurat,configurations,326,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:422,Deployability,configurat,configurations,422,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:1129,Energy Efficiency,allocate,allocate,1129,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:277,Modifiability,config,configurations,277,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:326,Modifiability,config,configurations,326,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:422,Modifiability,config,configurations,422,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:871,Testability,test,tests,871,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:1003,Testability,test,tests,1003,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ChildTarget/ChildTarget.cpp:383,Usability,Simpl,Simple,383,"//===----------- ChildTarget.cpp - Out-of-proc executor for lli -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Simple out-of-process executor for lli.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/ChildTarget/ChildTarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ChildTarget/ChildTarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:1485,Deployability,update,update,1485,"R""(OPTIONS:; --format - archive format to create; =default - default; =gnu - gnu; =darwin - darwin; =bsd - bsd; =bigarchive - big archive (AIX OS); --plugin=<string> - ignored for compatibility; -h --help - display this help and exit; --output - the directory to extract archive members to; --rsp-quoting - quoting style for response files; =posix - posix; =windows - windows; --thin - create a thin archive; --version - print the version and exit; -X{32|64|32_64|any} - object mode (only for AIX OS); @<file> - read options from <file>. OPERATIONS:; d - delete [files] from the archive; m - move [files] in the archive; p - print contents of [files] found in the archive; q - quick append [files] to the archive; r - replace or insert [files] into the archive; s - act as ranlib; t - display list of files in archive; x - extract [files] from the archive. MODIFIERS:; [a] - put [files] after [relpos]; [b] - put [files] before [relpos] (same as [i]); [c] - do not warn if archive had to be created; [D] - use zero for timestamps and uids/gids (default); [h] - display this help and exit; [i] - put [files] before [relpos] (same as [b]); [l] - ignored for compatibility; [L] - add archive's contents; [N] - use instance [count] of name; [o] - preserve original dates; [O] - display member offsets; [P] - use full names when matching (implied for thin archives); [s] - create an archive index (cf. ranlib); [S] - do not build a symbol table; [T] - deprecated, use --thin instead; [u] - update only [files] newer than archive contents; [U] - use actual timestamps and uids/gids; [v] - be verbose about actions taken; [V] - display the version and exit; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:150,Modifiability,plugin,plugin,150,"R""(OPTIONS:; --format - archive format to create; =default - default; =gnu - gnu; =darwin - darwin; =bsd - bsd; =bigarchive - big archive (AIX OS); --plugin=<string> - ignored for compatibility; -h --help - display this help and exit; --output - the directory to extract archive members to; --rsp-quoting - quoting style for response files; =posix - posix; =windows - windows; --thin - create a thin archive; --version - print the version and exit; -X{32|64|32_64|any} - object mode (only for AIX OS); @<file> - read options from <file>. OPERATIONS:; d - delete [files] from the archive; m - move [files] in the archive; p - print contents of [files] found in the archive; q - quick append [files] to the archive; r - replace or insert [files] into the archive; s - act as ranlib; t - display list of files in archive; x - extract [files] from the archive. MODIFIERS:; [a] - put [files] after [relpos]; [b] - put [files] before [relpos] (same as [i]); [c] - do not warn if archive had to be created; [D] - use zero for timestamps and uids/gids (default); [h] - display this help and exit; [i] - put [files] before [relpos] (same as [b]); [l] - ignored for compatibility; [L] - add archive's contents; [N] - use instance [count] of name; [o] - preserve original dates; [O] - display member offsets; [P] - use full names when matching (implied for thin archives); [s] - create an archive index (cf. ranlib); [S] - do not build a symbol table; [T] - deprecated, use --thin instead; [u] - update only [files] newer than archive contents; [U] - use actual timestamps and uids/gids; [v] - be verbose about actions taken; [V] - display the version and exit; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:12,Availability,error,error,12,"// Show the error plus the usage message, and exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:33,Integrability,message,message,33,"// Show the error plus the usage message, and exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:12,Availability,error,error,12,// Show the error message and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:18,Integrability,message,message,18,// Show the error message and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:75,Modifiability,variab,variable,75,"///< 'L' modifier; // Relative Positional Argument (for insert/move). This variable holds; // the name of the archive member to which the 'a', 'b' or 'i' modifier; // refers. Only one of 'a', 'b' or 'i' can be specified so we only need; // one variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:244,Modifiability,variab,variable,244,"///< 'L' modifier; // Relative Positional Argument (for insert/move). This variable holds; // the name of the archive member to which the 'a', 'b' or 'i' modifier; // refers. Only one of 'a', 'b' or 'i' can be specified so we only need; // one variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:42,Modifiability,variab,variable,42,"// Count parameter for 'N' modifier. This variable specifies which file should; // match for extract/delete operations when there are multiple matches. This is; // 1-indexed. A value of 0 is invalid, and implies 'N' is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:8,Modifiability,variab,variable,8,// This variable holds the name of the archive file as given on the; // command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:8,Modifiability,variab,variable,8,"// This variable holds the list of member files to proecess, as given; // on the command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:3,Performance,Perform,Perform,3,// Perform various checks on the operation/modifier specification; // to make sure we are dealing with a legal request.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:131,Testability,Test,Test,131,"// If OutputDir is not a directory, create_directories may still succeed if; // all components of the path prefix are directories. Test is_directory as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:19,Performance,optimiz,optimize,19,"// We could try to optimize this to a fstat, but it is not a common; // operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:122,Energy Efficiency,efficient,efficient,122,"// We have to walk this twice and computing it is not trivial, so creating an; // explicit std::vector is actually fairly efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:221,Deployability,update,update,221,"// When an archive is created or modified, if the s option is given, the; // resulting archive will have a current symbol table. If the S option; // is given, it will have no symbol table.; // In summary, we only need to update the symbol table if we have none.; // This is actually very common because of broken build systems that think; // they have to run ranlib.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:31,Modifiability,variab,variable,31,"// Get BitMode from enviorment variable ""OBJECT_MODE"" for AIX OS, if; // specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:57,Modifiability,variab,variable,57,"// If not specify -X option, get BitMode from enviorment variable; // ""OBJECT_MODE"" for AIX OS if specify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:85,Availability,error,error,85,"// Don't bother printing reason, just return to the test function,; // since a fatal error represents a successful parse (i.e. it correctly; // terminated with an error message to the user).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:163,Availability,error,error,163,"// Don't bother printing reason, just return to the test function,; // since a fatal error represents a successful parse (i.e. it correctly; // terminated with an error message to the user).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:169,Integrability,message,message,169,"// Don't bother printing reason, just return to the test function,; // since a fatal error represents a successful parse (i.e. it correctly; // terminated with an error message to the user).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:52,Testability,test,test,52,"// Don't bother printing reason, just return to the test function,; // since a fatal error represents a successful parse (i.e. it correctly; // terminated with an error message to the user).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for locals before setjmp so that memory can be collected; // if parse exits prematurely (via longjmp).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:8,Availability,echo,echo,8,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:410,Availability,echo,echo,410,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:609,Security,validat,validate,609,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:28,Testability,test,testing,28,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:433,Testability,test,test,433,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:14,Modifiability,variab,variable,14,// Try global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:76,Integrability,depend,dependency,76,"// If we have a hit, it means we already generated the instruction; // as a dependency to something else. We need to make sure; // it is ordered properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h:15,Testability,test,test,15,"/*===-- llvm-c-test.h - tool for testing libLLVM and llvm-c API -----------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Header file for llvm-c-test *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h:33,Testability,test,testing,33,"/*===-- llvm-c-test.h - tool for testing libLLVM and llvm-c API -----------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Header file for llvm-c-test *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h:431,Testability,test,test,431,"/*===-- llvm-c-test.h - tool for testing libLLVM and llvm-c API -----------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Header file for llvm-c-test *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h:3,Availability,echo,echo,3,// echo.c,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp:403,Testability,test,testing,403,"//===- llvm-cat.cpp - LLVM module concatenation utility -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is for testing features that rely on multi-module bitcode files.; // It takes a list of input modules and uses them to create a multi-module; // bitcode file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp:108,Availability,alive,alive,108,"// The string table does not own strings added to it, some of which are; // owned by the modules; keep them alive until we write the string table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/llvm-cfi-verify.cpp:415,Security,Integrity,Integrity,415,"//===-- llvm-cfi-verify.cpp - CFI Verification tool for LLVM --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool verifies Control Flow Integrity (CFI) instrumentation by static; // binary analysis. See the design document in /docs/CFIVerify.rst for more; // information.; //; // This tool is currently incomplete. It currently only does disassembly for; // object files, and searches through the code for indirect control flow; // instructions, printing them once found.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/llvm-cfi-verify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/llvm-cfi-verify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:45,Performance,load,load,45,"// Some architectures (e.g., AArch64) cannot load in an indirect branch, so; // we allow them one load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:98,Performance,load,load,98,"// Some architectures (e.g., AArch64) cannot load in an indirect branch, so; // we allow them one load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:26,Performance,load,load,26,// Add the registers this load reads to those we check for clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:53,Availability,failure,failures,53,// Avoid checking the PLT since it produces spurious failures on AArch64; // when ignoring DWARF data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:3,Safety,Avoid,Avoid,3,// Avoid checking the PLT since it produces spurious failures on AArch64; // when ignoring DWARF data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:77,Availability,error,error,77,"// The instruction referenced does not exist. This normally indicates an; // error in the program, where you try and validate a graph that was created; // in a different FileAnalysis object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:117,Security,validat,validate,117,"// The instruction referenced does not exist. This normally indicates an; // error in the program, where you try and validate a graph that was created; // in a different FileAnalysis object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:222,Performance,load,load,222,"// Returns the first place the operand register is clobbered between the CFI-; // check and the indirect CF instruction execution. We do this by walking; // backwards from the indirect CF and ensuring there is at most one load; // involving the operand register (which is the indirect CF itself on x86).; // If the register is not modified, returns the address of the indirect CF; // instruction. The result is undefined if the provided graph does not fall; // under either the FAIL_REGISTER_CLOBBERED or PROTECTED status (see; // CFIProtectionStatus).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:111,Integrability,depend,dependency,111,"// Construct a blank object with the provided triple and features. Used in; // testing, where a sub class will dependency inject protected methods to; // allow analysis of raw binary, without requiring a fully valid ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:122,Integrability,inject,inject,122,"// Construct a blank object with the provided triple and features. Used in; // testing, where a sub class will dependency inject protected methods to; // allow analysis of raw binary, without requiring a fully valid ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:122,Security,inject,inject,122,"// Construct a blank object with the provided triple and features. Used in; // testing, where a sub class will dependency inject protected methods to; // allow analysis of raw binary, without requiring a fully valid ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:79,Testability,test,testing,79,"// Construct a blank object with the provided triple and features. Used in; // testing, where a sub class will dependency inject protected methods to; // allow analysis of raw binary, without requiring a fully valid ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:140,Safety,avoid,avoid,140,// A mapping between the virtual memory address to the instruction metadata; // struct. TODO(hctim): Reimplement this as a sorted vector to avoid per-; // insertion allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/GraphBuilder.h:228,Deployability,update,update,228,"// Utilised by buildFlowGraphImpl to build the tree out from the provided; // conditional branch node to an undefined instruction. The provided; // conditional branch node must have exactly one of its subtrees set, and will; // update the node's CFIProtection field if a deterministic flow can be found; // to an undefined instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/GraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/GraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:538,Availability,avail,available,538,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:39,Deployability,configurat,configuration,39,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:440,Deployability,configurat,configuration,440,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:518,Deployability,install,installed,518,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:13,Modifiability,config,config,13,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:39,Modifiability,config,configuration,39,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:440,Modifiability,config,configuration,440,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:26,Modifiability,variab,variables,26,// Include the build time variables we can report to the user. This is generated; // at build time from the BuildVariables.inc.in file by the build system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:68,Availability,Avail,AvailableComponent,68,"// Include the component table. This creates an array of struct; // AvailableComponent entries, which record the component name, library name,; // and required components for all of the available libraries.; //; // Not all components define a library, we also use ""library groups"" as a way to; // create entries for pseudo groups like x86 or all-targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:186,Availability,avail,available,186,"// Include the component table. This creates an array of struct; // AvailableComponent entries, which record the component name, library name,; // and required components for all of the available libraries.; //; // Not all components define a library, we also use ""library groups"" as a way to; // create entries for pseudo groups like x86 or all-targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:43,Integrability,depend,dependencies,43,"// Built-in extensions also register their dependencies, but in a separate file,; // later in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:69,Modifiability,config,config,69,// LinkMode determines what libraries and flags are returned by llvm-config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:207,Availability,avail,available,207,"// LinkModeAuto will link with the default link mode for the installation,; // which is dependent on the value of LLVM_LINK_LLVM_DYLIB, and fall back; // to the alternative if the required libraries are not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:61,Deployability,install,installation,61,"// LinkModeAuto will link with the default link mode for the installation,; // which is dependent on the value of LLVM_LINK_LLVM_DYLIB, and fall back; // to the alternative if the required libraries are not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:88,Integrability,depend,dependent,88,"// LinkModeAuto will link with the default link mode for the installation,; // which is dependent on the value of LLVM_LINK_LLVM_DYLIB, and fall back; // to the alternative if the required libraries are not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:98,Availability,error,error,98,"// LinkModeShared will link with the dynamic component libraries if they; // exist, and return an error otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:97,Availability,error,error,97,"// LinkModeStatic will link with the static component libraries if they; // exist, and return an error otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:20,Deployability,install,installed,20,// Only include non-installed components if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:28,Integrability,depend,dependencies,28,"// Otherwise, visit all the dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:137,Performance,load,loaded,137,"// Special handling for the special 'extensions' component. Its content is; // not populated by llvm-build, but later in the process and loaded from; // ExtensionDependencies.inc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:314,Deployability,install,installed,314,"/// Compute the list of required libraries for a given list of; /// components, in an order suitable for passing to a linker (that is, libraries; /// appear prior to their dependencies).; ///; /// \param Components - The names of the components to find libraries for.; /// \param IncludeNonInstalled - Whether non-installed components should be; /// reported.; /// \param GetComponentNames - True if one would prefer the component names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:172,Integrability,depend,dependencies,172,"/// Compute the list of required libraries for a given list of; /// components, in an order suitable for passing to a linker (that is, libraries; /// appear prior to their dependencies).; ///; /// \param Components - The names of the components to find libraries for.; /// \param IncludeNonInstalled - Whether non-installed components should be; /// reported.; /// \param GetComponentNames - True if one would prefer the component names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:3,Security,Validat,Validate,3,// Validate that the user supplied a valid component name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:106,Integrability,depend,dependency,106,"// The list is now ordered with leafs first, we want the libraries to printed; // in the reverse order of dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:93,Deployability,install,installed,93,// llvm-config is designed to support being run both from a development tree; // and from an installed path. We try and auto-detect which case we are in so; // that we can report the correct information when run from a development; // tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:8,Modifiability,config,config,8,// llvm-config is designed to support being run both from a development tree; // and from an installed path. We try and auto-detect which case we are in so; // that we can report the correct information when run from a development; // tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:125,Safety,detect,detect,125,// llvm-config is designed to support being run both from a development tree; // and from an installed path. We try and auto-detect which case we are in so; // that we can report the correct information when run from a development; // tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:18,Safety,avoid,avoid,18,// Initialized to avoid warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:117,Availability,avail,available,117,"/// We only use `shared library` mode in cases where the static library form; /// of the components provided are not available; note however that this is; /// skipped if we're run from within the build dir. However, once installed,; /// we still need to provide correct output when the static archives are; /// removed or, as in the case of CMake's `BUILD_SHARED_LIBS`, never present; /// in the first place. This can't be done at configure/build time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:221,Deployability,install,installed,221,"/// We only use `shared library` mode in cases where the static library form; /// of the components provided are not available; note however that this is; /// skipped if we're run from within the build dir. However, once installed,; /// we still need to provide correct output when the static archives are; /// removed or, as in the case of CMake's `BUILD_SHARED_LIBS`, never present; /// in the first place. This can't be done at configure/build time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:431,Modifiability,config,configure,431,"/// We only use `shared library` mode in cases where the static library form; /// of the components provided are not available; note however that this is; /// skipped if we're run from within the build dir. However, once installed,; /// we still need to provide correct output when the static archives are; /// removed or, as in the case of CMake's `BUILD_SHARED_LIBS`, never present; /// in the first place. This can't be done at configure/build time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:44,Availability,error,error,44,// The shared library does not exist: don't error unless the user; // explicitly passes --link-shared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:20,Deployability,install,installed,20,// Only include non-installed components when in a development tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:79,Integrability,depend,dependent,79,// Print SYSTEM_LIBS after --libs.; // FIXME: Each LLVM component may have its dependent system libs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:14,Availability,error,error,14,/// Print the error message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:35,Availability,error,error,35,/// Print the error message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:20,Integrability,message,message,20,/// Print the error message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:37,Availability,error,error,37,/// Print the warning message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:22,Integrability,message,message,22,/// Print the warning message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:34,Performance,cache,cache,34,/// Retrieve a file status with a cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:57,Availability,error,error,57,/// Load the coverage mapping data. Return nullptr if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:4,Performance,Load,Load,4,/// Load the coverage mapping data. Return nullptr if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:22,Availability,avail,available,22,"/// If a demangler is available, demangle all symbol names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:16,Performance,cache,cache,16,/// File status cache used when finding the same file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:6,Performance,cache,cache,6,/// A cache for demangled symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:3,Performance,Cache,Cache,3,// Cache the demangled names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:29,Safety,safe,safe,29,"// In -output-dir mode, it's safe to use multiple threads to print files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:68,Availability,error,error,68,// Unreachable because we should have gracefully terminated with an error; // above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporter.h:427,Integrability,interface,interface,427,"//===- CoverageExporter.h - Code coverage exporter ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class defines a code coverage exporter interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporterLcov.cpp:1250,Security,checksum,checksum,1250,"//===- CoverageExporterLcov.cpp - Code coverage export --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements export of code coverage data to lcov trace file format.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; //; // The trace file code coverage export follows the following format (see also; // https://linux.die.net/man/1/geninfo). Each quoted string appears on its own; // line; the indentation shown here is only for documentation purposes.; //; // - for each source file:; // - ""SF:<absolute path to source file>""; // - for each function:; // - ""FN:<line number of function start>,<function name>""; // - for each function:; // - ""FNDA:<execution count>,<function name>""; // - ""FNF:<number of functions found>""; // - ""FNH:<number of functions hit>""; // - for each instrumented line:; // - ""DA:<line number>,<execution count>[,<checksum>]; // - for each branch:; // - ""BRDA:<line number>,<branch pair id>,<branch id>,<count>""; // - ""BRF:<number of branches found>""; // - ""BRH:<number of branches hit>""; // - ""LH:<number of lines with non-zero execution count>""; // - ""LF:<number of instrumented lines>""; // - ""end_of_record""; //; // If the user is exporting summary information only, then the FN, FNDA, and DA; // lines will not be present.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporterLcov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporterLcov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:22,Availability,redundant,redundant,22,/// Get the number of redundant path components in each path in \p Paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:22,Safety,redund,redundant,22,/// Get the number of redundant path components in each path in \p Paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:31,Availability,redundant,redundant,31,"// To start, set the number of redundant path components to the maximum; // possible value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:31,Safety,redund,redundant,31,"// To start, set the number of redundant path components to the maximum; // possible value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:33,Availability,redundant,redundant,33,// Do not increase the number of redundant components: that would remove; // useful parts of already-visited paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:33,Safety,redund,redundant,33,// Do not increase the number of redundant components: that would remove; // useful parts of already-visited paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:23,Availability,redundant,redundant,23,"// Lower the number of redundant components when there's a mismatch; // between the first path, and the path under consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:23,Safety,redund,redundant,23,"// Lower the number of redundant components when there's a mismatch; // between the first path, and the path under consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,Availability,redundant,redundant,40,/// Determine the length of the longest redundant prefix of the paths in; /// \p Paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,Safety,redund,redundant,40,/// Determine the length of the longest redundant prefix of the paths in; /// \p Paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:55,Availability,redundant,redundant,55,"// If there's at most one path, no path components are redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:55,Safety,redund,redundant,55,"// If there's at most one path, no path components are redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,Availability,redundant,redundant,40,"/// Determine the length of the longest redundant prefix of the substrs starts; /// from \p LCP in \p Paths. \p Paths can't be empty. If there's only one; /// element in \p Paths, the length of the substr is returned. Note this is; /// differnet from the behavior of the function above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,Safety,redund,redundant,40,"/// Determine the length of the longest redundant prefix of the substrs starts; /// from \p LCP in \p Paths. \p Paths can't be empty. If there's only one; /// element in \p Paths, the length of the substr is returned. Note this is; /// differnet from the behavior of the function above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h:340,Availability,error,error,340,"/// Prepare file reports for each directory in \p SourceFiles. The total; /// report for all files is returned and its Name is set to the LCP of all; /// files. The size of \p SourceFiles must be greater than 1 or else the; /// behavior is undefined, in which case you should use; /// CoverageReport::prepareSingleFileReport instead. If an error occurs,; /// the recursion will stop immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h:16,Modifiability,variab,variables,16,// These member variables below are used for avoiding being passed; // repeatedly in recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h:45,Safety,avoid,avoiding,45,// These member variables below are used for avoiding being passed; // repeatedly in recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageSummaryInfo.h:6,Performance,cache,cache,6,/// A cache for demangled symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageViewOptions.h:58,Availability,avail,available,58,/// Check if the created time of the profile data file is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageViewOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageViewOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp:64,Performance,concurren,concurrent,64,// Open .gcda and .gcda without requiring a NUL terminator. The concurrent; // modification may nullify the NUL terminator condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp:3,Usability,Clear,Clear,3,// Clear the filename to make it clear we didn't read anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp:33,Usability,clear,clear,33,// Clear the filename to make it clear we didn't read anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/llvm-cov.cpp:46,Testability,test,testing,46,/// The main entry point for the 'convert-for-testing' subcommand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/llvm-cov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/llvm-cov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp:65,Availability,error,error,65,// Unreachable because CodeCoverage.cpp should terminate with an error; // before we get here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp:65,Availability,error,error,65,// Unreachable because CodeCoverage.cpp should terminate with an error; // before we get here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:24,Integrability,Interface,Interface,24,/// @name File Creation Interface; /// @{; /// Create a file to print a coverage view into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:256,Integrability,Interface,Interface,256,/// A code coverage view of a source file or function.; ///; /// A source coverage view and its nested sub-views form a file-oriented; /// representation of code coverage data. This view can be printed out by a; /// renderer which implements the Rendering Interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:23,Usability,guid,guide,23,/// Various options to guide the coverage renderer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:20,Integrability,Interface,Interface,20,/// @name Rendering Interface; /// @{; /// Render a header for the view.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:47,Availability,avail,available,47,"/// Render \p Title, a project title if one is available, and the; /// created time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:1517,Energy Efficiency,green,green,1517,";; margin-right: 5px;; margin-bottom: 5px;; border: 1px solid #dbdbdb;; border-radius: 3px;; }; table {; border-collapse: collapse;; }; .light-row {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; }; .light-row-bold {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; font-weight: bold;; }; .column-entry {; text-align: left;; }; .column-entry-bold {; font-weight: bold;; text-align: left;; }; .column-entry-yellow {; text-align: left;; background-color: #ffffd0;; }; .column-entry-yellow:hover, tr:hover .column-entry-yellow {; background-color: #fffff0;; }; .column-entry-red {; text-align: left;; background-color: #ffd0d0;; }; .column-entry-red:hover, tr:hover .column-entry-red {; background-color: #fff0f0;; }; .column-entry-gray {; text-align: left;; background-color: #fbfbfb;; }; .column-entry-gray:hover, tr:hover .column-entry-gray {; background-color: #f0f0f0;; }; .column-entry-green {; text-align: left;; background-color: #d0ffd0;; }; .column-entry-green:hover, tr:hover .column-entry-green {; background-color: #f0fff0;; }; .line-number {; text-align: right;; color: #aaa;; }; .covered-line {; text-align: right;; color: #0080ff;; }; .uncovered-line {; text-align: right;; color: #ff3300;; }; .tooltip {; position: relative;; display: inline;; background-color: #b3e6ff;; text-decoration: none;; }; .tooltip span.tooltip-content {; position: absolute;; width: 100px;; margin-left: -50px;; color: #FFFFFF;; background: #000000;; height: 30px;; line-height: 30px;; text-align: center;; visibility: hidden;; border-radius: 6px;; }; .tooltip span.tooltip-content:after {; content: '';; position: absolute;; top: 100%;; left: 50%;; margin-left: -8px;; width: 0; height: 0;; border-top: 8px solid #000000;; border-right: 8px solid transparent;; border-left: 8px solid transparent;; }; :hover.tooltip span.tooltip-content {; visibility: visible;; opacity: 0.8;; bottom: 30px;; left: 50%;; z-index: 999;; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:1590,Energy Efficiency,green,green,1590," solid #dbdbdb;; border-radius: 3px;; }; table {; border-collapse: collapse;; }; .light-row {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; }; .light-row-bold {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; font-weight: bold;; }; .column-entry {; text-align: left;; }; .column-entry-bold {; font-weight: bold;; text-align: left;; }; .column-entry-yellow {; text-align: left;; background-color: #ffffd0;; }; .column-entry-yellow:hover, tr:hover .column-entry-yellow {; background-color: #fffff0;; }; .column-entry-red {; text-align: left;; background-color: #ffd0d0;; }; .column-entry-red:hover, tr:hover .column-entry-red {; background-color: #fff0f0;; }; .column-entry-gray {; text-align: left;; background-color: #fbfbfb;; }; .column-entry-gray:hover, tr:hover .column-entry-gray {; background-color: #f0f0f0;; }; .column-entry-green {; text-align: left;; background-color: #d0ffd0;; }; .column-entry-green:hover, tr:hover .column-entry-green {; background-color: #f0fff0;; }; .line-number {; text-align: right;; color: #aaa;; }; .covered-line {; text-align: right;; color: #0080ff;; }; .uncovered-line {; text-align: right;; color: #ff3300;; }; .tooltip {; position: relative;; display: inline;; background-color: #b3e6ff;; text-decoration: none;; }; .tooltip span.tooltip-content {; position: absolute;; width: 100px;; margin-left: -50px;; color: #FFFFFF;; background: #000000;; height: 30px;; line-height: 30px;; text-align: center;; visibility: hidden;; border-radius: 6px;; }; .tooltip span.tooltip-content:after {; content: '';; position: absolute;; top: 100%;; left: 50%;; margin-left: -8px;; width: 0; height: 0;; border-top: 8px solid #000000;; border-right: 8px solid transparent;; border-left: 8px solid transparent;; }; :hover.tooltip span.tooltip-content {; visibility: visible;; opacity: 0.8;; bottom: 30px;; left: 50%;; z-index: 999;; }; th, td {; vertical-align: top;; padding: 2px 8px;; bo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:1626,Energy Efficiency,green,green,1626,"e {; border-collapse: collapse;; }; .light-row {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; }; .light-row-bold {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; font-weight: bold;; }; .column-entry {; text-align: left;; }; .column-entry-bold {; font-weight: bold;; text-align: left;; }; .column-entry-yellow {; text-align: left;; background-color: #ffffd0;; }; .column-entry-yellow:hover, tr:hover .column-entry-yellow {; background-color: #fffff0;; }; .column-entry-red {; text-align: left;; background-color: #ffd0d0;; }; .column-entry-red:hover, tr:hover .column-entry-red {; background-color: #fff0f0;; }; .column-entry-gray {; text-align: left;; background-color: #fbfbfb;; }; .column-entry-gray:hover, tr:hover .column-entry-gray {; background-color: #f0f0f0;; }; .column-entry-green {; text-align: left;; background-color: #d0ffd0;; }; .column-entry-green:hover, tr:hover .column-entry-green {; background-color: #f0fff0;; }; .line-number {; text-align: right;; color: #aaa;; }; .covered-line {; text-align: right;; color: #0080ff;; }; .uncovered-line {; text-align: right;; color: #ff3300;; }; .tooltip {; position: relative;; display: inline;; background-color: #b3e6ff;; text-decoration: none;; }; .tooltip span.tooltip-content {; position: absolute;; width: 100px;; margin-left: -50px;; color: #FFFFFF;; background: #000000;; height: 30px;; line-height: 30px;; text-align: center;; visibility: hidden;; border-radius: 6px;; }; .tooltip span.tooltip-content:after {; content: '';; position: absolute;; top: 100%;; left: 50%;; margin-left: -8px;; width: 0; height: 0;; border-top: 8px solid #000000;; border-right: 8px solid transparent;; border-left: 8px solid transparent;; }; :hover.tooltip span.tooltip-content {; visibility: visible;; opacity: 0.8;; bottom: 30px;; left: 50%;; z-index: 999;; }; th, td {; vertical-align: top;; padding: 2px 8px;; border-collapse: collapse;; border-right: solid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:34,Availability,avail,available,34,"// Link to a stylesheet if one is available. Otherwise, use the default style.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:39,Integrability,wrap,wrap,39,"// Simplify the display file path, and wrap it in a link if requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the display file path, and wrap it in a link if requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:27,Safety,avoid,avoid,27,"// |Line| + 1 is needed to avoid underflow when, e.g |Line| = 0 and LCol = 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:13,Integrability,Wrap,WrappedSegment,13,"// 3. Use \p WrappedSegment to set the highlight for snippet 0. Use segment; // 1 to set the highlight for snippet 2, segment 2 to set the highlight for; // snippet 3, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.h:413,Integrability,interface,interface,413,"//===- SourceCoverageViewHTML.h - A html code coverage view ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This file defines the interface to the html coverage renderer.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewText.h:413,Integrability,interface,interface,413,"//===- SourceCoverageViewText.h - A text-based code coverage view ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This file defines the interface to the text-based coverage renderer.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewText.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewText.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp:7,Testability,Test,TestingSupport,7,"//===- TestingSupport.cpp - Convert objects files into test files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp:55,Testability,test,test,55,"//===- TestingSupport.cpp - Convert objects files into test files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp:89,Energy Efficiency,allocate,allocated,89,"// If this is a linked PE/COFF file, then we have to skip over the null byte; // that is allocated in the .lprfn$A section in the LLVM profiling runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp:7,Availability,Error,Error,7,"//===- Error.cpp - system_error extensions for llvm-cxxdump -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a new error_category for the llvm-cxxdump tool.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp:69,Availability,Error,Error,69,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp:176,Availability,Error,Error,176,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.h:7,Availability,Error,Error,7,"//===- Error.h - system_error extensions for llvm-cxxdump -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This declares a new error_category for the llvm-cxxdump tool.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxfilt/llvm-cxxfilt.cpp:21,Integrability,depend,depends,21,"// The default value depends on the default triple. Mach-O has symbols; // prefixed with ""_"", so strip by default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxfilt/llvm-cxxfilt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxfilt/llvm-cxxfilt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxmap/llvm-cxxmap.cpp:3,Performance,Load,Load,3,// Load the remapping file and prepare to canonicalize symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxmap/llvm-cxxmap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxmap/llvm-cxxmap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:426,Testability,log,logical,426,"//===-- llvm-debuginfo-analyzer.cpp - LLVM Debug info analysis utility ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is a utility that displays the logical view for the debug; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:63,Integrability,depend,dependencies,63,// Manually open up the bundle to avoid introducing additional dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:34,Safety,avoid,avoid,34,// Manually open up the bundle to avoid introducing additional dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:47,Availability,error,error,47,// Don't remove output file if we exit with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:22,Performance,perform,perform,22,// Create readers and perform requested tasks on them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:12,Availability,error,error,12,// Print an error message if unrecognized character.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:18,Integrability,message,message,18,// Print an error message if unrecognized character.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:46,Security,access,accessible,46,/// @}; // Copy local options into a globally accessible data structure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:32,Deployability,update,update,32,// Traverse list of options and update the given set (Using case and Regex).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:32,Deployability,update,update,32,// Traverse list of options and update the given set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:23,Integrability,depend,dependencies,23,"// Resolve any options dependencies (ie. --print=all should set other; // print options, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h:60,Availability,error,error,60,"// Parse an argument representing an offset. Return true on error.; // If the prefix is 0, the base is octal, if the prefix is 0x or 0X, the; // base is hexadecimal, otherwise the base is decimal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h:3,Performance,Perform,Perform,3,"// Perform any additional post parse command line actions. Propagate the; // values captured by the command line parser, into the generic reader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h:13,Testability,log,logicalview,13,// namespace logicalview,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp:474,Integrability,protocol,protocol,474,"//===-- llvm-debuginfod.cpp - federating debuginfod server ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the llvm-debuginfod tool, which serves the debuginfod; /// protocol over HTTP. The tool periodically scans zero or more filesystem; /// directories for ELF binaries to serve, and federates requests for unknown; /// build IDs to the debuginfod servers set in the DEBUGINFOD_URLS environment; /// variable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp:710,Modifiability,variab,variable,710,"//===-- llvm-debuginfod.cpp - federating debuginfod server ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the llvm-debuginfod tool, which serves the debuginfod; /// protocol over HTTP. The tool periodically scans zero or more filesystem; /// directories for ELF binaries to serve, and federates requests for unknown; /// build IDs to the debuginfod servers set in the DEBUGINFOD_URLS environment; /// variable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp:532,Modifiability,variab,variable,532,"//===-- llvm-debuginfod-find.cpp - Simple CLI for libdebuginfod-client ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the llvm-debuginfod-find tool. This tool; /// queries the debuginfod servers in the DEBUGINFOD_URLS environment; /// variable (delimited by space ("" "")) for the executable,; /// debuginfo, or specified source file of the binary matching the; /// given build-id.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp:35,Usability,Simpl,Simple,35,"//===-- llvm-debuginfod-find.cpp - Simple CLI for libdebuginfod-client ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the llvm-debuginfod-find tool. This tool; /// queries the debuginfod servers in the DEBUGINFOD_URLS environment; /// variable (delimited by space ("" "")) for the executable,; /// debuginfo, or specified source file of the binary matching the; /// given build-id.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp:25,Performance,cache,cached,25,// Print the path to the cached artifact file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp:35,Availability,error,error,35,"/// Reads a module from a file. On error, messages are written to stderr; /// and null is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp:42,Integrability,message,messages,42,"/// Reads a module from a file. On error, messages are written to stderr; /// and null is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp:3,Performance,Load,Load,3,// Load both modules. Die if that fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp:13,Testability,Log,Log,13,"//printValue(Log.getLeft(I), true);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp:13,Testability,Log,Log,13,"//printValue(Log.getLeft(I), true);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp:13,Testability,Log,Log,13,"//printValue(Log.getRight(I), false);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h:407,Integrability,interface,interface,407,"//===-- DiffConsumer.h - Difference Consumer --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference Consumer; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h:8,Integrability,interface,interface,8,/// The interface for consumers of difference data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h:170,Modifiability,variab,variables,170,"/// Record that a local context has been entered. Left and; /// Right are IR ""containers"" of some sort which are being; /// considered for structural equivalence: global variables,; /// functions, blocks, instructions, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:15,Performance,queue,queue,15,"/// A priority queue, implemented as a heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:14,Testability,test,test,14,"// Otherwise, test whether we should swap L and Index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:39,Modifiability,variab,variable,39,// Some initializers may reference the variable we're currently checking. This; // can cause an infinite loop. The Saved[LR]HS ivars can be checked to prevent; // recursing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:91,Integrability,depend,depend,91,"// Equivalence Assumptions; //; // For basic blocks in loops, some values in phi nodes may depend on; // values from not yet processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by indu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:686,Integrability,depend,depend,686,"// Equivalence Assumptions; //; // For basic blocks in loops, some values in phi nodes may depend on; // values from not yet processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by indu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:1187,Integrability,depend,depending,1187,"processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by induction on the; // iteration, using the computed value mapping.; // The class BlockDiffCandidate stores pairs which either hav",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:1481,Integrability,depend,dependency,1481,"ce and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by induction on the; // iteration, using the computed value mapping.; // The class BlockDiffCandidate stores pairs which either have already been; // proven to differ, or pairs whose equivalence depends on assumptions to be; // verified later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:2189,Integrability,depend,depends,2189,"ce and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by induction on the; // iteration, using the computed value mapping.; // The class BlockDiffCandidate stores pairs which either have already been; // proven to differ, or pairs whose equivalence depends on assumptions to be; // verified later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:892,Safety,avoid,avoid,892,"// Equivalence Assumptions; //; // For basic blocks in loops, some values in phi nodes may depend on; // values from not yet processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by indu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:1066,Usability,clear,clear,1066,"processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by induction on the; // iteration, using the computed value mapping.; // The class BlockDiffCandidate stores pairs which either hav",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:34,Performance,queue,queue,34,/// A type which sorts a priority queue by the number of unprocessed; /// predecessor blocks it has remaining.; ///; /// This is actually really expensive to calculate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:6,Performance,queue,queue,6,/// A queue of unified blocks to process.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:204,Safety,detect,detected,204,"// Register (L, R) as diffing pair. Note that we could directly emit a; // block diff here, but this way we ensure all diffs are emitted in one; // consistent order, independent of whether the diffs were detected; // immediately or via invalid assumptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:3,Performance,Perform,Perform,3,"// Perform the ""try unify"" step so that we can equate the indirect; // destinations before checking the call site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:67,Modifiability,variab,variable,67,"// If the left and right operands aren't both re-analyzing the; // variable, then the initialiers don't match, so report ""false"".; // Otherwise, we skip these operands..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:67,Modifiability,variab,variable,67,"// If the left and right operands aren't both re-analyzing the; // variable, then the initialiers don't match, so report ""false"".; // Otherwise, we skip these operands..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:95,Integrability,depend,depends,95,"// There are cases where we cannot determine whether two values are; // equivalent, because it depends on not yet processed basic blocks -- see the; // documentation on assumptions.; //; // AC is the context in which we are currently performing a diff.; // When we encounter a pair of values for which we can neither prove; // equivalence nor the opposite, we do the following:; // * If AC is nullptr, we treat the pair as non-equivalent.; // * If AC is set, we add an assumption for the basic blocks given by AC,; // and treat the pair as equivalent. The assumption is checked later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:234,Performance,perform,performing,234,"// There are cases where we cannot determine whether two values are; // equivalent, because it depends on not yet processed basic blocks -- see the; // documentation on assumptions.; //; // AC is the context in which we are currently performing a diff.; // When we encounter a pair of values for which we can neither prove; // equivalence nor the opposite, we do the following:; // * If AC is nullptr, we treat the pair as non-equivalent.; // * If AC is set, we add an assumption for the basic blocks given by AC,; // and treat the pair as equivalent. The assumption is checked later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:43,Integrability,depend,depend,43,"// L and R might be equivalent, this could depend on not yet processed; // basic blocks, so we cannot decide here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:3,Safety,Avoid,Avoid,3,// Avoid a gcc warning about accessing 'this' in an initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:29,Security,access,accessing,29,// Avoid a gcc warning about accessing 'this' in an initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h:407,Integrability,interface,interface,407,"//===-- DifferenceEngine.h - Module comparator ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference engine,; // which structurally compares functions within a module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h:16,Performance,perform,performing,16,/// A class for performing structural comparisons of LLVM assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h:4,Deployability,Install,Installs,4,"/// Installs an oracle to decide whether two global values are; /// equivalent as operands. Without an oracle, global values are; /// considered equivalent as operands precisely when they have the; /// same name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp:407,Integrability,interface,interface,407,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp:47,Security,access,accessories,47,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp:31,Testability,Log,Log,31,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp:440,Testability,log,log,440,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:407,Integrability,interface,interface,407,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:47,Security,access,accessories,47,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:31,Testability,Log,Log,31,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:440,Testability,log,log,440,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:49,Integrability,message,messages,49,/// A temporary-object class for building up log messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:45,Testability,log,log,45,/// A temporary-object class for building up log messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:60,Testability,Log,LogBuilder,60,"/// The use of a stored StringRef here is okay because; /// LogBuilder should be used only as a temporary, and as a; /// temporary it will be destructed before whatever temporary; /// might be initializing this format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:50,Integrability,message,messages,50,/// A temporary-object class for building up diff messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp:50,Safety,sanity check,sanity check,50,"//===-- DummyDemanglerFuzzer.cpp - Entry point to sanity check the fuzzer -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp:426,Testability,test,test,426,"//===-- DummyDemanglerFuzzer.cpp - Entry point to sanity check the fuzzer -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:19,Availability,error,error,19,/// Return true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:19,Availability,error,error,19,/// Return true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:51,Availability,error,error,51,"// In -verify mode, print DIEs without children in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:57,Integrability,message,messages,57,"// In -verify mode, print DIEs without children in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:40,Availability,down,down,40,"// If we have split DWARF, then recurse down into the .dwo files as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:274,Modifiability,extend,extend,274,"/// Handle the --lookup option and dump the DIEs and line info for the given; /// address.; /// TODO: specified Address for --lookup option could relate for several; /// different sections(in case not-linked object file). llvm-dwarfdump; /// need to do something with this: extend lookup option with section; /// information or probably display all matched entries, or something else...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:34,Availability,avail,available,34,"// Since there's no compile units available, walk the line tables and; // extract out any referenced paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:46,Safety,avoid,avoids,46,// Flush outs() when printing to errs(). This avoids interleaving output; // between the two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:10,Security,Audit,Audit,10,// FIXME: Audit interactions between these two options and make them; // compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:47,Availability,error,error,47,// Don't remove output file if we exit with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:131,Modifiability,variab,variables,131,"/// This represents the number of categories of debug location coverage being; /// calculated. The first category is the number of variables with 0% location; /// coverage, but the last category is the number of variables with 100%; /// location coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:212,Modifiability,variab,variables,212,"/// This represents the number of categories of debug location coverage being; /// calculated. The first category is the number of variables with 0% location; /// coverage, but the last category is the number of variables with 100%; /// location coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// This represents variables DIE offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:41,Modifiability,variab,variables,41,/// This maps function DIE offset to its variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:70,Safety,detect,detect,70,/// This represents a data type for the stats and it helps us to; /// detect an overflow.; /// NOTE: This can be implemented as a template if there is an another type; /// needing this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:93,Modifiability,variab,variables,93,"/// Holds statistics for one function (or other entity that has a PC range and; /// contains variables, such as a compile unit).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:14,Modifiability,variab,variables,14,/// Number of variables and parameters with location across all inlined; /// instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:24,Modifiability,variab,variables,24,"/// Number of arificial variables, parameters or members across all instances.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:16,Modifiability,Variab,Variables,16,/// List of all Variables and parameters in this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// Number of local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// Number of local variables with source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// Number of local variables with type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// Number of local variables with DW_AT_location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:43,Modifiability,variab,variable,43,/// Total number of PC range bytes in each variable's enclosing scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:83,Modifiability,variab,variables,83,/// Total number of PC range bytes covered by DW_AT_locations (only for local; /// variables).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:49,Modifiability,variab,variable,49,/// Total number of PC range bytes in each local variable's enclosing scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:131,Modifiability,variab,variables,131,/// Total number of PC range bytes covered by DW_AT_locations with; /// the debug entry values (DW_OP_entry_value) (only for local variables).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:156,Performance,tune,tune,156,/// Total byte size of inlined functions. This is the total number of bytes; /// for the top inline functions within concrete functions. This can help; /// tune the inline settings when compiling to match user expectations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:60,Modifiability,variab,variables,60,/// Holds accumulated debug location statistics about local variables and; /// formal parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:51,Modifiability,variab,variables,51,"/// Map the scope coverage decile to the number of variables in the decile.; /// The first element of the array (at the index zero) represents the number; /// of variables with the no debug location at all, but the last element; /// in the vector represents the number of fully covered variables within; /// its scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:162,Modifiability,variab,variables,162,"/// Map the scope coverage decile to the number of variables in the decile.; /// The first element of the array (at the index zero) represents the number; /// of variables with the no debug location at all, but the last element; /// in the vector represents the number of fully covered variables within; /// its scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:286,Modifiability,variab,variables,286,"/// Map the scope coverage decile to the number of variables in the decile.; /// The first element of the array (at the index zero) represents the number; /// of variables with the no debug location at all, but the last element; /// in the vector represents the number of fully covered variables within; /// its scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:44,Modifiability,variab,variables,44,/// The debug location statistics for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:50,Modifiability,variab,variables,50,/// Map non debug entry values coverage for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:26,Modifiability,variab,variables,26,/// Total number of local variables and function parameters processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:26,Modifiability,variab,variables,26,/// Total number of local variables processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:36,Modifiability,variab,variable,36,// No debug location at all for the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:17,Modifiability,variab,variable,17,// Fully covered variable within its scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:37,Modifiability,variab,variables,37,// Prefix + Name is enough for local variables and parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:28,Modifiability,variab,variables,28,// For zero covered inlined variables the locstats will be; // calculated later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:9,Modifiability,variab,variable,9,// Not a variable or constant member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:33,Modifiability,variab,variables,33,// Ignore declarations of global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:21,Modifiability,variab,variable,21,"// Do not track this variable any more, since it has location; // coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:39,Modifiability,variab,variables,39,// This catches constant members *and* variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:10,Modifiability,variab,variables,10,// Handle variables and function arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:249,Modifiability,variab,variable,249,"// Calculate how many bytes of the parent scope this entry covers.; // FIXME: In section 2.6.2 of the DWARFv5 spec it says that ""The; // address ranges defined by the bounded location descriptions of a; // location list may overlap"". So in theory a variable can have; // multiple simultaneous locations, which would make this calculation; // misleading because we will count the overlapped areas; // twice. However, clang does not currently emit DWARF like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:24,Modifiability,variab,variables,24,/// Recursively collect variables from subprogram with DW_AT_inline attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:28,Modifiability,variab,variables,28,// We want to know how many variables (with abstract_origin) don't have; // location info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:43,Modifiability,variab,variables,43,"// Skip over abstract origins, but collect variables; // from it so it can be used for location statistics; // for inlined instancies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:3,Deployability,Update,Update,3,// Update function prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:52,Modifiability,variab,variable,52,"// Not a scope, visit the Die itself. It could be a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:128,Modifiability,variab,variables,128,"// After we have processed all vars of the inlined function (or function with; // an abstract_origin), we want to know how many variables have no location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:18,Modifiability,variab,variables,18,/// Stop tracking variables that contain abstract_origin with a location.; /// This is used for out-of-order DW_AT_inline subprograms only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:47,Modifiability,variab,variables,47,/// Collect zero location coverage for inlined variables which refer to; /// a DW_AT_inline copy of subprogram that is out of order in the DWARF.; /// Also cover the variables of a concrete function (represented with; /// the DW_TAG_subprogram) with an abstract_origin attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:166,Modifiability,variab,variables,166,/// Collect zero location coverage for inlined variables which refer to; /// a DW_AT_inline copy of subprogram that is out of order in the DWARF.; /// Also cover the variables of a concrete function (represented with; /// the DW_TAG_subprogram) with an abstract_origin attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:12,Modifiability,variab,variable,12,"// The next variable is used to filter out functions that have been processed,; // leaving FnsWithAbstractOriginToBeProcessed with just CrossCU references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:47,Modifiability,variab,variables,47,/// Collect zero location coverage for inlined variables which refer to; /// a DW_AT_inline copy of subprogram that is in a different CU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:141,Availability,down,down,141,"/// \}; /// Collect debug info quality metrics for an entire DIContext.; ///; /// Do the impossible and reduce the quality of the debug info down to a few; /// numbers. The idea is to condense the data into numbers that can be tracked; /// over time to identify trends in newer compiler versions and gauge the effect; /// of particular optimizations. The raw numbers themselves are not particularly; /// useful, only the delta between compiling the same program with different; /// compilers is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:104,Energy Efficiency,reduce,reduce,104,"/// \}; /// Collect debug info quality metrics for an entire DIContext.; ///; /// Do the impossible and reduce the quality of the debug info down to a few; /// numbers. The idea is to condense the data into numbers that can be tracked; /// over time to identify trends in newer compiler versions and gauge the effect; /// of particular optimizations. The raw numbers themselves are not particularly; /// useful, only the delta between compiling the same program with different; /// compilers is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:336,Performance,optimiz,optimizations,336,"/// \}; /// Collect debug info quality metrics for an entire DIContext.; ///; /// Do the impossible and reduce the quality of the debug info down to a few; /// numbers. The idea is to condense the data into numbers that can be tracked; /// over time to identify trends in newer compiler versions and gauge the effect; /// of particular optimizations. The raw numbers themselves are not particularly; /// useful, only the delta between compiling the same program with different; /// compilers is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:8,Modifiability,variab,variable,8,"// This variable holds variable information for functions with; // abstract_origin globally, across all CUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:23,Modifiability,variab,variable,23,"// This variable holds variable information for functions with; // abstract_origin globally, across all CUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:8,Modifiability,variab,variable,8,// This variable holds information about the CU of a function with; // abstract_origin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:8,Modifiability,variab,variable,8,"// This variable holds variable information for functions with; // abstract_origin, but just for the current CU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:23,Modifiability,variab,variable,23,"// This variable holds variable information for functions with; // abstract_origin, but just for the current CU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:9,Modifiability,variab,variables,9,// Count variables in global scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:23,Modifiability,variab,variables,23,// This includes local variables and formal parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:31,Modifiability,variab,variables,31,// Print the summary for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:37,Modifiability,variab,variables,37,// Print the location statistics for variables (includes local variables; // and formal parameters).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:63,Modifiability,variab,variables,63,// Print the location statistics for variables (includes local variables; // and formal parameters).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:43,Modifiability,variab,variables,43,// Print the location statistics for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:28,Testability,log,logging,28,// FIXME: implement warning logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:20,Availability,error,error,20,// FIXME: implement error logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:26,Testability,log,logging,26,// FIXME: implement error logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:11,Integrability,message,message,11,// Display message for the replaced accelerator tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:11,Integrability,message,message,11,// Display message for the removed accelerator tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/Error.h:7,Availability,Error,Error,7,"//===- Error.h --------------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp:11,Availability,avail,available,11,// Use all available hardware threads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp:198,Availability,error,error,198,"// The file ""FileName"" was created by this utility in the previous steps; // (i.e. it is already known that it should pass the isObject check).; // If the createBinary() function does not return an error, the isObject; // check should also be successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:34,Testability,benchmark,benchmark,34,"// When not asking for a specific benchmark mode,; // we'll analyse the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:33,Availability,error,error,33,// Helper function that logs the error(s) and exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:24,Testability,log,logs,24,// Helper function that logs the error(s) and exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:27,Availability,failure,failure,27,// Check Err. If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:54,Availability,error,error,54,// Check Err. If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:41,Testability,log,log,41,// Check Err. If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:89,Availability,failure,failure,89,// Check E. If it's in a success state then return the contained value.; // If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:116,Availability,error,error,116,// Check E. If it's in a success state then return the contained value.; // If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:103,Testability,log,log,103,// Check E. If it's in a success state then return the contained value.; // If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:3,Availability,Error,Errors,3,// Errors from executing the snippets are fine.; // All other errors are a framework issue and should fail.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:62,Availability,error,errors,62,// Errors from executing the snippets are fine.; // All other errors are a framework issue and should fail.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:65,Testability,benchmark,benchmark,65,// Preliminary check to ensure features needed for requested; // benchmark mode are present on target CPU and/or OS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:8,Testability,benchmark,benchmarks,8,// Read benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:42,Performance,latency,latency,42,// FIXME: Merge points from several runs (latency and uops).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:22,Availability,avail,available,22,// Enable printing of available targets when flag --version is specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:56,Energy Efficiency,schedul,scheduling,56,"// Prints a row representing an instruction, along with scheduling info and; // point coordinates (measurements).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:12,Testability,benchmark,benchmarks,12,// Parallel benchmarks repeat the same opcode multiple times. Just show this; // opcode and show the whole snippet only on hover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:3,Performance,Latency,Latency,3,// Latency tries to find a serial path. Just show the opcode path and show the; // whole snippet only on hover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:16,Security,validat,validate,16,// In Uops mode validate() may not be enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:31,Performance,latency,latency,31,// Dismabiguate if more than 1 latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:11,Performance,throughput,throughput,11,// inverse throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:226,Modifiability,config,config,226,"R""(; <head>; <title>llvm-exegesis Analysis Results</title>; <style>; body {; font-family: sans-serif; }; span.sched-class-name {; font-weight: bold;; font-family: monospace;; }; span.opcode {; font-family: monospace;; }; span.config {; font-family: monospace;; }; div.inconsistency {; margin-top: 50px;; }; table {; margin-left: 50px;; border-collapse: collapse;; }; table, table tr,td,th {; border: 1px solid #444;; }; table ul {; padding-left: 0px;; margin: 0px;; list-style-type: none;; }; table.sched-class-clusters td {; padding-left: 10px;; padding-right: 10px;; padding-top: 10px;; padding-bottom: 10px;; }; table.sched-class-desc td {; padding-left: 10px;; padding-right: 10px;; padding-top: 2px;; padding-bottom: 2px;; }; span.mono {; font-family: monospace;; }; td.measurement {; text-align: center;; }; tr.good-cluster td.measurement {; color: #292; }; tr.bad-cluster td.measurement {; color: #922; }; tr.good-cluster td.measurement span.minmax {; color: #888;; }; tr.bad-cluster td.measurement span.minmax {; color: #888;; }; </style>; </head>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:20,Availability,error,errors,20,// Ignore noise and errors. FIXME: take noise into account ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:13,Energy Efficiency,schedul,scheduling,13,// Print any scheduling class that has at least one cluster that does not; // match the checked-in data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:416,Testability,benchmark,benchmark,416,"//===-- Analysis.h ----------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Analysis output for benchmark results.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:29,Testability,benchmark,benchmark,29,// A helper class to analyze benchmark results for a target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:18,Availability,error,errors,18,// Find potential errors in the scheduling information given measurements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:32,Energy Efficiency,schedul,scheduling,32,// Find potential errors in the scheduling information given measurements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:99,Security,validat,validate,99,// The frontend that generates that parses the memory mapping information; // from the user should validate that the requested address is a multiple; // of the page size. Assert that this is true here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:171,Testability,Assert,Assert,171,// The frontend that generates that parses the memory mapping information; // from the user should validate that the requested address is a multiple; // of the page size. Assert that this is true here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:50,Performance,load,load,50,"// If we're generating memory instructions, don't load in the value for; // the register with the stack pointer as it will be used later to finish; // the setup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:3,Performance,Load,Load,3,// Load a constant in the register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:3,Performance,Load,Load,3,// Load in the stack register now as we're done using it elsewhere; // and need to set the value in preparation for executing the; // snippet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:179,Testability,assert,assertion,179,"// If the snippet setup is not complete, we disable liveliness tracking. This; // means that we won't know what values are in the registers.; // FIXME: this should probably be an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:24,Performance,load,loadObjectImpl,24,// See RuntimeDyldImpl::loadObjectImpl(Obj) for much more complete; // implementation.; // Find the only function in the object file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h:41,Integrability,depend,depends,41,// Gather the set of reserved registers (depends on function's calling; // convention and target machine).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h:3,Performance,Load,Loads,3,// Loads the content of Filename as on ObjectFile and returns it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h:10,Testability,benchmark,benchmark,10,// Copies benchmark function's bytes from benchmark object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h:42,Testability,benchmark,benchmark,42,// Copies benchmark function's bytes from benchmark object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h:8,Testability,Benchmark,BenchmarkCode,8,"//===-- BenchmarkCode.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h:31,Deployability,configurat,configuration,31,// Informations about how this configuration was built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h:31,Modifiability,config,configuration,31,// Informations about how this configuration was built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h
