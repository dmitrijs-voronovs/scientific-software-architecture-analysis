id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:2396,Availability,mask,mask,2396," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based o",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:2488,Availability,mask,mask,2488," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based o",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:2630,Availability,mask,mask,2630,"OCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dim",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:2729,Availability,mask,mask,2729,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.a",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:2926,Availability,mask,mask,2926," THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:2953,Availability,mask,mask,2953," THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:3369,Availability,mask,mask,3369,"[docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:3420,Availability,mask,mask,3420,"[docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:3461,Availability,mask,mask,3461,"e `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:3566,Availability,mask,mask,3566,"o` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:3660,Availability,mask,mask,3660,"m is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. I",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:3709,Availability,mask,mask,3709,"m is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. I",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:3916,Availability,mask,mask,3916,"list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:4350,Availability,mask,mask,4350,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme p",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:4425,Availability,mask,mask,4425,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:4573,Availability,mask,mask,4573,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:5036,Availability,mask,mask,5036,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:5111,Availability,mask,mask,5111,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:5315,Deployability,update,updated,5315,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:4664,Performance,perform,performs,4664,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:4737,Testability,test,testing,4737,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.0.2/modules/qutip/propagator.html:5644,Deployability,update,update,5644,"ce(t, (int, float, np.integer, np.floating)):; tlist = [0, t]; else:; tlist = t. td_type = _td_format_check(H, c_op_list, solver='me'); ; if isinstance(H, (types.FunctionType, types.BuiltinFunctionType,; functools.partial)):; H0 = H(0.0, args); elif isinstance(H, list):; H0 = H[0][0] if isinstance(H[0], list) else H[0]; else:; H0 = H; ; if len(c_op_list) == 0 and H0.isoper:; # calculate propagator for the wave function. N = H0.shape[0]; dims = H0.dims; ; if parallel:; unitary_mode = 'single'; u = np.zeros([N, N, len(tlist)], dtype=complex); output = parallel_map(_parallel_sesolve,range(N),; task_args=(N,H, tlist,args,options),; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N):; for k, t in enumerate(tlist):; u[:, n, k] = output[n].states[k].full().T ; else:; if unitary_mode == 'single':; u = np.zeros([N, N, len(tlist)], dtype=complex); progress_bar.start(N); for n in range(0, N):; progress_bar.update(n); psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options, _safe_mode=False) ; for k, t in enumerate(tlist):; u[:, n, k] = output.states[k].full().T; progress_bar.finished() . elif unitary_mode =='batch':; u = np.zeros(len(tlist), dtype=object); _rows = np.array([(N+1)*m for m in range(N)]); _cols = np.zeros_like(_rows); _data = np.ones_like(_rows,dtype=complex); psi0 = Qobj(sp.coo_matrix((_data,(_rows,_cols))).tocsr()); if td_type[1] > 0 or td_type[2] > 0:; H2 = []; for k in range(len(H)):; if isinstance(H[k], list):; H2.append([tensor(qeye(N), H[k][0]), H[k][1]]); else:; H2.append(tensor(qeye(N), H[k])); else:; H2 = tensor(qeye(N), H); output = sesolve(H2, psi0, tlist, [] , args = args, _safe_mode=False, ; options=Options(normalize_output=False)); for k, t in enumerate(tlist):; u[k] = sp_reshape(output.states[k].data, (N, N)); unit_row_norm(u[k].data, u[k].indptr, u[k].shape[0]); u[k] = u[k].T.tocsr(); else:; raise Exception('Invalid unitary mode.'); . elif len(c_op_list) == 0 and H0.issuper:; # calculate the propagator for the vector ",MatchSource.WIKI,docs/4.0.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/propagator.html
https://qutip.org/docs/4.0.2/modules/qutip/propagator.html:7267,Deployability,update,update,7267,"lse:; H2 = tensor(qeye(N), H); output = sesolve(H2, psi0, tlist, [] , args = args, _safe_mode=False, ; options=Options(normalize_output=False)); for k, t in enumerate(tlist):; u[k] = sp_reshape(output.states[k].data, (N, N)); unit_row_norm(u[k].data, u[k].indptr, u[k].shape[0]); u[k] = u[k].T.tocsr(); else:; raise Exception('Invalid unitary mode.'); . elif len(c_op_list) == 0 and H0.issuper:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator); unitary_mode = 'single'; N = H0.shape[0]; sqrt_N = int(np.sqrt(N)); dims = H0.dims; ; u = np.zeros([N, N, len(tlist)], dtype=complex). if parallel:; output = parallel_map(_parallel_mesolve,range(N * N),; task_args=(sqrt_N,H,tlist,c_op_list,args,options),; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N * N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; progress_bar.start(N); for n in range(0, N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n,(sqrt_N,sqrt_N)); rho0 = Qobj(sp.csr_matrix(([1],([row_idx],[col_idx])), shape=(sqrt_N,sqrt_N), dtype=complex)); output = mesolve(H, rho0, tlist, [], [], args, options, _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). else:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator); unitary_mode = 'single'; N = H0.shape[0]; dims = [H0.dims, H0.dims]. u = np.zeros([N * N, N * N, len(tlist)], dtype=complex); ; if parallel:; output = parallel_map(_parallel_mesolve,range(N * N),; task_args=(N,H,tlist,c_op_list,args,options),; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N * N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; progress_bar.start(N * N); for n in range(N * N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n,(N,N)); rho0 = Qobj(sp.csr_matrix(([1]",MatchSource.WIKI,docs/4.0.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/propagator.html
https://qutip.org/docs/4.0.2/modules/qutip/propagator.html:8197,Deployability,update,update,8197,"ess_bar.start(N); for n in range(0, N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n,(sqrt_N,sqrt_N)); rho0 = Qobj(sp.csr_matrix(([1],([row_idx],[col_idx])), shape=(sqrt_N,sqrt_N), dtype=complex)); output = mesolve(H, rho0, tlist, [], [], args, options, _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). else:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator); unitary_mode = 'single'; N = H0.shape[0]; dims = [H0.dims, H0.dims]. u = np.zeros([N * N, N * N, len(tlist)], dtype=complex); ; if parallel:; output = parallel_map(_parallel_mesolve,range(N * N),; task_args=(N,H,tlist,c_op_list,args,options),; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N * N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; progress_bar.start(N * N); for n in range(N * N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n,(N,N)); rho0 = Qobj(sp.csr_matrix(([1],([row_idx],[col_idx])), shape=(N,N), dtype=complex)); output = mesolve(H, rho0, tlist, c_op_list, [], args, options, _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; if unitary_mode == 'batch':; return Qobj(u[-1], dims=dims); else:; return Qobj(u[:, :, 1], dims=dims); else:; if unitary_mode == 'batch':; return np.array([Qobj(u[k], dims=dims) for k in range(len(tlist))], dtype=object); else:; return np.array([Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))], dtype=object). def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`. Paramet",MatchSource.WIKI,docs/4.0.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/propagator.html
https://qutip.org/docs/4.0.2/modules/qutip/propagator.html:10244,Deployability,update,updated,10244,"lex)); output = mesolve(H, rho0, tlist, c_op_list, [], args, options, _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; if unitary_mode == 'batch':; return Qobj(u[-1], dims=dims); else:; return Qobj(u[:, :, 1], dims=dims); else:; if unitary_mode == 'batch':; return np.array([Qobj(u[k], dims=dims) for k in range(len(tlist))], dtype=object); else:; return np.array([Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))], dtype=object). def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`. Parameters; ----------; U : qobj; Operator representing the propagator. Returns; -------; a : qobj; Instance representing the steady-state density matrix. """""". evals, evecs = la.eig(U.full()); ; shifted_vals = np.abs(evals - 1.0); ev_idx = np.argmin(shifted_vals); ev_min = shifted_vals[ev_idx]; evecs = evecs.T; rho = Qobj(vec2mat(evecs[ev_idx]), dims=U.dims[0]); rho = rho * (1.0 / rho.tr()); rho = 0.5 * (rho + rho.dag()) # make sure rho is herm; rho.isherm = True; return rho. def _parallel_sesolve(n,N,H,tlist,args,options):; psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options, _safe_mode=False); return output. def _parallel_mesolve(n,N,H,tlist,c_op_list,args, options):; col_idx, row_idx = np.unravel_index(n,(N,N)); rho0 = Qobj(sp.csr_matrix(([1],([row_idx],[col_idx])), shape=(N,N), dtype=complex)); output = mesolve(H, rho0, tlist, c_op_list, [], args, options, _safe_mode=False); return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/propagator.html
https://qutip.org/docs/4.0.2/modules/qutip/propagator.html:3436,Integrability,depend,dependent,3436,"rmat_check); from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False, ; progress_bar=None, **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually ; ('single').; ; parallel : bool {False, True}; Run the propagator in parallel mode. This will override the ; unitary_mode settings if set to True.; ; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U",MatchSource.WIKI,docs/4.0.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/propagator.html
https://qutip.org/docs/4.0.2/modules/qutip/propagator.html:3711,Integrability,depend,dependent,3711,"ptions, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False, ; progress_bar=None, **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually ; ('single').; ; parallel : bool {False, True}; Run the propagator in parallel mode. This will override the ; unitary_mode settings if set to True.; ; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; num_cpus = kwargs['num_cpus']; else:; num_cpus = kw['num_cpus']; ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; r",MatchSource.WIKI,docs/4.0.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/propagator.html
https://qutip.org/docs/4.0.2/modules/qutip/propagator.html:2728,Modifiability,config,config,2728,"USINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.tensor import tensor; from qutip.operators import qeye; from qutip.rhs_generate import (rhs_generate, rhs_clear, _td_format_check); from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False, ; progress_bar=None, **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-depe",MatchSource.WIKI,docs/4.0.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/propagator.html
https://qutip.org/docs/4.0.2/modules/qutip/propagator.html:4232,Usability,progress bar,progress bar,4232,"rix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually ; ('single').; ; parallel : bool {False, True}; Run the propagator in parallel mode. This will override the ; unitary_mode settings if set to True.; ; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; num_cpus = kwargs['num_cpus']; else:; num_cpus = kw['num_cpus']; ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; rhs_clear(). if isinstance(t, (int, float, np.integer, np.floating)):; tlist = [0, t]; else:; tlist = t. td_type = _td_format_check(H, c_op_list, solver='me'); ; if isinstance(H, (types.FunctionType, types.BuiltinFunctionType,; functools.partial)):; H0 = H(0.0, args); elif isinstance(H, list):; H0 = H[0][0] if isinstance(H[0], list) else H[0]; else:; H0 = H; ; if len(c_op_list) == 0 and H0.isoper:; # calculate propagator for the wave function. N = H0.shape[0]; dims = H0.dims; ; if parallel:; unitary_mode = 'single'; u = np.zeros([N, N, len(tlist)], dtype=com",MatchSource.WIKI,docs/4.0.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/propagator.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:14092,Availability,mask,mask,14092,"sub__(self, other):; """"""; SUBTRACTION with Qobj on LEFT [ ex. Qobj-4 ]; """"""; return self + (-other). def __rsub__(self, other):; """"""; SUBTRACTION with Qobj on RIGHT [ ex. 4-Qobj ]; """"""; return (-self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims. if (not isinstance(dims[0][0], list) and; not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0], dims[1], fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching dims; # are traced out of that side.; out.dims = [max([1], [dim; for dim, m in zip(dims[0], mask) if not m]),; max([1], [dim; for dim, m in zip(dims[1], mask) if not m])]; ; else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out.tidyup() if settings.auto_tidyup else out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype=='object':; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:14382,Availability,mask,mask,14382,"self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims. if (not isinstance(dims[0][0], list) and; not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0], dims[1], fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching dims; # are traced out of that side.; out.dims = [max([1], [dim; for dim, m in zip(dims[0], mask) if not m]),; max([1], [dim; for dim, m in zip(dims[1], mask) if not m])]; ; else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out.tidyup() if settings.auto_tidyup else out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype=='object':; return np.array([self * item for item in other],; dtype=object); else:; return self.data * other; ; ; elif isinstance(other, list):; # if other is a list, do element-wise multiplication; return np",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:14443,Availability,mask,mask,14443,"self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims. if (not isinstance(dims[0][0], list) and; not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0], dims[1], fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching dims; # are traced out of that side.; out.dims = [max([1], [dim; for dim, m in zip(dims[0], mask) if not m]),; max([1], [dim; for dim, m in zip(dims[1], mask) if not m])]; ; else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out.tidyup() if settings.auto_tidyup else out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype=='object':; return np.array([self * item for item in other],; dtype=object); else:; return self.data * other; ; ; elif isinstance(other, list):; # if other is a list, do element-wise multiplication; return np",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:19412,Availability,error,errors,19412,"works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; # dense matrix and then to string, because it is pointless; # and is likely going to produce memory errors. Instead print the; # sparse data string representation; s += str(self.data). elif all(np.imag(self.data.data) == 0):; s += str(np.real(self.full())). else:; s += str(self.full()). return s. def __repr__(self):; # give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""); ; if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other); ; if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(o",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:25184,Availability,toler,tolerance,25184,"merate_flat(J.dims); J_dual = tensor.tensor_swap(J, *(; list(zip(tensor_idxs[0][1], tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; vals = sp_eigs(self.data, self.isherm, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(sqrt(abs(vals) ** 2)); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm must be 'l2', or 'max'.""). [docs]",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:27290,Availability,avail,available,27290,"lex``; otherwise. """"""; if self.isherm:; return float(np.real(np.sum(self.data.diagonal()))); else:; return complex(np.sum(self.data.diagonal())). [docs] def full(self, squeeze=False):; """"""Dense array from quantum object. Returns; -------; data : array; Array of complex data from quantum objects `data` attribute. """"""; if squeeze:; return self.data.toarray().squeeze(); else:; return self.data.toarray(). [docs] def diag(self):; """"""Diagonal elements of quantum object. Returns; -------; diags : array; Returns array of ``real`` values if operators is Hermitian,; otherwise ``complex`` values are returned. """"""; out = self.data.diagonal(); if np.any(np.imag(out) > settings.atol) or not self.isherm:; return out; else:; return np.real(out). [docs] def expm(self, method='dense'):; """"""Matrix exponential of quantum operator. Input operator must be square. Parameters; ----------; method : str {'dense', 'sparse'}; Use set method to use to calculate the matrix exponentiation. The; available choices includes 'dense' and 'sparse'. Since the ; exponential of a matrix is nearly always dense, method='dense'; is set as default.s. Returns; -------; oper : qobj; Exponentiated quantum operator. Raises; ------; TypeError; Quantum operator is not square. """"""; if self.dims[0][0] != self.dims[1][0]:; raise TypeError('Invalid operand for matrix exponential'). if method == 'dense':; F = sp_expm(self.data, sparse=False). elif method == 'sparse':; F = sp_expm(self.data, sparse=True). else:; raise ValueError(""method must be 'dense' or 'sparse'.""). out = Qobj(F, dims=self.dims); return out.tidyup() if settings.auto_tidyup else out. [docs] def check_herm(self):; """"""Check if the quantum object is hermitian. Returns; -------; isherm : bool; Returns the new value of isherm property.; """"""; self._isherm = None; return self.isherm. [docs] def sqrtm(self, sparse=False, tol=0, maxiter=100000):; """"""Sqrt of a quantum operator. Operator must be square. Parameters; ----------; sparse : bool; Use sparse eigenvalue/",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:31627,Availability,toler,tolerance,31627,"ttings.auto_tidyup:; return out.tidyup(); else:; return out. [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : qobj; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(self, order); return q.tidyup() if settings.auto_tidyup else q. [docs] def tidyup(self, atol=None):; """"""Removes small elements from the quantum object. Parameters; ----------; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns; -------; oper : qobj; Quantum object with small elements removed. """"""; if atol is None:; atol = settings.auto_tidyup_atol. if self.data.nnz:. data_real = self.data.data.real; data_real[np.abs(data_real) < atol] = 0. data_imag = self.data.data.imag; data_imag[np.abs(data_imag) < atol] = 0. self.data.data = data_real + 1j * data_imag. self.data.eliminate_zeros(); return self; else:; return self. [docs] def transform(self, inpt, inverse=False, sparse=True):; """"""Basis transform defined by input array. Input array can be a ``matrix`` defining the transformation,; or a ``list`` of kets that defines the new basis. Parameters; ----------; inpt : array_like; A ``matrix`` or ``list`` of kets defining the transformation.; inverse : bool; Whether to return inverse transformation.; sparse : bool; Use sparse matrices when possible. Can be slower. Returns; -------; oper : qobj; Operator in new basis. N",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:37434,Availability,toler,tolerance,37434,"aises; ------; TypeError; Can only calculate overlap between a bra and ket quantum objects.; ; """""". if isinstance(state, Qobj):. if self.isbra:; if state.isket:; return (self.data * state.data)[0, 0]; elif state.isbra:; return (self.data * state.data.H)[0, 0]. elif self.isket:; if state.isbra:; return (self.data.H * state.data.H)[0, 0]; elif state.isket:; return (self.data.H * state.data)[0, 0]. raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Para",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:38740,Availability,toler,tolerance,38740,"rder of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39531,Availability,toler,tolerance,39531," high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj;",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:52749,Availability,toler,tolerance,52749,"ing the `Qobj.isoperbra`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.isoperbra else False. def isoper(Q):; """"""Determines if given quantum object is a operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isoper : bool; True if Qobj is operator, False otherwise. Examples; --------; >>> a = destroy(5); >>> isoper(a); True. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isoper`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.isoper else False. def issuper(Q):; """"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B.; ; """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.ish",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:20609,Deployability,update,update,20609," complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""); ; if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other); ; if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""); ; elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:20840,Deployability,update,update,20840,"_str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""); ; if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other); ; if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""); ; elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%.1f"" % value; else:; return ""%.3f"" % value. def _format_element(m, n, d):; s = "" & "" if n > 0 else """"; if type(d) ==",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:54208,Deployability,update,updated,54208,"es if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B.; ; """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:18186,Energy Efficiency,power,powers,18186,"f.data / other; out.dims = self.dims; if isinstance(other, complex):; out._isherm = out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; out._isherm = self._isherm; return out.tidyup() if settings.auto_tidyup else out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:18310,Energy Efficiency,power,power,18310,". out.superrep = self.superrep. return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; out._isherm = self._isherm; return out.tidyup() if settings.auto_tidyup else out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:46059,Integrability,depend,dependent,46059,"value; return self._isherm. if self.dims[0] != self.dims[1]:; self._isherm = False; else:; data = self.data; h = np.abs((data.transpose().conj() - data).data); self._isherm = False if np.any(h > settings.atol) else True. return self._isherm. @isherm.setter; def isherm(self, isherm):; self._isherm = isherm. @property; def type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:46398,Integrability,depend,dependent,46398,"f type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specificati",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:46475,Integrability,depend,dependent,46475,"erty; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -------------------------------------------------------",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:46586,Integrability,depend,dependent,46586,".prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the lis",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:47188,Integrability,depend,dependent,47188,"H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:47282,Integrability,depend,dependent,47282,"H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:47372,Integrability,depend,dependent,47372,"H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:47519,Integrability,depend,dependent,47519," A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legac",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:47618,Integrability,depend,dependent,47618," A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legac",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:53874,Integrability,depend,dependencies,53874,"es if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B.; ; """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:6858,Performance,perform,performing,6858,"ject.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object.; ; """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays. def __init__(self, inpt=None, dims=[[], []], shape=[],; type=None, isherm=None, copy=True,; fast=False, superrep=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep. if fast == 'mc':; # fast Qobj construction for use in mcsolve with ket output; self._data = inpt; self.dims = dims; self._isherm = False; return. if",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:10547,Performance,cache,cache,10547,"t.shape[0])], [int(inpt.shape[1])]]; else:; self.dims = dims. elif isinstance(inpt, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; # if input is int, float, or complex then convert to array; _tmp = sp.csr_matrix([[inpt]], dtype=complex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr), ; shape = _tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr), ; shape = _tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; if self.type == 'oper':; self.dims = [[[d] for d in self.dims[0]],; [[d] for d in self.dims[1]]]. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. ; def get_data(self):; return self._data; #Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data); ; def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; other = Qobj(other). if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.data = self.data + dat * fast_identity(; self.shape[0]); else:; out.data = self.data; out.data.data = out.data.data + dat. out.dims = self.dims; if isinstance(dat, (int, float)):; out._isherm = self._isherm; else:; # We use _isherm here to prevent recalculating on self ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:20735,Performance,load,loading,20735,"y serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""); ; if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other); ; if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""); ; elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:25254,Performance,perform,performed,25254,"tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; vals = sp_eigs(self.data, self.isherm, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(sqrt(abs(vals) ** 2)); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm must be 'l2', or 'max'.""). [docs] def tr(self):; """"""Trace of a quantum object. Returns; -------; trace : float; Retu",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:30437,Performance,perform,performed,30437,"; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return 0.5 * ((1j * self).expm() + (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'); ; ; [docs] def sinm(self):; """"""Sine of a quantum operator. Operator must be square. Returns; -------; oper : qobj; Matrix sine of operator. Raises; ------; TypeError; Quantum object is not square. Notes; -----; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return -0.5j * ((1j * self).expm() - (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'); ; ; ; [docs] def unit(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : qobj; Normalized quantum object. """"""; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out. [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : qobj; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(se",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:37504,Performance,perform,performed,37504,"uantum objects.; ; """""". if isinstance(state, Qobj):. if self.isbra:; if state.isket:; return (self.data * state.data)[0, 0]; elif state.isbra:; return (self.data * state.data.H)[0, 0]. elif self.isket:; if state.isbra:; return (self.data.H * state.data.H)[0, 0]; elif state.isket:; return (self.data.H * state.data)[0, 0]. raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:38811,Performance,perform,performed,38811,"n the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39602,Performance,perform,performed,39602,"fault is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(s",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:43027,Performance,cache,cached,43027,"ity matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns; -------; q : Qobj; A new instance of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental.; ; """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B.; ; """"""; return mts.dnorm(self, B); ; ; @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:43242,Performance,cache,cached,43242,"ss:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental.; ; """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B.; ; """"""; return mts.dnorm(self, B); ; ; @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = s",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39239,Safety,safe,safe,39239,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Groun",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39641,Safety,safe,safe,39641,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] de",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39993,Safety,safe,safe,39993,"requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors norm",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:40141,Safety,safe,safe,40141,"iter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Retu",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:53859,Safety,avoid,avoid,53859,"es if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B.; ; """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:2677,Testability,log,log,2677,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types. try:; import builtins; except:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh, trunc). import numpy as np; import scipy.sparse as sp; import scipy.linalg as la; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.ptrace import _ptrace; from qutip.permute import _permute; from qutip.sparse import (sp_eigs, sp_expm, sp_fro_norm, sp_max_norm,; sp_one_norm, sp_L2_norm); from qutip.dimensions import type_from_dims, enumerate_flat, collapse_dims_super; from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint). import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. [docs]class Qobj(object):; """"""A class for representing quantum objects, such as quantum operators; and states. The Qobj class is the QuTiP representation of quan",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:43342,Testability,test,test,43342,"ces = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B.; ; """"""; return mts.dnorm(self, B); ; ; @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = self; else:; qobj = sr.to_choi(self). # Possibly collapse dims.; if any([len(index) > 1 for super_index in qobj.dims for index in super_index]):; qobj ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:44023,Testability,test,test,44023,"r"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = self; else:; qobj = sr.to_choi(self). # Possibly collapse dims.; if any([len(index) > 1 for super_index in qobj.dims for index in super_index]):; qobj = Qobj(qobj, dims=collapse_dims_super(qobj.dims)); else:; qobj = qobj. # We use the condition from John Watrous' lecture notes,; # Tr_1(J(Phi)) = identity_2.; tr_oper = ptrace((qobj), (0,)); ident = ops.identity(tr_oper.shape[0]); return isequal(tr_oper, ident) ; except:; return False; else:; return False. @property; def iscptp(self):; from qutip.superop_reps import to_choi; if self.type == ""super"" or self.type == ""oper"":; reps = ('choi', 'chi'); q_oper = to_choi(self) if self.superrep not in reps else self; return q_oper.iscp and q_oper.istp; else:; return False. @property; def isherm(self):. if self._isherm is not None:; # used previously computed value; return self._isherm. if self.dims[0] !=",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:47699,Testability,test,test,47699,"sinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method.; ; """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). def ptrace(Q, sel):; """"""Partial",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:48168,Testability,test,tests,48168," time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method.; ; """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). def ptrace(Q, sel):; """"""Partial trace of the Qobj with selected components remaining. Parameters; ----------; Q : qobj; Composite quantum object.; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``ptrace()`` Qobj method.; ; """"""; if not isinstance(Q",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:10536,Usability,clear,clear,10536,"t.shape[0])], [int(inpt.shape[1])]]; else:; self.dims = dims. elif isinstance(inpt, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; # if input is int, float, or complex then convert to array; _tmp = sp.csr_matrix([[inpt]], dtype=complex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr), ; shape = _tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr), ; shape = _tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; if self.type == 'oper':; self.dims = [[[d] for d in self.dims[0]],; [[d] for d in self.dims[1]]]. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. ; def get_data(self):; return self._data; #Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data); ; def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; other = Qobj(other). if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.data = self.data + dat * fast_identity(; self.shape[0]); else:; out.data = self.data; out.data.data = out.data.data + dat. out.dims = self.dims; if isinstance(dat, (int, float)):; out._isherm = self._isherm; else:; # We use _isherm here to prevent recalculating on self ",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:19773,Usability,simpl,simply,19773," def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; # dense matrix and then to string, because it is pointless; # and is likely going to produce memory errors. Instead print the; # sparse data string representation; s += str(self.data). elif all(np.imag(self.data.data) == 0):; s += str(np.real(self.full())). else:; s += str(self.full()). return s. def __repr__(self):; # give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""); ; if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other); ; if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""); ; elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines wha",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:34147,Usability,simpl,simply,34147,": ; raise TypeError('Invalid operand for basis transformation'). # transform data; if inverse:; if self.isket:; data = (S.conj().T) * self.data; elif self.isbra:; data = self.data.dot(S); else:; if sparse:; data = (S.conj().T) * self.data * S; else:; data = (S.conj().T).dot(self.data.dot(S)); else:; if self.isket:; data = S * self.data; elif self.isbra:; data = self.data.dot(S.conj().T); else:; if sparse:; data = S * self.data * (S.conj().T); else:; data = S.dot(self.data.dot(S.conj().T)). out = Qobj(data, dims=self.dims); out._isherm = self._isherm; out.superrep = self.superrep. if settings.auto_tidyup:; return out.tidyup(); else:; return out; . [docs] def trunc_neg(self, method=""clip""):; """"""Truncates negative eigenvalues and renormalizes. Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters; ----------; method : str; Algorithm to use to remove negative eigenvalues. ""clip""; simply discards negative eigenvalues, then renormalizes.; ""sgs"" uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns; -------; oper : qobj; A valid density operator.; ; """"""; if not self.isherm:; raise ValueError(""Must be a Hermitian operator to remove negative eigenvalues.""). if method not in ('clip', 'sgs'):; raise ValueError(""Method {} not recognized."".format(method)). eigvals, eigstates = self.eigenstates(); if all([eigval >= 0 for eigval in eigvals]):; # All positive, so just renormalize.; return self.unit(); idx_nonzero = eigvals != 0; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1] ; eigstates = eigstates[::-1]; ; acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals); ; for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0; ; eigvals[:idx+1] += acc / (i",MatchSource.WIKI,docs/4.0.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html
https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html:10024,Availability,error,error,10024,"e. Parameters; ----------; N : int; Dimension of the state vector to be returned. dims : list of ints, or None; Left-dimensions of the resultant quantum object.; If None, [N] is used. Returns; -------; psi : Qobj; A random state vector drawn from the Haar measure.; """"""; if dims:; _check_ket_dims(dims, N); else:; dims = [N]; psi = rand_unitary_haar(N) * basis(N, 0); psi.dims = [dims, [1]]; return psi. [docs]def rand_dm(N, density=0.75, pure=False, dims=None):; """"""Creates a random NxN density matrix. Parameters; ----------; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density : float; Density between [0,1] of output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper : qobj; NxN density matrix quantum operator. Notes; -----; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that :math:`Tr(\\rho)=1`. """"""; if isinstance(N,(np.ndarray,list)):; if np.abs(np.sum(N)-1.0) > 1e-15:; raise ValueError('Eigenvalues of a density matrix must sum to one.'); H = sp.diags(N,0, dtype=complex, format='csr'); N = len(N); if dims:; _check_dims(dims, N, N); nvals = N**2*density; while H.nnz < 0.95*nvals:; H = rand_jacobi_rotation(H); H.sort_indices(); elif isinstance(N,int):; if dims:; _check_dims(dims, N, N); if pure:; dm_density = sqrt(density); psi = rand_ket(N, dm_density); H = psi * psi.dag(); H.data.sort_indices(); else:; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density); H = H.dag() * H; non_zero = H.tr(); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H = H / H.tr(); H.data.sort_indices(); if dims:; return Qobj(H, dims=dims); else:; return Qobj(H). [docs]def rand_dm_ginibre(N=2, rank=None, dims=None):; """"""; Returns a Ginibre random de",MatchSource.WIKI,docs/4.0.2/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html
https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html:18890,Deployability,update,updated,18890,"dims, N, N); num_elems = np.int(np.ceil(N*(N+1)*density)/2); data = np.random.rand(num_elems); row_idx = np.random.choice(N, num_elems); col_idx = np.random.choice(N, num_elems); if kind=='left':; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsc(); else:; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsr(); M = 0.5*(M+M.conj().transpose()); if kind=='left':; num_cols = M.indptr.shape[0]-1; for col in range(num_cols):; col_start = M.indptr[col]; col_end = M.indptr[col+1]; col_sum = np.sum(M.data[col_start:col_end]); M.data[col_start:col_end] /= col_sum; M = M.tocsr(); else:; num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if dims:; return Qobj(M, dims=dims, shape=[N, N]); else:; return Qobj(M). def _check_ket_dims(dims, N1):; if not isinstance(dims, list) or isinstance(dims[0], list):; raise TypeError(""Left and right Qobj dimensions must be lists of ints. E.g.: [2, 3].""); if np.prod(dims) != N1:; raise ValueError(""Qobj dimensions must match matrix shape.""). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). # TRAILING IMPORTS; # qutip.propagator depends on rand_dm, so we need to put this import last.; from qutip.propagator import propagator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html
https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html:18681,Integrability,depend,depends,18681,"dims, N, N); num_elems = np.int(np.ceil(N*(N+1)*density)/2); data = np.random.rand(num_elems); row_idx = np.random.choice(N, num_elems); col_idx = np.random.choice(N, num_elems); if kind=='left':; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsc(); else:; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsr(); M = 0.5*(M+M.conj().transpose()); if kind=='left':; num_cols = M.indptr.shape[0]-1; for col in range(num_cols):; col_start = M.indptr[col]; col_end = M.indptr[col+1]; col_sum = np.sum(M.data[col_start:col_end]); M.data[col_start:col_end] /= col_sum; M = M.tocsr(); else:; num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if dims:; return Qobj(M, dims=dims, shape=[N, N]); else:; return Qobj(M). def _check_ket_dims(dims, N1):; if not isinstance(dims, list) or isinstance(dims[0], list):; raise TypeError(""Left and right Qobj dimensions must be lists of ints. E.g.: [2, 3].""); if np.prod(dims) != N1:; raise ValueError(""Qobj dimensions must match matrix shape.""). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). # TRAILING IMPORTS; # qutip.propagator depends on rand_dm, so we need to put this import last.; from qutip.propagator import propagator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html
https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html:15391,Safety,avoid,avoid,15391,"erated.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N],[N]], [[N],[N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre'); ; # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()); ; if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible improvement,; # iterative methods exist to find inverse square root matrices directly,; # as this is important in statistics.; Z = np.kron(; np.eye(N),; sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]",MatchSource.WIKI,docs/4.0.2/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:3670,Availability,error,error,3670,"-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperat",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:8338,Deployability,install,installed,8338,"c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2 or not isinstance(c_ops[k][0], Qobj):; raise TypeError(; ""Incorrect collapse operator specification""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstanc",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:11289,Deployability,update,update,11289,"elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:11544,Deployability,update,updated,11544,"elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2480,Integrability,depend,dependent,2480," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of gen",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2623,Integrability,depend,dependent,2623,"O, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the me",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:3343,Integrability,depend,dependent,3343,"rator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator"").",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:4059,Integrability,depend,dependence,4059," name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(msg + ""expected string format""). # loop over all collapse operators; for c_spec in c_ops:; if isinstance(c_spec, Qobj):; c = c_spec. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; c",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:6458,Integrability,depend,dependent,6458,"()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in ra",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:8121,Integrability,depend,dependence,8121,"TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2 or not isinstance(c_ops[k][0], Qobj):; raise TypeError(; ""Incorrect collapse operator specification""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:8288,Integrability,depend,dependence,8288,"TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2 or not isinstance(c_ops[k][0], Qobj):; raise TypeError(; ""Incorrect collapse operator specification""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:8679,Integrability,depend,dependence,8679,"_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; tim",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:9529,Integrability,depend,dependent,9529,"e to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:9717,Integrability,depend,dependence,9717,"e to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:9917,Integrability,depend,dependence,9917,"g if not objects; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:10130,Integrability,depend,dependence,10130,"(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:10296,Integrability,depend,dependence,10296," #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:10332,Integrability,depend,dependence,10332," #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:11333,Integrability,depend,dependent,11333,"elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2295,Modifiability,config,config,2295," OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of co",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2596,Modifiability,config,config,2596,"ARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2654,Modifiability,config,config,2654,"O, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the me",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2711,Modifiability,config,config,2711,"TS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options =",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2774,Modifiability,config,config,2774,"RY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2841,Modifiability,config,config,2841,"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldat",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2880,Modifiability,variab,variables,2880,"NG IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2914,Modifiability,config,config,2914,"NG IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:3682,Modifiability,config,config,3682,"holder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices)",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:3698,Modifiability,config,config,3698,"HS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:3734,Modifiability,config,config,3734," # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_co",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:3763,Modifiability,config,config,3763,"ol-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lob",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:3810,Modifiability,config,config,3810,"holder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:6126,Modifiability,config,config,6126," * spre(cdc) \; - 0.5 * spost(cdc); elif c.issuper:; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):;",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:6133,Modifiability,config,config,6133," * spre(cdc) \; - 0.5 * spost(cdc); elif c.issuper:; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):;",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:6156,Modifiability,config,config,6156,"; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarra",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:6206,Modifiability,config,config,6206," + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeErr",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:6292,Modifiability,config,config,6292,"c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specifica",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:6352,Modifiability,config,config,6352,"sg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:8474,Performance,load,load,8474," range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2 or not isinstance(c_ops[k][0], Qobj):; raise TypeError(; ""Incorrect collapse operator specification""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:2570,Usability,clear,clears,2570,"ARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes",MatchSource.WIKI,docs/4.0.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:18038,Availability,error,error,18038,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:2242,Deployability,integrat,integrate,2242,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlis",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:3100,Deployability,integrat,integrating,3100,"nitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:6717,Deployability,integrat,integrator,6717,"me-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t,",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:6808,Deployability,integrat,integrate,6808,"lve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_lis",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:6853,Deployability,integrat,integrate,6853,"args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_arg",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:8563,Deployability,integrat,integrator,8563,"st)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for u",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:8627,Deployability,integrat,integrate,8627,"# args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initi",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11575,Deployability,integrat,integrator,11575,"list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11638,Deployability,integrat,integrate,11638," parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE so",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14402,Deployability,integrat,integrator,14402," range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14465,Deployability,integrat,integrate,14465,"; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:15403,Deployability,integrat,integrator,15403,"; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:15966,Deployability,integrat,integrate,15966,"--------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:16018,Deployability,integrat,integrate,16018,"ion evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims=None):; """""";",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:17966,Deployability,update,update,17966,"tlist, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. .",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:18026,Deployability,integrat,integration,18026,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:18528,Deployability,integrat,integrate,18528,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:18886,Deployability,update,updated,18886,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:2242,Integrability,integrat,integrate,2242,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlis",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:3100,Integrability,integrat,integrating,3100,"nitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:3584,Integrability,depend,dependent,3584,"ngs import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ;",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:3937,Integrability,depend,dependent,3937," """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, [",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:4753,Integrability,depend,dependence,4753,"perators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:4869,Integrability,depend,dependent,4869,"perators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:5051,Integrability,depend,dependence,5051,"turns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:5732,Integrability,depend,dependent,5732,"s = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_s",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:6572,Integrability,depend,dependent,6572,"es.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, args); for n in range(1, len(H_list)):; #; #",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:6717,Integrability,integrat,integrator,6717,"me-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t,",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:6808,Integrability,integrat,integrate,6808,"lve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_lis",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:6853,Integrability,integrat,integrate,6853,"args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_arg",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:7376,Integrability,depend,dependence,7376,"; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlis",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:8563,Integrability,integrat,integrator,8563,"st)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for u",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:8627,Integrability,integrat,integrate,8627,"# args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initi",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:9316,Integrability,depend,dependent,9316,"s_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density matrix; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian; #; Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to h_coeff; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = ""1.0"". elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lo",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:10189,Integrability,depend,dependent,10189,"psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density matrix; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian; #; Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to h_coeff; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = ""1.0"". elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename i",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11575,Integrability,integrat,integrator,11575,"list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11638,Integrability,integrat,integrate,11638," parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE so",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:12296,Integrability,depend,dependent,12296,"en = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:12460,Integrability,depend,dependent,12460,"en = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:12611,Integrability,depend,dependent,12611,"; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:12696,Integrability,depend,dependent,12696,"; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:12850,Integrability,depend,dependent,12850,"ue(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:13042,Integrability,depend,dependent,13042,"eric_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:13233,Integrability,depend,dependent,13233,"ion evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:13448,Integrability,depend,dependent,13448," an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = p",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14402,Integrability,integrat,integrator,14402," range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14465,Integrability,integrat,integrate,14465,"; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:15097,Integrability,depend,dependent,15097,"ame = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:15261,Integrability,depend,dependent,15261,"ame = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:15403,Integrability,integrat,integrator,15403,"; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:15966,Integrability,integrat,integrate,15966,"--------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:16018,Integrability,integrat,integrate,16018,"ion evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims=None):; """""";",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:16484,Integrability,depend,dependent,16484," new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; ou",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:18026,Integrability,integrat,integration,18026,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:18528,Integrability,integrat,integrate,18528,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:2407,Modifiability,config,config,2407,"RPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:5014,Modifiability,config,config,5014,".Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:5039,Modifiability,config,config,5039,"turns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:5087,Modifiability,config,config,5087,"turns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11143,Modifiability,config,config,11143,"raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # ---------",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11197,Modifiability,config,config,11197,"dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # ----------------------------------------------------------",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11244,Modifiability,config,config,11244,"t)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution usin",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11269,Modifiability,config,config,11269,".append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11367,Modifiability,config,config,11367,"ptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_lis",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11374,Modifiability,config,config,11374,"ptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_lis",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11397,Modifiability,config,config,11397,"_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar)",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11447,Modifiability,config,config,11447," the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11533,Modifiability,config,config,11533," # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debu",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11652,Modifiability,config,config,11652,"s; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:12596,Modifiability,config,configure,12596,"; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:13185,Modifiability,config,config,13185,"---------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:13970,Modifiability,config,config,13970,"))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14024,Modifiability,config,config,14024,"):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wav",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14071,Modifiability,config,config,14071,"ust be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary qu",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14096,Modifiability,config,config,14096,"ength N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; #",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14194,Modifiability,config,config,14194,"f opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14201,Modifiability,config,config,14201,"f opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14224,Modifiability,config,config,14224,"ious time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave f",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14274,Modifiability,config,config,14274,"Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-depe",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14360,Modifiability,config,config,14360,"h = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:14479,Modifiability,config,config,14479,"[-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:18606,Modifiability,config,config,18606,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:18650,Modifiability,config,config,18650,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.0.2/modules/qutip/simdiag.html:5682,Deployability,update,updated,5682,")); inds = rng[inds]; if len(inds) > 1: # if at least 2 eigvals are degenerate; eigvecs_array[inds] = degen(; tol, eigvecs_array[inds],; np.array([ops[kk] for kk in range(1, num_ops)])); k = max(inds) + 1; eigvals_out = np.zeros((num_ops, len(ds)), dtype=float); kets_out = np.array([Qobj(eigvecs_array[j] / la.norm(eigvecs_array[j]),; dims=[ops[0].dims[0], [1]],; shape=[ops[0].shape[0], 1]); for j in range(len(ds))]); if not evals:; return kets_out; else:; for kk in range(num_ops):; for j in range(len(ds)):; eigvals_out[kk, j] = np.real(np.dot(; eigvecs_array[j].conj().T,; ops[kk].data * eigvecs_array[j])); return eigvals_out, kets_out. def degen(tol, in_vecs, ops):; """"""; Private function that finds eigen vals and vecs for degenerate matrices..; """"""; n = len(ops); if n == 0:; return in_vecs; A = ops[0]; vecs = np.column_stack(in_vecs); eigvals, eigvecs = la.eig(np.dot(vecs.conj().T, A.data.dot(vecs))); zipped = zip(-eigvals, range(len(eigvals))); zipped.sort(); ds, perm = zip(*zipped); ds = -np.real(np.array(ds)); perm = np.array(perm); vecsperm = np.zeros(eigvecs.shape, dtype=complex); for kk in range(len(perm)): # matrix with sorted eigvecs in columns; vecsperm[:, kk] = eigvecs[:, perm[kk]]; vecs_new = np.dot(vecs, vecsperm); vecs_out = np.array(; [np.zeros((A.shape[0], 1), dtype=complex) for k in range(len(ds))]); for kk in range(len(perm)): # matrix with sorted eigvecs in columns; vecs_out[kk][:, 0] = vecs_new[:, kk]; k = 0; rng = np.arange(len(ds)); while k < len(ds):; inds = np.array(abs(ds - ds[k]) < max(; tol, tol * abs(ds[k]))) # get indicies of degenerate eigvals; inds = rng[inds]; if len(inds) > 1: # if at least 2 eigvals are degenerate; vecs_out[inds] = degen(tol, vecs_out[inds],; np.array([ops[jj] for jj in range(1, n)])); k = max(inds) + 1; return vecs_out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/simdiag.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/simdiag.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:2777,Availability,toler,tolerance,2777,"ABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:2819,Availability,toler,tolerance,2819,"LITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero e",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:3807,Availability,error,errors,3807,"rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solvers.; rhs_reuse : bool {False,True}; Reuse Hamiltonian data.; rhs_with_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=Tr",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:5040,Availability,toler,tolerance,5040,"n using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solvers.; rhs_reuse : bool {False,True}; Reuse Hamiltonian data.; rhs_with_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_steps=5, rhs_reuse=False,; rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False,; store_final_state=False, store_states=False, seeds=None,; steady_state_average=False, normalize_output=True):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:5097,Availability,toler,tolerance,5097,"ture.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_steps=5, rhs_reuse=False,; rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False,; store_final_state=False, store_states=False, seeds=None,; steady_state_average=False, normalize_output=True):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependen",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:10706,Availability,toler,tolerance,10706,"ct is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix da",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:2909,Deployability,integrat,integrator,2909,"VISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solver",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:5533,Deployability,integrat,integrator,5533,"re provided, then states are stored by default and this; option has no effect. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_steps=5, rhs_reuse=False,; rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False,; store_final_state=False, store_states=False, seeds=None,; steady_state_average=False, normalize_output=True):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = 0; # Tolerance for wavefunction norm (mcsolve only); sel",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:10185,Deployability,update,update,10185,"ver. """"""; def __init__(self):; self.solver = None; self.times = None; self.states = []; self.expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:10416,Deployability,update,update,10416," self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:26319,Deployability,update,updated,26319,"mp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp_type,state); ; else:; raise Exception('Invalid time-dependent format.'); ; for ii in range(len(c_ops)):; if isinstance(c_ops[ii], Qobj):; _temp_state = c_ops[ii]; elif isinstance(c_ops[ii], list):; _temp_state = c_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims, Htype, _temp_state); ; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state). def _structure_check(Hdims, Htype, state):; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not share same structure.'). ; #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:2909,Integrability,integrat,integrator,2909,"VISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solver",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:5533,Integrability,integrat,integrator,5533,"re provided, then states are stored by default and this; option has no effect. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_steps=5, rhs_reuse=False,; rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False,; store_final_state=False, store_states=False, seeds=None,; steady_state_average=False, normalize_output=True):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = 0; # Tolerance for wavefunction norm (mcsolve only); sel",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:6094,Integrability,depend,dependent,6094,"elf.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = 0; # Tolerance for wavefunction norm (mcsolve only); self.norm_tol = norm_tol; # Max. number of steps taken to find wavefunction norm to within; # norm_tol (mcsolve only); self.norm_steps = norm_steps; # store final state?; self.store_final_state = store_final_state; # store states even if expectation operators are given?; self.store_states = store_states; # average mcsolver density matricies assuming steady state evolution; self.steady_state_average = steady_state_average; # Normalize output of solvers (turned off for batch unitary propagator mode); self.normalize_output = normalize",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:10977,Integrability,depend,dependence,10977," += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op in",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:11137,Integrability,depend,dependent,11137,"t happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_con",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:11163,Integrability,depend,dependent,11163,"_dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse op",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:11588,Integrability,depend,dependent,11588,"elf.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:12225,Integrability,depend,dependent,12225,"r for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:12421,Integrability,depend,dependent,12421,"; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:0",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:12656,Integrability,depend,dependent,12656,"trs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:12785,Integrability,depend,dependence,12785,"elf.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'; ; Parameters; ----------; section_names : list; list of keys t",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:17222,Integrability,message,message,17222," value; ; value : int; Initial value of the count, or added to an existing count; ; section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used; """"""; ; self._get_section(section).add_count(key, value); ; [docs] def add_timing(self, key, value, section=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solve",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:17358,Integrability,message,message,17358,"ed; """"""; ; self._get_section(section).add_count(key, value); ; [docs] def add_timing(self, key, value, section=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(va",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:17468,Integrability,message,messages,17468,"dy exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Re",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:17578,Integrability,message,message,17578,"dy exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Re",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:17611,Integrability,message,message,17611,"dy exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Re",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:17769,Integrability,message,message,17769,"dy exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Re",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:18653,Integrability,message,messages,18653," will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:18792,Integrability,message,messages,18792,"get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values;",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:19611,Integrability,message,messages,19611,"put=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values; ; The method parameter descriptions are the same as for those the parent ; with the same method name; ; Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; mes",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:20597,Integrability,message,messages,20597," for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values; ; The method parameter descriptions are the same as for those the parent ; with the same method name; ; Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; messages : OrderedDict; Text type output to be reported; ; total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:20958,Integrability,message,messages,20958,"-----; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; messages : OrderedDict; Text type output to be reported; ; total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:21990,Integrability,message,message,21990,"); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ;",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:22126,Integrability,message,message,22126,"value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:22216,Integrability,message,messages,22216,"alue); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = """,MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:22376,Integrability,message,messages,22376,"elf.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:22412,Integrability,message,messages,22412,"[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items()",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:22511,Integrability,message,messages,22511,"lue to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . d",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23357,Integrability,message,messages,23357,"en seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if is",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23423,Integrability,message,messages,23423," value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type;",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23549,Integrability,message,messages,23549," the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Inv",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23630,Integrability,message,messages,23630,"ection total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp_type,state); ; else:; raise Excep",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:24654,Integrability,depend,dependent,24654,"lear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp_type,state); ; else:; raise Exception('Invalid time-dependent format.'); ; for ii in range(len(c_ops)):; if isinstance(c_ops[ii], Qobj):; _temp_state = c_ops[ii]; elif isinstance(c_ops[ii], list):; _temp_state = c_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims, Htype, _temp_state); ; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state). def _structure_check(Hdims, Htype, state):; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); else:; raise Exception('Invalid ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:11455,Modifiability,variab,variables,11455,"on():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm c",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:26105,Modifiability,config,config,26105,"mp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp_type,state); ; else:; raise Exception('Invalid time-dependent format.'); ; for ii in range(len(c_ops)):; if isinstance(c_ops[ii], Qobj):; _temp_state = c_ops[ii]; elif isinstance(c_ops[ii], list):; _temp_state = c_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims, Htype, _temp_state); ; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state). def _structure_check(Hdims, Htype, state):; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not share same structure.'). ; #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:10311,Performance,load,loading,10311,"expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:13544,Performance,perform,performance,13544,"_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'; ; Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called 'main' is created; ; Attributes; ----------; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section; ; header : string; Some text that will be used as the heading in the report; By default there is None; ; total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported; ; Methods; -------; add_section; Add another section; ; add_count; Add some stat that is an int",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:19566,Usability,clear,clear,19566,"put=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values; ; The method parameter descriptions are the same as for those the parent ; with the same method name; ; Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; mes",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:19686,Usability,clear,clear,19686,"e reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values; ; The method parameter descriptions are the same as for those the parent ; with the same method name; ; Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; messages : OrderedDict; Text type output to be reported; ; total_time : float; Total time for pr",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23504,Usability,clear,clear,23504," the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Inv",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23594,Usability,clear,clear,23594," be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23616,Usability,clear,clear,23616,"nt and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp_type,state); ; else:;",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23639,Usability,clear,clear,23639,"_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp_type,state); ; else:; raise Exception('Inval",MatchSource.WIKI,docs/4.0.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html
https://qutip.org/docs/4.0.2/modules/qutip/states.html:13080,Availability,down,down,13080,"ket2dm(x); Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j]]. """"""; if Q.type == 'ket':; out = Q * Q.dag(); elif Q.type == 'bra':; out = Q.dag() * Q; else:; raise TypeError(""Input is not a ket or bra vector.""); return Qobj(out). #; # projection operator; #; [docs]def projection(N, n, m, offset=0):; """"""The projection operator that projects state :math:`|m>` on state :math:`|n>`. Parameters; ----------; N : int; Number of basis states in Hilbert space. n, m : float; The number states in the projection. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the projector. Returns; -------; oper : qobj; Requested projection operator.; ; """"""; ket1 = basis(N, n, offset=offset); ket2 = basis(N, m, offset=offset). return ket1 * ket2.dag(). #; # composite qubit states; #; def qstate(string):; """"""Creates a tensor product for a set of qubits in either; the 'up' :math:`|0>` or 'down' :math:`|1>` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu'); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # ",MatchSource.WIKI,docs/4.0.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/states.html
https://qutip.org/docs/4.0.2/modules/qutip/states.html:14028,Availability,down,down,14028,"):; """"""Creates a tensor product for a set of qubits in either; the 'up' :math:`|0>` or 'down' :math:`|1>` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu'); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; ----",MatchSource.WIKI,docs/4.0.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/states.html
https://qutip.org/docs/4.0.2/modules/qutip/states.html:14714,Availability,down,down,14714," ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; --------; >>> ket(""10""); Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue""); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([b",MatchSource.WIKI,docs/4.0.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/states.html
https://qutip.org/docs/4.0.2/modules/qutip/states.html:16210,Availability,down,down,16210,"[8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([basis(dim[i], _character_to_qudit(x)); for i, x in enumerate(seq)]). [docs]def bra(seq, dim=2):; """"""; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; bra : qobj. Examples; --------; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]; """"""; return ket(seq, dim=dim).dag(). #; # quantum state number helper functions; #; [docs]def state_number_enumerate(dims, excitations=None, state=None, idx=0):; """"""; An iterator ",MatchSource.WIKI,docs/4.0.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/states.html
https://qutip.org/docs/4.0.2/modules/qutip/states.html:28428,Deployability,update,updated,28428,"00':; Bell_state = tensor(; basis(2), basis(2))+tensor(basis(2, 1), basis(2, 1)); elif state == '01':; Bell_state = tensor(; basis(2), basis(2))-tensor(basis(2, 1), basis(2, 1)); elif state == '10':; Bell_state = tensor(; basis(2), basis(2, 1))+tensor(basis(2, 1), basis(2)); elif state == '11':; Bell_state = tensor(; basis(2), basis(2, 1))-tensor(basis(2, 1), basis(2)). return Bell_state.unit(). [docs]def singlet_state():; """"""; Returns the two particle singlet-state:. |S>=1/sqrt(2)*[|0>|1>-|1>|0>]. that is identical to the fourth bell state. Returns; -------; Bell_state : qobj; |B11> Bell state. """"""; return bell_state('11'). def triplet_states():; """"""; Returns the two particle triplet-states:. |T>= |1>|1>; = 1 / sqrt(2)*[|0>|1>-|1>|0>]; = |0>|0>; that is identical to the fourth bell state. Returns; -------; trip_states : list; 2 particle triplet states. """"""; trip_states = []; trip_states.append(tensor(basis(2, 1), basis(2, 1))); trip_states.append(; (tensor(basis(2), basis(2, 1)) + tensor(basis(2, 1), basis(2))).unit(); ); trip_states.append(tensor(basis(2), basis(2))); return trip_states. def w_state(N=3):; """"""; Returns the N-qubit W-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; W : qobj; N-qubit W-state. """"""; inds = np.zeros(N, dtype=int); inds[0] = 1; state = tensor([basis(2, x) for x in inds]); for kk in range(1, N):; perm_inds = np.roll(inds, kk); state += tensor([basis(2, x) for x in perm_inds]); return state.unit(). [docs]def ghz_state(N=3):; """"""; Returns the N-qubit GHZ-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; G : qobj; N-qubit GHZ-state. """"""; state = (tensor([basis(2) for k in range(N)]) +; tensor([basis(2, 1) for k in range(N)])); return state/np.sqrt(2). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/states.html
https://qutip.org/docs/4.0.2/modules/qutip/states.html:10810,Testability,log,log,10810," state density matrix. Examples; --------; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; -----; The 'operator' method (default) generates; the thermal state using the truncated number operator ``num(N)``. This; is the method that should be used in computations. The; 'analytic' method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. """"""; if n == 0:; return fock_dm(N, 0); else:; i = arange(N); if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); diags = diags / np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; # populates diagonal terms using analytic values; rm = sp.spdiags((1.0 + n) ** (-1.0) * (n / (1.0 + n)) ** (i),; 0, N, N, format='csr'); else:; raise ValueError(; ""'method' keyword argument must be 'operator' or 'analytic'""); return Qobj(rm). [docs]def maximally_mixed_dm(N):; """"""; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters; ----------; N : int; Number of basis states in Hilbert space. Returns; -------; dm : qobj; Thermal state density matrix.; """"""; if (not isinstance(N, (int, np.int64))) or N <= 0:; raise ValueError(""N must be integer N > 0""). dm = sp.spdiags(np.ones(N, dtype=complex)/float(N), 0, N, N, format='csr'). return Qobj(dm, isherm=True). [docs]def ket2dm(Q):; """"""Takes input ket or bra vector and returns density matrix;",MatchSource.WIKI,docs/4.0.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/states.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:20784,Availability,error,error,20784,"mres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_st",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:20805,Availability,toler,tolerance,20805,"mres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_st",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:20976,Availability,error,error,20976,"bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:21001,Availability,error,error,21001,"bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:35151,Availability,avail,available,35151,"r the Liouvillian; superoperator L.; ; w : double; frequency at which to evaluate pseudo-inverse. Can be zero for dense systems; and large sparse systems. Small sparse systems can fail for zero frequencies. sparse : bool; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : string; Name of method to use. For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L.; ; Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in nanostructures""; C. Flindt, PhD Thesis available online:; http://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/file_4732600/content; ; Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto ; the subspace defined by the projector Q.; ; """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); if 'method' not in kwargs.keys():; pseudo_args['method']='splu'; ; # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'; ; if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L,rhoss, w=w, **pseudo_args); else:; pseudo_args['method'] = pseudo_args['method'] if pseudo_args['method'] != 'splu' else 'direct'; return _p",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:36319,Deployability,update,updated,36319,"o use sparse or dense matrix methods when; computing the pseudo inverse. method : string; Name of method to use. For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L.; ; Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in nanostructures""; C. Flindt, PhD Thesis available online:; http://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/file_4732600/content; ; Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto ; the subspace defined by the projector Q.; ; """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); if 'method' not in kwargs.keys():; pseudo_args['method']='splu'; ; # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'; ; if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L,rhoss, w=w, **pseudo_args); else:; pseudo_args['method'] = pseudo_args['method'] if pseudo_args['method'] != 'splu' else 'direct'; return _pseudo_inverse_dense(L, rhoss, w=w, **pseudo_args). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:4988,Energy Efficiency,power,power,4988,"'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:4998,Energy Efficiency,power,power-gmres,4998,"'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:5013,Energy Efficiency,power,power-lgmres,5013,"'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:5029,Energy Efficiency,power,power-bicgstab,5029,"'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:5338,Energy Efficiency,power,power,5338,": 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a ",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:5352,Energy Efficiency,power,power,5352,": 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a ",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:5375,Energy Efficiency,power,power,5375,"=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:5390,Energy Efficiency,power,power-gmres,5390,"=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:5405,Energy Efficiency,power,power-lgmres,5405,"=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:5421,Energy Efficiency,power,power-bicgstab,5421,"=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:7981,Energy Efficiency,reduce,reduced,7981," False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, optional, default = 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; ; """"""; ss_args = _default_steadystate_args(); for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NAT",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:9955,Energy Efficiency,power,power,9955," passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['info']['weight']; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:9964,Energy Efficiency,power,power-gmres,9964," passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['info']['weight']; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:9980,Energy Efficiency,power,power-lgmres,9980," passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['info']['weight']; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:9996,Energy Efficiency,power,power-bicgstab,9996," passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['info']['weight']; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:22284,Energy Efficiency,power,power,22284,"a, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm'",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:23993,Energy Efficiency,power,power,23993,"rm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Precondition",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:24136,Energy Efficiency,power,power,24136,"L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start ",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:24440,Energy Efficiency,power,power,24440,"_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' ",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:24804,Energy Efficiency,power,power-gmres,24804,"%i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:24821,Energy Efficiency,power,power-lgmres,24821,"%i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:24837,Energy Efficiency,power,power-bicgstab,24837,"%i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:25187,Energy Efficiency,power,power,25187,"s['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, che",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:25741,Energy Efficiency,power,power,25741,"ng; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:25794,Energy Efficiency,power,power-gmres,25794,"iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:25984,Energy Efficiency,power,power-lgmres,25984,"iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:26148,Energy Efficiency,power,power-bicgstab,26148,"iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:26413,Energy Efficiency,power,power,26413," and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data), rhoss.shape[0], rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. [docs]def build_preconditioner(A, c_op_list=[], **kwargs):; """"""Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the ite",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:28503,Energy Efficiency,power,power,28503,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'.; ; permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the d",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:28532,Energy Efficiency,power,power,28532,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'.; ; permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the d",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:29163,Energy Efficiency,reduce,reduced,29163,"near solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'.; ; permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:30710,Energy Efficiency,power,power,30710,"ed users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. L = _steadystate_setup(A, c_op_list); # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(L.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. n = int(np.sqrt(L.shape[0])); if ss_args['method'] == 'iterative':; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); elif ss_args['method'] == 'power':; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ss_args); else:; raise Exception(""Invalid preconditioning method.""); ; M, ss_args = _iterative_precondition(L, n, ss_args). if ss_args['return_info']:; return M, ss_args['info']; else:; return M. def _pseudo_inverse_dense(L, rhoss, w=None, **pseudo_args):; """"""; Internal function for computing the pseudo inverse of an Liouvillian using; dense matrix methods. See pseudo_inverse for details.; """"""; rho_vec = np.transpose(mat2vec(rhoss.full())). tr_mat = tensor([identity(n) for n in L.dims[0][0]]); tr_vec = np.transpose(mat2vec(tr_mat.full())); N = np.prod(L.dims[0][0]); I = np.identity(N * N); P = np.kron(np.transpose(rho_vec), tr_vec); Q = I - P; ; if w is None:; L = L; else:; L = 1.0j*w*spre(tr_mat)+L; ; if pseudo_args['method'] == 'direct':; try:; LIQ = np.linalg.solve(L.full(), Q); except:; LIQ = np.linalg.lstsq(L.full(), Q)[0]; ; R = np.dot(Q, LIQ); ; return Qobj(R, dims=L.dims). elif pseudo_args['meth",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:12502,Integrability,message,message,12502,"m'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _dire",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:12581,Integrability,message,message,12581,"th(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_arg",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:6624,Performance,perform,perform,6624,"ow it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. permc_spec : str, optional, default='COLAMD'; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, op",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:25644,Security,access,accessible,25644," v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time']",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:3275,Testability,log,logger,3275,"'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape, ; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None, 'iterations': None,; 'residual_norm': None, 'rcm_time': None, 'wbm_time': None,; 'iter_time': None, 'precond_time': None, 'ILU_MILU': None,; 'fill_factor': None, 'diag_pivot_thresh': None, ; 'drop_tol': None, 'permc_spec': None, 'weight': None}; ; return def_info. def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 's",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:3318,Testability,log,logger,3318,"udo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape, ; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None, 'iterations': None,; 'residual_norm': None, 'rcm_time': None, 'wbm_time': None,; 'iter_time': None, 'precond_time': None, 'ILU_MILU': None,; 'fill_factor': None, 'diag_pivot_thresh': None, ; 'drop_tol': None, 'permc_spec': None, 'weight': None}; ; return def_info. def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info':",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:3456,Testability,test,test,3456," scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape, ; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None, 'iterations': None,; 'residual_norm': None, 'rcm_time': None, 'wbm_time': None,; 'iter_time': None, 'precond_time': None, 'ILU_MILU': None,; 'fill_factor': None, 'diag_pivot_thresh': None, ; 'drop_tol': None, 'permc_spec': None, 'weight': None}; ; return def_info. def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to t",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:11150,Testability,log,logger,11150,"). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; log",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:11213,Testability,log,logger,11213," check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction facto",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:11308,Testability,log,logger,11308,"or('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sor",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:11642,Testability,log,logger,11642,"villian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadyst",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:11732,Testability,log,logger,11732,"e[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:12117,Testability,log,logger,12117,"g:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:12163,Testability,log,logger,12163,"]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:12235,Testability,log,logger,12235,"cm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:12811,Testability,log,logger,12811,"me.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; i",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:14058,Testability,log,logger,14058,"= _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']) and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) !=0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dim",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:14114,Testability,log,logger,14114,"args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']) and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) !=0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.sh",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:15008,Testability,log,logger,15008,"tor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) !=0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:15823,Testability,log,logger,15823,"ims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); ",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:16015,Testability,log,logger,16015,".debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_arg",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:16217,Testability,log,logger,16217,"eight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time();",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:16263,Testability,log,logger,16263,"se_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:17130,Testability,log,logger,17130," = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:17936,Testability,log,logger,17936,":; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s s",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:17980,Testability,log,logger,17980,"ition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:18354,Testability,log,logger,18354,"gs['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precond",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:18410,Testability,log,logger,18410,"_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:18467,Testability,log,logger,18467," ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; Use",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:18909,Testability,log,logger,18909,"nfo']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). # Select iterative solver type; _iter_start = time.time(); if ss_args['method'] == 'iterative-gmres':; v, check = gmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count). elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:20614,Testability,log,logger,20614,"gs['tol'], M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count). elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrice",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:20675,Testability,log,logger,20675,"['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count). elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0])",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:21513,Testability,log,logger,21513," if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='cs",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:22629,Testability,log,logger,22629,"), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; ne",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:22680,Testability,log,logger,22680,"s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:22774,Testability,log,logger,22774,"d_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); lo",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:23136,Testability,log,logger,23136,"lse:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debu",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:23182,Testability,log,logger,23182,"n rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:23271,Testability,log,logger,23271,"ouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:23656,Testability,log,logger,23656,"]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = n",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:23702,Testability,log,logger,23702,".debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.i",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:23772,Testability,log,logger,23772,"e_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is No",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:23815,Testability,log,logger,23815,"Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:24095,Testability,log,logger,24095,"dwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['it",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:25459,Testability,log,logger,25459,"; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if i",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:25515,Testability,log,logger,25515,"m2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Fa",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html:26781,Testability,log,logger,26781,"'method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data), rhoss.shape[0], rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. [docs]def build_preconditioner(A, c_op_list=[], **kwargs):; """"""Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the 'steadystate' function. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthil",MatchSource.WIKI,docs/4.0.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:5193,Availability,toler,tolerance,5193,"----. H : :class:`qutip.Qobj`; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; List of deterministic collapse operators. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of :class:`qutip.Qobj`; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict / list; List of dictionary of additional problem-specific parameters.; Implicit methods can adjust tolerance via args = {'tol':value}. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. d1 : function; Function for calculating the operator-valued coefficient to the; deterministic increment dt. d2 : function; Function for calculating the operator-valued coefficient to the; stochastic increment(s) dW_n, where n is in [0, d2_len[. d2_len : int (default 1); The number of stochastic increments in the process. dW_factors : array; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : func",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:6901,Availability,toler,tolerance,6901,"ial equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are: ; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more ; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15', ; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : :class:`qutip.solver.Options`; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:17024,Availability,avail,available,17024,"A_ops_Euler. elif sso.solver == 'fast-milstein':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_single_fast; elif len(sc_ops) == 2:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast. elif sso.method == 'heterodyne':; sso.d2_len = 1; sso.sc_ops = []; for sc in iter(sc_ops):; sso.sc_ops += [sc / np.sqrt(2), -1.0j * sc / np.sqrt(2)]; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast; ; elif sso.solver == 'taylor15':; sso.generate_A_ops = _generate_A_ops_simple; sso.generate_noise = _generate_noise_Taylor_15; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noi",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:17436,Availability,avail,available,17436,"eterodyne':; sso.d2_len = 1; sso.sc_ops = []; for sc in iter(sc_ops):; sso.sc_ops += [sc / np.sqrt(2), -1.0j * sc / np.sqrt(2)]; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast; ; elif sso.solver == 'taylor15':; sso.generate_A_ops = _generate_A_ops_simple; sso.generate_noise = _generate_noise_Taylor_15; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:17852,Availability,avail,available,17852,"d is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:18252,Availability,avail,available,18252,"None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operato",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:23013,Availability,error,error,23013,"tore), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([ket2dm(data.states[mm][n]); for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssesolve_single_trajectory(n, sso):; """"""; Internal function. See ssesolve.; """"""; dt = sso.dt; times = sso.times; d1, d2 = sso.d1, sso.d2; d2_len = sso.d2_len; e_ops = sso.e_ops; H_data = sso.H.data; A_ops = sso.A_ops. expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex). psi_t = sso.state0.full().ravel(); dims = sso.state0.dims. # reseed the random number generator so that forked; # processes do not get the same sequence of random numbers; np.random.seed((n+1) * np.random.randint(0, 4294967295 // (sso.ntraj+1))). if sso.noise is None:; if sso.homogeneous:; if sso.distribution == 'normal':; dW = np.sqrt(dt) * \; np.random.randn(len(A_ops), sso",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:27639,Availability,error,error,27639,"ations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _smesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[mm][n] for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _smesolve_single_trajectory(n, sso):; """"""; Internal function. See smesolve.; """"""; dt = sso.dt; times = sso.times; d1, d2 = sso.d1, sso.d2; d2_len = sso.d2_len; L_data = sso.L.data; N_substeps = sso.N_substeps; N_store = sso.N_store; A_ops = sso.A_ops. rho_t = mat2vec(sso.state0.full()).ravel(); dims = sso.state0.dims. expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex). # reseed the random number generator so that forked; # processes do not get the same sequence of random numbers; np.random.seed((n+1) * np.random.randint(0, 4294967295 // (sso.ntraj+1))). if sso.noise is None:; if sso.generate_noise:; dW = sso.generate_noise(len(A_ops), N_stor",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:31773,Availability,error,error,31773," data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssepdpsolve_single_trajectory(data, Heff, dt, times, N_store, N_substeps,; psi_t, dims, c_ops, e_ops):; """"""; Internal function. See ssepdpsolve.; """"""; states_list = []. phi_t = np.copy(psi_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []; jump_op_idx = []. for t_idx, t in enumerate(times):. if e_ops:; for e_idx, e in enumerate(e_ops):; s = cy_expect_psi_csr(; e.data.data, e.data.indices, e.data.indptr, psi_t, 0); data.expect[e_idx, t_idx] += s; data.ss[e_idx, t_idx] += s ** 2; else:; states_list.append(Qobj(psi_t, dims=dims)). for j in range(N_substeps):. if norm(phi_t) ** 2 < r_jump:; # jump occurs; p = np.array([norm(c.data * psi_t) ** 2 for c in c_ops]); p = np.cumsum(p / ",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:34985,Availability,error,error,34985," / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / sso.ntraj. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. return data. def _smepdpsolve_single_trajectory(data, L, dt, times, N_store, N_substeps,; rho_t, dims, c_ops, e_ops):; """"""; Internal function. See smepdpsolve.; """"""; states_list = []. rho_t = np.copy(rho_t); sigma_t = np.copy(rho_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []; jump_op_idx = []. for t_idx, t in enumerate(times):. if e_ops:; for e_idx, e in enumerate(e_ops):; data.expect[e_idx, t_idx] += expect_rho_vec(e, rho_t); else:; states_list.append(Qobj(vec2mat(rho_t), dims=dims)). for j in range(N_substeps):. if sigma_t.norm() < r_jump:; # jump occurs; p = np.array([expect(c.dag() * c, rho_t) for c in c_ops]); p = np.cumsum(p / np.sum(p)); n = np.where(p >= r_op)[0][0]. # apply jump; rho_t = c_ops[n] * rho_t * c_ops[n].dag(); rho_t /= expect(c_ops[n].dag() * c_ops[n], rho_t); sigma_t = np.copy(rho_t). # store info about jump; jump_times.appe",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:21685,Deployability,integrat,integration,21685,"n of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **m",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:22389,Deployability,update,update,22389,"n enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([ket2dm(data.states[mm][n]); for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssesolve_single_trajectory(n, sso):; """"""; Internal function. See ssesolve.; """"""; dt = sso.dt; time",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:27024,Deployability,update,update,27024,"re = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _smesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[mm][n] for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _smesolve_single_trajectory(n, sso):; """"""; Internal function. See smesolve.; """"""; dt = sso.dt; times = sso.t",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:31189,Deployability,update,update,31189,", t_idx, :, dW_idx].sum() / (dt * N_substeps). if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic SE PDP solver; #; def _ssepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See ssepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssepdpsolve_single_trajectory(data, Heff, dt, times, N_store, N_substeps,; psi_t, dims, c_ops, e_ops):; """"""; Internal function. See ssepdpsolve.",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:34392,Deployability,update,update,34392,"hi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / sso.ntraj. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. return data. def _smepdpsolve_single_trajectory(data, L, dt, times, N_store, N_substeps,; rho_t, dims, c_ops, e_ops):; """"""; Internal function. See smepdpsolve.; """"""; states_list = []. rho_t = np.copy(rho_t); sigma_t = np.copy(rho_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:47151,Deployability,update,update,47151,"1_rho_heterodyne(t, rho_vec, A, args):; """"""; Need to cythonize, docstrings; """"""; return spmv(A[7], rho_vec). def d2_rho_heterodyne(t, rho_vec, A, args):; """"""; Need to cythonize, docstrings; """"""; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d1 = spmv(M, rho_vec) - e1 * rho_vec; M = A[0] - A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d2 = spmv(M, rho_vec) - e1 * rho_vec; return [1.0 / np.sqrt(2) * d1, -1.0j / np.sqrt(2) * d2]. def d1_rho_photocurrent(t, rho_vec, A, args):; """"""; Need to cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; n_sum = A[4] + A[5]; e1 = cy_expect_rho_vec(n_sum, rho_vec, 0); return 0.5 * (e1 * rho_vec - spmv(n_sum, rho_vec)). def d2_rho_photocurrent(t, rho_vec, A, args):; """"""; Need to cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; e1 = cy_expect_rho_vec(A[6], rho_vec, 0); if e1.real > 1e-15:; return [spmv(A[6], rho_vec) / e1 - rho_vec]; else:; return [-rho_vec]. # -----------------------------------------------------------------------------; # Deterministic part of the rho/psi update functions. TODO: Make these; # compatible with qutip's time-dependent hamiltonian and collapse operators; #; def _rhs_psi_deterministic(H, psi_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; dpsi_t = (-1.0j * dt) * (H * psi_t). return dpsi_t. def _rhs_rho_deterministic(L, rho_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; drho_t = spmv(L, rho_t) * dt. return drho_t. # -----------------------------------------------------------------------------; # Euler-Maruyama rhs functions for the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:49530,Deployability,update,updated,49530,"([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return rho_t + drho_t. def _rhs_rho_euler_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Fast Euler-Maruyama for homodyne detection.; """""". dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2). drho_t = d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]); drho_t += (1.0 - np.inner(np.real(e), dW)) * rho_t; return drho_t. # -----------------------------------------------------------------------------; # Platen method; #; def _rhs_psi_platen(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; TODO: support multiple stochastic increments. .. note::. Experimental. """""". sqrt_dt = np.sqrt(dt). dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * sqrt_dt); psi_t_m = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt -; d2(A, psi_t)[0] * sqrt_dt). dpsi_t += (; 0.50 * (d1(A, psi_t_1) + d1(A, psi_t)) * dt +; 0.25 * (d2(A, psi_t_p)[0] + d2(A, psi_t_m)[0] +; 2 * d2(A, psi_t)[0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = sp",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:58021,Deployability,update,updated,58021,"[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:9672,Integrability,depend,depending,9672,"lf.state0 = state0; self.times = times; self.c_ops = c_ops; self.sc_ops = sc_ops; self.e_ops = e_ops. if m_ops is None:; self.m_ops = [[c for _ in range(d2_len)] for c in sc_ops]; else:; self.m_ops = m_ops. self.ntraj = ntraj; self.nsubsteps = nsubsteps; self.solver = solver; self.method = method; self.distribution = distribution; self.homogeneous = homogeneous; self.rhs = rhs; self.options = options; self.progress_bar = progress_bar; self.store_measurement = store_measurement; self.store_states = options.store_states; self.noise = noise; self.args = args; self.normalize = normalize. self.generate_noise = generate_noise; self.generate_A_ops = generate_A_ops. if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map. self.map_kwargs = map_kwargs if map_kwargs is not None else {}. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, **kwargs):; """"""; Solve the stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`; An instance of the class :class:`qutip.solver.SolverResult`.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). if _safe_mode:; _solver_safety_check(H, psi0, sc_ops, e_ops); ; if isinstance(e_ops, dict):; e_ops_di",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:12602,Integrability,depend,depending,12602,"e(sso.sc_ops)]. elif sso.method == 'photocurrent':; sso.d1 = d1_psi_photocurrent; sso.d2 = d2_psi_photocurrent; sso.d2_len = 1; sso.homogeneous = False; sso.distribution = 'poisson'. if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([1]); if ""m_ops"" not in kwargs:; sso.m_ops = [[None] for c in sso.sc_ops]. else:; raise Exception(""Unrecognized method '%s'."" % sso.method). if sso.distribution == 'poisson':; sso.homogeneous = False. if sso.solver == 'euler-maruyama' or sso.solver is None:; sso.rhs = _rhs_psi_euler_maruyama. elif sso.solver == 'platen':; sso.rhs = _rhs_psi_platen. else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _ssesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], ; _safe_mode=True ,**kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:21685,Integrability,integrat,integration,21685,"n of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **m",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:47218,Integrability,depend,dependent,47218,"rings; """"""; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d1 = spmv(M, rho_vec) - e1 * rho_vec; M = A[0] - A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d2 = spmv(M, rho_vec) - e1 * rho_vec; return [1.0 / np.sqrt(2) * d1, -1.0j / np.sqrt(2) * d2]. def d1_rho_photocurrent(t, rho_vec, A, args):; """"""; Need to cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; n_sum = A[4] + A[5]; e1 = cy_expect_rho_vec(n_sum, rho_vec, 0); return 0.5 * (e1 * rho_vec - spmv(n_sum, rho_vec)). def d2_rho_photocurrent(t, rho_vec, A, args):; """"""; Need to cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; e1 = cy_expect_rho_vec(A[6], rho_vec, 0); if e1.real > 1e-15:; return [spmv(A[6], rho_vec) / e1 - rho_vec]; else:; return [-rho_vec]. # -----------------------------------------------------------------------------; # Deterministic part of the rho/psi update functions. TODO: Make these; # compatible with qutip's time-dependent hamiltonian and collapse operators; #; def _rhs_psi_deterministic(H, psi_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; dpsi_t = (-1.0j * dt) * (H * psi_t). return dpsi_t. def _rhs_rho_deterministic(L, rho_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; drho_t = spmv(L, rho_t) * dt. return drho_t. # -----------------------------------------------------------------------------; # Euler-Maruyama rhs functions for the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return psi_t + dpsi_t. def _rhs_rho_euler_maruyama(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """,MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:21530,Modifiability,parameteriz,parameterized,21530,"n of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **m",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:25824,Modifiability,parameteriz,parameterized,25824,"ops):; # dw_expect = norm(spmv(A[0], psi_t)) ** 2 * dt; dw_expect = cy_expect_psi_csr(A[3].data,; A[3].indices,; A[3].indptr, psi_t, 1) * dt; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len). psi_t = sso.rhs(H_data, psi_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). # optionally renormalize the wave function; if sso.normalize:; psi_t /= norm(psi_t). if sso.store_measurement:; for m_idx, m in enumerate(sso.m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_data = m[dW_idx].data; m_expt = cy_expect_psi_csr(m_data.data,; m_data.indices,; m_data.indptr,; psi_t, 0); else:; m_expt = 0; mm = (m_expt + dW_factor *; dW[m_idx, t_idx, :, dW_idx].sum() /; (dt * sso.N_substeps)); measurements[t_idx, m_idx, dW_idx] = mm. if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic master equation solver; #; def _smesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else N",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:30452,Modifiability,parameteriz,parameterized,30452,"d(Qobj(vec2mat(rho_t), dims=dims)). rho_prev = np.copy(rho_t). for j in range(N_substeps):. if sso.noise is None and not sso.homogeneous:; for a_idx, A in enumerate(A_ops):; dw_expect = cy_expect_rho_vec(A[4], rho_t, 1) * dt; if dw_expect > 0:; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len); else:; dW[a_idx, t_idx, j, :] = np.zeros(d2_len). rho_t = sso.rhs(L_data, rho_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). if sso.store_measurement:; for m_idx, m in enumerate(sso.s_m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_expt = cy_expect_rho_vec(m[dW_idx].data, rho_prev, 0); else:; m_expt = 0; measurements[t_idx, m_idx, dW_idx] = m_expt + dW_factor * \; dW[m_idx, t_idx, :, dW_idx].sum() / (dt * N_substeps). if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic SE PDP solver; #; def _ssepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See ssepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:33711,Modifiability,parameteriz,parameterized,33711,"ata * psi_t) ** 2 for c in c_ops]); p = np.cumsum(p / np.sum(p)); n = np.where(p >= r_op)[0][0]. # apply jump; psi_t = c_ops[n].data * psi_t; psi_t /= norm(psi_t); phi_t = np.copy(psi_t). # store info about jump; jump_times.append(times[t_idx] + dt * j); jump_op_idx.append(n). # get new random numbers for next jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dphi_t = (-1.0j * dt) * (Heff.data * phi_t). # deterministic evolution with correction for norm decay; dpsi_t = (-1.0j * dt) * (Heff.data * psi_t); A = 0.5 * np.sum([norm(c.data * psi_t) ** 2 for c in c_ops]); dpsi_t += dt * A * psi_t. # increment wavefunctions; phi_t += dphi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progres",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:2347,Performance,optimiz,optimizing,2347,"ARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code were contributed by Denis Vasilyev.; #; ###############################################################################; """"""; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options, _solver_safety_check; from qutip.settings import debug. if debug:; import qutip.logging_utils; im",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:2374,Performance,perform,performance,2374,"ARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code were contributed by Denis Vasilyev.; #; ###############################################################################; """"""; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options, _solver_safety_check; from qutip.settings import debug. if debug:; import qutip.logging_utils; im",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:51086,Performance,optimiz,optimizations,51086,"urn dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t); for n in range(A_len)]). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is subopti",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:6601,Safety,predict,predictor-corrector,6601,"ay; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are: ; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more ; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15', ; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function ",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:37108,Safety,avoid,avoid,37108,"jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dsigma_t = spmv(L.data, sigma_t) * dt. # deterministic evolution with correction for norm decay; drho_t = spmv(L.data, rho_t) * dt. rho_t += drho_t. # increment density matrices; sigma_t += dsigma_t; rho_t += drho_t. return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Helper-functions for stochastic DE; #; # d1 = deterministic part of the contribution to the DE RHS function, to be; # multiplied by the increament dt; #; # d1 = stochastic part of the contribution to the DE RHS function, to be; # multiplied by the increament dW; #. #; # For SSE; #. # Function sigurature:; #; # def d(A, psi):; #; # psi = wave function at the current time step; #; # A[0] = c; # A[1] = c + c.dag(); # A[2] = c - c.dag(); # A[3] = c.dag() * c; #; # where c is a collapse operator. The combinations of c's stored in A are; # precomputed before the time-evolution is started to avoid repeated; # computations. def _generate_psi_A_ops(sc_ops, H):; """"""; pre-compute superoperator operator combinations that are commonly needed; when evaluating the RHS of stochastic schrodinger equations; """""". A_ops = []; for c_idx, c in enumerate(sc_ops):; A_ops.append([c.data,; (c + c.dag()).data,; (c - c.dag()).data,; (c.dag() * c).data]). return A_ops. def d1_psi_homodyne(t, psi, A, args):; """"""; OK; Need to cythonize. .. math::. D_1(C, \psi) = \\frac{1}{2}(\\langle C + C^\\dagger\\rangle\\C psi -; C^\\dagger C\\psi - \\frac{1}{4}\\langle C + C^\\dagger\\rangle^2\\psi). """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return 0.5 * (e1 * spmv(A[0], psi) -; spmv(A[3], psi) -; 0.25 * e1 ** 2 * psi). def d2_psi_homodyne(t, psi, A, args):; """"""; OK; Need to cythonize. .. math::. D_2(\psi, t) = (C - \\frac{1}{2}\\langle C + C^\\dagger\\rangle)\\psi. """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); retur",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:48768,Safety,detect,detection,48768,"r the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return psi_t + dpsi_t. def _rhs_rho_euler_maruyama(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for density matrix solver.; """"""; dW_len = len(dW[0, :]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, rho_t, A, args); drho_t += d1(t, rho_t, A, args) * dt; drho_t += np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return rho_t + drho_t. def _rhs_rho_euler_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Fast Euler-Maruyama for homodyne detection.; """""". dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2). drho_t = d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]); drho_t += (1.0 - np.inner(np.real(e), dW)) * rho_t; return drho_t. # -----------------------------------------------------------------------------; # Platen method; #; def _rhs_psi_platen(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; TODO: support multiple stochastic increments. .. note::. Experimental. """""". sqrt_dt = np.sqrt(dt). dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:50403,Safety,detect,detection,50403," # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * sqrt_dt); psi_t_m = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt -; d2(A, psi_t)[0] * sqrt_dt). dpsi_t += (; 0.50 * (d1(A, psi_t_1) + d1(A, psi_t)) * dt +; 0.25 * (d2(A, psi_t_p)[0] + d2(A, psi_t_m)[0] +; 2 * d2(A, psi_t)[0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t)",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:51000,Safety,detect,detection,51000,"0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t); for n in range(A_len)]). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * ",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:52530,Safety,detect,detection,52530,"n case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homod",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:53016,Safety,detect,detection,53016,".0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:53579,Safety,detect,detection,53579,"chastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * r",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:54379,Safety,detect,detection,54379,"2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = a * dt; drho_t += b * dW[0]; drho_t += Lb * dW[1] # Milstein term. # new terms: ; drho_t += A[-1] * b * dW[2]; drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]; drho_t += A[-1] * a * (0.5 * dt*dt); drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4] ; ; return rho_t + drho_t. #include _rhs_rho_Taylor_15_two#. def _rhs_rho_milstein_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Milstein (theta = 1/2, eta = 0); Wang, X., Gan, S., & Wang, D. (2012). ; A family of fully implicit Milstein methods for stiff stochastic differential ; equations with multiplicative noise. ; BIT Numerical Mathema",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:56544,Safety,predict,prediction,56544,"* rho_t * (0.5 * dt); e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1). drho_t = b * dW[0] ; drho_t += a; drho_t += (A[0] * b - TrAb * rho_t - e0 * b) * dW[1] # Milstein term; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = drho_t + a, tol=args['tol']). return v; ; def _rhs_rho_taylor_15_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Taylor 1.5 (alpha = 1/2, beta = doesn't matter); Chaptert 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pre",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:56975,Safety,predict,predictor-corrector,56975,"t 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchf",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:57015,Safety,detect,detection,57015,"t 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchf",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:57077,Safety,predict,predictor,57077,"t 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchf",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:3343,Testability,log,logger,3343,"ork more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options, _solver_safety_check; from qutip.settings import debug. if debug:; import qutip.logging_utils; import inspect; logger = qutip.logging_utils.get_logger(). [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc.; Options can be specified either as arguments to the constructor::. sso = StochasticSolverOptions(nsubsteps=100, ...). or by changing the class attributes after creation::. sso = StochasticSolverOptions(); sso.nsubsteps = 1000. The stochastic solvers :func:`qutip.stochastic.ssesolve`,; :func:`qutip.stochastic.smesolve`, :func:`qutip.stochastic.ssepdpsolve` and; :func:`qutip.stochastic.smepdpsolve` all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Attributes; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:10547,Testability,log,logger,10547,"s, sc_ops=[], e_ops=[], _safe_mode=True, **kwargs):; """"""; Solve the stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`; An instance of the class :class:`qutip.solver.SolverResult`.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). if _safe_mode:; _solver_safety_check(H, psi0, sc_ops, e_ops); ; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops, **kwargs). if sso.generate_A_ops is None:; sso.generate_A_ops = _generate_psi_A_ops. if (sso.d1 is None) or (sso.d2 is None):. if sso.method == 'homodyne':; sso.d1 = d1_psi_homodyne; sso.d2 = d2_psi_homodyne; sso.d2_len = 1; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([1]); if ""m_ops"" not in kwargs:; sso.m_ops = [[c + c.dag()] for c in sso.sc_ops]. elif sso.method == 'heterodyne':; sso.d1 = d1_psi_heterodyne; sso.d2 = d2_psi_heterodyne; sso.d2_len = 2; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(2), np.sqrt(2)]); if ""m_ops"" not in kwargs:; sso",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:13732,Testability,log,logger,13732,"ho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. TODO; ----; Add checks for commuting jump operators in Milstein method.; """""". if debug:; logger.debug(inspect.stack()[0][3]). if isket(rho0):; rho0 = ket2dm(rho0). if _safe_mode:; _solver_safety_check(H, rho0, c_ops+sc_ops, e_ops); ; ; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; sc_ops=sc_ops, e_ops=e_ops, **kwargs). if (sso.d1 is None) or (sso.d2 is None):. if sso.method == 'homodyne' or sso.method is None:; sso.d1 = d1_rho_homodyne; sso.d2 = d2_rho_homodyne; sso.d2_len = 1; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(1)]); if ""m_ops"" not in kwargs:; sso.m_ops = [[c + c.dag()] for c in sso.sc_ops]. elif sso.method == 'heterodyne':; sso.d1 = d1_rho_heterodyne; sso.d2 = d2_rho_heterodyne; sso.d2_len = 2; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(2), np.sqrt(2)]); if ""m_ops"" not in",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:19474,Testability,log,logger,19474,"ict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=psi0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _ssepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each s",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:21024,Testability,log,logger,21024,"density matrix; evolution. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_s",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:21733,Testability,log,logger,21733,"erators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m);",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:25983,Testability,log,logger,25983,"* dt; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len). psi_t = sso.rhs(H_data, psi_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). # optionally renormalize the wave function; if sso.normalize:; psi_t /= norm(psi_t). if sso.store_measurement:; for m_idx, m in enumerate(sso.m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_data = m[dW_idx].data; m_expt = cy_expect_psi_csr(m_data.data,; m_data.indices,; m_data.indptr,; psi_t, 0); else:; m_expt = 0; mm = (m_expt + dW_factor *; dW[m_idx, t_idx, :, dW_idx].sum() /; (dt * sso.N_substeps)); measurements[t_idx, m_idx, dW_idx] = mm. if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic master equation solver; #; def _smesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:30607,Testability,log,logger,30607,"s:; for a_idx, A in enumerate(A_ops):; dw_expect = cy_expect_rho_vec(A[4], rho_t, 1) * dt; if dw_expect > 0:; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len); else:; dW[a_idx, t_idx, j, :] = np.zeros(d2_len). rho_t = sso.rhs(L_data, rho_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). if sso.store_measurement:; for m_idx, m in enumerate(sso.s_m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_expt = cy_expect_rho_vec(m[dW_idx].data, rho_prev, 0); else:; m_expt = 0; measurements[t_idx, m_idx, dW_idx] = m_expt + dW_factor * \; dW[m_idx, t_idx, :, dW_idx].sum() / (dt * N_substeps). if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic SE PDP solver; #; def _ssepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See ssepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:33866,Testability,log,logger,33866,"psi_t; psi_t /= norm(psi_t); phi_t = np.copy(psi_t). # store info about jump; jump_times.append(times[t_idx] + dt * j); jump_op_idx.append(n). # get new random numbers for next jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dphi_t = (-1.0j * dt) * (Heff.data * phi_t). # deterministic evolution with correction for norm decay; dpsi_t = (-1.0j * dt) * (Heff.data * psi_t); A = 0.5 * np.sum([norm(c.data * psi_t) ** 2 for c in c_ops]); dpsi_t += dt * A * psi_t. # increment wavefunctions; phi_t += dphi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] ",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html:8000,Usability,progress bar,progress bar,8000,"yne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : :class:`qutip.solver.Options`; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance. """"""; def __init__(self, H=None, state0=None, times=None, c_ops=[], sc_ops=[],; e_ops=[], m_ops=None, args=None, ntraj=1, nsubsteps=1,; d1=None, d2=None, d2_len=1, dW_factors=None, rhs=None,; generate_A_ops=None, generate_noise=None, homogeneous=True,; solver=None, method=None, distribution='normal',; store_measurement=False, noise=None, normalize=True,; options=None, progress_bar=None, map_func=None,; map_kwargs=None):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). self.H = H; self.d1 = d1; self.d2 = d2; self.d2_len = d2_len; self.dW_factors = dW_factors if dW_factors else np.ones(d2_len); self.state0 = state0; self.times = times; self.c_ops = c_ops; self.sc_ops = sc_ops; self.e_ops = e_ops. if m_ops is None:; self.m_ops = [[c for _ in range(d2_len)] for c in sc_ops]; else:; self.m_ops = m_ops. self.ntraj = ntraj; self.nsubsteps = nsubsteps; self.solver = solver; self.method = method; self.distribution ",MatchSource.WIKI,docs/4.0.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.0.2/modules/qutip/superoperator.html:8880,Deployability,update,updated,8880,"ameters; ----------; A : qobj; Quantum operator for post multiplication. Returns; -------; super : qobj; Superoperator formed from input qauntum object.; """"""; if not isinstance(A, Qobj):; raise TypeError('Input is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(A.data.T, ; fast_identity(np.prod(A.shape[0]))); return S. [docs]def spre(A):; """"""Superoperator formed from pre-multiplication by operator A. Parameters; ----------; A : qobj; Quantum operator for pre-multiplication. Returns; --------; super :qobj; Superoperator formed from input quantum object.; """"""; if not isinstance(A, Qobj):; raise TypeError('Input is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(fast_identity(np.prod(A.shape[1])), A.data); return S. def _drop_projected_dims(dims):; """"""; Eliminate subsystems that has been collapsed to only one state due to; a projection.; """"""; return [d for d in dims if d != 1]. [docs]def sprepost(A, B):; """"""Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters; ----------; A : Qobj; Quantum operator for pre-multiplication. B : Qobj; Quantum operator for post-multiplication. Returns; --------; super : Qobj; Superoperator formed from input quantum objects.; """""". dims = [[_drop_projected_dims(A.dims[0]), _drop_projected_dims(B.dims[1])],; [_drop_projected_dims(A.dims[1]), _drop_projected_dims(B.dims[0])]]; data = zcsr_kron(B.data.T, A.data); return Qobj(data, dims=dims, superrep='super'). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superoperator.html
https://qutip.org/docs/4.0.2/modules/qutip/superoperator.html:2713,Safety,avoid,avoids,2713,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : array_like; A ``list`` or ``array`` of collapse operators. Returns; -------; L : qobj; Liouvillian superoperator. """""". if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). if H is not None:; if H.isoper:; op_dims = H.dims; op_shape = H.shape; elif H.issuper:; op_dims = H.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issuper:; op_dims = c.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for collapse operator.""); else:; raise TypeError(""Either H or c_ops must be given.""). sop_dims = [[op_d",MatchSource.WIKI,docs/4.0.2/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superoperator.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:10581,Availability,down,down,10581,"other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), but easier to write down.; Ks = list(map(Qobj, array(U * S).reshape((d, d, dK), order='F').transpose((2, 0, 1)))); for K in Ks:; K.dims = [outdims, indims]; return Ks. def _generalized_kraus(q_oper, thresh=1e-10):; # TODO: document!; # TODO: use this to generalize to_kraus to the case where U != V.; # This is critical for non-CP maps, as appear in (for example); # diamond norm differences between two CP maps.; if q_oper.type != ""super"" or q_oper.superrep != ""choi"":; raise ValueError(""Expected a Choi matrix, got a {} (superrep {})."".format(q_oper.type, q_oper.superrep)); ; # Remember the shape of the underlying space,; # as we'll need this to make Kraus operators later.; dL, dR = map(int, map(sqrt, q_oper.shape)); # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. # Find the SVD.; U, S, V = svd(q_oper.data.todense()). # Truncate away the zero singular values, up to a threshold.; nonzero_idxs = S > thresh; dK = nonzer",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:18339,Availability,error,errors,18339,"{0.type} ""; ""and superrep = {0.superrep} to supermatrix not ""; ""supported."".format(q_oper); ). [docs]def to_kraus(q_oper):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper)); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:18714,Deployability,update,updated,18714,"{0.type} ""; ""and superrep = {0.superrep} to supermatrix not ""; ""supported."".format(q_oper); ). [docs]def to_kraus(q_oper):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper)); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:5853,Energy Efficiency,power,powers,5853,".dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:6057,Energy Efficiency,power,power,6057,"een representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() ",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:8930,Energy Efficiency,power,power,8930,"as a; strict sub-class of Qobj.; """"""; vals, vecs = eig(q_oper.data.todense()); vecs = [array(_) for _ in zip(*vecs)]; return [Qobj(inpt=sqrt(val)*vec2mat(vec)) for val, vec in zip(vals, vecs)]. def kraus_to_choi(kraus_list):; """"""; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: matrix(x.data.todense()), kraus_list)); op_len = len(kraus_mat_list[0]); op_rng = range(op_len); choi_blocks = array([[sum([op[:, c_ix] * array([op.H[r_ix, :]]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, s",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:5504,Integrability,wrap,wrap,5504,"s can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus bre",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:9117,Modifiability,extend,extend,9117,"rators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: matrix(x.data.todense()), kraus_list)); op_len = len(kraus_mat_list[0]); op_rng = range(op_len); choi_blocks = array([[sum([op[:, c_ix] * array([op.H[r_ix, :]]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_o",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:9537,Modifiability,extend,extend,9537,")),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), b",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:2836,Safety,avoid,avoid,2836,"RACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, spre, spost, operator_to_vector; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopef",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:5037,Security,expose,exposed,5037,"., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:12381,Testability,assert,assert,12381,"_dims. # Find the SVD.; U, S, V = svd(q_oper.data.todense()). # Truncate away the zero singular values, up to a threshold.; nonzero_idxs = S > thresh; dK = nonzero_idxs.sum(); U = array(U)[:, nonzero_idxs]; # We also want S to be a single index array, which np.matrix; # doesn't allow for. This is stripped by calling array() on it.; S = sqrt(array(S)[nonzero_idxs]); # Since NumPy returns V and not V+, we need to take the dagger; # to get back to quantum info notation for Stinespring pairs.; V = array(V.conj().T)[:, nonzero_idxs]. # Next, we convert each of U and V into Kraus operators.; # Finally, we want the Kraus index to be left-most so that we; # can map over it when making Qobjs.; # FIXME: does not preserve dims!; kU = _svd_u_to_kraus(U, S, dL, dK, out_right, out_left); kV = _svd_u_to_kraus(V, S, dL, dK, in_right, in_left). return kU, kV. def choi_to_stinespring(q_oper, thresh=1e-10):; # TODO: document!; kU, kV = _generalized_kraus(q_oper, thresh=thresh). assert(len(kU) == len(kV)); dK = len(kU); dL = kU[0].shape[0]; dR = kV[0].shape[1]; # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. A = Qobj(zeros((dK * dL, dL)), dims=[out_left + [dK], out_right + [1]]); B = Qobj(zeros((dK * dR, dR)), dims=[in_left + [dK], in_right + [1]]). for idx_kraus, (KL, KR) in enumerate(zip(kU, kV)):; A += tensor(KL, basis(dK, idx_kraus)); B += tensor(KR, basis(dK, idx_kraus)); ; # There is no input (right) Kraus index, so strip that off.; del A.dims[1][-1]; del B.dims[1][-1]. return A, B. # PUBLIC CONVERSION FUNCTIONS -------------------------------------------------; # These functions handle superoperator conversions in a way that preserves the; # correctness of Qobj.type, and in a way that automatically branches based on; # the input Qobj.type. [docs]def to_choi(q_oper):; """"""; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the returned operator is equal to",MatchSource.WIKI,docs/4.0.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:3709,Availability,error,error,3709,"rs; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]); Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, q2, q3, ...); qlist = args. if not all([isinstance(q, Qobj) for q in qlist]):; # raise error if one of the inputs is not a quantum object; raise TypeError(""One of inputs is not a quantum object""). out = Qobj(). if qlist[0].issuper:; out.superrep = qlist[0].superrep; if not all([q.superrep == out.superrep for q in qlist]):; raise TypeError(""In tensor products of superroperators, all must"" +; ""have the same representation""). out.isherm = True; for n, q in enumerate(qlist):; if n == 0:; out.data = q.data; out.dims = q.dims; else:; out.data = zcsr_kron(out.data, q.data); ; out.dims = [out.dims[0] + q.dims[0], out.dims[1] + q.dims[1]]. out.isherm = out.isherm and q.isherm. if not out.isherm:; out._isherm = None. return out.tidyup() if qutip.settings.auto_tidyup else out. [docs]def super_tensor(*args):; """"""Calculates the tensor product of input superoperators, by tensoring; together the underlying Hilbert spaces on which each vectorized operator; acts. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects with ``type=""super""``. Returns; -------; obj : qobj; A composite qu",MatchSource.WIKI,docs/4.0.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html
https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:11921,Deployability,update,updated,11921,"ng one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html
https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:2629,Integrability,depend,dependency,2629,"OCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Module for the creation of composite quantum objects via the tensor product.; """""". __all__ = [; 'tensor', 'super_tensor', 'composite', 'tensor_swap', 'tensor_contract'; ]. import numpy as np; import scipy.sparse as sp; from qutip.cy.spmath import zcsr_kron; from qutip.qobj import Qobj; from qutip.permute import reshuffle; from qutip.superoperator import operator_to_vector; from qutip.dimensions import (; flatten, enumerate_flat, unflatten, deep_remove,; dims_to_tensor_shape, dims_idxs_to_tensor_idxs; ). import qutip.settings; import qutip.superop_reps # Avoid circular dependency here. [docs]def tensor(*args):; """"""Calculates the tensor product of input operators. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]); Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html
https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:8026,Integrability,contract,contract,8026,"e already type=super, while it will; # promote unitaries to superunitaries.; return super_tensor(*map(qutip.superop_reps.to_super, args)). else:; # Everything's just an oper, so ordinary tensor products work.; return tensor(*args). elif all(map(_isketlike, args)):; # Ket-likes.; if any(arg.isoperket for arg in args):; # We have a vectorized operator, we we may need to promote; # something.; return super_tensor(*(; arg if arg.isoperket; else operator_to_vector(qutip.states.ket2dm(arg)); for arg in args; )). else:; # Everything's ordinary, so we can use the tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); contract_at = i if j == i + 1 else 0; return np.sum(arr[sl], axis=contract_at). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. def tensor_swap(q_oper, *pairs):; """"""Transposes one or more pairs of indices of a Qobj.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; `",MatchSource.WIKI,docs/4.0.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html
https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:8628,Integrability,contract,contraction,8628,"e tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); contract_at = i if j == i + 1 else 0; return np.sum(arr[sl], axis=contract_at). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. def tensor_swap(q_oper, *pairs):; """"""Transposes one or more pairs of indices of a Qobj.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be swapped. Returns; -------. sqobj : Qobj; The original Qobj with all named index pairs swapped with each other; """"""; dims = q_oper.dims; tensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i",MatchSource.WIKI,docs/4.0.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html
https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:10282,Integrability,contract,contracted,10282,"ensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = dee",MatchSource.WIKI,docs/4.0.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html
https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:10371,Integrability,contract,contracted,10371,".reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don'",MatchSource.WIKI,docs/4.0.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html
https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:10850,Integrability,contract,contracting,10850,"d right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyri",MatchSource.WIKI,docs/4.0.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html
https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:10974,Integrability,contract,contracted,10974," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read th",MatchSource.WIKI,docs/4.0.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html
https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html:2366,Deployability,configurat,configuration,2366,"DING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():;",MatchSource.WIKI,docs/4.0.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html:2455,Deployability,configurat,configurations,2455,"PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of",MatchSource.WIKI,docs/4.0.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html:3999,Deployability,update,updated,3999,"s module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from the qutrit code; sig11 = one * one.dag(); sig22 = two * two.dag(); sig33 = three * three.dag(); sig12 = one * two.dag(); sig32 = three * two.dag(); return array([sig11, sig22, sig33, sig12, sig32], dtype=object). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html:2366,Modifiability,config,configuration,2366,"DING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():;",MatchSource.WIKI,docs/4.0.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html:2455,Modifiability,config,configurations,2455,"PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of",MatchSource.WIKI,docs/4.0.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.0.2/modules/qutip/tomography.html:6679,Deployability,update,updated,6679," fig argument). threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if ax is None:; if fig is None:; fig = plt.figure(figsize=figsize); ax = fig.add_subplot(1, 1, 1, projection='3d', position=[0, 0, 1, 1]). xlabels = []; for inds in _index_permutations([len(lbls) for lbls in lbls_list]):; xlabels.append("""".join(; [lbls_list[k][inds[k]] for k in range(len(lbls_list))])). if not title:; title = r""$\chi$"". matrix_histogram_complex(chi, xlabels, xlabels, title=title, ax=ax,; threshold=threshold). return fig, ax. [docs]def qpt(U, op_basis_list):; """"""; Calculate the quantum process tomography chi matrix for a given (possibly; nonunitary) transformation matrix U, which transforms a density matrix in; vector form according to:. vec(rho) = U * vec(rho0). or. rho = vec2mat(U * mat2vec(rho0)). U can be calculated for an open quantum system using the QuTiP propagator; function. Parameters; ----------; U : Qobj; Transformation operator. Can be calculated using QuTiP propagator; function. op_basis_list : list; A list of Qobj's representing the basis states. Returns; -------; chi : array; QPT chi matrix. """""". E_ops = []; # loop over all index permutations; for inds in _index_permutations([len(ops) for ops in op_basis_list]):; # loop over all composite systems; E_op_list = [op_basis_list[k][inds[k]] for k in range(len(; op_basis_list))]; E_ops.append(tensor(E_op_list)). EE_ops = [spre(E1) * spost(E2.dag()) for E1 in E_ops for E2 in E_ops]. M = hstack([mat2vec(EE.full()) for EE in EE_ops]). Uvec = mat2vec(U.full()). chi_vec = la.solve(M, Uvec). return vec2mat(chi_vec). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/tomography.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tomography.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:9986,Deployability,update,updated,9986,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:5429,Energy Efficiency,energy,energy,5429,".min([j2 + j3 + m1, j3 - j1 + j2, j3 + m3])). C = np.sqrt((2.0 * j3 + 1.0) * factorial(j3 + j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : flo",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:5518,Energy Efficiency,energy,energy,5518," j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The en",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:5745,Energy Efficiency,energy,energy,5745," S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in ",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6041,Energy Efficiency,energy,energy,6041,"-----------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Return",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6122,Energy Efficiency,energy,energy,6122,".602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; #",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6196,Energy Efficiency,energy,energy,6196,"_unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_t",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6347,Energy Efficiency,energy,energy,6347,"1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit ",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6428,Energy Efficiency,energy,energy,6428,"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 me",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6502,Energy Efficiency,energy,energy,6502,"-; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """""";",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6640,Energy Efficiency,energy,energy,6640,"he name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit :",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6719,Energy Efficiency,energy,energy,6719,"-; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 m",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6793,Energy Efficiency,energy,energy,6793,"rig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """,MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:6926,Energy Efficiency,energy,energy,6926,"t %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_ne",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7005,Energy Efficiency,energy,energy,7005,"o]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7079,Energy Efficiency,energy,energy,7079,"unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7208,Energy Efficiency,energy,energy,7208," in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7288,Energy Efficiency,energy,energy,7288," * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; ----",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7362,Energy Efficiency,energy,energy,7362,"nergy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz ",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7500,Energy Efficiency,energy,energy,7500,"ay; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters;",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7580,Energy Efficiency,energy,energy,7580,"= w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_prop",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7654,Energy Efficiency,energy,energy,7654,"energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in ",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7794,Energy Efficiency,energy,energy,7794," The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__cla",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7874,Energy Efficiency,energy,energy,7874," w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(p",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:7948,Energy Efficiency,energy,energy,7948,"rom unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = me",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:8159,Energy Efficiency,energy,energy,8159,"return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].sp",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:8239,Energy Efficiency,energy,energy,8239,"eV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:8313,Energy Efficiency,energy,energy,8313,"he old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_lis",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:3916,Modifiability,coupling,coupling,3916,"n 1.0 / (np.exp(w / w_th) - 1.0). else:; if (w_th > 0) and np.exp(w / w_th) != 1.0:; return 1.0 / (np.exp(w / w_th) - 1.0); else:; return 0.0. [docs]def linspace_with(start, stop, num=50, elems=[]):; """"""; Return an array of numbers sampled over specified interval; with additional elements added. Returns `num` spaced array with elements from `elems` inserted; if not already included in set. Returned sample array is not evenly spaced if addtional elements; are added. Parameters; ----------; start : int; The starting value of the sequence.; stop : int; The stoping values of the sequence.; num : int, optional; Number of samples to generate.; elems : list/ndarray, optional; Requested elements to include in array. Returns; -------; samples : ndadrray; Original equally spaced sample array with additional; elements added.; """"""; elems = np.array(elems); lspace = np.linspace(start, stop, num); return np.union1d(lspace, elems). [docs]def clebsch(j1, j2, j3, m1, m2, m3):; """"""Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters; ----------; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns; -------; cg_coeff : float; Requested Clebsch-Gordan coefficient. """"""; if m3 != m1 + m2:; return 0; vmin = int(np.max([-j1 + j2 + m3, -j1 + m1, 0])); vmax = int(np.min([j2 + j3 + m1, j3 - j1 + j2, j3 + m3])). C = np.sqrt((2.0 * j3 + 1.0) * factorial(j3 + j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 -",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:9328,Modifiability,config,config,9328,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:9364,Modifiability,config,config,9364,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:9458,Modifiability,config,config,9458,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:9589,Modifiability,config,config,9589,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html
https://qutip.org/docs/4.0.2/modules/qutip/visualization.html:39048,Deployability,update,updated,39048," a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. """"""; if not isket(ket):; raise Exception(""Schmidt plot works only for pure states, i.e. kets.""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]. if splitting is None:; splitting = (len(dim_list) + 1) // 2. if isinstance(labels_iteration, int):; labels_iteration = labels_iteration, labels_iteration. ketdata = ket.full(). dim_list_y = dim_list[:splitting]; dim_list_x = dim_list[splitting:]. size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). ketdata = ketdata.reshape((size_y, size_x)). dim_list_small_x = dim_list_x[:labels_iteration[1]]; dim_list_small_y = dim_list_y[:labels_iteration[0]]. quadrants_x = np.prod(dim_list_small_x); quadrants_y = np.prod(dim_list_small_y). ticks_x = [size_x / quadrants_x * (i + 0.5); for i in range(quadrants_x)]; ticks_y = [size_y / quadrants_y * (quadrants_y - i - 0.5); for i in range(quadrants_y)]. labels_x = [_sequence_to_latex(_index_to_sequence(i*size_x // quadrants_x,; dim_list=dim_list_x)); for i in range(quadrants_x)]; labels_y = [_sequence_to_latex(_index_to_sequence(i*size_y // quadrants_y,; dim_list=dim_list_y)); for i in range(quadrants_y)]. ax.set_xticks(ticks_x); ax.set_xticklabels(labels_x); ax.set_yticks(ticks_y); ax.set_yticklabels(labels_y); ax.set_xlabel(""last particles""); ax.set_ylabel(""first particles""). ax.imshow(complex_array_to_rgb(ketdata, theme=theme),; interpolation=""none"",; extent=(0, size_x, 0, size_y)). return fig, ax. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/visualization.html
https://qutip.org/docs/4.0.2/modules/qutip/visualization.html:14341,Energy Efficiency,energy,energy,14341,"None:; fig = plt.figure(); ax = Axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isi",MatchSource.WIKI,docs/4.0.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/visualization.html
https://qutip.org/docs/4.0.2/modules/qutip/visualization.html:14408,Energy Efficiency,energy,energy,14408,"lor=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not a",MatchSource.WIKI,docs/4.0.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/visualization.html
https://qutip.org/docs/4.0.2/modules/qutip/visualization.html:14455,Energy Efficiency,energy,energy,14455,"plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else mi",MatchSource.WIKI,docs/4.0.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/visualization.html
https://qutip.org/docs/4.0.2/modules/qutip/visualization.html:14787,Energy Efficiency,energy,energy,14787,"s; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N) / (2 * np.pi); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]",MatchSource.WIKI,docs/4.0.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/visualization.html
https://qutip.org/docs/4.0.2/modules/qutip/visualization.html:14853,Energy Efficiency,energy,energy,14853,"et_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N) / (2 * np.pi); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]:. H = H + H1; evals1 = H.eigenenergies() / (2 * np.pi). for e_idx, e in enum",MatchSource.WIKI,docs/4.0.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/visualization.html
https://qutip.org/docs/4.0.2/modules/qutip/visualization.html:17703,Energy Efficiency,green,green,17703,"_fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; """"""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). if isket(rho):; rho = ket2dm(rho). N = rho.shape[0]. ax.bar(np.arange(offset, offset + N) - .4, np.real(rho.diag()),; color=""green"", alpha=0.6, width=0.8); if unit_y_range:; ax.set_ylim(0, 1). ax.set_xlim(-.5 + offset, N + offset); ax.set_xlabel('Fock number', fontsize=12); ax.set_ylabel('Occupation probability', fontsize=12). if title:; ax.set_title(title). return fig, ax. def fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; warnings.warn(""Deprecated: Use plot_fock_distribution""); return plot_fock_distribution(rho, offset=offset, fig=fig, ax=ax,; figsize=figsize, title=title,; unit_y_range=unit_y_range). [docs]def plot_wigner(rho, fig=None, ax=None, figsize=(8, 4),; cmap=None, alpha_max=7.5, colorbar=False,; method='iterative', projection='2d'):; """"""; Plot the the Wigner function for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotli",MatchSource.WIKI,docs/4.0.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/visualization.html
https://qutip.org/docs/4.0.2/modules/qutip/visualization.html:12878,Safety,avoid,avoid,12878,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = Axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use mi",MatchSource.WIKI,docs/4.0.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/visualization.html
https://qutip.org/docs/4.0.2/modules/qutip/visualization.html:31932,Security,access,access,31932,"e. style : 'ket' (default), 'bra' or 'bare'; Style of LaTeX (i.e. |01> or <01| or 01, respectively). Returns; -------; latex : str; LaTeX output. """"""; if style == 'ket':; latex = ""$\\left|{0}\\right\\rangle$""; elif style == 'bra':; latex = ""$\\left\\langle{0}\\right|$""; elif style == 'bare':; latex = ""${0}$""; else:; raise Exception(""No such style.""); return latex.format("""".join(map(str, seq))). [docs]def plot_qubism(ket, theme='light', how='pairs',; grid_iteration=1, legend_iteration=0,; fig=None, ax=None, figsize=(6, 6)):; """"""; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; ; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; ""Qubism: self-similar visualization of many-body wavefunctions"",; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters; ----------; ket : Qobj; Pure state for plotting. theme : 'light' (default) or 'dark'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : 'pairs' (default), 'pairs_skewed' or 'before_after'; Type of Qubism plotting.; Options:; ; 'pairs' - typical coordinates,; 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or 'grid_iteration' or 'all'; Show labels for first 2*legend_iteration particles.; Option 'grid_iteration' sets the same number of particles; as for grid_iteration.; Option 'all' makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance;",MatchSource.WIKI,docs/4.0.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/visualization.html
https://qutip.org/docs/4.0.2/modules/qutip/wigner.html:16486,Deployability,update,updated,16486,"Q function. Returns; -------; Q, THETA, PHI : 2d-array; Values representing the spin Q function at the values specified; by THETA and PHI. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in arange(-j, j+1):. Q += binom(2*j, j+m1) * cos(THETA/2) ** (2*(j-m1)) * sin(THETA/2) ** (2*(j+m1)) * \; rho.data[int(j-m1), int(j-m1)]. for m2 in arange(m1+1, j+1):. Q += (sqrt(binom(2*j, j+m1)) * sqrt(binom(2*j, j+m2)) *; cos(THETA/2) ** (2*j-m1-m2) * sin(THETA/2) ** (2*j+m1+m2)) * \; (exp(1j * (m2-m1) * PHI) * rho.data[int(j-m1), int(j-m2)] +; exp(1j * (m1-m2) * PHI) * rho.data[int(j-m2), int(j-m1)]). return Q.real, THETA, PHI. def _rho_kq(rho, j, k, q):; v = 0j. for m1 in arange(-j, j+1):; for m2 in arange(-j, j+1):; v += (-1)**(j - m1 - q) * clebsch(j, j, k, m1, -m2,; q) * rho.data[m1 + j, m2 + j]. return v. [docs]def spin_wigner(rho, theta, phi):; """"""Wigner function for spins on the Bloch sphere. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; theta-coordinates at which to calculate the Q function.; phi : array_like; phi-coordinates at which to calculate the Q function. Returns; -------; W, THETA, PHI : 2d-array; Values representing the spin Wigner function at the values specified; by THETA and PHI. Notes; -----; Experimental. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). W = np.zeros_like(THETA, dtype=complex). for k in range(int(2 * j)+1):; for q in range(-k, k+1):; W += _rho_kq(rho, j, k, q) * sph_harm(q, k, PHI, THETA). return W, THETA, PHI. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/wigner.html
https://qutip.org/docs/4.0.2/modules/qutip/wigner.html:3708,Energy Efficiency,efficient,efficient,3708,"iag. [docs]def wigner(psi, xvec, yvec, method='clenshaw', g=sqrt(2), ; sparse=False, parfor=False):; """"""Wigner function for a state vector or density matrix at points; `xvec + i * yvec`. Parameters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' ; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; ; parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-c",MatchSource.WIKI,docs/4.0.2/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/wigner.html
https://qutip.org/docs/4.0.2/modules/qutip/wigner.html:10813,Energy Efficiency,efficient,efficient,10813,"0]]),; np.fliplr(psi.conj()),; np.zeros((1, n//2 - 1))), axis=1); r2 = np.concatenate((np.array([[0]]), psi,; np.zeros((1, n//2 - 1))), axis=1); w = la.toeplitz(np.zeros((n//2, 1)), r1) * \; np.flipud(la.toeplitz(np.zeros((n//2, 1)), r2)); w = np.concatenate((w[:, n//2:n], w[:, 0:n//2]), axis=1); w = ft.fft(w); w = np.real(np.concatenate((w[:, 3*n//4:n+1], w[:, 0:n//4]), axis=1)); p = np.arange(-n/4, n/4)*np.pi / (n*(xvec[1] - xvec[0])); w = w / (p[1] - p[0]) / n; return w, p. def _osc_eigen(N, pnts):; """"""; Vector of and N-dim oscillator eigenfunctions evaluated; at the points in pnts.; """"""; pnts = np.asarray(pnts); lpnts = len(pnts); A = np.zeros((N, lpnts)); A[0, :] = np.exp(-pnts ** 2 / 2.0) / pi ** 0.25; if N == 1:; return A; else:; A[1, :] = np.sqrt(2) * pnts * A[0, :]; for k in range(2, N):; A[k, :] = np.sqrt(2.0 / k) * pnts * A[k - 1, :] - \; np.sqrt((k - 1.0) / k) * A[k - 2, :]; return A. def _wigner_clenshaw(rho, xvec, yvec, g=sqrt(2), sparse=False):; """"""; Using Clenshaw summation - numerically stable and efficient; iterative algorithm to evaluate polynomial series.; ; The Wigner function is calculated as; :math:`W = e^(-0.5*x^2)/pi * \sum_{L} c_L (2x)^L / sqrt(L!)` where ; :math:`c_L = \sum_n \\rho_{n,L+n} LL_n^L` where; :math:`LL_n^L = (-1)^n sqrt(L!n!/(L+n)!) LaguerreL[n,L,x]`; ; """""". M = np.prod(rho.shape[0]); X,Y = np.meshgrid(xvec, yvec); #A = 0.5 * g * (X + 1.0j * Y); A2 = g * (X + 1.0j * Y) #this is A2 = 2*A; ; B = np.abs(A2); B *= B; w0 = (2*rho.data[0,-1])*np.ones_like(A2); L = M-1; #calculation of \sum_{L} c_L (2x)^L / sqrt(L!); #using Horner's method; if not sparse:; rho = rho.full() * (2*np.ones((M,M)) - np.diag(np.ones(M))); while L > 0:; L -= 1; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 = _wig_laguerre_val(L, B, np.diag(rho, L)) + w0 * A2 * (L+1)**-0.5; else:; while L > 0:; L -= 1; diag = _csr_get_diag(rho.data.data,rho.data.indices,; rho.data.indptr,L); if L != 0:; diag *= 2; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)",MatchSource.WIKI,docs/4.0.2/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/wigner.html
https://qutip.org/docs/4.0.2/modules/qutip/wigner.html:4210,Performance,perform,performance,4210," g * (x + iy)`, default `g = sqrt(2)`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' ; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; ; parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; ----------. Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). """""". if not (psi.type == 'ket' or psi.type == 'oper' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.'). if method == 'fft':; return _wigner_fourier(psi, xvec, g). if psi.type == 'ket' or psi.type == 'bra':; rho = ket2dm(psi); else:; rho = psi. if method == 'iterative':; return _wigner_iterative(rho, xvec, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/wigner.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:6330,Availability,error,error,6330,"ummary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir(); return self._dump_dir. @dump_dir.setter; def dump_dir(self, value):; self._dump_dir = value; if not self.create_dump_dir():; self._dump_dir = None. [docs] def create_dump_dir(self):; """"""; Checks dump directory exists, creates it if not; """"""; if self._dump_dir is None or len(self._dump_dir) == 0:; self._dump_dir = DUMP_DIR. dir_ok, self._dump_dir, msg = qtrlio.create_dir(; self._dump_dir, desc='dump'). if not dir_ok:; self.write_to_file = False; msg += ""\ndump file output will be suppressed.""; logger.error(msg). return dir_ok. @property; def fname_base(self):; return self._fname_base. @fname_base.setter; def fname_base(self, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attrib",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:7629,Availability,error,error,7629,"le(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than th",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:9850,Availability,avail,available,9850,"e summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:12975,Availability,error,errors,12975,"ed then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes; ----------; dum",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:17927,Availability,avail,available,17927,"se:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_evo_dump(self):; """"""Add dump of current time evolution generating objects""""""; dyn = self.parent; item = EvoCompDumpItem(self); item.idx = len(self.evo_dumps); self.evo_dumps.append(item); if self.dump_amps:; item.ctrl_amps = copy.deepcopy(dyn.ctrl_amps); if self.dump_dyn_gen:; item.dyn_gen = copy.deepcopy(dyn._dyn_gen); if self.dump_prop:; item.prop = copy.deepcopy(dyn._prop); if self.dump_prop_grad:; item.prop_grad = copy.deepcopy(dyn._prop_grad); if self.dump_fwd_evo:; item.fwd_evo = copy.deepcopy(dyn._fwd_evo); if self.dump_onwd_evo:; item.onwd_evo = copy.deepcopy(dyn._onwd_evo); if self.dump_onto_evo:; item.onto_evo = copy.deepcopy(dyn._onto_evo). if self.write_to_file:; item.writeout(); return item. [docs] def add_evo_comp_summary(self, dump_item_idx=None):; """"""add copy of current evo comp summary""""""; dyn = self.parent; if dyn.tslot_computer.evo_comp_summary is None:; raise RuntimeError(""Cannot add evo_comp_summary as not available""); ecs = copy.copy(dyn.tslot_computer.evo_comp_summary); ecs.idx = len(self.evo_summary); ecs.evo_dump_idx = dump_item_idx; if dyn.stats:; ecs.iter_num = dyn.stats.num_iter; ecs.fid_func_call_num = dyn.stats.num_fidelity_func_calls; ecs.grad_func_call_num = dyn.stats.num_grad_func_calls. self.evo_summary.append(ecs); if self.write_to_file:; if ecs.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(ecs.get_value_line(self.summary_sep))). f.close(); return ecs. [docs] def writeout(self, f=None):; """"""write all the dump items and the summary out to file(s); Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:25937,Deployability,update,updated,25937,"s.path.join(dump.dump_dir, fname), 'wb'); closef = True; for dg in self.dyn_gen:; f.write(asbytes(""Evolution from {} to end\n"".format(k))); np.savetxt(f, self.fwd_evo[k], delimiter=dump.data_sep); k += 1; if closef: f.close(). # onto evolution; if not self.onto_evo is None:; k = 0; if fall:; f = fall; f.write(asbytes(""Onto evolution\n"")); else:; fname = ""{}-onto_evo.{}"".format(fnbase,; dump.dump_file_ext); f = open(os.path.join(dump.dump_dir, fname), 'wb'); closef = True; for dg in self.dyn_gen:; f.write(asbytes(""Evolution from {} onto target\n"".format(k))); np.savetxt(f, self.fwd_evo[k], delimiter=dump.data_sep); k += 1; if closef: f.close(). if closefall:; fall.close(). [docs]class DumpSummaryItem(object):; """"""A summary of the most recent iteration; Abstract class only. Attributes:; idx : int; Index in the summary list in which this is stored; """"""; min_col_width = 11; summary_property_names = (). summary_property_fmt_type = (). summary_property_fmt_prec = (). @classmethod; def get_header_line(cls, sep=' '):; if sep == ' ':; line = ''; i = 0; for a in cls.summary_property_names:; if i > 0:; line += sep; i += 1; line += format(a, str(max(len(a), cls.min_col_width)) + 's'); else:; line = sep.join(cls.summary_property_names); return line. def reset(self):; self.idx = 0. def get_value_line(self, sep=' '):; line = """"; i = 0; for a in zip(self.summary_property_names,; self.summary_property_fmt_type,; self.summary_property_fmt_prec):; if i > 0:; line += sep; i += 1; v = getattr(self, a[0]); w = max(len(a[0]), self.min_col_width); if v is not None:; fmt = ''; if sep == ' ':; fmt += str(w); else:; fmt += '0'; if a[2] > 0:; fmt += '.' + str(a[2]); fmt += a[1]; line += format(v, fmt); else:; if sep == ' ':; line += format('None', str(w) + 's'); else:; line += 'None'. return line. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:2845,Integrability,depend,depends,2845," (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:3554,Modifiability,config,configured,3554,"nce(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:9241,Modifiability,config,config,9241,"reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summar",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:16295,Modifiability,config,config,16295,"any(self):; """"""True if any of the calculation objects are to be dumped""""""; if (self.dump_amps or; self.dump_dyn_gen or; self.dump_prop or; self.dump_prop_grad or; self.dump_fwd_evo or; self.dump_onwd_evo or; self.dump_onto_evo):; return True; else:; return False. @property; def dump_all(self):; """"""True if all of the calculation objects are to be dumped""""""; dyn = self.parent; if (self.dump_amps and; self.dump_dyn_gen and; self.dump_prop and; self.dump_prop_grad and; self.dump_fwd_evo and; (self.dump_onwd_evo) or; (self.dump_onwd_evo == dyn.fid_computer.uses_onwd_evo) and; (self.dump_onto_evo or; (self.dump_onto_evo == dyn.fid_computer.uses_onto_evo))):; return True; else:; return False. def _apply_level(self, level=None):; dyn = self.parent; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_amps = False; self.dump_dyn_gen = False; self.dump_prop = False; self.dump_prop_grad = False; self.dump_fwd_evo = False; self.dump_onwd_evo = False; self.dump_onto_evo = False; elif level == 'FULL':; self.dump_summary = True; self.dump_amps = True; self.dump_dyn_gen = True; self.dump_prop = True; self.dump_prop_grad = True; self.dump_fwd_evo = True; self.dump_onwd_evo = dyn.fid_computer.uses_onwd_evo; self.dump_onto_evo = dyn.fid_computer.uses_onto_evo; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_evo_dump(self):; """"""Add dump of current time evolution generating objects""""""; dyn = self.parent; item = EvoCompDumpItem(self); item.idx = len(self.evo_dumps); self.evo_dumps.append(item); if self.dump_amps:; item.ctrl_amps = copy.deepcopy(dyn.ctrl_amps); if self.dump_dyn_gen:; item.dyn_gen = copy.deepcopy(dyn._",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:2219,Performance,optimiz,optimizer,2219,"LDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file i",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:7464,Performance,optimiz,optimizer,7464,"lf, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = N",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:8029,Performance,optimiz,optimizer,8029,"; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump l",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:9714,Performance,optimiz,optimizer,9714," self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:2357,Testability,log,logging,2357,"NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; leve",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:2394,Testability,log,logger,2394,"ABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See prop",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:4729,Testability,log,logger,4729," : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:4847,Testability,log,logger,4847,"t of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_du",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:4868,Testability,log,logger,4868,"t of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_du",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:4895,Testability,log,logger,4895,"class. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir(); return self._dump_dir. @dump_dir.setter; def dump_dir(self, valu",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:6323,Testability,log,logger,6323,"elf.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir(); return self._dump_dir. @dump_dir.setter; def dump_dir(self, value):; self._dump_dir = value; if not self.create_dump_dir():; self._dump_dir = None. [docs] def create_dump_dir(self):; """"""; Checks dump directory exists, creates it if not; """"""; if self._dump_dir is None or len(self._dump_dir) == 0:; self._dump_dir = DUMP_DIR. dir_ok, self._dump_dir, msg = qtrlio.create_dir(; self._dump_dir, desc='dump'). if not dir_ok:; self.write_to_file = False; msg += ""\ndump file output will be suppressed.""; logger.error(msg). return dir_ok. @property; def fname_base(self):; return self._fname_base. @fname_base.setter; def fname_base(self, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisat",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:10581,Testability,log,log,10581," = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:11109,Testability,log,log,11109,"get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; #",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:11396,Testability,log,log,11396,"g.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:11706,Testability,log,logs,11706," mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.ge",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:12838,Testability,log,logger,12838,"ata will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:13643,Testability,log,logger,13643,"format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes; ----------; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummary'; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. ev",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:13709,Testability,log,logger,13709,"_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes; ----------; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummary'; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of :class:`EvoCompDumpItem`; A new dump i",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:13769,Testability,log,logger,13769,"e(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes; ----------; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummary'; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of :class:`EvoCompDumpItem`; A new dump item is appended at each recomputation of the evo",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:19756,Testability,log,logger,19756,"data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem(object):; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; :class:`DynamicsDump` dump_ attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = No",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:19909,Testability,log,logger,19909," a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem(object):; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; :class:`DynamicsDump` dump_ attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Paramete",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:19978,Testability,log,logger,19978,"his.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem(object):; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; :class:`DynamicsDump` dump_ attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Parameters; ----------; f : filename or filehandle; If specified th",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:20041,Testability,log,logger,20041,"then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem(object):; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; :class:`DynamicsDump` dump_ attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Parameters; ----------; f : filename or filehandle; If specified then all object data will go in one file.; If None i",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:8462,Usability,clear,clear,8462,"er.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FU",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html:15216,Usability,clear,clear,15216,". dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of :class:`EvoCompDumpItem`; A new dump item is appended at each recomputation of the evolution.; That is if any of the calculation objects are to be dumped. """"""; def __init__(self, dynamics, level='SUMMARY'):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.evo_dumps = []; self.evo_summary = []; self._fname_base = 'dyndump'. def clear(self):; del self.evo_dumps[:]; del self.evo_summary[:]. @property; def dump_any(self):; """"""True if any of the calculation objects are to be dumped""""""; if (self.dump_amps or; self.dump_dyn_gen or; self.dump_prop or; self.dump_prop_grad or; self.dump_fwd_evo or; self.dump_onwd_evo or; self.dump_onto_evo):; return True; else:; return False. @property; def dump_all(self):; """"""True if all of the calculation objects are to be dumped""""""; dyn = self.parent; if (self.dump_amps and; self.dump_dyn_gen and; self.dump_prop and; self.dump_prop_grad and; self.dump_fwd_evo and; (self.dump_onwd_evo) or; (self.dump_onwd_evo == dyn.fid_computer.uses_onwd_evo) and; (self.dump_onto_evo or; (self.dump_onto_evo == dyn.fid_computer.uses_onto_evo))):; return True; else:; return False. def _apply_level(self, level=None):; dyn = self.parent; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:3385,Availability,error,errors,3385,"the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning,",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:3395,Availability,error,errors,3395,"the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning,",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:6351,Availability,error,error,6351,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:6374,Availability,error,error,6374,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:25994,Availability,error,errors,25994," self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; self._num_ctrls = len(self.ctrl_dyn_gen). if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has be",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:26195,Availability,error,errors,26195,"; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; self._num_ctrls = len(self.ctrl_dyn_gen). if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """,MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:26388,Availability,error,errors,26388,"mp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; self._num_ctrls = len(self.ctrl_dyn_gen). if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the fi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:26891,Availability,error,errors,26891," any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; self._num_ctrls = len(self.ctrl_dyn_gen). if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:28547,Availability,error,error,28547,"; If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_a",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:28601,Availability,error,error,28601,"; If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_a",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:30410,Availability,error,errors,30410,"t dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes, ""; ""because drift_dyn_gen is not Qobj (nor list of)""); ; self.dyn_shape = d0.shape; self.dyn_dims = d0.dims; ; [docs] def get_num_ctrls(self):; """"""; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently; """"""; _func_deprecation(""'get_num_ctrls' has been replaced by ""; ""'num_ctrls' property""); return self.num_ctrls. def _get_num_ctrls(self):; if not isinstance(self.ctrl_dyn_gen, (list, tuple)):; raise errors.UsageError(""Controls list not set""); self._num_ctrls = len(self.ctrl_dyn_gen); return self._num_ctrls. @property; def num_ctrls(self):; """"""; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently; """"""; if self._num_ctrls is None:; self._num_ctrls = self._get_num_ctrls(); return self._num_ctrls. @property; def onto_evo_target(self):; if self._onto_evo_target is None:; self._get_onto_evo_target(). if self._onto_evo_target_qobj is None:; if isinstance(self._onto_evo_target, Qobj):; self._onto_evo_target_qobj = self._onto_evo_target; else:; rev_dims = [self.sys_dims[1], self.sys_dims[0]]; self._onto_evo_target_qobj = Qobj(self._onto_evo_target,; dims=rev_dims). return self._onto_evo_target_qobj. def get_owd_evo_target(self):; _func_deprecation(""'get_owd_evo_target' has been replaced by ""; ""'onto_evo_target' property""); return self.onto_evo_target. def _get_onto_evo_target(self):; """"""; G",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:38715,Availability,error,errors,38715,"nge(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full()));",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:39164,Availability,error,errors,39164,"nian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full())); else:; err = np.sum(abs(np.eye(len(A)) - A.dot(A.T.conj()))). return err. [docs] def unitarity_check(self):; """"""; Checks whether all propagators are unitary; """"""; for k in range(self.num_tslots):; if not self._is_unitary(self._prop[k]):; logger.warning(; ""Progator of timeslot {} is not unitary",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:44172,Availability,down,down,44172,"rating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; """""". if self.oper_dtype == Qobj:; H = self._dyn_gen[k]; # Returns eigenvalues as array (row); # and eigenvectors as rows of an array; eig_val, eig_vec = sp_eigs(H.data, H.isherm, ; sparse=self.sparse_eigen_decomp); eig_vec = eig_vec.T. elif self.oper_dtype == np.ndarray:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = np.linalg.eigh(H); else:; if sparse:; H = self._dyn_gen[k].toarray(); else:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = la.eigh(H). # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isin",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:6150,Deployability,update,updated,6150,"ystems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:17261,Deployability,configurat,configuration,17261,"USTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(s",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:25848,Deployability,configurat,configuration,25848,"p_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; self._num_ctrls = len(self.ctrl_dyn_gen). if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). d",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:38563,Deployability,update,update,38563,"_onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:38619,Deployability,update,update,38619,"_onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:41559,Deployability,configurat,configuration,41559,"o compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:42110,Deployability,configurat,configuration,42110,"control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); if self._num_ctrls is None:; self._num_ctrls = self._get_num_ctrls(); return self._num_ctrls. def _get_onto_evo_target(self):; """"""; Get the adjoint of the target.; Used for calculating the 'backward' evolution; """"""; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); else:; self._onto_evo_target = self._target.T.conj(); return self._onto_evo_target. def _spectral_decomp(self, k):; """"""; Ca",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:47995,Deployability,configurat,configuration,47995,"; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calcul",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:49557,Deployability,update,updated,49557,"reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calculated until the dyn_shape is set; # that is after the drift Hamitonan has been set.; if self._dyn_gen_phase is None:; self._dyn_gen_phase = self._get_omega(). return self._dyn_gen_phase. def _apply_phase(self, dg):; """"""; Apply some phase factor or operator; """"""; if self.dyn_gen_phase is None:; phased_dg = dg; else:; if hasattr(self.dyn_gen_phase, 'dot'):; phased_dg = -dg.dot(self.dyn_gen_phase); else:; phased_dg = -dg*self.dyn_gen_phase; return phased_dg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:5915,Energy Efficiency,reduce,reduce,5915,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more informati",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:20922,Energy Efficiency,efficient,efficient,20922,")); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; for c in self.ctrl_dyn_gen:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense method; self.oper_dtype = np.ndarray. return self.oper_dtype. def _init_evo(self):; """"""; Create the container lists / arrays for the:; dynamics generations, propagators, and evolutions etc; Set the time slices and cumula",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:2675,Integrability,depend,depends,2675,"ICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:3946,Integrability,message,message,3946,"ol; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:4034,Integrability,message,message,4034,"ol; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:4122,Integrability,message,message,4122," from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better u",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:4197,Integrability,message,message,4197,"port qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:4285,Integrability,message,message,4285,"port qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:4373,Integrability,message,message,4373,"rrors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBU",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:13643,Integrability,depend,depending,13643,"g to SUMMARY; when setting a path; ; """"""; def __init__(self, optimconfig, params=None):; self.config = optimconfig; self.params = params; self.reset(). def reset(self):; # Link to optimiser object if self is linked to one; self.parent = None; # Main functional attributes; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self._tau = None; self._evo_time = None; self._num_ctrls = None; self._num_tslots = None; # attributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:27811,Integrability,message,message,27811,"s(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:12663,Modifiability,config,config,12663,"ty of the system evolution is checked at at; evolution recomputation.; level 1 checks all propagators; level 2 checks eigen basis as well; Default is 0. unitarity_tol :; Tolerance used in checking if operator is unitary; Default is 1e-10. dump : :class:`dump.DynamicsDump`; Store of historical calculation data.; Set to None (Default) for no storing of historical data; Use dumping property to set level of data dumping. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the calculations; dumping will be set to SUMMARY during init_evo if dump_to_file is True; and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; dyn_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path; ; """"""; def __init__(self, optimconfig, params=None):; self.config = optimconfig; self.params = params; self.reset(). def reset(self):; # Link to optimiser object if self is linked to one; self.parent = None; # Main functional attributes; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self._tau = None; self._evo_time = None; self._num_ctrls = None; self._num_tslots = None; # attributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._dri",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:14786,Modifiability,config,config,14786,"._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:17261,Modifiability,config,configuration,17261,"USTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(s",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:17316,Modifiability,config,config,17316,"o specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots();",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:18812,Modifiability,config,config,18812,".evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory opt",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:25848,Modifiability,config,configuration,25848,"p_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; self._num_ctrls = len(self.ctrl_dyn_gen). if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). d",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:41559,Modifiability,config,configuration,41559,"o compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:41614,Modifiability,config,config,41614,"lculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_h",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:42110,Modifiability,config,configuration,42110,"control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); if self._num_ctrls is None:; self._num_ctrls = self._get_num_ctrls(); return self._num_ctrls. def _get_onto_evo_target(self):; """"""; Get the adjoint of the target.; Used for calculating the 'backward' evolution; """"""; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); else:; self._onto_evo_target = self._target.T.conj(); return self._onto_evo_target. def _spectral_decomp(self, k):; """"""; Ca",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:47995,Modifiability,config,configuration,47995,"; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calcul",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:48050,Modifiability,config,config,48050,"dj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calculated until the dyn_shape is set; # that is after the drift Hamitona",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:5118,Performance,perform,performance,5118,"ter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:5860,Performance,perform,performance,5860,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more informati",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:7211,Performance,perform,performs,7211,"ompute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: boo",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:7264,Performance,perform,perform,7264,"o computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:7314,Performance,perform,perform,7314,"o computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:7822,Performance,cache,cache,7822,"parse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evol",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:8080,Performance,cache,cached,8080,"eory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj or list of Qobj; Drift or system dynamics generator (Hamiltonian);",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:44630,Safety,avoid,avoid,44630," eig_vec = np.linalg.eigh(H); else:; if sparse:; H = self._dyn_gen[k].toarray(); else:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = la.eigh(H). # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isinstance(factors, np.ndarray):; self._dyn_gen_factormatrix[k] = factors; else:; self._dyn_gen_factormatrix[k] = np.array(factors). if self.oper_dtype == Qobj:; self._prop_eigen[k] = Qobj(np.diagflat(prop_eig),; dims=self.dyn_dims); self._dyn_gen_eigenvectors[k] = Qobj(eig_vec,; dims=self.dyn_dims); # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); else",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:4713,Security,access,access,4713," basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are th",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:14141,Security,access,accessors,14141,"ributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computer",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:3260,Testability,log,logging,3260,". """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Us",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:3299,Testability,log,logging,3299,"(quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:3308,Testability,log,logger,3308,"(quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:3317,Testability,log,logging,3317,"(quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:5280,Testability,log,logger,5280,"n warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagat",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:15708,Testability,log,logger,15708," None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; se",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:15826,Testability,log,logger,15826,"log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.Dynam",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:15847,Testability,log,logger,15847,"log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.Dynam",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:15874,Testability,log,logger,15874,"_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dum",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:19592,Testability,log,logger,19592,"ttribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvec",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:19743,Testability,log,logger,19743,"timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:19837,Testability,log,logger,19837,"num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".for",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:20058,Testability,log,logger,20058,"tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken f",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:20284,Testability,log,logger,20284,"s):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:20544,Testability,log,logger,20544,"e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; for c in self.ctrl_dyn_gen:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:20786,Testability,log,logger,20786,"data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; for c in self.ctrl_dyn_gen:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense method; self.oper_dtype = np.ndarray. return self.oper_dtype. def _init_evo(self):; """"""; Cre",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:23577,Testability,log,logger,23577,"lf.target, Qobj):; raise TypeError(""target must be a Qobj""). self.refresh_drift_attribs(); self._set_memory_optimizations(); self.sys_dims = self.initial.dims; self.sys_shape = self.initial.shape; if self.oper_dtype == Qobj:; self._initial = self.initial; self._target = self.target; self._drift_dyn_gen = self.drift_dyn_gen; self._ctrl_dyn_gen = self.ctrl_dyn_gen; elif self.oper_dtype == np.ndarray:; self._initial = self.initial.full(); self._target = self.target.full(); if self.time_depend_drift:; self._drift_dyn_gen = [d.full() for d in self.drift_dyn_gen]; else:; self._drift_dyn_gen = self.drift_dyn_gen.full(); self._ctrl_dyn_gen = [ctrl.full() for ctrl in self.ctrl_dyn_gen]; elif self.oper_dtype == sp.csr_matrix:; self._initial = self.initial.data; self._target = self.target.data; if self.time_depend_drift:; self._drift_dyn_gen = [d.data for d in self.drift_dyn_gen]; else:; self._drift_dyn_gen = self.drift_dyn_gen.data; self._ctrl_dyn_gen = [ctrl.data for ctrl in self.ctrl_dyn_gen]; else:; logger.warn(""Unknown option '{}' for oper_dtype. ""; ""Assuming that internal drift, ctrls, initial and target ""; ""have been set correctly"".format(self.oper_dtype)); if self.cache_phased_dyn_gen and not self.dyn_gen_phase is None:; self._phased_ctrl_dyn_gen = [self._apply_phase(ctrl); for ctrl in self._ctrl_dyn_gen]; self._dyn_gen = [object for x in range(self.num_tslots)]; if self.cache_phased_dyn_gen:; self._phased_dyn_gen = [object for x in range(self.num_tslots)]; self._prop = [object for x in range(self.num_tslots)]; if self.prop_computer.grad_exact and self.cache_prop_grad:; self._prop_grad = np.empty([self.num_tslots, self._num_ctrls],; dtype=object); # Time evolution operator (forward propagation); self._fwd_evo = [object for x in range(self.num_tslots+1)]; self._fwd_evo[0] = self._initial; if self.fid_computer.uses_onwd_evo:; # Time evolution operator (onward propagation); self._onwd_evo = [object for x in range(self.num_tslots)]; if self.fid_computer.uses_onto_evo:; # On",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:24850,Testability,log,logging,24850,"_phase(ctrl); for ctrl in self._ctrl_dyn_gen]; self._dyn_gen = [object for x in range(self.num_tslots)]; if self.cache_phased_dyn_gen:; self._phased_dyn_gen = [object for x in range(self.num_tslots)]; self._prop = [object for x in range(self.num_tslots)]; if self.prop_computer.grad_exact and self.cache_prop_grad:; self._prop_grad = np.empty([self.num_tslots, self._num_ctrls],; dtype=object); # Time evolution operator (forward propagation); self._fwd_evo = [object for x in range(self.num_tslots+1)]; self._fwd_evo[0] = self._initial; if self.fid_computer.uses_onwd_evo:; # Time evolution operator (onward propagation); self._onwd_evo = [object for x in range(self.num_tslots)]; if self.fid_computer.uses_onto_evo:; # Onward propagation overlap with inverse target; self._onto_evo = [object for x in range(self.num_tslots+1)]; self._onto_evo[self.num_tslots] = self._get_onto_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:25071,Testability,log,logger,25071,"ect for x in range(self.num_tslots)]; if self.prop_computer.grad_exact and self.cache_prop_grad:; self._prop_grad = np.empty([self.num_tslots, self._num_ctrls],; dtype=object); # Time evolution operator (forward propagation); self._fwd_evo = [object for x in range(self.num_tslots+1)]; self._fwd_evo[0] = self._initial; if self.fid_computer.uses_onwd_evo:; # Time evolution operator (onward propagation); self._onwd_evo = [object for x in range(self.num_tslots)]; if self.fid_computer.uses_onto_evo:; # Onward propagation overlap with inverse target; self._onto_evo = [object for x in range(self.num_tslots+1)]; self._onto_evo[self.num_tslots] = self._get_onto_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:27827,Testability,log,logged,27827,"s(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:28122,Testability,log,logger,28122," [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.co",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:28461,Testability,log,logger,28461,"e (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this return",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:28540,Testability,log,logger,28540," each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:28884,Testability,log,logging,28884,"= True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeErro",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:28908,Testability,log,logger,28908,"s None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:28915,Testability,log,log,28915," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:28919,Testability,log,logging,28919," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:38267,Testability,log,logging,38267,"._onwd_evo_qobj. @property; def evo_t2targ(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:38291,Testability,log,logger,38291,"erty; def evo_t2targ(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:38298,Testability,log,log,38298,"rg(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whe",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:38302,Testability,log,logging,38302,"rg(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whe",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:39943,Testability,log,logger,39943,"f eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full())); else:; err = np.sum(abs(np.eye(len(A)) - A.dot(A.T.conj()))). return err. [docs] def unitarity_check(self):; """"""; Checks whether all propagators are unitary; """"""; for k in range(self.num_tslots):; if not self._is_unitary(self._prop[k]):; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)). [docs]class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'; self.apply_params(). [docs]class DynamicsUnitary(Dynamics):; """"""; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:46523,Testability,log,logger,46523,"t None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); else:; self._prop_eigen[k] = np.diagflat(prop_eig); self._dyn_gen_eigenvectors[k] = eig_vec; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].conj().T. def _get_dyn_gen_eigenvectors_adj(self, k):; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; return self._dyn_gen_eigenvectors_adj[k]; else:; if self.oper_dtype == Qobj:; return self._dyn_gen_eigenvectors[k].dag(); else:; return self._dyn_gen_eigenvectors[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitary(self._prop_eigen[k]); eigvec_unit = self._is_unitary(self._dyn_gen_eigenvectors[k]); if self._dyn_gen_eigenvectors_adj is not None:; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omeg",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:47259,Testability,log,logger,47259,"rs[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitary(self._prop_eigen[k]); eigvec_unit = self._is_unitary(self._dyn_gen_eigenvectors[k]); if self._dyn_gen_eigenvectors_adj is not None:; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:3861,Usability,simpl,simplefilter,3861,"ol; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:15147,Usability,clear,clear,15147," # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:17581,Usability,clear,clear,17581,"ring(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html:17697,Usability,clear,clear,17697,"None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # s",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:2316,Availability,error,error,2316," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:2363,Availability,error,error,2363," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3263,Availability,error,errors,3263,"mputer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3273,Availability,error,errors,3273,"mputer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:5478,Availability,error,error,5478,"-----; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_f",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:5794,Availability,error,error,5794,"ed.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_curre",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:5912,Availability,error,error,5912,"_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:7887,Availability,error,errors,7887,"lse; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecati",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:7947,Availability,error,error,7947,"the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def use",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:8115,Availability,error,error,8115," created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:8238,Availability,error,errors,8238," created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:8300,Availability,error,error,8300,"elf.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Comput",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:9292,Availability,error,error,9292,"etting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:11074,Availability,error,errors,11074,"'PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:11175,Availability,error,errors,11175,"ty_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation functio",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:11409,Availability,error,errors,11409,"""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; self.dimensional_norm = 1.0; self.dimensional_norm = \; self.fid_norm_func(dyn.target.dag()*dyn.target). [do",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:13749,Availability,error,error,13749," np.real(norm) / self.dimensional_norm. [docs] def normalize_gradient_SU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This SU version respects global phase; """"""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_e",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:15122,Availability,error,error,15122,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:16133,Availability,error,error,16133," in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:17341,Availability,error,error,17341,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:17421,Availability,error,error,17421,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:17916,Availability,error,error,17916,"range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:18007,Availability,error,error,18007," _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:18373,Availability,error,errors,18373,"eral system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error u",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:18918,Availability,error,error,18918,"elity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.deb",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:19360,Availability,error,error,19360,"idelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:19924,Availability,error,error,19924,"or in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplit",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20072,Availability,error,error,20072,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20605,Availability,error,error,20605,"o_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20871,Availability,error,error,20871," = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_ev",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:23044,Availability,error,error,23044,"yn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:2644,Deployability,configurat,configuration,2644,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:6269,Deployability,configurat,configuration,6269,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:7657,Deployability,configurat,configuration,7657,"self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:11287,Deployability,configurat,configuration,11287," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:15248,Deployability,update,updates,15248,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:18576,Deployability,configurat,configuration,18576,"e a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20198,Deployability,update,updates,20198,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:24436,Deployability,update,updated,24436,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:2531,Energy Efficiency,efficient,efficient,2531,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3375,Integrability,message,message,3375,"n. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3463,Integrability,message,message,3463,"n. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3551,Integrability,message,message,3551,"ds for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; i",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3626,Integrability,message,message,3626,"s were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or ab",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3714,Integrability,message,message,3714,"s were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or ab",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3802,Integrability,message,message,3802,"es are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimension",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3876,Integrability,wrap,wrapper,3876,"es are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimension",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:2644,Modifiability,config,configuration,2644,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:6269,Modifiability,config,configuration,6269,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:7657,Modifiability,config,configuration,7657,"self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:11287,Modifiability,config,configuration,11287," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:13993,Modifiability,config,config,13993,"""""""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:18576,Modifiability,config,configuration,18576,"e a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:14417,Performance,cache,cached,14417,"ensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_pre",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:15182,Performance,cache,cached,15182,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20132,Performance,cache,cached,20132,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:19478,Safety,avoid,avoids,19478,"params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(se",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:21697,Safety,avoid,avoids,21697,"ent norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_evo); if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1].dot(evo_grad); g = -2*self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_grad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wr",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:23734,Safety,avoid,avoids,23734,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3138,Testability,log,logging,3138,"d; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3177,Testability,log,logging,3177," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3186,Testability,log,logger,3186," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3195,Testability,log,logging,3195," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:4517,Testability,log,logger,4517,"e function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity er",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:7394,Testability,log,logger,7394," self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have b",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:7515,Testability,log,logger,7515,"unc = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """,MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:7536,Testability,log,logger,7536,"unc = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """,MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:7563,Testability,log,logger,7563,"pply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculatin",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:14156,Testability,log,logging,14156,"A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrl",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:14172,Testability,log,logger,14172,"ypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The grad",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:14901,Testability,log,logging,14901,"alue; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:14917,Testability,log,logger,14917,"ation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; i",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:15427,Testability,log,logging,15427," because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; co",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:15451,Testability,log,logger,15451," the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:15458,Testability,log,log,15458,"ulation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:15462,Testability,log,logging,15462,"ulation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:16054,Testability,log,logging,16054,"_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_e",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:16078,Testability,log,logger,16078," Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:16085,Testability,log,log,16085,"lised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.do",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:16089,Testability,log,logging,16089,"lised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.do",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:16208,Testability,log,logging,16208," requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradien",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:16224,Testability,log,logger,16224,"le times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; ti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:18773,Testability,log,logging,18773,"Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:18789,Testability,log,logger,18789,"'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:19135,Testability,log,logging,19135,"sion of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:19159,Testability,log,logger,19159,"n the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:19166,Testability,log,log,19166," initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutli",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:19170,Testability,log,logging,19170," initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutli",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:19885,Testability,log,logging,19885,"_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error functi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:19901,Testability,log,logger,19901,"Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each ti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20537,Testability,log,logging,20537," Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._ge",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20561,Testability,log,logger,20561," self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20568,Testability,log,log,20568,"*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20572,Testability,log,logging,20572,"*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20680,Testability,log,logging,20680,"; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # u",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:20696,Testability,log,logger,20696,").T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:22995,Testability,log,logging,22995,"rad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dy",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:23011,Testability,log,logger,23011,"n(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_fi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:2637,Usability,simpl,simple,2637,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:3290,Usability,simpl,simplefilter,3290,"n. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:6293,Usability,clear,clear,6293,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:6576,Usability,clear,clear,6576,"lag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(l",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:6596,Usability,clear,clear,6596,"r are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initia",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:6615,Usability,clear,clear,6615,"r are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initia",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:10085,Usability,clear,clear,10085,"self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:10116,Usability,clear,clear,10116,"ecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to No",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:2643,Availability,error,error,2643,"OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: Optimize",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:2904,Availability,error,error,2904,"CE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:4208,Availability,error,error,4208,"m SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:4763,Availability,error,errors,4763,"t generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:4773,Availability,error,errors,4773,"t generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:6634,Availability,error,error,6634,"rom the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:13203,Availability,error,errors,13203,"elf.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:13345,Availability,error,errors,13345,"elf, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_opt",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:13544,Availability,error,errors,13544,"mplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_met",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:13599,Availability,error,error,13599,"ult.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_o",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:13605,Availability,toler,tolerance,13605,"ult.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_o",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:17044,Availability,error,error,17044,"; if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_condition",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:19412,Availability,error,errors,19412,"bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error a",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:20405,Availability,error,error,20405,"cept errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_call",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:20782,Availability,error,error,20782,"t; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:21098,Availability,error,error,21098,"te for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:21554,Availability,error,errors,21554,"e minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not N",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:21648,Availability,error,errors,21648,"as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= loggi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:21779,Availability,error,error,21779,"hey have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:23375,Availability,error,errors,23375," explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_r",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:24069,Availability,error,errors,24069,".num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:24421,Availability,error,errors,24421,"id_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:24511,Availability,error,errors,24511,", *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.s",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:24611,Availability,error,errors,24611,"s has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:24711,Availability,error,errors,24711," logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimize",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:25844,Availability,error,error,25844," the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fpri",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:27764,Availability,error,errors,27764,"_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """""";",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:29531,Availability,error,error,29531," term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.co",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:32516,Availability,error,errors,32516,"; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:32993,Availability,error,error,32993,"fun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generat",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:34419,Availability,error,errors,34419,"onfiguration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:36376,Availability,error,error,36376,"the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in func",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:36957,Availability,error,error,36957,"idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_op",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:39243,Availability,toler,tolerance,39243,"ogger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:39611,Availability,error,errors,39611,"lf.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:40221,Availability,error,error,40221,"= \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:5410,Deployability,configurat,configuration,5410,"ort numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool;",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:8051,Deployability,configurat,configuration,8051,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:13000,Deployability,configurat,configuration,13000,"ue):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:16340,Deployability,update,update,16340,"_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:20724,Deployability,update,update,20724,"es; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_gra",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:20930,Deployability,update,update,20930,"; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:22142,Deployability,update,update,22142,"um_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. i",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:22476,Deployability,update,update,22476,"fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReach",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:24106,Deployability,update,update,24106,"d_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:25394,Deployability,update,update,25394,"sinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelit",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:28744,Deployability,configurat,configuration,28744,"ion_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisa",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:33405,Deployability,configurat,configuration,33405,"elity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:41204,Deployability,update,updated,41204,"tion_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:8466,Energy Efficiency,reduce,reduce,8466,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:3890,Integrability,wrap,wrapper,3890,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:4182,Integrability,wrap,wrappers,4182,"m SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:6461,Integrability,message,message,6461,"instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the con",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:16953,Integrability,wrap,wrapper,16953,"instance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult obj",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:19066,Integrability,message,message,19066,"als = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the functi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:26112,Integrability,wrap,wrapper,26112,"d_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self.",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:29898,Integrability,wrap,wrapper,29898,"ard compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self.",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:36312,Integrability,wrap,wrapper,36312,"he optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimis",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:36870,Integrability,wrap,wrapper,36870,"_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_v",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:2678,Modifiability,variab,variables,2678," LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian ap",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:3839,Modifiability,variab,variables,3839,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:5410,Modifiability,config,configuration,5410,"ort numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool;",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:8012,Modifiability,config,config,8012,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:8051,Modifiability,config,configuration,8051,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:9501,Modifiability,config,config,9501,"te it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:9555,Modifiability,config,config,9555,": :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:9564,Modifiability,config,config,9564,": :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:9667,Modifiability,config,config,9667,"the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @l",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10329,Modifiability,config,config,10329,"etting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, ke",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10390,Modifiability,config,config,10390,"the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of da",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10422,Modifiability,config,config,10422,"ration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10465,Modifiability,config,config,10465,"is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10500,Modifiability,config,config,10500,"rams=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10532,Modifiability,config,config,10532,"ynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each it",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10575,Modifiability,config,config,10575,"arams = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:13000,Modifiability,config,configuration,13000,"ue):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:16405,Modifiability,config,config,16405,"radient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The functio",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:18106,Modifiability,config,config,18106,"_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:19703,Modifiability,variab,variable,19703,"d)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the s",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:19978,Modifiability,variab,variable,19978,"func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:20589,Modifiability,variab,variable,20589,"t, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(e",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:21813,Modifiability,variab,variables,21813,"hey have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:21967,Modifiability,variab,variables,21967,"1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that r",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:22007,Modifiability,variab,variable,22007,"unc_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:22906,Modifiability,config,config,22906,"tion algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.w",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:28161,Modifiability,variab,variable,28161,"grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; s",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:28744,Modifiability,config,configuration,28744,"ion_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisa",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:28873,Modifiability,config,config,28873,"efault_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Esse",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:28934,Modifiability,config,config,28934,"ime). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function;",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:28971,Modifiability,config,config,28971,"docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a war",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:29024,Modifiability,config,config,29024,"ts the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BF",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:29064,Modifiability,config,config,29064,"ithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:29101,Modifiability,config,config,29101,"------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy d",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:29163,Modifiability,config,config,29163,"ble metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:30551,Modifiability,config,config,30551,"algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Op",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:33405,Modifiability,config,configuration,33405,"elity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:34871,Modifiability,variab,variable,34871,") != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:35067,Modifiability,extend,extend,35067,"lse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:35218,Modifiability,variab,variable,35218,".PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Op",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:37812,Modifiability,config,config,37812,"None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:18,Performance,optimiz,optimizer,18,". . qutip.control.optimizer — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:270,Performance,optimiz,optimizer,270,". . qutip.control.optimizer — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:311,Performance,optimiz,optimizer,311,". . qutip.control.optimizer — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:3203,Performance,optimiz,optimize,3203,"s here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are cal",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:3791,Performance,perform,performs,3791,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:4070,Performance,optimiz,optimize,4070,"al minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:;",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:4470,Performance,optimiz,optimize,4470,"on is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control opti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:6481,Performance,optimiz,optimize,6481,"uantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value appl",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:6547,Performance,optimiz,optimize,6547,"og_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:8411,Performance,perform,performance,8411,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:12749,Performance,optimiz,optimizer,12749,"umped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_c",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:14410,Performance,optimiz,optimize,14410,"check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gr",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:15828,Performance,optimiz,optimize,15828,"maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.app",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:16975,Performance,optimiz,optimize,16975,"= {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:26135,Performance,optimiz,optimize,26135,"result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; opt",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:28336,Performance,optimiz,optimize,28336,"_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_lev",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:29921,Performance,optimiz,optimize,29921,"ttr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.a",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:32838,Performance,optimiz,optimize,32838,"f.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; er",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:36266,Performance,optimiz,optimize,36266,"hat is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Spec",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:36892,Performance,optimiz,optimize,36892,"_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:4585,Testability,log,logging,4585,"ass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:4594,Testability,log,logger,4594,"ass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:4603,Testability,log,logging,4603,"ass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:5606,Testability,log,logger,5606,"ogging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize meth",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10655,Testability,log,logger,10655,"elf):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised l",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10773,Testability,log,logger,10773,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10794,Testability,log,logger,10794,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:10821,Testability,log,logger,10821,"on_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; e",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:11575,Testability,log,logs,11575,"config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the curren",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:11755,Testability,log,logs,11755," and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:14040,Testability,log,logger,14040," is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:17525,Testability,test,tested,17525,"s):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_gra",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:18579,Testability,log,logging,18579," some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:18741,Testability,log,logger,18741,"ameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of th",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:19220,Testability,log,logger,19220,"e_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamic",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:21059,Testability,log,logging,21059,"s passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed a",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:21075,Testability,log,logger,21075,"optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. H",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:22633,Testability,log,logging,22633,"unc_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; se",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:22649,Testability,log,logger,22649,"errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:23670,Testability,log,logging,23670,"ient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_re",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:23686,Testability,log,logger,23686,"at(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:26934,Testability,log,logging,26934,"d when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(re",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:27081,Testability,log,logger,27081," iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:29288,Testability,log,logging,29288,"re used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if th",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:29347,Testability,log,logging,29347,".fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an Opti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:31533,Testability,log,logging,31533,"dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.Optimiza",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:31684,Testability,log,logger,31684,"r(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_r",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:35528,Testability,log,logging,35528,"h control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:35600,Testability,log,logger,35600,"""""""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:38222,Testability,log,logging,38222," or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Func",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:38237,Testability,log,logger,38237," or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (w",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:38985,Testability,log,logger,38985,"efault_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_nu",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:13898,Usability,clear,clear,13898,"e optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(sel",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html:2666,Availability,error,error,2666,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html:2736,Availability,error,error,2736,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html:2805,Availability,error,error,2805,"# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operat",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html:2935,Availability,error,error,2935,"R OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the r",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html:4695,Deployability,update,updated,4695,"n; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html:3921,Performance,optimiz,optimizer,3921,"n; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html:4566,Performance,optimiz,optimizer,4566,"n; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:2826,Availability,error,errors,2826,"IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:6235,Availability,error,errors,6235,"he logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX';",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:6681,Availability,error,errors,6681," dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Co",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:4323,Deployability,configurat,configuration,4323,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:7033,Deployability,configurat,configuration,7033,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:7814,Deployability,configurat,configuration,7814,"oose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:14107,Deployability,update,updated,14107,"or; and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(j)*dyn.tau[k]; if compute_prop:; prop, prop_grad = la.expm_frechet(A, E); else:; prop_grad = la.expm_frechet(A, E,; compute_expm=False); else:; # Assuming some sparse matrix; spcls = dyn._dyn_gen[k].__class__; A = (dyn._get_phased_dyn_gen(k)*dyn.tau[k]).toarray(); E = (dyn._get_phased_ctrl_dyn_gen(j)*dyn.tau[k]).toarray(); if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = spcls(prop_dense); prop_grad = spcls(prop_grad_dense); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = spcls(prop_grad_dense). if compute_prop:; return prop, prop_grad; else:; return prop_grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:9907,Energy Efficiency,efficient,efficient,9907,"_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau[k]",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:9989,Energy Efficiency,efficient,efficiently,9989,"_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau[k]",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:12355,Energy Efficiency,efficient,efficient,12355,"lot using the exponentiation of the the augmented; matrix.; The propagtor is calculated for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k); aug = self._get_aug_mat(k, j). if dyn.oper_dtype == Qobj:; aug_exp = aug.expm(); prop_grad = Qobj(aug_exp.data[:dg.shape[0], dg.shape[1]:],; dims=dyn.dyn_dims); if compute_prop:; prop = Qobj(aug_exp.data[:dg.shape[0], :dg.shape[1]],; dims=dyn.dyn_dims); else:; aug_exp = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator:; exponentiating the combined dynamics generator; and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; E ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:2856,Integrability,message,message,2856,"USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:2944,Integrability,message,message,2944,"USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:3032,Integrability,message,message,3032,"###############################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:4323,Modifiability,config,configuration,4323,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:7033,Modifiability,config,configuration,7033,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:7814,Modifiability,config,configuration,7814,"oose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:2696,Testability,log,logging,2696,"ITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:2735,Testability,log,logging,2735,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:2744,Testability,log,logger,2744,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:2753,Testability,log,logging,2753,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:3612,Testability,log,logger,3612,"ings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instanti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:3659,Testability,log,logging,3659,"logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:4999,Testability,log,logger,4999,"RN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsil",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:5117,Testability,log,logger,5117,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:5138,Testability,log,logger,5138,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:5165,Testability,log,logger,5165,"rop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the dire",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html:6877,Usability,simpl,simply,6877,"epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; P",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:2672,Availability,error,errors,2672,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied ov",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:2682,Availability,error,errors,2682,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied ov",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:8515,Availability,error,errors,8515,".scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _apply_bounds_and_offset(self, pulse):; """"""; Ensure that the randomly generated pulse fits within the bounds",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:36477,Deployability,update,updated,36477,"rier basis functions, i.e. sin and cos. Attributes; ----------; freqs : float array[num_coeffs]; Frequencies for the basis functions; randomize_freqs : bool; If True (default) the some random offset is applied to the frequencies; """""". [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGenCrab.reset(self); self.freqs = None; self.randomize_freqs = True. [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGenCrab.init_pulse(self); ; self.init_freqs(); ; [docs] def init_freqs(self):; """"""; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset; """"""; self.freqs = np.empty(self.num_coeffs); ff = 2*np.pi / self.pulse_time; for i in range(self.num_coeffs):; self.freqs[i] = ff*(i + 1); ; if self.randomize_freqs:; self.freqs += np.random.random(self.num_coeffs) - 0.5; ; [docs] def gen_pulse(self, coeffs=None):; """"""; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes.; ; Parameters; ----------; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name.; """"""; if coeffs:; self.coeffs = coeffs; ; if not self._pulse_initialised:; self.init_pulse(); ; pulse = np.zeros(self.num_tslots). for i in range(self.num_coeffs):; phase = self.freqs[i]*self.time; # basis1comp = self.coeffs[i, 0]*np.sin(phase); # basis2comp = self.coeffs[i, 1]*np.cos(phase); # pulse += basis1comp + basis2comp; pulse += self.coeffs[i, 0]*np.sin(phase) + \; self.coeffs[i, 1]*np.cos(phase) . if self.guess_pulse_func:; pulse = self.guess_pulse_func(pulse); if self.ramping_pulse is not None:; pulse = self._apply_ramping_pulse(pulse); ; return self._apply_bounds(pulse); . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:30731,Energy Efficiency,efficient,efficient,30731,"If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; T",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:30814,Integrability,message,message,30814,"effs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:29260,Modifiability,variab,variables,29260,".parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_leve",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:30372,Modifiability,variab,variables,30372,"um_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:12659,Safety,avoid,avoid,12659,"scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; self._uses_time = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; self.apply_params(). def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = self.time; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). num_comp_waves : integer; Number of component waves. That is the number of waves that; are summe",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:15055,Safety,avoid,avoid,15055,"elf.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0; self.apply_params(). def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = self.time; wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scaling attribute; """"""; def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.res",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:31775,Safety,avoid,avoided,31775," {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:2568,Testability,log,logging,2568,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:2577,Testability,log,logger,2577,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:2586,Testability,log,logging,2586,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:6553,Testability,log,logger,6553,"caling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset : float; linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tau : array[num_tslots] of float; Duration of each timeslot; (copied from Dynamics if given). lbound : float; Lower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. ubound : float; Upper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic : boolean; True if the pulse generator produces periodic pulses. random : boolean; True if the pulse generator produces random pulses. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; """"""; def __init__(self, dyn=None, params=None):; self.parent = dyn; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; if isinstance(self.parent, dynamics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pul",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:8151,Testability,log,logger,8151,"ics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:8272,Testability,log,logger,8272,".scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubou",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:8293,Testability,log,logger,8293,".scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubou",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:8320,Testability,log,logger,8320,"; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). d",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:29082,Testability,log,logging,29082," initialised, otherwise they will all be equal to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:29133,Testability,log,logger,29133,"l to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:30218,Testability,log,logging,30218,", which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:30233,Testability,log,logger,30233,"tal of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Return",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:30569,Testability,log,logging,30569,"he initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:30632,Testability,log,logger,30632,"um_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:32081,Testability,log,logger,32081,"s_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._boun",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:32346,Testability,log,logger,32346,"n num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scale) + self.ubound; self._bound_scale_cond = self._BSC_GT_MEAN. elif self.ubound is None:; # only lower bound; if self.lbound < 0:; self._bound_mean = 0.0; self._bound_scale = abs(self.lbound); else:; self._bound_scale = self.scaling*self.num_coeffs + \; self.",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html:11044,Usability,simpl,simply,11044,"und - max_amp; else:; # min_amp + offset must exceed the lbound; return pulse + self.lbound - min_amp; else:; bound_range = self.ubound - self.lbound; amp_range = max_amp - min_amp; if max_amp - min_amp > bound_range:; # pulse range is too high, it must be scaled; pulse = pulse * bound_range / amp_range. # otherwise the pulse should fit anyway; return pulse + self.lbound - min(pulse). def _apply_ramping_pulse(self, pulse, ramping_pulse=None):; if ramping_pulse is None:; ramping_pulse = self.ramping_pulse; if ramping_pulse is not None:; pulse = pulse*ramping_pulse; ; return pulse; ; [docs]class PulseGenZero(PulseGen):; """"""; Generates a flat pulse; """"""; [docs] def gen_pulse(self):; """"""; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset; """"""; pulse = np.zeros(self.num_tslots); return self._apply_bounds_and_offset(pulse). [docs]class PulseGenRandom(PulseGen):; """"""; Generates random pulses as simply random values for each timeslot; """"""; def reset(self):; PulseGen.reset(self); self.random = True; self.apply_params(). [docs] def gen_pulse(self):; """"""; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot; """"""; pulse = (2*np.random.random(self.num_tslots) - 1) * self.scaling. return self._apply_bounds_and_offset(pulse). class PulseGenRndFourier(PulseGen):; """"""; Generates pulses by summing sine waves as a Fourier series; with random coefficients. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:2472,Availability,error,error,2472,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number o",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:2640,Availability,error,error,2640,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:2937,Availability,error,error,2937,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:3190,Availability,error,error,3190,"email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Co",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:3873,Availability,error,error,3873,"odule. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import q",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:4867,Availability,error,errors,4867,"imisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_param",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:4877,Availability,error,errors,4877,"imisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_param",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:6292,Availability,error,error,6292,"e message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:6703,Availability,error,error,6703,"0,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is gi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:6723,Availability,error,error,6723,"0,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is gi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:8142,Availability,error,error,8142,"overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a sc",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:8209,Availability,error,error,8209,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:9224,Availability,error,error,9224,"lue. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameter",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:10848,Availability,error,error,10848,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:10868,Availability,error,error,10868,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:14064,Availability,error,error,14064,"name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:19413,Availability,error,error,19413,"not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) f",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:20083,Availability,error,error,20083,"_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : arra",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:20250,Availability,error,error,20250,"ng_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for th",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:21553,Availability,error,error,21553,"the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scip",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:21620,Availability,error,error,21620,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pu",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:22633,Availability,error,error,22633,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_para",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:26845,Availability,error,error,26845,"be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; if not isinstance(H_d, (list, tuple)):; raise TypeError(""H_d should be a Qobj or a list of Qobj""); else:; for H in H_d:; if not isinstance(H, Qobj):; raise TypeError(""H_d should be a Qobj or a list of Qobj""). if not isinstance(H_c, (list, tuple)):; raise TypeError(""H_c should be a list of Qobj""); else:; for ctrl in H_c:; if not isinstance(ctrl, Qobj):; raise TypeError(""H_c should be a list of Qobj""). if not isinstance(U_0, Qobj):; raise TypeError(""U_0 must be a Qobj""). if not isinstance(U_targ, Qobj):; raise TypeError(""U_targ must be a Qobj""); ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is depreca",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:30645,Availability,error,error,30645,"nit_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats); ; [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:31127,Availability,error,error,31127,"tim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot d",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:31147,Availability,error,error,31147,"tim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot d",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:32566,Availability,error,error,32566,"overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:32633,Availability,error,error,32633,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while sti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:34328,Availability,error,error,34328,"his is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:35164,Availability,error,error,35164," be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes. ; Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None; ; guess_pulse_params : di",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:35184,Availability,error,error,35184," be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes. ; Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None; ; guess_pulse_params : di",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:38227,Availability,error,error,38227,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_param",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:41032,Availability,error,error,41032,"t_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:41774,Availability,error,error,41774,"pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations wi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:41794,Availability,error,error,41794,"pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations wi",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:43202,Availability,error,error,43202,"the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:43269,Availability,error,error,43269,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while sti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:44964,Availability,error,error,44964," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:48375,Availability,error,error,48375,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_param",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:52871,Availability,error,error,52871,"overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a sc",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:52938,Availability,error,error,52938,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:53953,Availability,error,error,53953,"lue. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:55588,Availability,error,error,55588,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:55608,Availability,error,error,55608,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:61437,Availability,error,errors,61437,"tion is None:; if isinstance(fid_params, dict):; if not 'phase_option' in fid_params:; fid_params['phase_option'] = phase_option; else:; fid_params = {'phase_option':phase_option}; _param_deprecation(; ""The 'phase_option' parameter is deprecated. ""; ""Use 'phase_option' in fid_params instead""); ; # fid_err_scale_factor; if not fid_err_scale_factor is None:; if isinstance(fid_params, dict):; if not 'fid_err_scale_factor' in fid_params:; fid_params['scale_factor'] = fid_err_scale_factor; else:; fid_params = {'scale_factor':fid_err_scale_factor}; _param_deprecation(; ""The 'fid_err_scale_factor' parameter is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_le",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:62015,Availability,error,errors,62015,"er is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pa",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:62694,Availability,error,errors,62694,"ulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(pr",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:63586,Availability,error,errors,63586,"T':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.f",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:64509,Availability,error,errors,64509,"ropcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method;",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:64910,Availability,error,errors,64910,"ceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; t",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:65317,Availability,error,errors,65317,"Diff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:66696,Availability,error,errors,66696,"m = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params); if alg_up == 'CRAB':; # Create a pulse generator for each ctrl; crab_pulse_params = None; num_coeffs = None; init_coeff_scaling = None; if isinstance(alg_params, dict):; num_coeffs = alg_params.get('num_coeffs'); init_coeff_scaling = alg_params.get('init_coeff_scaling'); if 'crab_pulse_params' in alg_params:; crab_pulse_params = alg_params.get('crab_pulse_params'); ; guess_pulse_type = init_pul",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:2344,Deployability,configurat,configuration,2344,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:17561,Deployability,configurat,configuration,17561,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:51384,Deployability,configurat,configuration,51384,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:69809,Deployability,update,updated,69809,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:3509,Energy Efficiency,reduce,reduces,3509,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:5158,Integrability,message,message,5158,"o, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:5246,Integrability,message,message,5246,"o, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:5334,Integrability,message,message,5334,"random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combin",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:7005,Integrability,depend,dependent,7005,"on=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each con",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:9455,Integrability,depend,dependent,9455,"me : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPRO",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:19525,Integrability,wrap,wrapper,19525,"e). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:20435,Integrability,depend,dependent,20435,"lse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of f",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:22864,Integrability,depend,dependent,22864,"ime : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs;",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:31429,Integrability,depend,dependent,31429,"ne, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each con",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:41144,Integrability,wrap,wrapper,41144,"_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.;",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:42086,Integrability,depend,dependent,42086,"idelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:51734,Integrability,depend,dependent,51734,"m_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each con",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:54184,Integrability,depend,dependent,54184,"float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:68923,Integrability,message,message,68923,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:2344,Modifiability,config,configuration,2344,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:2962,Modifiability,variab,variables,2962,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:3544,Modifiability,variab,variables,3544,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:3633,Modifiability,variab,variables,3633,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:3714,Modifiability,variab,variables,3714,"um control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qut",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:17561,Modifiability,config,configuration,17561,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:30934,Modifiability,variab,variables,30934," ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None impli",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:33745,Modifiability,variab,variable,33745,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:34270,Modifiability,variab,variable,34270,"his is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:41581,Modifiability,variab,variables,41581,"None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:44381,Modifiability,variab,variable,44381,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The ke",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:44906,Modifiability,variab,variable,44906," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:51384,Modifiability,config,configuration,51384,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:69333,Modifiability,config,config,69333,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:2894,Performance,optimiz,optimize,2894,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:4396,Performance,optimiz,optimization,4396,"was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:4785,Performance,optimiz,optimizer,4785,"it gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:4798,Performance,optimiz,optimizer,4798,"it gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:9137,Performance,optimiz,optimize,9137," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:9322,Performance,optimiz,optimize,9322,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:9834,Performance,optimiz,optimize,9834,"rams : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:22546,Performance,optimiz,optimize,22546,"ty error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_typ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:22731,Performance,optimiz,optimize,22731,"lue, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the obj",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:23245,Performance,optimiz,optimize,23245,"ms : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the tim",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:33547,Performance,perform,performane,33547,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:33886,Performance,optimiz,optimize,33886,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:34193,Performance,optimiz,optimize,34193," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:44183,Performance,perform,performane,44183,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:44522,Performance,optimiz,optimize,44522,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict;",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:44829,Performance,optimiz,optimize,44829," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPD",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:53866,Performance,optimiz,optimize,53866," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamic",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:54051,Performance,optimiz,optimize,54051,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is cr",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:54574,Performance,optimiz,optimize,54574,"ionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:58728,Performance,optimiz,optimizer,58728,"The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:58801,Performance,optimiz,optimizer,58801," name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:65049,Performance,optimiz,optimizer,65049,"== '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wa",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:65165,Performance,optimiz,optimizer,65165,", fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:65265,Performance,optimiz,optimizer,65265," == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is no",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:65471,Performance,optimiz,optimize,65471,"FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:65573,Performance,optimiz,optimizer,65573,"option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:65623,Performance,optimiz,optimizer,65623,"; ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supp",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:66287,Performance,perform,performance,66287,"_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:69379,Performance,optimiz,optimizer,69379,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:2812,Security,access,accessible,2812," CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default i",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:13869,Security,access,accessible,13869,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:26651,Security,access,accessible,26651,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; if not isinstance(H_d, (list, tuple)):; raise TypeError(""H_d should be a Qobj or a list of Qobj""); else:; for H in H_d:; if not isinstance(H, Qobj):; raise TypeError(""H_d should be a Qobj or a list of Qobj""). if not isinstance(H_c, (list, tuple)):; raise TypeError(""H_c should be a list of Qobj""); else:; for ctrl in H_c:; if not isinstance(ctrl, Qobj):; raise TypeError(""H_c should be a list of Qobj""). if not isinstance(U_0, Qobj):; raise TypeError(""U_0 must be a Qobj""). if not isinstance(U_targ, Qobj):; raise TypeError(""U_targ must be a Qobj""); ; # The deprecation",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:38032,Security,access,accessible,38032,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:48180,Security,access,accessible,48180,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:58370,Security,access,accessible,58370,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; ra",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:58573,Security,access,accessed,58573,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not op",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:58676,Security,access,accessed,58676,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not ma",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:4564,Testability,log,logging,4564,"the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:4573,Testability,log,logger,4573,"the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:4582,Testability,log,logging,4582,"the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:6183,Testability,log,logging,6183,"tion(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. init",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:13152,Testability,log,logger,13152,"_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:14145,Testability,log,logging,14145,"name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:14174,Testability,log,logger,14174,"s are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecat",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:14209,Testability,log,logger,14209,"ng_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'accuracy_factor' par",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:17532,Testability,log,logging,17532," max_wall_time=max_wall_time,; alg=alg, alg_params=alg_params, optim_params=optim_params,; optim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:18087,Testability,log,logger,18087,"ots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:18268,Testability,log,logging,18268,"ptim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_puls",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:18283,Testability,log,logger,18283,"init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_par",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:18567,Testability,log,logging,18567," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse,",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:18582,Testability,log,logger,18582,"_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate option",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:19304,Testability,log,logging,19304,"g.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Pa",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:25934,Testability,log,logger,25934,"_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""".",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:30536,Testability,log,logging,30536,"method_params,; dyn_type='UNIT', dyn_params=dyn_params,; prop_params=prop_params, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats); ; [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dyna",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:33784,Testability,test,tested,33784,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:37315,Testability,log,logger,37315,"d after the object is created; ; guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD ; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:38392,Testability,log,logging,38392,"evels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pul",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:38421,Testability,log,logger,38421,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:38456,Testability,log,logger,38456,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ; not 'pulse_action' in guess_pu",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:40923,Testability,log,logging,40923,"arams,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target ev",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:44420,Testability,test,tested,44420,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The ke",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:47463,Testability,log,logger,47463,"d after the object is created; ; guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD ; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:48540,Testability,log,logging,48540,"evels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pul",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:48569,Testability,log,logger,48569,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:48604,Testability,log,logger,48604,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ; not 'pulse_action' in guess_pu",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:51147,Testability,log,logging,51147,"ms=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that times",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:57898,Testability,log,logger,57898," ; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. . init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:62299,Testability,log,logging,62299,"e_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_ty",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:62328,Testability,log,logger,62328,"ated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not i",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:62363,Testability,log,logger,62363,"ead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, pro",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:69288,Testability,log,logging,69288,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:69304,Testability,log,logger,69304,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:5073,Usability,simpl,simplefilter,5073,"o, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:19516,Usability,simpl,simply,19516,"e). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:41135,Usability,simpl,simply,41135,"_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.;",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:2324,Availability,redundant,redundant,2324," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:4025,Availability,error,error,4025,"me for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:2517,Deployability,configurat,configurations,2517,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:2556,Deployability,update,updated,2556,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:4830,Deployability,update,updated,4830,"ned onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; sel",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:4916,Deployability,update,updates,4916,".; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; sel",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:5152,Deployability,update,update,5152,"adient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mea",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:5365,Deployability,update,update,5365,"_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:9078,Deployability,update,updates,9078,"(""Wall time computing forward propagation: "" +; self._format_datetime(self.wall_time_fwd_prop_compute, tot)); print(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift an",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:9153,Deployability,update,updates,9153,"int(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:9363,Deployability,update,update,9363,"gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:9562,Deployability,update,update,9562,"function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator com",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:9696,Deployability,configurat,configurations,9696,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:9752,Deployability,update,updated,9752,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:9880,Deployability,update,update,9880,"mat(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average num",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:10224,Deployability,update,update,10224,"n: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:10550,Deployability,update,update,10550,"_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward propagation. mean_wall_time_onwd_prop_compute; Mean average time to compute onward propagation; """""". def __init__(self):; self.reset(). def reset(self):; Stats.reset(self); # Dynamics generators (Hamiltonians); self.num_dyn_gen_computes = 0; self.mean_num_dyn_gen_computes_per_update = 0.0; self.mean_wall_time_dyn_gen_compute = 0.",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:13552,Deployability,update,update,13552,"_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_fwd_prop_compute = \; (self.wall_time_fwd_prop_compute /; float(self.num_fwd_prop_step_computes)). self.mean_num_onwd_prop_step_computes_per_update = \; (self.num_onwd_prop_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_onwd_prop_compute = \; (self.wall_time_onwd_prop_compute /; float(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:13937,Deployability,update,update,13937,"t(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:14347,Deployability,update,update,14347,"lf.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:14778,Deployability,update,update,14778,"lf.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:15074,Deployability,update,updated,15074,"lf.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:2517,Modifiability,config,configurations,2517,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:9696,Modifiability,config,configurations,9696,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:2324,Safety,redund,redundant,2324," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:2849,Usability,simpl,simply,2849,"CT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; th",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:5478,Usability,clear,clear,5478,"ity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still ru",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html:5491,Usability,clear,clear,5491,"nteger; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still running then the o",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.0.2/modules/qutip/control/termcond.html:2789,Availability,error,error,2789,"ON) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(se",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/termcond.html
https://qutip.org/docs/4.0.2/modules/qutip/control/termcond.html:4047,Deployability,update,updated,4047,"@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/termcond.html
https://qutip.org/docs/4.0.2/modules/qutip/control/termcond.html:3456,Performance,optimiz,optimize,3456,"@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/termcond.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:3624,Availability,error,errors,3624,"; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:3634,Availability,error,errors,3634,"; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:14206,Availability,mask,masks,14206,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:20388,Availability,error,errors,20388,"w.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; grad_func_call_num : int; Gradient function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; num_amps_changed : int; Number of control timeslot amplitudes changed since previous; evolution ca",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:2415,Deployability,update,update,2415,"INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:2519,Deployability,update,updates,2519,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:2549,Deployability,update,update,2549,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:2781,Deployability,update,updated,2781,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(mes",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:3180,Deployability,update,update,3180,"organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the da",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:6805,Deployability,update,updated,6805,"def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gr",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:8099,Deployability,update,update,8099,"they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_r",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:12613,Deployability,update,updated,12613,"itarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:12628,Deployability,update,update,12628,"""""""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = n",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:13116,Deployability,update,updated,13116,"imply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:14280,Deployability,update,update,14280,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:15231,Deployability,update,updated,15231," are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalcula",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:15758,Deployability,update,update,15758,"changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_ca",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:16687,Deployability,update,update,16687,"adients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2targ_recomp_now[:-1]; | self.prop_calc_now[:]) & self.prop_recalc[:]; dyn_gen_recomp_now = (prop_recomp_now[:] | self.dyn_gen_calc_now[:]) \; & self.dyn_gen_r",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:23073,Deployability,update,updated,23073," optimisation; None if evolution compute outside of a pulse optimisation; ; num_amps_changed : int; Number of control timeslot amplitudes changed since previous; evolution calculation; ; num_timeslots_changed : int; Number of timeslots in which any amplitudes changed since previous; evolution calculation; ; wall_time_dyn_gen_compute : float; Time spent computing dynamics generators; (in seconds of elapsed time); ; wall_time_prop_compute : float; Time spent computing propagators (including and propagator gradients); (in seconds of elapsed time); ; wall_time_fwd_prop_compute : float; Time spent computing the forward evolution of the system; see :property:`dynamics.fwd_evo` ; (in seconds of elapsed time); ; wall_time_onwd_prop_compute : float; Time spent computing the 'backward' evolution of the system; see :property:`dynamics.onwd_evo` and :property:`dynamics.onto_evo`; (in seconds of elapsed time); """"""; ; min_col_width = 11; summary_property_names = (; ""idx"", ""evo_dump_idx"", ; ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""num_amps_changed"", ""num_timeslots_changed"",; ""wall_time_dyn_gen_compute"", ""wall_time_prop_compute"",; ""wall_time_fwd_prop_compute"", ""wall_time_onwd_prop_compute""); ; summary_property_fmt_type = (; 'd', 'd',; 'd', 'd', 'd',; 'd', 'd',; 'g', 'g', ; 'g', 'g'; ); ; summary_property_fmt_prec = (; 0, 0, ; 0, 0, 0,; 0, 0, ; 3, 3,; 3, 3; ); ; def __init__(self):; self.reset(); ; def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.evo_dump_idx = None; self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.num_amps_changed = 0; self.num_timeslots_changed = 0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:3790,Integrability,message,message,3790,"ns accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:3878,Integrability,message,message,3878,"ns accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:3966,Integrability,message,message,3966,"sed for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise Ty",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:6619,Modifiability,config,config,6619,"if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # Tru",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:20009,Modifiability,config,config,20009,"mer(); # compute the onward propagation; R = range(n_ts-1, -1, -1); for k in R:; if evo_t2targ_recomp_now[k]:; dyn.evo_t2targ[k] = dyn.evo_t2targ[k+1].dot(dyn.prop[k]); self.evo_t2targ_recalc[k] = False; if dyn.stats is not None:; dyn.stats.num_onwd_prop_step_computes += \; evo_t2targ_recomp_now.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if ",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:8758,Security,access,access,8758,"ity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:3689,Testability,log,logging,3689,"he GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:3728,Testability,log,logging,3728,"e) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html:3737,Testability,log,logger,3737,"e) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.0.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/tslotcomp.html
